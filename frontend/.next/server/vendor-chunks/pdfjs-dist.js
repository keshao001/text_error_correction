"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pdfjs-dist";
exports.ids = ["vendor-chunks/pdfjs-dist"];
exports.modules = {

/***/ "(ssr)/./node_modules/pdfjs-dist/build/pdf.mjs":
/*!***********************************************!*\
  !*** ./node_modules/pdfjs-dist/build/pdf.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortException: () => (/* binding */ __webpack_exports__AbortException),\n/* harmony export */   AnnotationEditorLayer: () => (/* binding */ __webpack_exports__AnnotationEditorLayer),\n/* harmony export */   AnnotationEditorParamsType: () => (/* binding */ __webpack_exports__AnnotationEditorParamsType),\n/* harmony export */   AnnotationEditorType: () => (/* binding */ __webpack_exports__AnnotationEditorType),\n/* harmony export */   AnnotationEditorUIManager: () => (/* binding */ __webpack_exports__AnnotationEditorUIManager),\n/* harmony export */   AnnotationLayer: () => (/* binding */ __webpack_exports__AnnotationLayer),\n/* harmony export */   AnnotationMode: () => (/* binding */ __webpack_exports__AnnotationMode),\n/* harmony export */   ColorPicker: () => (/* binding */ __webpack_exports__ColorPicker),\n/* harmony export */   DOMSVGFactory: () => (/* binding */ __webpack_exports__DOMSVGFactory),\n/* harmony export */   DrawLayer: () => (/* binding */ __webpack_exports__DrawLayer),\n/* harmony export */   FeatureTest: () => (/* binding */ __webpack_exports__FeatureTest),\n/* harmony export */   GlobalWorkerOptions: () => (/* binding */ __webpack_exports__GlobalWorkerOptions),\n/* harmony export */   ImageKind: () => (/* binding */ __webpack_exports__ImageKind),\n/* harmony export */   InvalidPDFException: () => (/* binding */ __webpack_exports__InvalidPDFException),\n/* harmony export */   MissingPDFException: () => (/* binding */ __webpack_exports__MissingPDFException),\n/* harmony export */   OPS: () => (/* binding */ __webpack_exports__OPS),\n/* harmony export */   OutputScale: () => (/* binding */ __webpack_exports__OutputScale),\n/* harmony export */   PDFDataRangeTransport: () => (/* binding */ __webpack_exports__PDFDataRangeTransport),\n/* harmony export */   PDFDateString: () => (/* binding */ __webpack_exports__PDFDateString),\n/* harmony export */   PDFWorker: () => (/* binding */ __webpack_exports__PDFWorker),\n/* harmony export */   PasswordResponses: () => (/* binding */ __webpack_exports__PasswordResponses),\n/* harmony export */   PermissionFlag: () => (/* binding */ __webpack_exports__PermissionFlag),\n/* harmony export */   PixelsPerInch: () => (/* binding */ __webpack_exports__PixelsPerInch),\n/* harmony export */   RenderingCancelledException: () => (/* binding */ __webpack_exports__RenderingCancelledException),\n/* harmony export */   TextLayer: () => (/* binding */ __webpack_exports__TextLayer),\n/* harmony export */   UnexpectedResponseException: () => (/* binding */ __webpack_exports__UnexpectedResponseException),\n/* harmony export */   Util: () => (/* binding */ __webpack_exports__Util),\n/* harmony export */   VerbosityLevel: () => (/* binding */ __webpack_exports__VerbosityLevel),\n/* harmony export */   XfaLayer: () => (/* binding */ __webpack_exports__XfaLayer),\n/* harmony export */   build: () => (/* binding */ __webpack_exports__build),\n/* harmony export */   createValidAbsoluteUrl: () => (/* binding */ __webpack_exports__createValidAbsoluteUrl),\n/* harmony export */   fetchData: () => (/* binding */ __webpack_exports__fetchData),\n/* harmony export */   getDocument: () => (/* binding */ __webpack_exports__getDocument),\n/* harmony export */   getFilenameFromUrl: () => (/* binding */ __webpack_exports__getFilenameFromUrl),\n/* harmony export */   getPdfFilenameFromUrl: () => (/* binding */ __webpack_exports__getPdfFilenameFromUrl),\n/* harmony export */   getXfaPageViewport: () => (/* binding */ __webpack_exports__getXfaPageViewport),\n/* harmony export */   isDataScheme: () => (/* binding */ __webpack_exports__isDataScheme),\n/* harmony export */   isPdfFile: () => (/* binding */ __webpack_exports__isPdfFile),\n/* harmony export */   noContextMenu: () => (/* binding */ __webpack_exports__noContextMenu),\n/* harmony export */   normalizeUnicode: () => (/* binding */ __webpack_exports__normalizeUnicode),\n/* harmony export */   setLayerDimensions: () => (/* binding */ __webpack_exports__setLayerDimensions),\n/* harmony export */   shadow: () => (/* binding */ __webpack_exports__shadow),\n/* harmony export */   stopEvent: () => (/* binding */ __webpack_exports__stopEvent),\n/* harmony export */   version: () => (/* binding */ __webpack_exports__version)\n/* harmony export */ });\n/**\n * @licstart The following is the entire license notice for the\n * JavaScript code in this page\n *\n * Copyright 2024 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @licend The above is the entire license notice for the\n * JavaScript code in this page\n */ /******/ // The require scope\n/******/ var __nested_webpack_require_838__ = {};\n/******/ /************************************************************************/ /******/ /* webpack/runtime/define property getters */ /******/ (()=>{\n    /******/ // define getter functions for harmony exports\n    /******/ __nested_webpack_require_838__.d = (exports, definition)=>{\n        /******/ for(var key in definition){\n            /******/ if (__nested_webpack_require_838__.o(definition, key) && !__nested_webpack_require_838__.o(exports, key)) {\n                /******/ Object.defineProperty(exports, key, {\n                    enumerable: true,\n                    get: definition[key]\n                });\n            /******/ }\n        /******/ }\n    /******/ };\n/******/ })();\n/******/ /******/ /* webpack/runtime/hasOwnProperty shorthand */ /******/ (()=>{\n    /******/ __nested_webpack_require_838__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);\n/******/ })();\n/******/ /************************************************************************/ var __nested_webpack_exports__ = globalThis.pdfjsLib = {};\n// EXPORTS\n__nested_webpack_require_838__.d(__nested_webpack_exports__, {\n    AbortException: ()=>/* reexport */ AbortException,\n    AnnotationEditorLayer: ()=>/* reexport */ AnnotationEditorLayer,\n    AnnotationEditorParamsType: ()=>/* reexport */ AnnotationEditorParamsType,\n    AnnotationEditorType: ()=>/* reexport */ AnnotationEditorType,\n    AnnotationEditorUIManager: ()=>/* reexport */ AnnotationEditorUIManager,\n    AnnotationLayer: ()=>/* reexport */ AnnotationLayer,\n    AnnotationMode: ()=>/* reexport */ AnnotationMode,\n    ColorPicker: ()=>/* reexport */ ColorPicker,\n    DOMSVGFactory: ()=>/* reexport */ DOMSVGFactory,\n    DrawLayer: ()=>/* reexport */ DrawLayer,\n    FeatureTest: ()=>/* reexport */ util_FeatureTest,\n    GlobalWorkerOptions: ()=>/* reexport */ GlobalWorkerOptions,\n    ImageKind: ()=>/* reexport */ util_ImageKind,\n    InvalidPDFException: ()=>/* reexport */ InvalidPDFException,\n    MissingPDFException: ()=>/* reexport */ MissingPDFException,\n    OPS: ()=>/* reexport */ OPS,\n    OutputScale: ()=>/* reexport */ OutputScale,\n    PDFDataRangeTransport: ()=>/* reexport */ PDFDataRangeTransport,\n    PDFDateString: ()=>/* reexport */ PDFDateString,\n    PDFWorker: ()=>/* reexport */ PDFWorker,\n    PasswordResponses: ()=>/* reexport */ PasswordResponses,\n    PermissionFlag: ()=>/* reexport */ PermissionFlag,\n    PixelsPerInch: ()=>/* reexport */ PixelsPerInch,\n    RenderingCancelledException: ()=>/* reexport */ RenderingCancelledException,\n    TextLayer: ()=>/* reexport */ TextLayer,\n    UnexpectedResponseException: ()=>/* reexport */ UnexpectedResponseException,\n    Util: ()=>/* reexport */ Util,\n    VerbosityLevel: ()=>/* reexport */ VerbosityLevel,\n    XfaLayer: ()=>/* reexport */ XfaLayer,\n    build: ()=>/* reexport */ build,\n    createValidAbsoluteUrl: ()=>/* reexport */ createValidAbsoluteUrl,\n    fetchData: ()=>/* reexport */ fetchData,\n    getDocument: ()=>/* reexport */ getDocument,\n    getFilenameFromUrl: ()=>/* reexport */ getFilenameFromUrl,\n    getPdfFilenameFromUrl: ()=>/* reexport */ getPdfFilenameFromUrl,\n    getXfaPageViewport: ()=>/* reexport */ getXfaPageViewport,\n    isDataScheme: ()=>/* reexport */ isDataScheme,\n    isPdfFile: ()=>/* reexport */ isPdfFile,\n    noContextMenu: ()=>/* reexport */ noContextMenu,\n    normalizeUnicode: ()=>/* reexport */ normalizeUnicode,\n    setLayerDimensions: ()=>/* reexport */ setLayerDimensions,\n    shadow: ()=>/* reexport */ shadow,\n    stopEvent: ()=>/* reexport */ stopEvent,\n    version: ()=>/* reexport */ version\n});\n; // ./src/shared/util.js\nconst isNodeJS = typeof process === \"object\" && process + \"\" === \"[object process]\" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== \"browser\");\nconst IDENTITY_MATRIX = [\n    1,\n    0,\n    0,\n    1,\n    0,\n    0\n];\nconst FONT_IDENTITY_MATRIX = [\n    0.001,\n    0,\n    0,\n    0.001,\n    0,\n    0\n];\nconst MAX_IMAGE_SIZE_TO_CACHE = 10e6;\nconst LINE_FACTOR = 1.35;\nconst LINE_DESCENT_FACTOR = 0.35;\nconst BASELINE_FACTOR = LINE_DESCENT_FACTOR / LINE_FACTOR;\nconst RenderingIntentFlag = {\n    ANY: 0x01,\n    DISPLAY: 0x02,\n    PRINT: 0x04,\n    SAVE: 0x08,\n    ANNOTATIONS_FORMS: 0x10,\n    ANNOTATIONS_STORAGE: 0x20,\n    ANNOTATIONS_DISABLE: 0x40,\n    IS_EDITING: 0x80,\n    OPLIST: 0x100\n};\nconst AnnotationMode = {\n    DISABLE: 0,\n    ENABLE: 1,\n    ENABLE_FORMS: 2,\n    ENABLE_STORAGE: 3\n};\nconst AnnotationEditorPrefix = \"pdfjs_internal_editor_\";\nconst AnnotationEditorType = {\n    DISABLE: -1,\n    NONE: 0,\n    FREETEXT: 3,\n    HIGHLIGHT: 9,\n    STAMP: 13,\n    INK: 15\n};\nconst AnnotationEditorParamsType = {\n    RESIZE: 1,\n    CREATE: 2,\n    FREETEXT_SIZE: 11,\n    FREETEXT_COLOR: 12,\n    FREETEXT_OPACITY: 13,\n    INK_COLOR: 21,\n    INK_THICKNESS: 22,\n    INK_OPACITY: 23,\n    HIGHLIGHT_COLOR: 31,\n    HIGHLIGHT_DEFAULT_COLOR: 32,\n    HIGHLIGHT_THICKNESS: 33,\n    HIGHLIGHT_FREE: 34,\n    HIGHLIGHT_SHOW_ALL: 35,\n    DRAW_STEP: 41\n};\nconst PermissionFlag = {\n    PRINT: 0x04,\n    MODIFY_CONTENTS: 0x08,\n    COPY: 0x10,\n    MODIFY_ANNOTATIONS: 0x20,\n    FILL_INTERACTIVE_FORMS: 0x100,\n    COPY_FOR_ACCESSIBILITY: 0x200,\n    ASSEMBLE: 0x400,\n    PRINT_HIGH_QUALITY: 0x800\n};\nconst TextRenderingMode = {\n    FILL: 0,\n    STROKE: 1,\n    FILL_STROKE: 2,\n    INVISIBLE: 3,\n    FILL_ADD_TO_PATH: 4,\n    STROKE_ADD_TO_PATH: 5,\n    FILL_STROKE_ADD_TO_PATH: 6,\n    ADD_TO_PATH: 7,\n    FILL_STROKE_MASK: 3,\n    ADD_TO_PATH_FLAG: 4\n};\nconst util_ImageKind = {\n    GRAYSCALE_1BPP: 1,\n    RGB_24BPP: 2,\n    RGBA_32BPP: 3\n};\nconst AnnotationType = {\n    TEXT: 1,\n    LINK: 2,\n    FREETEXT: 3,\n    LINE: 4,\n    SQUARE: 5,\n    CIRCLE: 6,\n    POLYGON: 7,\n    POLYLINE: 8,\n    HIGHLIGHT: 9,\n    UNDERLINE: 10,\n    SQUIGGLY: 11,\n    STRIKEOUT: 12,\n    STAMP: 13,\n    CARET: 14,\n    INK: 15,\n    POPUP: 16,\n    FILEATTACHMENT: 17,\n    SOUND: 18,\n    MOVIE: 19,\n    WIDGET: 20,\n    SCREEN: 21,\n    PRINTERMARK: 22,\n    TRAPNET: 23,\n    WATERMARK: 24,\n    THREED: 25,\n    REDACT: 26\n};\nconst AnnotationReplyType = {\n    GROUP: \"Group\",\n    REPLY: \"R\"\n};\nconst AnnotationFlag = {\n    INVISIBLE: 0x01,\n    HIDDEN: 0x02,\n    PRINT: 0x04,\n    NOZOOM: 0x08,\n    NOROTATE: 0x10,\n    NOVIEW: 0x20,\n    READONLY: 0x40,\n    LOCKED: 0x80,\n    TOGGLENOVIEW: 0x100,\n    LOCKEDCONTENTS: 0x200\n};\nconst AnnotationFieldFlag = {\n    READONLY: 0x0000001,\n    REQUIRED: 0x0000002,\n    NOEXPORT: 0x0000004,\n    MULTILINE: 0x0001000,\n    PASSWORD: 0x0002000,\n    NOTOGGLETOOFF: 0x0004000,\n    RADIO: 0x0008000,\n    PUSHBUTTON: 0x0010000,\n    COMBO: 0x0020000,\n    EDIT: 0x0040000,\n    SORT: 0x0080000,\n    FILESELECT: 0x0100000,\n    MULTISELECT: 0x0200000,\n    DONOTSPELLCHECK: 0x0400000,\n    DONOTSCROLL: 0x0800000,\n    COMB: 0x1000000,\n    RICHTEXT: 0x2000000,\n    RADIOSINUNISON: 0x2000000,\n    COMMITONSELCHANGE: 0x4000000\n};\nconst AnnotationBorderStyleType = {\n    SOLID: 1,\n    DASHED: 2,\n    BEVELED: 3,\n    INSET: 4,\n    UNDERLINE: 5\n};\nconst AnnotationActionEventType = {\n    E: \"Mouse Enter\",\n    X: \"Mouse Exit\",\n    D: \"Mouse Down\",\n    U: \"Mouse Up\",\n    Fo: \"Focus\",\n    Bl: \"Blur\",\n    PO: \"PageOpen\",\n    PC: \"PageClose\",\n    PV: \"PageVisible\",\n    PI: \"PageInvisible\",\n    K: \"Keystroke\",\n    F: \"Format\",\n    V: \"Validate\",\n    C: \"Calculate\"\n};\nconst DocumentActionEventType = {\n    WC: \"WillClose\",\n    WS: \"WillSave\",\n    DS: \"DidSave\",\n    WP: \"WillPrint\",\n    DP: \"DidPrint\"\n};\nconst PageActionEventType = {\n    O: \"PageOpen\",\n    C: \"PageClose\"\n};\nconst VerbosityLevel = {\n    ERRORS: 0,\n    WARNINGS: 1,\n    INFOS: 5\n};\nconst OPS = {\n    dependency: 1,\n    setLineWidth: 2,\n    setLineCap: 3,\n    setLineJoin: 4,\n    setMiterLimit: 5,\n    setDash: 6,\n    setRenderingIntent: 7,\n    setFlatness: 8,\n    setGState: 9,\n    save: 10,\n    restore: 11,\n    transform: 12,\n    moveTo: 13,\n    lineTo: 14,\n    curveTo: 15,\n    curveTo2: 16,\n    curveTo3: 17,\n    closePath: 18,\n    rectangle: 19,\n    stroke: 20,\n    closeStroke: 21,\n    fill: 22,\n    eoFill: 23,\n    fillStroke: 24,\n    eoFillStroke: 25,\n    closeFillStroke: 26,\n    closeEOFillStroke: 27,\n    endPath: 28,\n    clip: 29,\n    eoClip: 30,\n    beginText: 31,\n    endText: 32,\n    setCharSpacing: 33,\n    setWordSpacing: 34,\n    setHScale: 35,\n    setLeading: 36,\n    setFont: 37,\n    setTextRenderingMode: 38,\n    setTextRise: 39,\n    moveText: 40,\n    setLeadingMoveText: 41,\n    setTextMatrix: 42,\n    nextLine: 43,\n    showText: 44,\n    showSpacedText: 45,\n    nextLineShowText: 46,\n    nextLineSetSpacingShowText: 47,\n    setCharWidth: 48,\n    setCharWidthAndBounds: 49,\n    setStrokeColorSpace: 50,\n    setFillColorSpace: 51,\n    setStrokeColor: 52,\n    setStrokeColorN: 53,\n    setFillColor: 54,\n    setFillColorN: 55,\n    setStrokeGray: 56,\n    setFillGray: 57,\n    setStrokeRGBColor: 58,\n    setFillRGBColor: 59,\n    setStrokeCMYKColor: 60,\n    setFillCMYKColor: 61,\n    shadingFill: 62,\n    beginInlineImage: 63,\n    beginImageData: 64,\n    endInlineImage: 65,\n    paintXObject: 66,\n    markPoint: 67,\n    markPointProps: 68,\n    beginMarkedContent: 69,\n    beginMarkedContentProps: 70,\n    endMarkedContent: 71,\n    beginCompat: 72,\n    endCompat: 73,\n    paintFormXObjectBegin: 74,\n    paintFormXObjectEnd: 75,\n    beginGroup: 76,\n    endGroup: 77,\n    beginAnnotation: 80,\n    endAnnotation: 81,\n    paintImageMaskXObject: 83,\n    paintImageMaskXObjectGroup: 84,\n    paintImageXObject: 85,\n    paintInlineImageXObject: 86,\n    paintInlineImageXObjectGroup: 87,\n    paintImageXObjectRepeat: 88,\n    paintImageMaskXObjectRepeat: 89,\n    paintSolidColorImageMask: 90,\n    constructPath: 91,\n    setStrokeTransparent: 92,\n    setFillTransparent: 93\n};\nconst PasswordResponses = {\n    NEED_PASSWORD: 1,\n    INCORRECT_PASSWORD: 2\n};\nlet verbosity = VerbosityLevel.WARNINGS;\nfunction setVerbosityLevel(level) {\n    if (Number.isInteger(level)) {\n        verbosity = level;\n    }\n}\nfunction getVerbosityLevel() {\n    return verbosity;\n}\nfunction info(msg) {\n    if (verbosity >= VerbosityLevel.INFOS) {\n        console.log(`Info: ${msg}`);\n    }\n}\nfunction warn(msg) {\n    if (verbosity >= VerbosityLevel.WARNINGS) {\n        console.log(`Warning: ${msg}`);\n    }\n}\nfunction unreachable(msg) {\n    throw new Error(msg);\n}\nfunction assert(cond, msg) {\n    if (!cond) {\n        unreachable(msg);\n    }\n}\nfunction _isValidProtocol(url) {\n    switch(url?.protocol){\n        case \"http:\":\n        case \"https:\":\n        case \"ftp:\":\n        case \"mailto:\":\n        case \"tel:\":\n            return true;\n        default:\n            return false;\n    }\n}\nfunction createValidAbsoluteUrl(url, baseUrl = null, options = null) {\n    if (!url) {\n        return null;\n    }\n    try {\n        if (options && typeof url === \"string\") {\n            if (options.addDefaultProtocol && url.startsWith(\"www.\")) {\n                const dots = url.match(/\\./g);\n                if (dots?.length >= 2) {\n                    url = `http://${url}`;\n                }\n            }\n            if (options.tryConvertEncoding) {\n                try {\n                    url = stringToUTF8String(url);\n                } catch  {}\n            }\n        }\n        const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);\n        if (_isValidProtocol(absoluteUrl)) {\n            return absoluteUrl;\n        }\n    } catch  {}\n    return null;\n}\nfunction shadow(obj, prop, value, nonSerializable = false) {\n    Object.defineProperty(obj, prop, {\n        value,\n        enumerable: !nonSerializable,\n        configurable: true,\n        writable: false\n    });\n    return value;\n}\nconst BaseException = function BaseExceptionClosure() {\n    function BaseException(message, name) {\n        this.message = message;\n        this.name = name;\n    }\n    BaseException.prototype = new Error();\n    BaseException.constructor = BaseException;\n    return BaseException;\n}();\nclass PasswordException extends BaseException {\n    constructor(msg, code){\n        super(msg, \"PasswordException\");\n        this.code = code;\n    }\n}\nclass UnknownErrorException extends BaseException {\n    constructor(msg, details){\n        super(msg, \"UnknownErrorException\");\n        this.details = details;\n    }\n}\nclass InvalidPDFException extends BaseException {\n    constructor(msg){\n        super(msg, \"InvalidPDFException\");\n    }\n}\nclass MissingPDFException extends BaseException {\n    constructor(msg){\n        super(msg, \"MissingPDFException\");\n    }\n}\nclass UnexpectedResponseException extends BaseException {\n    constructor(msg, status){\n        super(msg, \"UnexpectedResponseException\");\n        this.status = status;\n    }\n}\nclass FormatError extends BaseException {\n    constructor(msg){\n        super(msg, \"FormatError\");\n    }\n}\nclass AbortException extends BaseException {\n    constructor(msg){\n        super(msg, \"AbortException\");\n    }\n}\nfunction bytesToString(bytes) {\n    if (typeof bytes !== \"object\" || bytes?.length === undefined) {\n        unreachable(\"Invalid argument for bytesToString\");\n    }\n    const length = bytes.length;\n    const MAX_ARGUMENT_COUNT = 8192;\n    if (length < MAX_ARGUMENT_COUNT) {\n        return String.fromCharCode.apply(null, bytes);\n    }\n    const strBuf = [];\n    for(let i = 0; i < length; i += MAX_ARGUMENT_COUNT){\n        const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);\n        const chunk = bytes.subarray(i, chunkEnd);\n        strBuf.push(String.fromCharCode.apply(null, chunk));\n    }\n    return strBuf.join(\"\");\n}\nfunction stringToBytes(str) {\n    if (typeof str !== \"string\") {\n        unreachable(\"Invalid argument for stringToBytes\");\n    }\n    const length = str.length;\n    const bytes = new Uint8Array(length);\n    for(let i = 0; i < length; ++i){\n        bytes[i] = str.charCodeAt(i) & 0xff;\n    }\n    return bytes;\n}\nfunction string32(value) {\n    return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);\n}\nfunction objectSize(obj) {\n    return Object.keys(obj).length;\n}\nfunction objectFromMap(map) {\n    const obj = Object.create(null);\n    for (const [key, value] of map){\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction isLittleEndian() {\n    const buffer8 = new Uint8Array(4);\n    buffer8[0] = 1;\n    const view32 = new Uint32Array(buffer8.buffer, 0, 1);\n    return view32[0] === 1;\n}\nfunction isEvalSupported() {\n    try {\n        new Function(\"\");\n        return true;\n    } catch  {\n        return false;\n    }\n}\nclass util_FeatureTest {\n    static get isLittleEndian() {\n        return shadow(this, \"isLittleEndian\", isLittleEndian());\n    }\n    static get isEvalSupported() {\n        return shadow(this, \"isEvalSupported\", isEvalSupported());\n    }\n    static get isOffscreenCanvasSupported() {\n        return shadow(this, \"isOffscreenCanvasSupported\", typeof OffscreenCanvas !== \"undefined\");\n    }\n    static get isImageDecoderSupported() {\n        return shadow(this, \"isImageDecoderSupported\", typeof ImageDecoder !== \"undefined\");\n    }\n    static get platform() {\n        if (typeof navigator !== \"undefined\" && typeof navigator?.platform === \"string\") {\n            return shadow(this, \"platform\", {\n                isMac: navigator.platform.includes(\"Mac\"),\n                isWindows: navigator.platform.includes(\"Win\"),\n                isFirefox: typeof navigator?.userAgent === \"string\" && navigator.userAgent.includes(\"Firefox\")\n            });\n        }\n        return shadow(this, \"platform\", {\n            isMac: false,\n            isWindows: false,\n            isFirefox: false\n        });\n    }\n    static get isCSSRoundSupported() {\n        return shadow(this, \"isCSSRoundSupported\", globalThis.CSS?.supports?.(\"width: round(1.5px, 1px)\"));\n    }\n}\nconst hexNumbers = Array.from(Array(256).keys(), (n)=>n.toString(16).padStart(2, \"0\"));\nclass Util {\n    static makeHexColor(r, g, b) {\n        return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;\n    }\n    static scaleMinMax(transform, minMax) {\n        let temp;\n        if (transform[0]) {\n            if (transform[0] < 0) {\n                temp = minMax[0];\n                minMax[0] = minMax[2];\n                minMax[2] = temp;\n            }\n            minMax[0] *= transform[0];\n            minMax[2] *= transform[0];\n            if (transform[3] < 0) {\n                temp = minMax[1];\n                minMax[1] = minMax[3];\n                minMax[3] = temp;\n            }\n            minMax[1] *= transform[3];\n            minMax[3] *= transform[3];\n        } else {\n            temp = minMax[0];\n            minMax[0] = minMax[1];\n            minMax[1] = temp;\n            temp = minMax[2];\n            minMax[2] = minMax[3];\n            minMax[3] = temp;\n            if (transform[1] < 0) {\n                temp = minMax[1];\n                minMax[1] = minMax[3];\n                minMax[3] = temp;\n            }\n            minMax[1] *= transform[1];\n            minMax[3] *= transform[1];\n            if (transform[2] < 0) {\n                temp = minMax[0];\n                minMax[0] = minMax[2];\n                minMax[2] = temp;\n            }\n            minMax[0] *= transform[2];\n            minMax[2] *= transform[2];\n        }\n        minMax[0] += transform[4];\n        minMax[1] += transform[5];\n        minMax[2] += transform[4];\n        minMax[3] += transform[5];\n    }\n    static transform(m1, m2) {\n        return [\n            m1[0] * m2[0] + m1[2] * m2[1],\n            m1[1] * m2[0] + m1[3] * m2[1],\n            m1[0] * m2[2] + m1[2] * m2[3],\n            m1[1] * m2[2] + m1[3] * m2[3],\n            m1[0] * m2[4] + m1[2] * m2[5] + m1[4],\n            m1[1] * m2[4] + m1[3] * m2[5] + m1[5]\n        ];\n    }\n    static applyTransform(p, m) {\n        const xt = p[0] * m[0] + p[1] * m[2] + m[4];\n        const yt = p[0] * m[1] + p[1] * m[3] + m[5];\n        return [\n            xt,\n            yt\n        ];\n    }\n    static applyInverseTransform(p, m) {\n        const d = m[0] * m[3] - m[1] * m[2];\n        const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;\n        const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;\n        return [\n            xt,\n            yt\n        ];\n    }\n    static getAxialAlignedBoundingBox(r, m) {\n        const p1 = this.applyTransform(r, m);\n        const p2 = this.applyTransform(r.slice(2, 4), m);\n        const p3 = this.applyTransform([\n            r[0],\n            r[3]\n        ], m);\n        const p4 = this.applyTransform([\n            r[2],\n            r[1]\n        ], m);\n        return [\n            Math.min(p1[0], p2[0], p3[0], p4[0]),\n            Math.min(p1[1], p2[1], p3[1], p4[1]),\n            Math.max(p1[0], p2[0], p3[0], p4[0]),\n            Math.max(p1[1], p2[1], p3[1], p4[1])\n        ];\n    }\n    static inverseTransform(m) {\n        const d = m[0] * m[3] - m[1] * m[2];\n        return [\n            m[3] / d,\n            -m[1] / d,\n            -m[2] / d,\n            m[0] / d,\n            (m[2] * m[5] - m[4] * m[3]) / d,\n            (m[4] * m[1] - m[5] * m[0]) / d\n        ];\n    }\n    static singularValueDecompose2dScale(m) {\n        const transpose = [\n            m[0],\n            m[2],\n            m[1],\n            m[3]\n        ];\n        const a = m[0] * transpose[0] + m[1] * transpose[2];\n        const b = m[0] * transpose[1] + m[1] * transpose[3];\n        const c = m[2] * transpose[0] + m[3] * transpose[2];\n        const d = m[2] * transpose[1] + m[3] * transpose[3];\n        const first = (a + d) / 2;\n        const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;\n        const sx = first + second || 1;\n        const sy = first - second || 1;\n        return [\n            Math.sqrt(sx),\n            Math.sqrt(sy)\n        ];\n    }\n    static normalizeRect(rect) {\n        const r = rect.slice(0);\n        if (rect[0] > rect[2]) {\n            r[0] = rect[2];\n            r[2] = rect[0];\n        }\n        if (rect[1] > rect[3]) {\n            r[1] = rect[3];\n            r[3] = rect[1];\n        }\n        return r;\n    }\n    static intersect(rect1, rect2) {\n        const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));\n        const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));\n        if (xLow > xHigh) {\n            return null;\n        }\n        const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));\n        const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));\n        if (yLow > yHigh) {\n            return null;\n        }\n        return [\n            xLow,\n            yLow,\n            xHigh,\n            yHigh\n        ];\n    }\n    static #getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, t, minMax) {\n        if (t <= 0 || t >= 1) {\n            return;\n        }\n        const mt = 1 - t;\n        const tt = t * t;\n        const ttt = tt * t;\n        const x = mt * (mt * (mt * x0 + 3 * t * x1) + 3 * tt * x2) + ttt * x3;\n        const y = mt * (mt * (mt * y0 + 3 * t * y1) + 3 * tt * y2) + ttt * y3;\n        minMax[0] = Math.min(minMax[0], x);\n        minMax[1] = Math.min(minMax[1], y);\n        minMax[2] = Math.max(minMax[2], x);\n        minMax[3] = Math.max(minMax[3], y);\n    }\n    static #getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, a, b, c, minMax) {\n        if (Math.abs(a) < 1e-12) {\n            if (Math.abs(b) >= 1e-12) {\n                this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, -c / b, minMax);\n            }\n            return;\n        }\n        const delta = b ** 2 - 4 * c * a;\n        if (delta < 0) {\n            return;\n        }\n        const sqrtDelta = Math.sqrt(delta);\n        const a2 = 2 * a;\n        this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, (-b + sqrtDelta) / a2, minMax);\n        this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, (-b - sqrtDelta) / a2, minMax);\n    }\n    static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3, minMax) {\n        if (minMax) {\n            minMax[0] = Math.min(minMax[0], x0, x3);\n            minMax[1] = Math.min(minMax[1], y0, y3);\n            minMax[2] = Math.max(minMax[2], x0, x3);\n            minMax[3] = Math.max(minMax[3], y0, y3);\n        } else {\n            minMax = [\n                Math.min(x0, x3),\n                Math.min(y0, y3),\n                Math.max(x0, x3),\n                Math.max(y0, y3)\n            ];\n        }\n        this.#getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-x0 + 3 * (x1 - x2) + x3), 6 * (x0 - 2 * x1 + x2), 3 * (x1 - x0), minMax);\n        this.#getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-y0 + 3 * (y1 - y2) + y3), 6 * (y0 - 2 * y1 + y2), 3 * (y1 - y0), minMax);\n        return minMax;\n    }\n}\nconst PDFStringTranslateTable = /* unused pure expression or super */ null && 0;\nfunction stringToPDFString(str) {\n    if (str[0] >= \"\\xef\") {\n        let encoding;\n        if (str[0] === \"\\xfe\" && str[1] === \"\\xff\") {\n            encoding = \"utf-16be\";\n            if (str.length % 2 === 1) {\n                str = str.slice(0, -1);\n            }\n        } else if (str[0] === \"\\xff\" && str[1] === \"\\xfe\") {\n            encoding = \"utf-16le\";\n            if (str.length % 2 === 1) {\n                str = str.slice(0, -1);\n            }\n        } else if (str[0] === \"\\xef\" && str[1] === \"\\xbb\" && str[2] === \"\\xbf\") {\n            encoding = \"utf-8\";\n        }\n        if (encoding) {\n            try {\n                const decoder = new TextDecoder(encoding, {\n                    fatal: true\n                });\n                const buffer = stringToBytes(str);\n                const decoded = decoder.decode(buffer);\n                if (!decoded.includes(\"\\x1b\")) {\n                    return decoded;\n                }\n                return decoded.replaceAll(/\\x1b[^\\x1b]*(?:\\x1b|$)/g, \"\");\n            } catch (ex) {\n                warn(`stringToPDFString: \"${ex}\".`);\n            }\n        }\n    }\n    const strBuf = [];\n    for(let i = 0, ii = str.length; i < ii; i++){\n        const charCode = str.charCodeAt(i);\n        if (charCode === 0x1b) {\n            while(++i < ii && str.charCodeAt(i) !== 0x1b){}\n            continue;\n        }\n        const code = PDFStringTranslateTable[charCode];\n        strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));\n    }\n    return strBuf.join(\"\");\n}\nfunction stringToUTF8String(str) {\n    return decodeURIComponent(escape(str));\n}\nfunction utf8StringToString(str) {\n    return unescape(encodeURIComponent(str));\n}\nfunction isArrayEqual(arr1, arr2) {\n    if (arr1.length !== arr2.length) {\n        return false;\n    }\n    for(let i = 0, ii = arr1.length; i < ii; i++){\n        if (arr1[i] !== arr2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction getModificationDate(date = new Date()) {\n    const buffer = [\n        date.getUTCFullYear().toString(),\n        (date.getUTCMonth() + 1).toString().padStart(2, \"0\"),\n        date.getUTCDate().toString().padStart(2, \"0\"),\n        date.getUTCHours().toString().padStart(2, \"0\"),\n        date.getUTCMinutes().toString().padStart(2, \"0\"),\n        date.getUTCSeconds().toString().padStart(2, \"0\")\n    ];\n    return buffer.join(\"\");\n}\nlet NormalizeRegex = null;\nlet NormalizationMap = null;\nfunction normalizeUnicode(str) {\n    if (!NormalizeRegex) {\n        NormalizeRegex = /([\\u00a0\\u00b5\\u037e\\u0eb3\\u2000-\\u200a\\u202f\\u2126\\ufb00-\\ufb04\\ufb06\\ufb20-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufba1\\ufba4-\\ufba9\\ufbae-\\ufbb1\\ufbd3-\\ufbdc\\ufbde-\\ufbe7\\ufbea-\\ufbf8\\ufbfc-\\ufbfd\\ufc00-\\ufc5d\\ufc64-\\ufcf1\\ufcf5-\\ufd3d\\ufd88\\ufdf4\\ufdfa-\\ufdfb\\ufe71\\ufe77\\ufe79\\ufe7b\\ufe7d]+)|(\\ufb05+)/gu;\n        NormalizationMap = new Map([\n            [\n                \"ﬅ\",\n                \"ſt\"\n            ]\n        ]);\n    }\n    return str.replaceAll(NormalizeRegex, (_, p1, p2)=>p1 ? p1.normalize(\"NFKC\") : NormalizationMap.get(p2));\n}\nfunction getUuid() {\n    if (typeof crypto.randomUUID === \"function\") {\n        return crypto.randomUUID();\n    }\n    const buf = new Uint8Array(32);\n    crypto.getRandomValues(buf);\n    return bytesToString(buf);\n}\nconst AnnotationPrefix = \"pdfjs_internal_id_\";\nconst FontRenderOps = {\n    BEZIER_CURVE_TO: 0,\n    MOVE_TO: 1,\n    LINE_TO: 2,\n    QUADRATIC_CURVE_TO: 3,\n    RESTORE: 4,\n    SAVE: 5,\n    SCALE: 6,\n    TRANSFORM: 7,\n    TRANSLATE: 8\n};\nfunction toHexUtil(arr) {\n    if (Uint8Array.prototype.toHex) {\n        return arr.toHex();\n    }\n    return Array.from(arr, (num)=>hexNumbers[num]).join(\"\");\n}\nfunction toBase64Util(arr) {\n    if (Uint8Array.prototype.toBase64) {\n        return arr.toBase64();\n    }\n    return btoa(bytesToString(arr));\n}\nfunction fromBase64Util(str) {\n    if (Uint8Array.fromBase64) {\n        return Uint8Array.fromBase64(str);\n    }\n    return stringToBytes(atob(str));\n}\nif (typeof Promise.try !== \"function\") {\n    Promise.try = function(fn, ...args) {\n        return new Promise((resolve)=>{\n            resolve(fn(...args));\n        });\n    };\n}\n; // ./src/display/display_utils.js\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\nclass PixelsPerInch {\n    static{\n        this.CSS = 96.0;\n    }\n    static{\n        this.PDF = 72.0;\n    }\n    static{\n        this.PDF_TO_CSS_UNITS = this.CSS / this.PDF;\n    }\n}\nasync function fetchData(url, type = \"text\") {\n    if (isValidFetchUrl(url, document.baseURI)) {\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(response.statusText);\n        }\n        switch(type){\n            case \"arraybuffer\":\n                return response.arrayBuffer();\n            case \"blob\":\n                return response.blob();\n            case \"json\":\n                return response.json();\n        }\n        return response.text();\n    }\n    return new Promise((resolve, reject)=>{\n        const request = new XMLHttpRequest();\n        request.open(\"GET\", url, true);\n        request.responseType = type;\n        request.onreadystatechange = ()=>{\n            if (request.readyState !== XMLHttpRequest.DONE) {\n                return;\n            }\n            if (request.status === 200 || request.status === 0) {\n                switch(type){\n                    case \"arraybuffer\":\n                    case \"blob\":\n                    case \"json\":\n                        resolve(request.response);\n                        return;\n                }\n                resolve(request.responseText);\n                return;\n            }\n            reject(new Error(request.statusText));\n        };\n        request.send(null);\n    });\n}\nclass PageViewport {\n    constructor({ viewBox, scale, rotation, offsetX = 0, offsetY = 0, dontFlip = false }){\n        this.viewBox = viewBox;\n        this.scale = scale;\n        this.rotation = rotation;\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        const centerX = (viewBox[2] + viewBox[0]) / 2;\n        const centerY = (viewBox[3] + viewBox[1]) / 2;\n        let rotateA, rotateB, rotateC, rotateD;\n        rotation %= 360;\n        if (rotation < 0) {\n            rotation += 360;\n        }\n        switch(rotation){\n            case 180:\n                rotateA = -1;\n                rotateB = 0;\n                rotateC = 0;\n                rotateD = 1;\n                break;\n            case 90:\n                rotateA = 0;\n                rotateB = 1;\n                rotateC = 1;\n                rotateD = 0;\n                break;\n            case 270:\n                rotateA = 0;\n                rotateB = -1;\n                rotateC = -1;\n                rotateD = 0;\n                break;\n            case 0:\n                rotateA = 1;\n                rotateB = 0;\n                rotateC = 0;\n                rotateD = -1;\n                break;\n            default:\n                throw new Error(\"PageViewport: Invalid rotation, must be a multiple of 90 degrees.\");\n        }\n        if (dontFlip) {\n            rotateC = -rotateC;\n            rotateD = -rotateD;\n        }\n        let offsetCanvasX, offsetCanvasY;\n        let width, height;\n        if (rotateA === 0) {\n            offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;\n            offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;\n            width = (viewBox[3] - viewBox[1]) * scale;\n            height = (viewBox[2] - viewBox[0]) * scale;\n        } else {\n            offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;\n            offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;\n            width = (viewBox[2] - viewBox[0]) * scale;\n            height = (viewBox[3] - viewBox[1]) * scale;\n        }\n        this.transform = [\n            rotateA * scale,\n            rotateB * scale,\n            rotateC * scale,\n            rotateD * scale,\n            offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY,\n            offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY\n        ];\n        this.width = width;\n        this.height = height;\n    }\n    get rawDims() {\n        const { viewBox } = this;\n        return shadow(this, \"rawDims\", {\n            pageWidth: viewBox[2] - viewBox[0],\n            pageHeight: viewBox[3] - viewBox[1],\n            pageX: viewBox[0],\n            pageY: viewBox[1]\n        });\n    }\n    clone({ scale = this.scale, rotation = this.rotation, offsetX = this.offsetX, offsetY = this.offsetY, dontFlip = false } = {}) {\n        return new PageViewport({\n            viewBox: this.viewBox.slice(),\n            scale,\n            rotation,\n            offsetX,\n            offsetY,\n            dontFlip\n        });\n    }\n    convertToViewportPoint(x, y) {\n        return Util.applyTransform([\n            x,\n            y\n        ], this.transform);\n    }\n    convertToViewportRectangle(rect) {\n        const topLeft = Util.applyTransform([\n            rect[0],\n            rect[1]\n        ], this.transform);\n        const bottomRight = Util.applyTransform([\n            rect[2],\n            rect[3]\n        ], this.transform);\n        return [\n            topLeft[0],\n            topLeft[1],\n            bottomRight[0],\n            bottomRight[1]\n        ];\n    }\n    convertToPdfPoint(x, y) {\n        return Util.applyInverseTransform([\n            x,\n            y\n        ], this.transform);\n    }\n}\nclass RenderingCancelledException extends BaseException {\n    constructor(msg, extraDelay = 0){\n        super(msg, \"RenderingCancelledException\");\n        this.extraDelay = extraDelay;\n    }\n}\nfunction isDataScheme(url) {\n    const ii = url.length;\n    let i = 0;\n    while(i < ii && url[i].trim() === \"\"){\n        i++;\n    }\n    return url.substring(i, i + 5).toLowerCase() === \"data:\";\n}\nfunction isPdfFile(filename) {\n    return typeof filename === \"string\" && /\\.pdf$/i.test(filename);\n}\nfunction getFilenameFromUrl(url) {\n    [url] = url.split(/[#?]/, 1);\n    return url.substring(url.lastIndexOf(\"/\") + 1);\n}\nfunction getPdfFilenameFromUrl(url, defaultFilename = \"document.pdf\") {\n    if (typeof url !== \"string\") {\n        return defaultFilename;\n    }\n    if (isDataScheme(url)) {\n        warn('getPdfFilenameFromUrl: ignore \"data:\"-URL for performance reasons.');\n        return defaultFilename;\n    }\n    const reURI = /^(?:(?:[^:]+:)?\\/\\/[^/]+)?([^?#]*)(\\?[^#]*)?(#.*)?$/;\n    const reFilename = /[^/?#=]+\\.pdf\\b(?!.*\\.pdf\\b)/i;\n    const splitURI = reURI.exec(url);\n    let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);\n    if (suggestedFilename) {\n        suggestedFilename = suggestedFilename[0];\n        if (suggestedFilename.includes(\"%\")) {\n            try {\n                suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];\n            } catch  {}\n        }\n    }\n    return suggestedFilename || defaultFilename;\n}\nclass StatTimer {\n    time(name) {\n        if (name in this.started) {\n            warn(`Timer is already running for ${name}`);\n        }\n        this.started[name] = Date.now();\n    }\n    timeEnd(name) {\n        if (!(name in this.started)) {\n            warn(`Timer has not been started for ${name}`);\n        }\n        this.times.push({\n            name,\n            start: this.started[name],\n            end: Date.now()\n        });\n        delete this.started[name];\n    }\n    toString() {\n        const outBuf = [];\n        let longest = 0;\n        for (const { name } of this.times){\n            longest = Math.max(name.length, longest);\n        }\n        for (const { name, start, end } of this.times){\n            outBuf.push(`${name.padEnd(longest)} ${end - start}ms\\n`);\n        }\n        return outBuf.join(\"\");\n    }\n    constructor(){\n        this.started = Object.create(null);\n        this.times = [];\n    }\n}\nfunction isValidFetchUrl(url, baseUrl) {\n    try {\n        const { protocol } = baseUrl ? new URL(url, baseUrl) : new URL(url);\n        return protocol === \"http:\" || protocol === \"https:\";\n    } catch  {\n        return false;\n    }\n}\nfunction noContextMenu(e) {\n    e.preventDefault();\n}\nfunction stopEvent(e) {\n    e.preventDefault();\n    e.stopPropagation();\n}\nfunction deprecated(details) {\n    console.log(\"Deprecated API usage: \" + details);\n}\nclass PDFDateString {\n    static #regex;\n    static toDateObject(input) {\n        if (!input || typeof input !== \"string\") {\n            return null;\n        }\n        this.#regex ||= new RegExp(\"^D:\" + \"(\\\\d{4})\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"([Z|+|-])?\" + \"(\\\\d{2})?\" + \"'?\" + \"(\\\\d{2})?\" + \"'?\");\n        const matches = this.#regex.exec(input);\n        if (!matches) {\n            return null;\n        }\n        const year = parseInt(matches[1], 10);\n        let month = parseInt(matches[2], 10);\n        month = month >= 1 && month <= 12 ? month - 1 : 0;\n        let day = parseInt(matches[3], 10);\n        day = day >= 1 && day <= 31 ? day : 1;\n        let hour = parseInt(matches[4], 10);\n        hour = hour >= 0 && hour <= 23 ? hour : 0;\n        let minute = parseInt(matches[5], 10);\n        minute = minute >= 0 && minute <= 59 ? minute : 0;\n        let second = parseInt(matches[6], 10);\n        second = second >= 0 && second <= 59 ? second : 0;\n        const universalTimeRelation = matches[7] || \"Z\";\n        let offsetHour = parseInt(matches[8], 10);\n        offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;\n        let offsetMinute = parseInt(matches[9], 10) || 0;\n        offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;\n        if (universalTimeRelation === \"-\") {\n            hour += offsetHour;\n            minute += offsetMinute;\n        } else if (universalTimeRelation === \"+\") {\n            hour -= offsetHour;\n            minute -= offsetMinute;\n        }\n        return new Date(Date.UTC(year, month, day, hour, minute, second));\n    }\n}\nfunction getXfaPageViewport(xfaPage, { scale = 1, rotation = 0 }) {\n    const { width, height } = xfaPage.attributes.style;\n    const viewBox = [\n        0,\n        0,\n        parseInt(width),\n        parseInt(height)\n    ];\n    return new PageViewport({\n        viewBox,\n        scale,\n        rotation\n    });\n}\nfunction getRGB(color) {\n    if (color.startsWith(\"#\")) {\n        const colorRGB = parseInt(color.slice(1), 16);\n        return [\n            (colorRGB & 0xff0000) >> 16,\n            (colorRGB & 0x00ff00) >> 8,\n            colorRGB & 0x0000ff\n        ];\n    }\n    if (color.startsWith(\"rgb(\")) {\n        return color.slice(4, -1).split(\",\").map((x)=>parseInt(x));\n    }\n    if (color.startsWith(\"rgba(\")) {\n        return color.slice(5, -1).split(\",\").map((x)=>parseInt(x)).slice(0, 3);\n    }\n    warn(`Not a valid color format: \"${color}\"`);\n    return [\n        0,\n        0,\n        0\n    ];\n}\nfunction getColorValues(colors) {\n    const span = document.createElement(\"span\");\n    span.style.visibility = \"hidden\";\n    document.body.append(span);\n    for (const name of colors.keys()){\n        span.style.color = name;\n        const computedColor = window.getComputedStyle(span).color;\n        colors.set(name, getRGB(computedColor));\n    }\n    span.remove();\n}\nfunction getCurrentTransform(ctx) {\n    const { a, b, c, d, e, f } = ctx.getTransform();\n    return [\n        a,\n        b,\n        c,\n        d,\n        e,\n        f\n    ];\n}\nfunction getCurrentTransformInverse(ctx) {\n    const { a, b, c, d, e, f } = ctx.getTransform().invertSelf();\n    return [\n        a,\n        b,\n        c,\n        d,\n        e,\n        f\n    ];\n}\nfunction setLayerDimensions(div, viewport, mustFlip = false, mustRotate = true) {\n    if (viewport instanceof PageViewport) {\n        const { pageWidth, pageHeight } = viewport.rawDims;\n        const { style } = div;\n        const useRound = util_FeatureTest.isCSSRoundSupported;\n        const w = `var(--scale-factor) * ${pageWidth}px`, h = `var(--scale-factor) * ${pageHeight}px`;\n        const widthStr = useRound ? `round(down, ${w}, var(--scale-round-x, 1px))` : `calc(${w})`, heightStr = useRound ? `round(down, ${h}, var(--scale-round-y, 1px))` : `calc(${h})`;\n        if (!mustFlip || viewport.rotation % 180 === 0) {\n            style.width = widthStr;\n            style.height = heightStr;\n        } else {\n            style.width = heightStr;\n            style.height = widthStr;\n        }\n    }\n    if (mustRotate) {\n        div.setAttribute(\"data-main-rotation\", viewport.rotation);\n    }\n}\nclass OutputScale {\n    constructor(){\n        const pixelRatio = window.devicePixelRatio || 1;\n        this.sx = pixelRatio;\n        this.sy = pixelRatio;\n    }\n    get scaled() {\n        return this.sx !== 1 || this.sy !== 1;\n    }\n    get symmetric() {\n        return this.sx === this.sy;\n    }\n}\n; // ./src/display/editor/toolbar.js\nclass EditorToolbar {\n    #toolbar;\n    #colorPicker;\n    #editor;\n    #buttons;\n    #altText;\n    static #l10nRemove = null;\n    constructor(editor){\n        this.#toolbar = null;\n        this.#colorPicker = null;\n        this.#buttons = null;\n        this.#altText = null;\n        this.#editor = editor;\n        EditorToolbar.#l10nRemove ||= Object.freeze({\n            freetext: \"pdfjs-editor-remove-freetext-button\",\n            highlight: \"pdfjs-editor-remove-highlight-button\",\n            ink: \"pdfjs-editor-remove-ink-button\",\n            stamp: \"pdfjs-editor-remove-stamp-button\"\n        });\n    }\n    render() {\n        const editToolbar = this.#toolbar = document.createElement(\"div\");\n        editToolbar.classList.add(\"editToolbar\", \"hidden\");\n        editToolbar.setAttribute(\"role\", \"toolbar\");\n        const signal = this.#editor._uiManager._signal;\n        editToolbar.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        editToolbar.addEventListener(\"pointerdown\", EditorToolbar.#pointerDown, {\n            signal\n        });\n        const buttons = this.#buttons = document.createElement(\"div\");\n        buttons.className = \"buttons\";\n        editToolbar.append(buttons);\n        const position = this.#editor.toolbarPosition;\n        if (position) {\n            const { style } = editToolbar;\n            const x = this.#editor._uiManager.direction === \"ltr\" ? 1 - position[0] : position[0];\n            style.insetInlineEnd = `${100 * x}%`;\n            style.top = `calc(${100 * position[1]}% + var(--editor-toolbar-vert-offset))`;\n        }\n        this.#addDeleteButton();\n        return editToolbar;\n    }\n    get div() {\n        return this.#toolbar;\n    }\n    static #pointerDown(e) {\n        e.stopPropagation();\n    }\n    #focusIn(e) {\n        this.#editor._focusEventsAllowed = false;\n        stopEvent(e);\n    }\n    #focusOut(e) {\n        this.#editor._focusEventsAllowed = true;\n        stopEvent(e);\n    }\n    #addListenersToElement(element) {\n        const signal = this.#editor._uiManager._signal;\n        element.addEventListener(\"focusin\", this.#focusIn.bind(this), {\n            capture: true,\n            signal\n        });\n        element.addEventListener(\"focusout\", this.#focusOut.bind(this), {\n            capture: true,\n            signal\n        });\n        element.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n    }\n    hide() {\n        this.#toolbar.classList.add(\"hidden\");\n        this.#colorPicker?.hideDropdown();\n    }\n    show() {\n        this.#toolbar.classList.remove(\"hidden\");\n        this.#altText?.shown();\n    }\n    #addDeleteButton() {\n        const { editorType, _uiManager } = this.#editor;\n        const button = document.createElement(\"button\");\n        button.className = \"delete\";\n        button.tabIndex = 0;\n        button.setAttribute(\"data-l10n-id\", EditorToolbar.#l10nRemove[editorType]);\n        this.#addListenersToElement(button);\n        button.addEventListener(\"click\", (e)=>{\n            _uiManager.delete();\n        }, {\n            signal: _uiManager._signal\n        });\n        this.#buttons.append(button);\n    }\n    get #divider() {\n        const divider = document.createElement(\"div\");\n        divider.className = \"divider\";\n        return divider;\n    }\n    async addAltText(altText) {\n        const button = await altText.render();\n        this.#addListenersToElement(button);\n        this.#buttons.prepend(button, this.#divider);\n        this.#altText = altText;\n    }\n    addColorPicker(colorPicker) {\n        this.#colorPicker = colorPicker;\n        const button = colorPicker.renderButton();\n        this.#addListenersToElement(button);\n        this.#buttons.prepend(button, this.#divider);\n    }\n    remove() {\n        this.#toolbar.remove();\n        this.#colorPicker?.destroy();\n        this.#colorPicker = null;\n    }\n}\nclass HighlightToolbar {\n    #buttons;\n    #toolbar;\n    #uiManager;\n    constructor(uiManager){\n        this.#buttons = null;\n        this.#toolbar = null;\n        this.#uiManager = uiManager;\n    }\n    #render() {\n        const editToolbar = this.#toolbar = document.createElement(\"div\");\n        editToolbar.className = \"editToolbar\";\n        editToolbar.setAttribute(\"role\", \"toolbar\");\n        editToolbar.addEventListener(\"contextmenu\", noContextMenu, {\n            signal: this.#uiManager._signal\n        });\n        const buttons = this.#buttons = document.createElement(\"div\");\n        buttons.className = \"buttons\";\n        editToolbar.append(buttons);\n        this.#addHighlightButton();\n        return editToolbar;\n    }\n    #getLastPoint(boxes, isLTR) {\n        let lastY = 0;\n        let lastX = 0;\n        for (const box of boxes){\n            const y = box.y + box.height;\n            if (y < lastY) {\n                continue;\n            }\n            const x = box.x + (isLTR ? box.width : 0);\n            if (y > lastY) {\n                lastX = x;\n                lastY = y;\n                continue;\n            }\n            if (isLTR) {\n                if (x > lastX) {\n                    lastX = x;\n                }\n            } else if (x < lastX) {\n                lastX = x;\n            }\n        }\n        return [\n            isLTR ? 1 - lastX : lastX,\n            lastY\n        ];\n    }\n    show(parent, boxes, isLTR) {\n        const [x, y] = this.#getLastPoint(boxes, isLTR);\n        const { style } = this.#toolbar ||= this.#render();\n        parent.append(this.#toolbar);\n        style.insetInlineEnd = `${100 * x}%`;\n        style.top = `calc(${100 * y}% + var(--editor-toolbar-vert-offset))`;\n    }\n    hide() {\n        this.#toolbar.remove();\n    }\n    #addHighlightButton() {\n        const button = document.createElement(\"button\");\n        button.className = \"highlightButton\";\n        button.tabIndex = 0;\n        button.setAttribute(\"data-l10n-id\", `pdfjs-highlight-floating-button1`);\n        const span = document.createElement(\"span\");\n        button.append(span);\n        span.className = \"visuallyHidden\";\n        span.setAttribute(\"data-l10n-id\", \"pdfjs-highlight-floating-button-label\");\n        const signal = this.#uiManager._signal;\n        button.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        button.addEventListener(\"click\", ()=>{\n            this.#uiManager.highlightSelection(\"floating_button\");\n        }, {\n            signal\n        });\n        this.#buttons.append(button);\n    }\n}\n; // ./src/display/editor/tools.js\nfunction bindEvents(obj, element, names) {\n    for (const name of names){\n        element.addEventListener(name, obj[name].bind(obj));\n    }\n}\nfunction opacityToHex(opacity) {\n    return Math.round(Math.min(255, Math.max(1, 255 * opacity))).toString(16).padStart(2, \"0\");\n}\nclass IdManager {\n    #id;\n    get id() {\n        return `${AnnotationEditorPrefix}${this.#id++}`;\n    }\n    constructor(){\n        this.#id = 0;\n    }\n}\nclass ImageManager {\n    #baseId;\n    #id;\n    #cache;\n    static get _isSVGFittingCanvas() {\n        const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n        const canvas = new OffscreenCanvas(1, 3);\n        const ctx = canvas.getContext(\"2d\", {\n            willReadFrequently: true\n        });\n        const image = new Image();\n        image.src = svg;\n        const promise = image.decode().then(()=>{\n            ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);\n            return new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0] === 0;\n        });\n        return shadow(this, \"_isSVGFittingCanvas\", promise);\n    }\n    async #get(key, rawData) {\n        this.#cache ||= new Map();\n        let data = this.#cache.get(key);\n        if (data === null) {\n            return null;\n        }\n        if (data?.bitmap) {\n            data.refCounter += 1;\n            return data;\n        }\n        try {\n            data ||= {\n                bitmap: null,\n                id: `image_${this.#baseId}_${this.#id++}`,\n                refCounter: 0,\n                isSvg: false\n            };\n            let image;\n            if (typeof rawData === \"string\") {\n                data.url = rawData;\n                image = await fetchData(rawData, \"blob\");\n            } else if (rawData instanceof File) {\n                image = data.file = rawData;\n            } else if (rawData instanceof Blob) {\n                image = rawData;\n            }\n            if (image.type === \"image/svg+xml\") {\n                const mustRemoveAspectRatioPromise = ImageManager._isSVGFittingCanvas;\n                const fileReader = new FileReader();\n                const imageElement = new Image();\n                const imagePromise = new Promise((resolve, reject)=>{\n                    imageElement.onload = ()=>{\n                        data.bitmap = imageElement;\n                        data.isSvg = true;\n                        resolve();\n                    };\n                    fileReader.onload = async ()=>{\n                        const url = data.svgUrl = fileReader.result;\n                        imageElement.src = await mustRemoveAspectRatioPromise ? `${url}#svgView(preserveAspectRatio(none))` : url;\n                    };\n                    imageElement.onerror = fileReader.onerror = reject;\n                });\n                fileReader.readAsDataURL(image);\n                await imagePromise;\n            } else {\n                data.bitmap = await createImageBitmap(image);\n            }\n            data.refCounter = 1;\n        } catch (e) {\n            warn(e);\n            data = null;\n        }\n        this.#cache.set(key, data);\n        if (data) {\n            this.#cache.set(data.id, data);\n        }\n        return data;\n    }\n    async getFromFile(file) {\n        const { lastModified, name, size, type } = file;\n        return this.#get(`${lastModified}_${name}_${size}_${type}`, file);\n    }\n    async getFromUrl(url) {\n        return this.#get(url, url);\n    }\n    async getFromBlob(id, blobPromise) {\n        const blob = await blobPromise;\n        return this.#get(id, blob);\n    }\n    async getFromId(id) {\n        this.#cache ||= new Map();\n        const data = this.#cache.get(id);\n        if (!data) {\n            return null;\n        }\n        if (data.bitmap) {\n            data.refCounter += 1;\n            return data;\n        }\n        if (data.file) {\n            return this.getFromFile(data.file);\n        }\n        if (data.blobPromise) {\n            const { blobPromise } = data;\n            delete data.blobPromise;\n            return this.getFromBlob(data.id, blobPromise);\n        }\n        return this.getFromUrl(data.url);\n    }\n    getFromCanvas(id, canvas) {\n        this.#cache ||= new Map();\n        let data = this.#cache.get(id);\n        if (data?.bitmap) {\n            data.refCounter += 1;\n            return data;\n        }\n        const offscreen = new OffscreenCanvas(canvas.width, canvas.height);\n        const ctx = offscreen.getContext(\"2d\");\n        ctx.drawImage(canvas, 0, 0);\n        data = {\n            bitmap: offscreen.transferToImageBitmap(),\n            id: `image_${this.#baseId}_${this.#id++}`,\n            refCounter: 1,\n            isSvg: false\n        };\n        this.#cache.set(id, data);\n        this.#cache.set(data.id, data);\n        return data;\n    }\n    getSvgUrl(id) {\n        const data = this.#cache.get(id);\n        if (!data?.isSvg) {\n            return null;\n        }\n        return data.svgUrl;\n    }\n    deleteId(id) {\n        this.#cache ||= new Map();\n        const data = this.#cache.get(id);\n        if (!data) {\n            return;\n        }\n        data.refCounter -= 1;\n        if (data.refCounter !== 0) {\n            return;\n        }\n        const { bitmap } = data;\n        if (!data.url && !data.file) {\n            const canvas = new OffscreenCanvas(bitmap.width, bitmap.height);\n            const ctx = canvas.getContext(\"bitmaprenderer\");\n            ctx.transferFromImageBitmap(bitmap);\n            data.blobPromise = canvas.convertToBlob();\n        }\n        bitmap.close?.();\n        data.bitmap = null;\n    }\n    isValidId(id) {\n        return id.startsWith(`image_${this.#baseId}_`);\n    }\n    constructor(){\n        this.#baseId = getUuid();\n        this.#id = 0;\n        this.#cache = null;\n    }\n}\nclass CommandManager {\n    #commands;\n    #locked;\n    #maxSize;\n    #position;\n    constructor(maxSize = 128){\n        this.#commands = [];\n        this.#locked = false;\n        this.#position = -1;\n        this.#maxSize = maxSize;\n    }\n    add({ cmd, undo, post, mustExec, type = NaN, overwriteIfSameType = false, keepUndo = false }) {\n        if (mustExec) {\n            cmd();\n        }\n        if (this.#locked) {\n            return;\n        }\n        const save = {\n            cmd,\n            undo,\n            post,\n            type\n        };\n        if (this.#position === -1) {\n            if (this.#commands.length > 0) {\n                this.#commands.length = 0;\n            }\n            this.#position = 0;\n            this.#commands.push(save);\n            return;\n        }\n        if (overwriteIfSameType && this.#commands[this.#position].type === type) {\n            if (keepUndo) {\n                save.undo = this.#commands[this.#position].undo;\n            }\n            this.#commands[this.#position] = save;\n            return;\n        }\n        const next = this.#position + 1;\n        if (next === this.#maxSize) {\n            this.#commands.splice(0, 1);\n        } else {\n            this.#position = next;\n            if (next < this.#commands.length) {\n                this.#commands.splice(next);\n            }\n        }\n        this.#commands.push(save);\n    }\n    undo() {\n        if (this.#position === -1) {\n            return;\n        }\n        this.#locked = true;\n        const { undo, post } = this.#commands[this.#position];\n        undo();\n        post?.();\n        this.#locked = false;\n        this.#position -= 1;\n    }\n    redo() {\n        if (this.#position < this.#commands.length - 1) {\n            this.#position += 1;\n            this.#locked = true;\n            const { cmd, post } = this.#commands[this.#position];\n            cmd();\n            post?.();\n            this.#locked = false;\n        }\n    }\n    hasSomethingToUndo() {\n        return this.#position !== -1;\n    }\n    hasSomethingToRedo() {\n        return this.#position < this.#commands.length - 1;\n    }\n    cleanType(type) {\n        if (this.#position === -1) {\n            return;\n        }\n        for(let i = this.#position; i >= 0; i--){\n            if (this.#commands[i].type !== type) {\n                this.#commands.splice(i + 1, this.#position - i);\n                this.#position = i;\n                return;\n            }\n        }\n        this.#commands.length = 0;\n        this.#position = -1;\n    }\n    destroy() {\n        this.#commands = null;\n    }\n}\nclass KeyboardManager {\n    constructor(callbacks){\n        this.buffer = [];\n        this.callbacks = new Map();\n        this.allKeys = new Set();\n        const { isMac } = util_FeatureTest.platform;\n        for (const [keys, callback, options = {}] of callbacks){\n            for (const key of keys){\n                const isMacKey = key.startsWith(\"mac+\");\n                if (isMac && isMacKey) {\n                    this.callbacks.set(key.slice(4), {\n                        callback,\n                        options\n                    });\n                    this.allKeys.add(key.split(\"+\").at(-1));\n                } else if (!isMac && !isMacKey) {\n                    this.callbacks.set(key, {\n                        callback,\n                        options\n                    });\n                    this.allKeys.add(key.split(\"+\").at(-1));\n                }\n            }\n        }\n    }\n    #serialize(event) {\n        if (event.altKey) {\n            this.buffer.push(\"alt\");\n        }\n        if (event.ctrlKey) {\n            this.buffer.push(\"ctrl\");\n        }\n        if (event.metaKey) {\n            this.buffer.push(\"meta\");\n        }\n        if (event.shiftKey) {\n            this.buffer.push(\"shift\");\n        }\n        this.buffer.push(event.key);\n        const str = this.buffer.join(\"+\");\n        this.buffer.length = 0;\n        return str;\n    }\n    exec(self, event) {\n        if (!this.allKeys.has(event.key)) {\n            return;\n        }\n        const info = this.callbacks.get(this.#serialize(event));\n        if (!info) {\n            return;\n        }\n        const { callback, options: { bubbles = false, args = [], checker = null } } = info;\n        if (checker && !checker(self, event)) {\n            return;\n        }\n        callback.bind(self, ...args, event)();\n        if (!bubbles) {\n            stopEvent(event);\n        }\n    }\n}\nclass ColorManager {\n    static{\n        this._colorsMapping = new Map([\n            [\n                \"CanvasText\",\n                [\n                    0,\n                    0,\n                    0\n                ]\n            ],\n            [\n                \"Canvas\",\n                [\n                    255,\n                    255,\n                    255\n                ]\n            ]\n        ]);\n    }\n    get _colors() {\n        const colors = new Map([\n            [\n                \"CanvasText\",\n                null\n            ],\n            [\n                \"Canvas\",\n                null\n            ]\n        ]);\n        getColorValues(colors);\n        return shadow(this, \"_colors\", colors);\n    }\n    convert(color) {\n        const rgb = getRGB(color);\n        if (!window.matchMedia(\"(forced-colors: active)\").matches) {\n            return rgb;\n        }\n        for (const [name, RGB] of this._colors){\n            if (RGB.every((x, i)=>x === rgb[i])) {\n                return ColorManager._colorsMapping.get(name);\n            }\n        }\n        return rgb;\n    }\n    getHexCode(name) {\n        const rgb = this._colors.get(name);\n        if (!rgb) {\n            return name;\n        }\n        return Util.makeHexColor(...rgb);\n    }\n}\nclass AnnotationEditorUIManager {\n    #abortController;\n    #activeEditor;\n    #allEditors;\n    #allLayers;\n    #altTextManager;\n    #annotationStorage;\n    #changedExistingAnnotations;\n    #commandManager;\n    #copyPasteAC;\n    #currentDrawingSession;\n    #currentPageIndex;\n    #deletedAnnotationsElementIds;\n    #draggingEditors;\n    #editorTypes;\n    #editorsToRescale;\n    #enableHighlightFloatingButton;\n    #enableUpdatedAddImage;\n    #enableNewAltTextWhenAddingImage;\n    #filterFactory;\n    #focusMainContainerTimeoutId;\n    #focusManagerAC;\n    #highlightColors;\n    #highlightWhenShiftUp;\n    #highlightToolbar;\n    #idManager;\n    #isEnabled;\n    #isWaiting;\n    #keyboardManagerAC;\n    #lastActiveElement;\n    #mainHighlightColorPicker;\n    #mlManager;\n    #mode;\n    #selectedEditors;\n    #selectedTextNode;\n    #pageColors;\n    #showAllStates;\n    #previousStates;\n    #translation;\n    #translationTimeoutId;\n    #container;\n    #viewer;\n    #updateModeCapability;\n    static{\n        this.TRANSLATE_SMALL = 1;\n    }\n    static{\n        this.TRANSLATE_BIG = 10;\n    }\n    static get _keyboardManager() {\n        const proto = AnnotationEditorUIManager.prototype;\n        const arrowChecker = (self)=>self.#container.contains(document.activeElement) && document.activeElement.tagName !== \"BUTTON\" && self.hasSomethingToControl();\n        const textInputChecker = (_self, { target: el })=>{\n            if (el instanceof HTMLInputElement) {\n                const { type } = el;\n                return type !== \"text\" && type !== \"number\";\n            }\n            return true;\n        };\n        const small = this.TRANSLATE_SMALL;\n        const big = this.TRANSLATE_BIG;\n        return shadow(this, \"_keyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"ctrl+a\",\n                    \"mac+meta+a\"\n                ],\n                proto.selectAll,\n                {\n                    checker: textInputChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+z\",\n                    \"mac+meta+z\"\n                ],\n                proto.undo,\n                {\n                    checker: textInputChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+y\",\n                    \"ctrl+shift+z\",\n                    \"mac+meta+shift+z\",\n                    \"ctrl+shift+Z\",\n                    \"mac+meta+shift+Z\"\n                ],\n                proto.redo,\n                {\n                    checker: textInputChecker\n                }\n            ],\n            [\n                [\n                    \"Backspace\",\n                    \"alt+Backspace\",\n                    \"ctrl+Backspace\",\n                    \"shift+Backspace\",\n                    \"mac+Backspace\",\n                    \"mac+alt+Backspace\",\n                    \"mac+ctrl+Backspace\",\n                    \"Delete\",\n                    \"ctrl+Delete\",\n                    \"shift+Delete\",\n                    \"mac+Delete\"\n                ],\n                proto.delete,\n                {\n                    checker: textInputChecker\n                }\n            ],\n            [\n                [\n                    \"Enter\",\n                    \"mac+Enter\"\n                ],\n                proto.addNewEditorFromKeyboard,\n                {\n                    checker: (self, { target: el })=>!(el instanceof HTMLButtonElement) && self.#container.contains(el) && !self.isEnterHandled\n                }\n            ],\n            [\n                [\n                    \" \",\n                    \"mac+ \"\n                ],\n                proto.addNewEditorFromKeyboard,\n                {\n                    checker: (self, { target: el })=>!(el instanceof HTMLButtonElement) && self.#container.contains(document.activeElement)\n                }\n            ],\n            [\n                [\n                    \"Escape\",\n                    \"mac+Escape\"\n                ],\n                proto.unselectAll\n            ],\n            [\n                [\n                    \"ArrowLeft\",\n                    \"mac+ArrowLeft\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        -small,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowLeft\",\n                    \"mac+shift+ArrowLeft\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        -big,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowRight\",\n                    \"mac+ArrowRight\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        small,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowRight\",\n                    \"mac+shift+ArrowRight\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        big,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"mac+ArrowUp\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        0,\n                        -small\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowUp\",\n                    \"mac+shift+ArrowUp\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        0,\n                        -big\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"mac+ArrowDown\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        0,\n                        small\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowDown\",\n                    \"mac+shift+ArrowDown\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        0,\n                        big\n                    ],\n                    checker: arrowChecker\n                }\n            ]\n        ]));\n    }\n    constructor(container, viewer, altTextManager, eventBus, pdfDocument, pageColors, highlightColors, enableHighlightFloatingButton, enableUpdatedAddImage, enableNewAltTextWhenAddingImage, mlManager, editorUndoBar){\n        this.#abortController = new AbortController();\n        this.#activeEditor = null;\n        this.#allEditors = new Map();\n        this.#allLayers = new Map();\n        this.#altTextManager = null;\n        this.#annotationStorage = null;\n        this.#changedExistingAnnotations = null;\n        this.#commandManager = new CommandManager();\n        this.#copyPasteAC = null;\n        this.#currentDrawingSession = null;\n        this.#currentPageIndex = 0;\n        this.#deletedAnnotationsElementIds = new Set();\n        this.#draggingEditors = null;\n        this.#editorTypes = null;\n        this.#editorsToRescale = new Set();\n        this._editorUndoBar = null;\n        this.#enableHighlightFloatingButton = false;\n        this.#enableUpdatedAddImage = false;\n        this.#enableNewAltTextWhenAddingImage = false;\n        this.#filterFactory = null;\n        this.#focusMainContainerTimeoutId = null;\n        this.#focusManagerAC = null;\n        this.#highlightColors = null;\n        this.#highlightWhenShiftUp = false;\n        this.#highlightToolbar = null;\n        this.#idManager = new IdManager();\n        this.#isEnabled = false;\n        this.#isWaiting = false;\n        this.#keyboardManagerAC = null;\n        this.#lastActiveElement = null;\n        this.#mainHighlightColorPicker = null;\n        this.#mlManager = null;\n        this.#mode = AnnotationEditorType.NONE;\n        this.#selectedEditors = new Set();\n        this.#selectedTextNode = null;\n        this.#pageColors = null;\n        this.#showAllStates = null;\n        this.#previousStates = {\n            isEditing: false,\n            isEmpty: true,\n            hasSomethingToUndo: false,\n            hasSomethingToRedo: false,\n            hasSelectedEditor: false,\n            hasSelectedText: false\n        };\n        this.#translation = [\n            0,\n            0\n        ];\n        this.#translationTimeoutId = null;\n        this.#container = null;\n        this.#viewer = null;\n        this.#updateModeCapability = null;\n        const signal = this._signal = this.#abortController.signal;\n        this.#container = container;\n        this.#viewer = viewer;\n        this.#altTextManager = altTextManager;\n        this._eventBus = eventBus;\n        eventBus._on(\"editingaction\", this.onEditingAction.bind(this), {\n            signal\n        });\n        eventBus._on(\"pagechanging\", this.onPageChanging.bind(this), {\n            signal\n        });\n        eventBus._on(\"scalechanging\", this.onScaleChanging.bind(this), {\n            signal\n        });\n        eventBus._on(\"rotationchanging\", this.onRotationChanging.bind(this), {\n            signal\n        });\n        eventBus._on(\"setpreference\", this.onSetPreference.bind(this), {\n            signal\n        });\n        eventBus._on(\"switchannotationeditorparams\", (evt)=>this.updateParams(evt.type, evt.value), {\n            signal\n        });\n        this.#addSelectionListener();\n        this.#addDragAndDropListeners();\n        this.#addKeyboardManager();\n        this.#annotationStorage = pdfDocument.annotationStorage;\n        this.#filterFactory = pdfDocument.filterFactory;\n        this.#pageColors = pageColors;\n        this.#highlightColors = highlightColors || null;\n        this.#enableHighlightFloatingButton = enableHighlightFloatingButton;\n        this.#enableUpdatedAddImage = enableUpdatedAddImage;\n        this.#enableNewAltTextWhenAddingImage = enableNewAltTextWhenAddingImage;\n        this.#mlManager = mlManager || null;\n        this.viewParameters = {\n            realScale: PixelsPerInch.PDF_TO_CSS_UNITS,\n            rotation: 0\n        };\n        this.isShiftKeyDown = false;\n        this._editorUndoBar = editorUndoBar || null;\n    }\n    destroy() {\n        this.#updateModeCapability?.resolve();\n        this.#updateModeCapability = null;\n        this.#abortController?.abort();\n        this.#abortController = null;\n        this._signal = null;\n        for (const layer of this.#allLayers.values()){\n            layer.destroy();\n        }\n        this.#allLayers.clear();\n        this.#allEditors.clear();\n        this.#editorsToRescale.clear();\n        this.#activeEditor = null;\n        this.#selectedEditors.clear();\n        this.#commandManager.destroy();\n        this.#altTextManager?.destroy();\n        this.#highlightToolbar?.hide();\n        this.#highlightToolbar = null;\n        if (this.#focusMainContainerTimeoutId) {\n            clearTimeout(this.#focusMainContainerTimeoutId);\n            this.#focusMainContainerTimeoutId = null;\n        }\n        if (this.#translationTimeoutId) {\n            clearTimeout(this.#translationTimeoutId);\n            this.#translationTimeoutId = null;\n        }\n        this._editorUndoBar?.destroy();\n    }\n    combinedSignal(ac) {\n        return AbortSignal.any([\n            this._signal,\n            ac.signal\n        ]);\n    }\n    get mlManager() {\n        return this.#mlManager;\n    }\n    get useNewAltTextFlow() {\n        return this.#enableUpdatedAddImage;\n    }\n    get useNewAltTextWhenAddingImage() {\n        return this.#enableNewAltTextWhenAddingImage;\n    }\n    get hcmFilter() {\n        return shadow(this, \"hcmFilter\", this.#pageColors ? this.#filterFactory.addHCMFilter(this.#pageColors.foreground, this.#pageColors.background) : \"none\");\n    }\n    get direction() {\n        return shadow(this, \"direction\", getComputedStyle(this.#container).direction);\n    }\n    get highlightColors() {\n        return shadow(this, \"highlightColors\", this.#highlightColors ? new Map(this.#highlightColors.split(\",\").map((pair)=>pair.split(\"=\").map((x)=>x.trim()))) : null);\n    }\n    get highlightColorNames() {\n        return shadow(this, \"highlightColorNames\", this.highlightColors ? new Map(Array.from(this.highlightColors, (e)=>e.reverse())) : null);\n    }\n    setCurrentDrawingSession(layer) {\n        if (layer) {\n            this.unselectAll();\n            this.disableUserSelect(true);\n        } else {\n            this.disableUserSelect(false);\n        }\n        this.#currentDrawingSession = layer;\n    }\n    setMainHighlightColorPicker(colorPicker) {\n        this.#mainHighlightColorPicker = colorPicker;\n    }\n    editAltText(editor, firstTime = false) {\n        this.#altTextManager?.editAltText(this, editor, firstTime);\n    }\n    switchToMode(mode, callback) {\n        this._eventBus.on(\"annotationeditormodechanged\", callback, {\n            once: true,\n            signal: this._signal\n        });\n        this._eventBus.dispatch(\"showannotationeditorui\", {\n            source: this,\n            mode\n        });\n    }\n    setPreference(name, value) {\n        this._eventBus.dispatch(\"setpreference\", {\n            source: this,\n            name,\n            value\n        });\n    }\n    onSetPreference({ name, value }) {\n        switch(name){\n            case \"enableNewAltTextWhenAddingImage\":\n                this.#enableNewAltTextWhenAddingImage = value;\n                break;\n        }\n    }\n    onPageChanging({ pageNumber }) {\n        this.#currentPageIndex = pageNumber - 1;\n    }\n    focusMainContainer() {\n        this.#container.focus();\n    }\n    findParent(x, y) {\n        for (const layer of this.#allLayers.values()){\n            const { x: layerX, y: layerY, width, height } = layer.div.getBoundingClientRect();\n            if (x >= layerX && x <= layerX + width && y >= layerY && y <= layerY + height) {\n                return layer;\n            }\n        }\n        return null;\n    }\n    disableUserSelect(value = false) {\n        this.#viewer.classList.toggle(\"noUserSelect\", value);\n    }\n    addShouldRescale(editor) {\n        this.#editorsToRescale.add(editor);\n    }\n    removeShouldRescale(editor) {\n        this.#editorsToRescale.delete(editor);\n    }\n    onScaleChanging({ scale }) {\n        this.commitOrRemove();\n        this.viewParameters.realScale = scale * PixelsPerInch.PDF_TO_CSS_UNITS;\n        for (const editor of this.#editorsToRescale){\n            editor.onScaleChanging();\n        }\n        this.#currentDrawingSession?.onScaleChanging();\n    }\n    onRotationChanging({ pagesRotation }) {\n        this.commitOrRemove();\n        this.viewParameters.rotation = pagesRotation;\n    }\n    #getAnchorElementForSelection({ anchorNode }) {\n        return anchorNode.nodeType === Node.TEXT_NODE ? anchorNode.parentElement : anchorNode;\n    }\n    #getLayerForTextLayer(textLayer) {\n        const { currentLayer } = this;\n        if (currentLayer.hasTextLayer(textLayer)) {\n            return currentLayer;\n        }\n        for (const layer of this.#allLayers.values()){\n            if (layer.hasTextLayer(textLayer)) {\n                return layer;\n            }\n        }\n        return null;\n    }\n    highlightSelection(methodOfCreation = \"\") {\n        const selection = document.getSelection();\n        if (!selection || selection.isCollapsed) {\n            return;\n        }\n        const { anchorNode, anchorOffset, focusNode, focusOffset } = selection;\n        const text = selection.toString();\n        const anchorElement = this.#getAnchorElementForSelection(selection);\n        const textLayer = anchorElement.closest(\".textLayer\");\n        const boxes = this.getSelectionBoxes(textLayer);\n        if (!boxes) {\n            return;\n        }\n        selection.empty();\n        const layer = this.#getLayerForTextLayer(textLayer);\n        const isNoneMode = this.#mode === AnnotationEditorType.NONE;\n        const callback = ()=>{\n            layer?.createAndAddNewEditor({\n                x: 0,\n                y: 0\n            }, false, {\n                methodOfCreation,\n                boxes,\n                anchorNode,\n                anchorOffset,\n                focusNode,\n                focusOffset,\n                text\n            });\n            if (isNoneMode) {\n                this.showAllEditors(\"highlight\", true, true);\n            }\n        };\n        if (isNoneMode) {\n            this.switchToMode(AnnotationEditorType.HIGHLIGHT, callback);\n            return;\n        }\n        callback();\n    }\n    #displayHighlightToolbar() {\n        const selection = document.getSelection();\n        if (!selection || selection.isCollapsed) {\n            return;\n        }\n        const anchorElement = this.#getAnchorElementForSelection(selection);\n        const textLayer = anchorElement.closest(\".textLayer\");\n        const boxes = this.getSelectionBoxes(textLayer);\n        if (!boxes) {\n            return;\n        }\n        this.#highlightToolbar ||= new HighlightToolbar(this);\n        this.#highlightToolbar.show(textLayer, boxes, this.direction === \"ltr\");\n    }\n    addToAnnotationStorage(editor) {\n        if (!editor.isEmpty() && this.#annotationStorage && !this.#annotationStorage.has(editor.id)) {\n            this.#annotationStorage.setValue(editor.id, editor);\n        }\n    }\n    #selectionChange() {\n        const selection = document.getSelection();\n        if (!selection || selection.isCollapsed) {\n            if (this.#selectedTextNode) {\n                this.#highlightToolbar?.hide();\n                this.#selectedTextNode = null;\n                this.#dispatchUpdateStates({\n                    hasSelectedText: false\n                });\n            }\n            return;\n        }\n        const { anchorNode } = selection;\n        if (anchorNode === this.#selectedTextNode) {\n            return;\n        }\n        const anchorElement = this.#getAnchorElementForSelection(selection);\n        const textLayer = anchorElement.closest(\".textLayer\");\n        if (!textLayer) {\n            if (this.#selectedTextNode) {\n                this.#highlightToolbar?.hide();\n                this.#selectedTextNode = null;\n                this.#dispatchUpdateStates({\n                    hasSelectedText: false\n                });\n            }\n            return;\n        }\n        this.#highlightToolbar?.hide();\n        this.#selectedTextNode = anchorNode;\n        this.#dispatchUpdateStates({\n            hasSelectedText: true\n        });\n        if (this.#mode !== AnnotationEditorType.HIGHLIGHT && this.#mode !== AnnotationEditorType.NONE) {\n            return;\n        }\n        if (this.#mode === AnnotationEditorType.HIGHLIGHT) {\n            this.showAllEditors(\"highlight\", true, true);\n        }\n        this.#highlightWhenShiftUp = this.isShiftKeyDown;\n        if (!this.isShiftKeyDown) {\n            const activeLayer = this.#mode === AnnotationEditorType.HIGHLIGHT ? this.#getLayerForTextLayer(textLayer) : null;\n            activeLayer?.toggleDrawing();\n            const ac = new AbortController();\n            const signal = this.combinedSignal(ac);\n            const pointerup = (e)=>{\n                if (e.type === \"pointerup\" && e.button !== 0) {\n                    return;\n                }\n                ac.abort();\n                activeLayer?.toggleDrawing(true);\n                if (e.type === \"pointerup\") {\n                    this.#onSelectEnd(\"main_toolbar\");\n                }\n            };\n            window.addEventListener(\"pointerup\", pointerup, {\n                signal\n            });\n            window.addEventListener(\"blur\", pointerup, {\n                signal\n            });\n        }\n    }\n    #onSelectEnd(methodOfCreation = \"\") {\n        if (this.#mode === AnnotationEditorType.HIGHLIGHT) {\n            this.highlightSelection(methodOfCreation);\n        } else if (this.#enableHighlightFloatingButton) {\n            this.#displayHighlightToolbar();\n        }\n    }\n    #addSelectionListener() {\n        document.addEventListener(\"selectionchange\", this.#selectionChange.bind(this), {\n            signal: this._signal\n        });\n    }\n    #addFocusManager() {\n        if (this.#focusManagerAC) {\n            return;\n        }\n        this.#focusManagerAC = new AbortController();\n        const signal = this.combinedSignal(this.#focusManagerAC);\n        window.addEventListener(\"focus\", this.focus.bind(this), {\n            signal\n        });\n        window.addEventListener(\"blur\", this.blur.bind(this), {\n            signal\n        });\n    }\n    #removeFocusManager() {\n        this.#focusManagerAC?.abort();\n        this.#focusManagerAC = null;\n    }\n    blur() {\n        this.isShiftKeyDown = false;\n        if (this.#highlightWhenShiftUp) {\n            this.#highlightWhenShiftUp = false;\n            this.#onSelectEnd(\"main_toolbar\");\n        }\n        if (!this.hasSelection) {\n            return;\n        }\n        const { activeElement } = document;\n        for (const editor of this.#selectedEditors){\n            if (editor.div.contains(activeElement)) {\n                this.#lastActiveElement = [\n                    editor,\n                    activeElement\n                ];\n                editor._focusEventsAllowed = false;\n                break;\n            }\n        }\n    }\n    focus() {\n        if (!this.#lastActiveElement) {\n            return;\n        }\n        const [lastEditor, lastActiveElement] = this.#lastActiveElement;\n        this.#lastActiveElement = null;\n        lastActiveElement.addEventListener(\"focusin\", ()=>{\n            lastEditor._focusEventsAllowed = true;\n        }, {\n            once: true,\n            signal: this._signal\n        });\n        lastActiveElement.focus();\n    }\n    #addKeyboardManager() {\n        if (this.#keyboardManagerAC) {\n            return;\n        }\n        this.#keyboardManagerAC = new AbortController();\n        const signal = this.combinedSignal(this.#keyboardManagerAC);\n        window.addEventListener(\"keydown\", this.keydown.bind(this), {\n            signal\n        });\n        window.addEventListener(\"keyup\", this.keyup.bind(this), {\n            signal\n        });\n    }\n    #removeKeyboardManager() {\n        this.#keyboardManagerAC?.abort();\n        this.#keyboardManagerAC = null;\n    }\n    #addCopyPasteListeners() {\n        if (this.#copyPasteAC) {\n            return;\n        }\n        this.#copyPasteAC = new AbortController();\n        const signal = this.combinedSignal(this.#copyPasteAC);\n        document.addEventListener(\"copy\", this.copy.bind(this), {\n            signal\n        });\n        document.addEventListener(\"cut\", this.cut.bind(this), {\n            signal\n        });\n        document.addEventListener(\"paste\", this.paste.bind(this), {\n            signal\n        });\n    }\n    #removeCopyPasteListeners() {\n        this.#copyPasteAC?.abort();\n        this.#copyPasteAC = null;\n    }\n    #addDragAndDropListeners() {\n        const signal = this._signal;\n        document.addEventListener(\"dragover\", this.dragOver.bind(this), {\n            signal\n        });\n        document.addEventListener(\"drop\", this.drop.bind(this), {\n            signal\n        });\n    }\n    addEditListeners() {\n        this.#addKeyboardManager();\n        this.#addCopyPasteListeners();\n    }\n    removeEditListeners() {\n        this.#removeKeyboardManager();\n        this.#removeCopyPasteListeners();\n    }\n    dragOver(event) {\n        for (const { type } of event.dataTransfer.items){\n            for (const editorType of this.#editorTypes){\n                if (editorType.isHandlingMimeForPasting(type)) {\n                    event.dataTransfer.dropEffect = \"copy\";\n                    event.preventDefault();\n                    return;\n                }\n            }\n        }\n    }\n    drop(event) {\n        for (const item of event.dataTransfer.items){\n            for (const editorType of this.#editorTypes){\n                if (editorType.isHandlingMimeForPasting(item.type)) {\n                    editorType.paste(item, this.currentLayer);\n                    event.preventDefault();\n                    return;\n                }\n            }\n        }\n    }\n    copy(event) {\n        event.preventDefault();\n        this.#activeEditor?.commitOrRemove();\n        if (!this.hasSelection) {\n            return;\n        }\n        const editors = [];\n        for (const editor of this.#selectedEditors){\n            const serialized = editor.serialize(true);\n            if (serialized) {\n                editors.push(serialized);\n            }\n        }\n        if (editors.length === 0) {\n            return;\n        }\n        event.clipboardData.setData(\"application/pdfjs\", JSON.stringify(editors));\n    }\n    cut(event) {\n        this.copy(event);\n        this.delete();\n    }\n    async paste(event) {\n        event.preventDefault();\n        const { clipboardData } = event;\n        for (const item of clipboardData.items){\n            for (const editorType of this.#editorTypes){\n                if (editorType.isHandlingMimeForPasting(item.type)) {\n                    editorType.paste(item, this.currentLayer);\n                    return;\n                }\n            }\n        }\n        let data = clipboardData.getData(\"application/pdfjs\");\n        if (!data) {\n            return;\n        }\n        try {\n            data = JSON.parse(data);\n        } catch (ex) {\n            warn(`paste: \"${ex.message}\".`);\n            return;\n        }\n        if (!Array.isArray(data)) {\n            return;\n        }\n        this.unselectAll();\n        const layer = this.currentLayer;\n        try {\n            const newEditors = [];\n            for (const editor of data){\n                const deserializedEditor = await layer.deserialize(editor);\n                if (!deserializedEditor) {\n                    return;\n                }\n                newEditors.push(deserializedEditor);\n            }\n            const cmd = ()=>{\n                for (const editor of newEditors){\n                    this.#addEditorToLayer(editor);\n                }\n                this.#selectEditors(newEditors);\n            };\n            const undo = ()=>{\n                for (const editor of newEditors){\n                    editor.remove();\n                }\n            };\n            this.addCommands({\n                cmd,\n                undo,\n                mustExec: true\n            });\n        } catch (ex) {\n            warn(`paste: \"${ex.message}\".`);\n        }\n    }\n    keydown(event) {\n        if (!this.isShiftKeyDown && event.key === \"Shift\") {\n            this.isShiftKeyDown = true;\n        }\n        if (this.#mode !== AnnotationEditorType.NONE && !this.isEditorHandlingKeyboard) {\n            AnnotationEditorUIManager._keyboardManager.exec(this, event);\n        }\n    }\n    keyup(event) {\n        if (this.isShiftKeyDown && event.key === \"Shift\") {\n            this.isShiftKeyDown = false;\n            if (this.#highlightWhenShiftUp) {\n                this.#highlightWhenShiftUp = false;\n                this.#onSelectEnd(\"main_toolbar\");\n            }\n        }\n    }\n    onEditingAction({ name }) {\n        switch(name){\n            case \"undo\":\n            case \"redo\":\n            case \"delete\":\n            case \"selectAll\":\n                this[name]();\n                break;\n            case \"highlightSelection\":\n                this.highlightSelection(\"context_menu\");\n                break;\n        }\n    }\n    #dispatchUpdateStates(details) {\n        const hasChanged = Object.entries(details).some(([key, value])=>this.#previousStates[key] !== value);\n        if (hasChanged) {\n            this._eventBus.dispatch(\"annotationeditorstateschanged\", {\n                source: this,\n                details: Object.assign(this.#previousStates, details)\n            });\n            if (this.#mode === AnnotationEditorType.HIGHLIGHT && details.hasSelectedEditor === false) {\n                this.#dispatchUpdateUI([\n                    [\n                        AnnotationEditorParamsType.HIGHLIGHT_FREE,\n                        true\n                    ]\n                ]);\n            }\n        }\n    }\n    #dispatchUpdateUI(details) {\n        this._eventBus.dispatch(\"annotationeditorparamschanged\", {\n            source: this,\n            details\n        });\n    }\n    setEditingState(isEditing) {\n        if (isEditing) {\n            this.#addFocusManager();\n            this.#addCopyPasteListeners();\n            this.#dispatchUpdateStates({\n                isEditing: this.#mode !== AnnotationEditorType.NONE,\n                isEmpty: this.#isEmpty(),\n                hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n                hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n                hasSelectedEditor: false\n            });\n        } else {\n            this.#removeFocusManager();\n            this.#removeCopyPasteListeners();\n            this.#dispatchUpdateStates({\n                isEditing: false\n            });\n            this.disableUserSelect(false);\n        }\n    }\n    registerEditorTypes(types) {\n        if (this.#editorTypes) {\n            return;\n        }\n        this.#editorTypes = types;\n        for (const editorType of this.#editorTypes){\n            this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);\n        }\n    }\n    getId() {\n        return this.#idManager.id;\n    }\n    get currentLayer() {\n        return this.#allLayers.get(this.#currentPageIndex);\n    }\n    getLayer(pageIndex) {\n        return this.#allLayers.get(pageIndex);\n    }\n    get currentPageIndex() {\n        return this.#currentPageIndex;\n    }\n    addLayer(layer) {\n        this.#allLayers.set(layer.pageIndex, layer);\n        if (this.#isEnabled) {\n            layer.enable();\n        } else {\n            layer.disable();\n        }\n    }\n    removeLayer(layer) {\n        this.#allLayers.delete(layer.pageIndex);\n    }\n    async updateMode(mode, editId = null, isFromKeyboard = false) {\n        if (this.#mode === mode) {\n            return;\n        }\n        if (this.#updateModeCapability) {\n            await this.#updateModeCapability.promise;\n            if (!this.#updateModeCapability) {\n                return;\n            }\n        }\n        this.#updateModeCapability = Promise.withResolvers();\n        this.#mode = mode;\n        if (mode === AnnotationEditorType.NONE) {\n            this.setEditingState(false);\n            this.#disableAll();\n            this._editorUndoBar?.hide();\n            this.#updateModeCapability.resolve();\n            return;\n        }\n        this.setEditingState(true);\n        await this.#enableAll();\n        this.unselectAll();\n        for (const layer of this.#allLayers.values()){\n            layer.updateMode(mode);\n        }\n        if (!editId) {\n            if (isFromKeyboard) {\n                this.addNewEditorFromKeyboard();\n            }\n            this.#updateModeCapability.resolve();\n            return;\n        }\n        for (const editor of this.#allEditors.values()){\n            if (editor.annotationElementId === editId) {\n                this.setSelected(editor);\n                editor.enterInEditMode();\n            } else {\n                editor.unselect();\n            }\n        }\n        this.#updateModeCapability.resolve();\n    }\n    addNewEditorFromKeyboard() {\n        if (this.currentLayer.canCreateNewEmptyEditor()) {\n            this.currentLayer.addNewEditor();\n        }\n    }\n    updateToolbar(mode) {\n        if (mode === this.#mode) {\n            return;\n        }\n        this._eventBus.dispatch(\"switchannotationeditormode\", {\n            source: this,\n            mode\n        });\n    }\n    updateParams(type, value) {\n        if (!this.#editorTypes) {\n            return;\n        }\n        switch(type){\n            case AnnotationEditorParamsType.CREATE:\n                this.currentLayer.addNewEditor();\n                return;\n            case AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR:\n                this.#mainHighlightColorPicker?.updateColor(value);\n                break;\n            case AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL:\n                this._eventBus.dispatch(\"reporttelemetry\", {\n                    source: this,\n                    details: {\n                        type: \"editing\",\n                        data: {\n                            type: \"highlight\",\n                            action: \"toggle_visibility\"\n                        }\n                    }\n                });\n                (this.#showAllStates ||= new Map()).set(type, value);\n                this.showAllEditors(\"highlight\", value);\n                break;\n        }\n        for (const editor of this.#selectedEditors){\n            editor.updateParams(type, value);\n        }\n        for (const editorType of this.#editorTypes){\n            editorType.updateDefaultParams(type, value);\n        }\n    }\n    showAllEditors(type, visible, updateButton = false) {\n        for (const editor of this.#allEditors.values()){\n            if (editor.editorType === type) {\n                editor.show(visible);\n            }\n        }\n        const state = this.#showAllStates?.get(AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL) ?? true;\n        if (state !== visible) {\n            this.#dispatchUpdateUI([\n                [\n                    AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL,\n                    visible\n                ]\n            ]);\n        }\n    }\n    enableWaiting(mustWait = false) {\n        if (this.#isWaiting === mustWait) {\n            return;\n        }\n        this.#isWaiting = mustWait;\n        for (const layer of this.#allLayers.values()){\n            if (mustWait) {\n                layer.disableClick();\n            } else {\n                layer.enableClick();\n            }\n            layer.div.classList.toggle(\"waiting\", mustWait);\n        }\n    }\n    async #enableAll() {\n        if (!this.#isEnabled) {\n            this.#isEnabled = true;\n            const promises = [];\n            for (const layer of this.#allLayers.values()){\n                promises.push(layer.enable());\n            }\n            await Promise.all(promises);\n            for (const editor of this.#allEditors.values()){\n                editor.enable();\n            }\n        }\n    }\n    #disableAll() {\n        this.unselectAll();\n        if (this.#isEnabled) {\n            this.#isEnabled = false;\n            for (const layer of this.#allLayers.values()){\n                layer.disable();\n            }\n            for (const editor of this.#allEditors.values()){\n                editor.disable();\n            }\n        }\n    }\n    getEditors(pageIndex) {\n        const editors = [];\n        for (const editor of this.#allEditors.values()){\n            if (editor.pageIndex === pageIndex) {\n                editors.push(editor);\n            }\n        }\n        return editors;\n    }\n    getEditor(id) {\n        return this.#allEditors.get(id);\n    }\n    addEditor(editor) {\n        this.#allEditors.set(editor.id, editor);\n    }\n    removeEditor(editor) {\n        if (editor.div.contains(document.activeElement)) {\n            if (this.#focusMainContainerTimeoutId) {\n                clearTimeout(this.#focusMainContainerTimeoutId);\n            }\n            this.#focusMainContainerTimeoutId = setTimeout(()=>{\n                this.focusMainContainer();\n                this.#focusMainContainerTimeoutId = null;\n            }, 0);\n        }\n        this.#allEditors.delete(editor.id);\n        this.unselect(editor);\n        if (!editor.annotationElementId || !this.#deletedAnnotationsElementIds.has(editor.annotationElementId)) {\n            this.#annotationStorage?.remove(editor.id);\n        }\n    }\n    addDeletedAnnotationElement(editor) {\n        this.#deletedAnnotationsElementIds.add(editor.annotationElementId);\n        this.addChangedExistingAnnotation(editor);\n        editor.deleted = true;\n    }\n    isDeletedAnnotationElement(annotationElementId) {\n        return this.#deletedAnnotationsElementIds.has(annotationElementId);\n    }\n    removeDeletedAnnotationElement(editor) {\n        this.#deletedAnnotationsElementIds.delete(editor.annotationElementId);\n        this.removeChangedExistingAnnotation(editor);\n        editor.deleted = false;\n    }\n    #addEditorToLayer(editor) {\n        const layer = this.#allLayers.get(editor.pageIndex);\n        if (layer) {\n            layer.addOrRebuild(editor);\n        } else {\n            this.addEditor(editor);\n            this.addToAnnotationStorage(editor);\n        }\n    }\n    setActiveEditor(editor) {\n        if (this.#activeEditor === editor) {\n            return;\n        }\n        this.#activeEditor = editor;\n        if (editor) {\n            this.#dispatchUpdateUI(editor.propertiesToUpdate);\n        }\n    }\n    get #lastSelectedEditor() {\n        let ed = null;\n        for (ed of this.#selectedEditors){}\n        return ed;\n    }\n    updateUI(editor) {\n        if (this.#lastSelectedEditor === editor) {\n            this.#dispatchUpdateUI(editor.propertiesToUpdate);\n        }\n    }\n    updateUIForDefaultProperties(editorType) {\n        this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);\n    }\n    toggleSelected(editor) {\n        if (this.#selectedEditors.has(editor)) {\n            this.#selectedEditors.delete(editor);\n            editor.unselect();\n            this.#dispatchUpdateStates({\n                hasSelectedEditor: this.hasSelection\n            });\n            return;\n        }\n        this.#selectedEditors.add(editor);\n        editor.select();\n        this.#dispatchUpdateUI(editor.propertiesToUpdate);\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: true\n        });\n    }\n    setSelected(editor) {\n        this.#currentDrawingSession?.commitOrRemove();\n        for (const ed of this.#selectedEditors){\n            if (ed !== editor) {\n                ed.unselect();\n            }\n        }\n        this.#selectedEditors.clear();\n        this.#selectedEditors.add(editor);\n        editor.select();\n        this.#dispatchUpdateUI(editor.propertiesToUpdate);\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: true\n        });\n    }\n    isSelected(editor) {\n        return this.#selectedEditors.has(editor);\n    }\n    get firstSelectedEditor() {\n        return this.#selectedEditors.values().next().value;\n    }\n    unselect(editor) {\n        editor.unselect();\n        this.#selectedEditors.delete(editor);\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: this.hasSelection\n        });\n    }\n    get hasSelection() {\n        return this.#selectedEditors.size !== 0;\n    }\n    get isEnterHandled() {\n        return this.#selectedEditors.size === 1 && this.firstSelectedEditor.isEnterHandled;\n    }\n    undo() {\n        this.#commandManager.undo();\n        this.#dispatchUpdateStates({\n            hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n            hasSomethingToRedo: true,\n            isEmpty: this.#isEmpty()\n        });\n        this._editorUndoBar?.hide();\n    }\n    redo() {\n        this.#commandManager.redo();\n        this.#dispatchUpdateStates({\n            hasSomethingToUndo: true,\n            hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n            isEmpty: this.#isEmpty()\n        });\n    }\n    addCommands(params) {\n        this.#commandManager.add(params);\n        this.#dispatchUpdateStates({\n            hasSomethingToUndo: true,\n            hasSomethingToRedo: false,\n            isEmpty: this.#isEmpty()\n        });\n    }\n    cleanUndoStack(type) {\n        this.#commandManager.cleanType(type);\n    }\n    #isEmpty() {\n        if (this.#allEditors.size === 0) {\n            return true;\n        }\n        if (this.#allEditors.size === 1) {\n            for (const editor of this.#allEditors.values()){\n                return editor.isEmpty();\n            }\n        }\n        return false;\n    }\n    delete() {\n        this.commitOrRemove();\n        const drawingEditor = this.currentLayer?.endDrawingSession(true);\n        if (!this.hasSelection && !drawingEditor) {\n            return;\n        }\n        const editors = drawingEditor ? [\n            drawingEditor\n        ] : [\n            ...this.#selectedEditors\n        ];\n        const cmd = ()=>{\n            this._editorUndoBar?.show(undo, editors.length === 1 ? editors[0].editorType : editors.length);\n            for (const editor of editors){\n                editor.remove();\n            }\n        };\n        const undo = ()=>{\n            for (const editor of editors){\n                this.#addEditorToLayer(editor);\n            }\n        };\n        this.addCommands({\n            cmd,\n            undo,\n            mustExec: true\n        });\n    }\n    commitOrRemove() {\n        this.#activeEditor?.commitOrRemove();\n    }\n    hasSomethingToControl() {\n        return this.#activeEditor || this.hasSelection;\n    }\n    #selectEditors(editors) {\n        for (const editor of this.#selectedEditors){\n            editor.unselect();\n        }\n        this.#selectedEditors.clear();\n        for (const editor of editors){\n            if (editor.isEmpty()) {\n                continue;\n            }\n            this.#selectedEditors.add(editor);\n            editor.select();\n        }\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: this.hasSelection\n        });\n    }\n    selectAll() {\n        for (const editor of this.#selectedEditors){\n            editor.commit();\n        }\n        this.#selectEditors(this.#allEditors.values());\n    }\n    unselectAll() {\n        if (this.#activeEditor) {\n            this.#activeEditor.commitOrRemove();\n            if (this.#mode !== AnnotationEditorType.NONE) {\n                return;\n            }\n        }\n        if (this.#currentDrawingSession?.commitOrRemove()) {\n            return;\n        }\n        if (!this.hasSelection) {\n            return;\n        }\n        for (const editor of this.#selectedEditors){\n            editor.unselect();\n        }\n        this.#selectedEditors.clear();\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: false\n        });\n    }\n    translateSelectedEditors(x, y, noCommit = false) {\n        if (!noCommit) {\n            this.commitOrRemove();\n        }\n        if (!this.hasSelection) {\n            return;\n        }\n        this.#translation[0] += x;\n        this.#translation[1] += y;\n        const [totalX, totalY] = this.#translation;\n        const editors = [\n            ...this.#selectedEditors\n        ];\n        const TIME_TO_WAIT = 1000;\n        if (this.#translationTimeoutId) {\n            clearTimeout(this.#translationTimeoutId);\n        }\n        this.#translationTimeoutId = setTimeout(()=>{\n            this.#translationTimeoutId = null;\n            this.#translation[0] = this.#translation[1] = 0;\n            this.addCommands({\n                cmd: ()=>{\n                    for (const editor of editors){\n                        if (this.#allEditors.has(editor.id)) {\n                            editor.translateInPage(totalX, totalY);\n                        }\n                    }\n                },\n                undo: ()=>{\n                    for (const editor of editors){\n                        if (this.#allEditors.has(editor.id)) {\n                            editor.translateInPage(-totalX, -totalY);\n                        }\n                    }\n                },\n                mustExec: false\n            });\n        }, TIME_TO_WAIT);\n        for (const editor of editors){\n            editor.translateInPage(x, y);\n        }\n    }\n    setUpDragSession() {\n        if (!this.hasSelection) {\n            return;\n        }\n        this.disableUserSelect(true);\n        this.#draggingEditors = new Map();\n        for (const editor of this.#selectedEditors){\n            this.#draggingEditors.set(editor, {\n                savedX: editor.x,\n                savedY: editor.y,\n                savedPageIndex: editor.pageIndex,\n                newX: 0,\n                newY: 0,\n                newPageIndex: -1\n            });\n        }\n    }\n    endDragSession() {\n        if (!this.#draggingEditors) {\n            return false;\n        }\n        this.disableUserSelect(false);\n        const map = this.#draggingEditors;\n        this.#draggingEditors = null;\n        let mustBeAddedInUndoStack = false;\n        for (const [{ x, y, pageIndex }, value] of map){\n            value.newX = x;\n            value.newY = y;\n            value.newPageIndex = pageIndex;\n            mustBeAddedInUndoStack ||= x !== value.savedX || y !== value.savedY || pageIndex !== value.savedPageIndex;\n        }\n        if (!mustBeAddedInUndoStack) {\n            return false;\n        }\n        const move = (editor, x, y, pageIndex)=>{\n            if (this.#allEditors.has(editor.id)) {\n                const parent = this.#allLayers.get(pageIndex);\n                if (parent) {\n                    editor._setParentAndPosition(parent, x, y);\n                } else {\n                    editor.pageIndex = pageIndex;\n                    editor.x = x;\n                    editor.y = y;\n                }\n            }\n        };\n        this.addCommands({\n            cmd: ()=>{\n                for (const [editor, { newX, newY, newPageIndex }] of map){\n                    move(editor, newX, newY, newPageIndex);\n                }\n            },\n            undo: ()=>{\n                for (const [editor, { savedX, savedY, savedPageIndex }] of map){\n                    move(editor, savedX, savedY, savedPageIndex);\n                }\n            },\n            mustExec: true\n        });\n        return true;\n    }\n    dragSelectedEditors(tx, ty) {\n        if (!this.#draggingEditors) {\n            return;\n        }\n        for (const editor of this.#draggingEditors.keys()){\n            editor.drag(tx, ty);\n        }\n    }\n    rebuild(editor) {\n        if (editor.parent === null) {\n            const parent = this.getLayer(editor.pageIndex);\n            if (parent) {\n                parent.changeParent(editor);\n                parent.addOrRebuild(editor);\n            } else {\n                this.addEditor(editor);\n                this.addToAnnotationStorage(editor);\n                editor.rebuild();\n            }\n        } else {\n            editor.parent.addOrRebuild(editor);\n        }\n    }\n    get isEditorHandlingKeyboard() {\n        return this.getActive()?.shouldGetKeyboardEvents() || this.#selectedEditors.size === 1 && this.firstSelectedEditor.shouldGetKeyboardEvents();\n    }\n    isActive(editor) {\n        return this.#activeEditor === editor;\n    }\n    getActive() {\n        return this.#activeEditor;\n    }\n    getMode() {\n        return this.#mode;\n    }\n    get imageManager() {\n        return shadow(this, \"imageManager\", new ImageManager());\n    }\n    getSelectionBoxes(textLayer) {\n        if (!textLayer) {\n            return null;\n        }\n        const selection = document.getSelection();\n        for(let i = 0, ii = selection.rangeCount; i < ii; i++){\n            if (!textLayer.contains(selection.getRangeAt(i).commonAncestorContainer)) {\n                return null;\n            }\n        }\n        const { x: layerX, y: layerY, width: parentWidth, height: parentHeight } = textLayer.getBoundingClientRect();\n        let rotator;\n        switch(textLayer.getAttribute(\"data-main-rotation\")){\n            case \"90\":\n                rotator = (x, y, w, h)=>({\n                        x: (y - layerY) / parentHeight,\n                        y: 1 - (x + w - layerX) / parentWidth,\n                        width: h / parentHeight,\n                        height: w / parentWidth\n                    });\n                break;\n            case \"180\":\n                rotator = (x, y, w, h)=>({\n                        x: 1 - (x + w - layerX) / parentWidth,\n                        y: 1 - (y + h - layerY) / parentHeight,\n                        width: w / parentWidth,\n                        height: h / parentHeight\n                    });\n                break;\n            case \"270\":\n                rotator = (x, y, w, h)=>({\n                        x: 1 - (y + h - layerY) / parentHeight,\n                        y: (x - layerX) / parentWidth,\n                        width: h / parentHeight,\n                        height: w / parentWidth\n                    });\n                break;\n            default:\n                rotator = (x, y, w, h)=>({\n                        x: (x - layerX) / parentWidth,\n                        y: (y - layerY) / parentHeight,\n                        width: w / parentWidth,\n                        height: h / parentHeight\n                    });\n                break;\n        }\n        const boxes = [];\n        for(let i = 0, ii = selection.rangeCount; i < ii; i++){\n            const range = selection.getRangeAt(i);\n            if (range.collapsed) {\n                continue;\n            }\n            for (const { x, y, width, height } of range.getClientRects()){\n                if (width === 0 || height === 0) {\n                    continue;\n                }\n                boxes.push(rotator(x, y, width, height));\n            }\n        }\n        return boxes.length === 0 ? null : boxes;\n    }\n    addChangedExistingAnnotation({ annotationElementId, id }) {\n        (this.#changedExistingAnnotations ||= new Map()).set(annotationElementId, id);\n    }\n    removeChangedExistingAnnotation({ annotationElementId }) {\n        this.#changedExistingAnnotations?.delete(annotationElementId);\n    }\n    renderAnnotationElement(annotation) {\n        const editorId = this.#changedExistingAnnotations?.get(annotation.data.id);\n        if (!editorId) {\n            return;\n        }\n        const editor = this.#annotationStorage.getRawValue(editorId);\n        if (!editor) {\n            return;\n        }\n        if (this.#mode === AnnotationEditorType.NONE && !editor.hasBeenModified) {\n            return;\n        }\n        editor.renderAnnotationElement(annotation);\n    }\n}\n; // ./src/display/editor/alt_text.js\nclass AltText {\n    #altText;\n    #altTextDecorative;\n    #altTextButton;\n    #altTextButtonLabel;\n    #altTextTooltip;\n    #altTextTooltipTimeout;\n    #altTextWasFromKeyBoard;\n    #badge;\n    #editor;\n    #guessedText;\n    #textWithDisclaimer;\n    #useNewAltTextFlow;\n    static #l10nNewButton = null;\n    static{\n        this._l10n = null;\n    }\n    constructor(editor){\n        this.#altText = null;\n        this.#altTextDecorative = false;\n        this.#altTextButton = null;\n        this.#altTextButtonLabel = null;\n        this.#altTextTooltip = null;\n        this.#altTextTooltipTimeout = null;\n        this.#altTextWasFromKeyBoard = false;\n        this.#badge = null;\n        this.#editor = null;\n        this.#guessedText = null;\n        this.#textWithDisclaimer = null;\n        this.#useNewAltTextFlow = false;\n        this.#editor = editor;\n        this.#useNewAltTextFlow = editor._uiManager.useNewAltTextFlow;\n        AltText.#l10nNewButton ||= Object.freeze({\n            added: \"pdfjs-editor-new-alt-text-added-button\",\n            \"added-label\": \"pdfjs-editor-new-alt-text-added-button-label\",\n            missing: \"pdfjs-editor-new-alt-text-missing-button\",\n            \"missing-label\": \"pdfjs-editor-new-alt-text-missing-button-label\",\n            review: \"pdfjs-editor-new-alt-text-to-review-button\",\n            \"review-label\": \"pdfjs-editor-new-alt-text-to-review-button-label\"\n        });\n    }\n    static initialize(l10n) {\n        AltText._l10n ??= l10n;\n    }\n    async render() {\n        const altText = this.#altTextButton = document.createElement(\"button\");\n        altText.className = \"altText\";\n        altText.tabIndex = \"0\";\n        const label = this.#altTextButtonLabel = document.createElement(\"span\");\n        altText.append(label);\n        if (this.#useNewAltTextFlow) {\n            altText.classList.add(\"new\");\n            altText.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton.missing);\n            label.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton[\"missing-label\"]);\n        } else {\n            altText.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-button\");\n            label.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-button-label\");\n        }\n        const signal = this.#editor._uiManager._signal;\n        altText.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        altText.addEventListener(\"pointerdown\", (event)=>event.stopPropagation(), {\n            signal\n        });\n        const onClick = (event)=>{\n            event.preventDefault();\n            this.#editor._uiManager.editAltText(this.#editor);\n            if (this.#useNewAltTextFlow) {\n                this.#editor._reportTelemetry({\n                    action: \"pdfjs.image.alt_text.image_status_label_clicked\",\n                    data: {\n                        label: this.#label\n                    }\n                });\n            }\n        };\n        altText.addEventListener(\"click\", onClick, {\n            capture: true,\n            signal\n        });\n        altText.addEventListener(\"keydown\", (event)=>{\n            if (event.target === altText && event.key === \"Enter\") {\n                this.#altTextWasFromKeyBoard = true;\n                onClick(event);\n            }\n        }, {\n            signal\n        });\n        await this.#setState();\n        return altText;\n    }\n    get #label() {\n        return this.#altText && \"added\" || this.#altText === null && this.guessedText && \"review\" || \"missing\";\n    }\n    finish() {\n        if (!this.#altTextButton) {\n            return;\n        }\n        this.#altTextButton.focus({\n            focusVisible: this.#altTextWasFromKeyBoard\n        });\n        this.#altTextWasFromKeyBoard = false;\n    }\n    isEmpty() {\n        if (this.#useNewAltTextFlow) {\n            return this.#altText === null;\n        }\n        return !this.#altText && !this.#altTextDecorative;\n    }\n    hasData() {\n        if (this.#useNewAltTextFlow) {\n            return this.#altText !== null || !!this.#guessedText;\n        }\n        return this.isEmpty();\n    }\n    get guessedText() {\n        return this.#guessedText;\n    }\n    async setGuessedText(guessedText) {\n        if (this.#altText !== null) {\n            return;\n        }\n        this.#guessedText = guessedText;\n        this.#textWithDisclaimer = await AltText._l10n.get(\"pdfjs-editor-new-alt-text-generated-alt-text-with-disclaimer\", {\n            generatedAltText: guessedText\n        });\n        this.#setState();\n    }\n    toggleAltTextBadge(visibility = false) {\n        if (!this.#useNewAltTextFlow || this.#altText) {\n            this.#badge?.remove();\n            this.#badge = null;\n            return;\n        }\n        if (!this.#badge) {\n            const badge = this.#badge = document.createElement(\"div\");\n            badge.className = \"noAltTextBadge\";\n            this.#editor.div.append(badge);\n        }\n        this.#badge.classList.toggle(\"hidden\", !visibility);\n    }\n    serialize(isForCopying) {\n        let altText = this.#altText;\n        if (!isForCopying && this.#guessedText === altText) {\n            altText = this.#textWithDisclaimer;\n        }\n        return {\n            altText,\n            decorative: this.#altTextDecorative,\n            guessedText: this.#guessedText,\n            textWithDisclaimer: this.#textWithDisclaimer\n        };\n    }\n    get data() {\n        return {\n            altText: this.#altText,\n            decorative: this.#altTextDecorative\n        };\n    }\n    set data({ altText, decorative, guessedText, textWithDisclaimer, cancel = false }) {\n        if (guessedText) {\n            this.#guessedText = guessedText;\n            this.#textWithDisclaimer = textWithDisclaimer;\n        }\n        if (this.#altText === altText && this.#altTextDecorative === decorative) {\n            return;\n        }\n        if (!cancel) {\n            this.#altText = altText;\n            this.#altTextDecorative = decorative;\n        }\n        this.#setState();\n    }\n    toggle(enabled = false) {\n        if (!this.#altTextButton) {\n            return;\n        }\n        if (!enabled && this.#altTextTooltipTimeout) {\n            clearTimeout(this.#altTextTooltipTimeout);\n            this.#altTextTooltipTimeout = null;\n        }\n        this.#altTextButton.disabled = !enabled;\n    }\n    shown() {\n        this.#editor._reportTelemetry({\n            action: \"pdfjs.image.alt_text.image_status_label_displayed\",\n            data: {\n                label: this.#label\n            }\n        });\n    }\n    destroy() {\n        this.#altTextButton?.remove();\n        this.#altTextButton = null;\n        this.#altTextButtonLabel = null;\n        this.#altTextTooltip = null;\n        this.#badge?.remove();\n        this.#badge = null;\n    }\n    async #setState() {\n        const button = this.#altTextButton;\n        if (!button) {\n            return;\n        }\n        if (this.#useNewAltTextFlow) {\n            button.classList.toggle(\"done\", !!this.#altText);\n            button.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton[this.#label]);\n            this.#altTextButtonLabel?.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton[`${this.#label}-label`]);\n            if (!this.#altText) {\n                this.#altTextTooltip?.remove();\n                return;\n            }\n        } else {\n            if (!this.#altText && !this.#altTextDecorative) {\n                button.classList.remove(\"done\");\n                this.#altTextTooltip?.remove();\n                return;\n            }\n            button.classList.add(\"done\");\n            button.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-edit-button\");\n        }\n        let tooltip = this.#altTextTooltip;\n        if (!tooltip) {\n            this.#altTextTooltip = tooltip = document.createElement(\"span\");\n            tooltip.className = \"tooltip\";\n            tooltip.setAttribute(\"role\", \"tooltip\");\n            tooltip.id = `alt-text-tooltip-${this.#editor.id}`;\n            const DELAY_TO_SHOW_TOOLTIP = 100;\n            const signal = this.#editor._uiManager._signal;\n            signal.addEventListener(\"abort\", ()=>{\n                clearTimeout(this.#altTextTooltipTimeout);\n                this.#altTextTooltipTimeout = null;\n            }, {\n                once: true\n            });\n            button.addEventListener(\"mouseenter\", ()=>{\n                this.#altTextTooltipTimeout = setTimeout(()=>{\n                    this.#altTextTooltipTimeout = null;\n                    this.#altTextTooltip.classList.add(\"show\");\n                    this.#editor._reportTelemetry({\n                        action: \"alt_text_tooltip\"\n                    });\n                }, DELAY_TO_SHOW_TOOLTIP);\n            }, {\n                signal\n            });\n            button.addEventListener(\"mouseleave\", ()=>{\n                if (this.#altTextTooltipTimeout) {\n                    clearTimeout(this.#altTextTooltipTimeout);\n                    this.#altTextTooltipTimeout = null;\n                }\n                this.#altTextTooltip?.classList.remove(\"show\");\n            }, {\n                signal\n            });\n        }\n        if (this.#altTextDecorative) {\n            tooltip.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-decorative-tooltip\");\n        } else {\n            tooltip.removeAttribute(\"data-l10n-id\");\n            tooltip.textContent = this.#altText;\n        }\n        if (!tooltip.parentNode) {\n            button.append(tooltip);\n        }\n        const element = this.#editor.getImageForAltText();\n        element?.setAttribute(\"aria-describedby\", tooltip.id);\n    }\n}\n; // ./src/display/editor/editor.js\nclass AnnotationEditor {\n    #accessibilityData;\n    #allResizerDivs;\n    #altText;\n    #disabled;\n    #dragPointerId;\n    #dragPointerType;\n    #keepAspectRatio;\n    #resizersDiv;\n    #lastPointerCoords;\n    #savedDimensions;\n    #focusAC;\n    #focusedResizerName;\n    #hasBeenClicked;\n    #initialRect;\n    #isEditing;\n    #isInEditMode;\n    #isResizerEnabledForKeyboard;\n    #moveInDOMTimeout;\n    #prevDragX;\n    #prevDragY;\n    #telemetryTimeouts;\n    static{\n        this._l10n = null;\n    }\n    static{\n        this._l10nResizer = null;\n    }\n    #isDraggable;\n    #zIndex;\n    static{\n        this._borderLineWidth = -1;\n    }\n    static{\n        this._colorManager = new ColorManager();\n    }\n    static{\n        this._zIndex = 1;\n    }\n    static{\n        this._telemetryTimeout = 1000;\n    }\n    static get _resizerKeyboardManager() {\n        const resize = AnnotationEditor.prototype._resizeWithKeyboard;\n        const small = AnnotationEditorUIManager.TRANSLATE_SMALL;\n        const big = AnnotationEditorUIManager.TRANSLATE_BIG;\n        return shadow(this, \"_resizerKeyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"ArrowLeft\",\n                    \"mac+ArrowLeft\"\n                ],\n                resize,\n                {\n                    args: [\n                        -small,\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowLeft\",\n                    \"mac+shift+ArrowLeft\"\n                ],\n                resize,\n                {\n                    args: [\n                        -big,\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowRight\",\n                    \"mac+ArrowRight\"\n                ],\n                resize,\n                {\n                    args: [\n                        small,\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowRight\",\n                    \"mac+shift+ArrowRight\"\n                ],\n                resize,\n                {\n                    args: [\n                        big,\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"mac+ArrowUp\"\n                ],\n                resize,\n                {\n                    args: [\n                        0,\n                        -small\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowUp\",\n                    \"mac+shift+ArrowUp\"\n                ],\n                resize,\n                {\n                    args: [\n                        0,\n                        -big\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"mac+ArrowDown\"\n                ],\n                resize,\n                {\n                    args: [\n                        0,\n                        small\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowDown\",\n                    \"mac+shift+ArrowDown\"\n                ],\n                resize,\n                {\n                    args: [\n                        0,\n                        big\n                    ]\n                }\n            ],\n            [\n                [\n                    \"Escape\",\n                    \"mac+Escape\"\n                ],\n                AnnotationEditor.prototype._stopResizingWithKeyboard\n            ]\n        ]));\n    }\n    constructor(parameters){\n        this.#accessibilityData = null;\n        this.#allResizerDivs = null;\n        this.#altText = null;\n        this.#disabled = false;\n        this.#dragPointerId = null;\n        this.#dragPointerType = \"\";\n        this.#keepAspectRatio = false;\n        this.#resizersDiv = null;\n        this.#lastPointerCoords = null;\n        this.#savedDimensions = null;\n        this.#focusAC = null;\n        this.#focusedResizerName = \"\";\n        this.#hasBeenClicked = false;\n        this.#initialRect = null;\n        this.#isEditing = false;\n        this.#isInEditMode = false;\n        this.#isResizerEnabledForKeyboard = false;\n        this.#moveInDOMTimeout = null;\n        this.#prevDragX = 0;\n        this.#prevDragY = 0;\n        this.#telemetryTimeouts = null;\n        this._editToolbar = null;\n        this._initialOptions = Object.create(null);\n        this._initialData = null;\n        this._isVisible = true;\n        this._uiManager = null;\n        this._focusEventsAllowed = true;\n        this.#isDraggable = false;\n        this.#zIndex = AnnotationEditor._zIndex++;\n        this.parent = parameters.parent;\n        this.id = parameters.id;\n        this.width = this.height = null;\n        this.pageIndex = parameters.parent.pageIndex;\n        this.name = parameters.name;\n        this.div = null;\n        this._uiManager = parameters.uiManager;\n        this.annotationElementId = null;\n        this._willKeepAspectRatio = false;\n        this._initialOptions.isCentered = parameters.isCentered;\n        this._structTreeParentId = null;\n        const { rotation, rawDims: { pageWidth, pageHeight, pageX, pageY } } = this.parent.viewport;\n        this.rotation = rotation;\n        this.pageRotation = (360 + rotation - this._uiManager.viewParameters.rotation) % 360;\n        this.pageDimensions = [\n            pageWidth,\n            pageHeight\n        ];\n        this.pageTranslation = [\n            pageX,\n            pageY\n        ];\n        const [width, height] = this.parentDimensions;\n        this.x = parameters.x / width;\n        this.y = parameters.y / height;\n        this.isAttachedToDOM = false;\n        this.deleted = false;\n    }\n    get editorType() {\n        return Object.getPrototypeOf(this).constructor._type;\n    }\n    static get isDrawer() {\n        return false;\n    }\n    static get _defaultLineColor() {\n        return shadow(this, \"_defaultLineColor\", this._colorManager.getHexCode(\"CanvasText\"));\n    }\n    static deleteAnnotationElement(editor) {\n        const fakeEditor = new FakeEditor({\n            id: editor.parent.getNextId(),\n            parent: editor.parent,\n            uiManager: editor._uiManager\n        });\n        fakeEditor.annotationElementId = editor.annotationElementId;\n        fakeEditor.deleted = true;\n        fakeEditor._uiManager.addToAnnotationStorage(fakeEditor);\n    }\n    static initialize(l10n, _uiManager) {\n        AnnotationEditor._l10n ??= l10n;\n        AnnotationEditor._l10nResizer ||= Object.freeze({\n            topLeft: \"pdfjs-editor-resizer-top-left\",\n            topMiddle: \"pdfjs-editor-resizer-top-middle\",\n            topRight: \"pdfjs-editor-resizer-top-right\",\n            middleRight: \"pdfjs-editor-resizer-middle-right\",\n            bottomRight: \"pdfjs-editor-resizer-bottom-right\",\n            bottomMiddle: \"pdfjs-editor-resizer-bottom-middle\",\n            bottomLeft: \"pdfjs-editor-resizer-bottom-left\",\n            middleLeft: \"pdfjs-editor-resizer-middle-left\"\n        });\n        if (AnnotationEditor._borderLineWidth !== -1) {\n            return;\n        }\n        const style = getComputedStyle(document.documentElement);\n        AnnotationEditor._borderLineWidth = parseFloat(style.getPropertyValue(\"--outline-width\")) || 0;\n    }\n    static updateDefaultParams(_type, _value) {}\n    static get defaultPropertiesToUpdate() {\n        return [];\n    }\n    static isHandlingMimeForPasting(mime) {\n        return false;\n    }\n    static paste(item, parent) {\n        unreachable(\"Not implemented\");\n    }\n    get propertiesToUpdate() {\n        return [];\n    }\n    get _isDraggable() {\n        return this.#isDraggable;\n    }\n    set _isDraggable(value) {\n        this.#isDraggable = value;\n        this.div?.classList.toggle(\"draggable\", value);\n    }\n    get isEnterHandled() {\n        return true;\n    }\n    center() {\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        switch(this.parentRotation){\n            case 90:\n                this.x -= this.height * pageHeight / (pageWidth * 2);\n                this.y += this.width * pageWidth / (pageHeight * 2);\n                break;\n            case 180:\n                this.x += this.width / 2;\n                this.y += this.height / 2;\n                break;\n            case 270:\n                this.x += this.height * pageHeight / (pageWidth * 2);\n                this.y -= this.width * pageWidth / (pageHeight * 2);\n                break;\n            default:\n                this.x -= this.width / 2;\n                this.y -= this.height / 2;\n                break;\n        }\n        this.fixAndSetPosition();\n    }\n    addCommands(params) {\n        this._uiManager.addCommands(params);\n    }\n    get currentLayer() {\n        return this._uiManager.currentLayer;\n    }\n    setInBackground() {\n        this.div.style.zIndex = 0;\n    }\n    setInForeground() {\n        this.div.style.zIndex = this.#zIndex;\n    }\n    setParent(parent) {\n        if (parent !== null) {\n            this.pageIndex = parent.pageIndex;\n            this.pageDimensions = parent.pageDimensions;\n        } else {\n            this.#stopResizing();\n        }\n        this.parent = parent;\n    }\n    focusin(event) {\n        if (!this._focusEventsAllowed) {\n            return;\n        }\n        if (!this.#hasBeenClicked) {\n            this.parent.setSelected(this);\n        } else {\n            this.#hasBeenClicked = false;\n        }\n    }\n    focusout(event) {\n        if (!this._focusEventsAllowed) {\n            return;\n        }\n        if (!this.isAttachedToDOM) {\n            return;\n        }\n        const target = event.relatedTarget;\n        if (target?.closest(`#${this.id}`)) {\n            return;\n        }\n        event.preventDefault();\n        if (!this.parent?.isMultipleSelection) {\n            this.commitOrRemove();\n        }\n    }\n    commitOrRemove() {\n        if (this.isEmpty()) {\n            this.remove();\n        } else {\n            this.commit();\n        }\n    }\n    commit() {\n        this.addToAnnotationStorage();\n    }\n    addToAnnotationStorage() {\n        this._uiManager.addToAnnotationStorage(this);\n    }\n    setAt(x, y, tx, ty) {\n        const [width, height] = this.parentDimensions;\n        [tx, ty] = this.screenToPageTranslation(tx, ty);\n        this.x = (x + tx) / width;\n        this.y = (y + ty) / height;\n        this.fixAndSetPosition();\n    }\n    #translate([width, height], x, y) {\n        [x, y] = this.screenToPageTranslation(x, y);\n        this.x += x / width;\n        this.y += y / height;\n        this._onTranslating(this.x, this.y);\n        this.fixAndSetPosition();\n    }\n    translate(x, y) {\n        this.#translate(this.parentDimensions, x, y);\n    }\n    translateInPage(x, y) {\n        this.#initialRect ||= [\n            this.x,\n            this.y,\n            this.width,\n            this.height\n        ];\n        this.#translate(this.pageDimensions, x, y);\n        this.div.scrollIntoView({\n            block: \"nearest\"\n        });\n    }\n    drag(tx, ty) {\n        this.#initialRect ||= [\n            this.x,\n            this.y,\n            this.width,\n            this.height\n        ];\n        const { div, parentDimensions: [parentWidth, parentHeight] } = this;\n        this.x += tx / parentWidth;\n        this.y += ty / parentHeight;\n        if (this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {\n            const { x, y } = this.div.getBoundingClientRect();\n            if (this.parent.findNewParent(this, x, y)) {\n                this.x -= Math.floor(this.x);\n                this.y -= Math.floor(this.y);\n            }\n        }\n        let { x, y } = this;\n        const [bx, by] = this.getBaseTranslation();\n        x += bx;\n        y += by;\n        const { style } = div;\n        style.left = `${(100 * x).toFixed(2)}%`;\n        style.top = `${(100 * y).toFixed(2)}%`;\n        this._onTranslating(x, y);\n        div.scrollIntoView({\n            block: \"nearest\"\n        });\n    }\n    _onTranslating(x, y) {}\n    _onTranslated(x, y) {}\n    get _hasBeenMoved() {\n        return !!this.#initialRect && (this.#initialRect[0] !== this.x || this.#initialRect[1] !== this.y);\n    }\n    get _hasBeenResized() {\n        return !!this.#initialRect && (this.#initialRect[2] !== this.width || this.#initialRect[3] !== this.height);\n    }\n    getBaseTranslation() {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        const { _borderLineWidth } = AnnotationEditor;\n        const x = _borderLineWidth / parentWidth;\n        const y = _borderLineWidth / parentHeight;\n        switch(this.rotation){\n            case 90:\n                return [\n                    -x,\n                    y\n                ];\n            case 180:\n                return [\n                    x,\n                    y\n                ];\n            case 270:\n                return [\n                    x,\n                    -y\n                ];\n            default:\n                return [\n                    -x,\n                    -y\n                ];\n        }\n    }\n    get _mustFixPosition() {\n        return true;\n    }\n    fixAndSetPosition(rotation = this.rotation) {\n        const { div: { style }, pageDimensions: [pageWidth, pageHeight] } = this;\n        let { x, y, width, height } = this;\n        width *= pageWidth;\n        height *= pageHeight;\n        x *= pageWidth;\n        y *= pageHeight;\n        if (this._mustFixPosition) {\n            switch(rotation){\n                case 0:\n                    x = Math.max(0, Math.min(pageWidth - width, x));\n                    y = Math.max(0, Math.min(pageHeight - height, y));\n                    break;\n                case 90:\n                    x = Math.max(0, Math.min(pageWidth - height, x));\n                    y = Math.min(pageHeight, Math.max(width, y));\n                    break;\n                case 180:\n                    x = Math.min(pageWidth, Math.max(width, x));\n                    y = Math.min(pageHeight, Math.max(height, y));\n                    break;\n                case 270:\n                    x = Math.min(pageWidth, Math.max(height, x));\n                    y = Math.max(0, Math.min(pageHeight - width, y));\n                    break;\n            }\n        }\n        this.x = x /= pageWidth;\n        this.y = y /= pageHeight;\n        const [bx, by] = this.getBaseTranslation();\n        x += bx;\n        y += by;\n        style.left = `${(100 * x).toFixed(2)}%`;\n        style.top = `${(100 * y).toFixed(2)}%`;\n        this.moveInDOM();\n    }\n    static #rotatePoint(x, y, angle) {\n        switch(angle){\n            case 90:\n                return [\n                    y,\n                    -x\n                ];\n            case 180:\n                return [\n                    -x,\n                    -y\n                ];\n            case 270:\n                return [\n                    -y,\n                    x\n                ];\n            default:\n                return [\n                    x,\n                    y\n                ];\n        }\n    }\n    screenToPageTranslation(x, y) {\n        return AnnotationEditor.#rotatePoint(x, y, this.parentRotation);\n    }\n    pageTranslationToScreen(x, y) {\n        return AnnotationEditor.#rotatePoint(x, y, 360 - this.parentRotation);\n    }\n    #getRotationMatrix(rotation) {\n        switch(rotation){\n            case 90:\n                {\n                    const [pageWidth, pageHeight] = this.pageDimensions;\n                    return [\n                        0,\n                        -pageWidth / pageHeight,\n                        pageHeight / pageWidth,\n                        0\n                    ];\n                }\n            case 180:\n                return [\n                    -1,\n                    0,\n                    0,\n                    -1\n                ];\n            case 270:\n                {\n                    const [pageWidth, pageHeight] = this.pageDimensions;\n                    return [\n                        0,\n                        pageWidth / pageHeight,\n                        -pageHeight / pageWidth,\n                        0\n                    ];\n                }\n            default:\n                return [\n                    1,\n                    0,\n                    0,\n                    1\n                ];\n        }\n    }\n    get parentScale() {\n        return this._uiManager.viewParameters.realScale;\n    }\n    get parentRotation() {\n        return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;\n    }\n    get parentDimensions() {\n        const { parentScale, pageDimensions: [pageWidth, pageHeight] } = this;\n        return [\n            pageWidth * parentScale,\n            pageHeight * parentScale\n        ];\n    }\n    setDims(width, height) {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        const { style } = this.div;\n        style.width = `${(100 * width / parentWidth).toFixed(2)}%`;\n        if (!this.#keepAspectRatio) {\n            style.height = `${(100 * height / parentHeight).toFixed(2)}%`;\n        }\n    }\n    fixDims() {\n        const { style } = this.div;\n        const { height, width } = style;\n        const widthPercent = width.endsWith(\"%\");\n        const heightPercent = !this.#keepAspectRatio && height.endsWith(\"%\");\n        if (widthPercent && heightPercent) {\n            return;\n        }\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        if (!widthPercent) {\n            style.width = `${(100 * parseFloat(width) / parentWidth).toFixed(2)}%`;\n        }\n        if (!this.#keepAspectRatio && !heightPercent) {\n            style.height = `${(100 * parseFloat(height) / parentHeight).toFixed(2)}%`;\n        }\n    }\n    getInitialTranslation() {\n        return [\n            0,\n            0\n        ];\n    }\n    #createResizers() {\n        if (this.#resizersDiv) {\n            return;\n        }\n        this.#resizersDiv = document.createElement(\"div\");\n        this.#resizersDiv.classList.add(\"resizers\");\n        const classes = this._willKeepAspectRatio ? [\n            \"topLeft\",\n            \"topRight\",\n            \"bottomRight\",\n            \"bottomLeft\"\n        ] : [\n            \"topLeft\",\n            \"topMiddle\",\n            \"topRight\",\n            \"middleRight\",\n            \"bottomRight\",\n            \"bottomMiddle\",\n            \"bottomLeft\",\n            \"middleLeft\"\n        ];\n        const signal = this._uiManager._signal;\n        for (const name of classes){\n            const div = document.createElement(\"div\");\n            this.#resizersDiv.append(div);\n            div.classList.add(\"resizer\", name);\n            div.setAttribute(\"data-resizer-name\", name);\n            div.addEventListener(\"pointerdown\", this.#resizerPointerdown.bind(this, name), {\n                signal\n            });\n            div.addEventListener(\"contextmenu\", noContextMenu, {\n                signal\n            });\n            div.tabIndex = -1;\n        }\n        this.div.prepend(this.#resizersDiv);\n    }\n    #resizerPointerdown(name, event) {\n        event.preventDefault();\n        const { isMac } = util_FeatureTest.platform;\n        if (event.button !== 0 || event.ctrlKey && isMac) {\n            return;\n        }\n        this.#altText?.toggle(false);\n        const savedDraggable = this._isDraggable;\n        this._isDraggable = false;\n        this.#lastPointerCoords = [\n            event.screenX,\n            event.screenY\n        ];\n        const ac = new AbortController();\n        const signal = this._uiManager.combinedSignal(ac);\n        this.parent.togglePointerEvents(false);\n        window.addEventListener(\"pointermove\", this.#resizerPointermove.bind(this, name), {\n            passive: true,\n            capture: true,\n            signal\n        });\n        window.addEventListener(\"touchmove\", stopEvent, {\n            passive: false,\n            signal\n        });\n        window.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        this.#savedDimensions = {\n            savedX: this.x,\n            savedY: this.y,\n            savedWidth: this.width,\n            savedHeight: this.height\n        };\n        const savedParentCursor = this.parent.div.style.cursor;\n        const savedCursor = this.div.style.cursor;\n        this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(event.target).cursor;\n        const pointerUpCallback = ()=>{\n            ac.abort();\n            this.parent.togglePointerEvents(true);\n            this.#altText?.toggle(true);\n            this._isDraggable = savedDraggable;\n            this.parent.div.style.cursor = savedParentCursor;\n            this.div.style.cursor = savedCursor;\n            this.#addResizeToUndoStack();\n        };\n        window.addEventListener(\"pointerup\", pointerUpCallback, {\n            signal\n        });\n        window.addEventListener(\"blur\", pointerUpCallback, {\n            signal\n        });\n    }\n    #resize(x, y, width, height) {\n        this.width = width;\n        this.height = height;\n        this.x = x;\n        this.y = y;\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.setDims(parentWidth * width, parentHeight * height);\n        this.fixAndSetPosition();\n        this._onResized();\n    }\n    _onResized() {}\n    #addResizeToUndoStack() {\n        if (!this.#savedDimensions) {\n            return;\n        }\n        const { savedX, savedY, savedWidth, savedHeight } = this.#savedDimensions;\n        this.#savedDimensions = null;\n        const newX = this.x;\n        const newY = this.y;\n        const newWidth = this.width;\n        const newHeight = this.height;\n        if (newX === savedX && newY === savedY && newWidth === savedWidth && newHeight === savedHeight) {\n            return;\n        }\n        this.addCommands({\n            cmd: this.#resize.bind(this, newX, newY, newWidth, newHeight),\n            undo: this.#resize.bind(this, savedX, savedY, savedWidth, savedHeight),\n            mustExec: true\n        });\n    }\n    #resizerPointermove(name, event) {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        const savedX = this.x;\n        const savedY = this.y;\n        const savedWidth = this.width;\n        const savedHeight = this.height;\n        const minWidth = AnnotationEditor.MIN_SIZE / parentWidth;\n        const minHeight = AnnotationEditor.MIN_SIZE / parentHeight;\n        const round = (x)=>Math.round(x * 10000) / 10000;\n        const rotationMatrix = this.#getRotationMatrix(this.rotation);\n        const transf = (x, y)=>[\n                rotationMatrix[0] * x + rotationMatrix[2] * y,\n                rotationMatrix[1] * x + rotationMatrix[3] * y\n            ];\n        const invRotationMatrix = this.#getRotationMatrix(360 - this.rotation);\n        const invTransf = (x, y)=>[\n                invRotationMatrix[0] * x + invRotationMatrix[2] * y,\n                invRotationMatrix[1] * x + invRotationMatrix[3] * y\n            ];\n        let getPoint;\n        let getOpposite;\n        let isDiagonal = false;\n        let isHorizontal = false;\n        switch(name){\n            case \"topLeft\":\n                isDiagonal = true;\n                getPoint = (w, h)=>[\n                        0,\n                        0\n                    ];\n                getOpposite = (w, h)=>[\n                        w,\n                        h\n                    ];\n                break;\n            case \"topMiddle\":\n                getPoint = (w, h)=>[\n                        w / 2,\n                        0\n                    ];\n                getOpposite = (w, h)=>[\n                        w / 2,\n                        h\n                    ];\n                break;\n            case \"topRight\":\n                isDiagonal = true;\n                getPoint = (w, h)=>[\n                        w,\n                        0\n                    ];\n                getOpposite = (w, h)=>[\n                        0,\n                        h\n                    ];\n                break;\n            case \"middleRight\":\n                isHorizontal = true;\n                getPoint = (w, h)=>[\n                        w,\n                        h / 2\n                    ];\n                getOpposite = (w, h)=>[\n                        0,\n                        h / 2\n                    ];\n                break;\n            case \"bottomRight\":\n                isDiagonal = true;\n                getPoint = (w, h)=>[\n                        w,\n                        h\n                    ];\n                getOpposite = (w, h)=>[\n                        0,\n                        0\n                    ];\n                break;\n            case \"bottomMiddle\":\n                getPoint = (w, h)=>[\n                        w / 2,\n                        h\n                    ];\n                getOpposite = (w, h)=>[\n                        w / 2,\n                        0\n                    ];\n                break;\n            case \"bottomLeft\":\n                isDiagonal = true;\n                getPoint = (w, h)=>[\n                        0,\n                        h\n                    ];\n                getOpposite = (w, h)=>[\n                        w,\n                        0\n                    ];\n                break;\n            case \"middleLeft\":\n                isHorizontal = true;\n                getPoint = (w, h)=>[\n                        0,\n                        h / 2\n                    ];\n                getOpposite = (w, h)=>[\n                        w,\n                        h / 2\n                    ];\n                break;\n        }\n        const point = getPoint(savedWidth, savedHeight);\n        const oppositePoint = getOpposite(savedWidth, savedHeight);\n        let transfOppositePoint = transf(...oppositePoint);\n        const oppositeX = round(savedX + transfOppositePoint[0]);\n        const oppositeY = round(savedY + transfOppositePoint[1]);\n        let ratioX = 1;\n        let ratioY = 1;\n        let deltaX, deltaY;\n        if (!event.fromKeyboard) {\n            const { screenX, screenY } = event;\n            const [lastScreenX, lastScreenY] = this.#lastPointerCoords;\n            [deltaX, deltaY] = this.screenToPageTranslation(screenX - lastScreenX, screenY - lastScreenY);\n            this.#lastPointerCoords[0] = screenX;\n            this.#lastPointerCoords[1] = screenY;\n        } else {\n            ({ deltaX, deltaY } = event);\n        }\n        [deltaX, deltaY] = invTransf(deltaX / parentWidth, deltaY / parentHeight);\n        if (isDiagonal) {\n            const oldDiag = Math.hypot(savedWidth, savedHeight);\n            ratioX = ratioY = Math.max(Math.min(Math.hypot(oppositePoint[0] - point[0] - deltaX, oppositePoint[1] - point[1] - deltaY) / oldDiag, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);\n        } else if (isHorizontal) {\n            ratioX = Math.max(minWidth, Math.min(1, Math.abs(oppositePoint[0] - point[0] - deltaX))) / savedWidth;\n        } else {\n            ratioY = Math.max(minHeight, Math.min(1, Math.abs(oppositePoint[1] - point[1] - deltaY))) / savedHeight;\n        }\n        const newWidth = round(savedWidth * ratioX);\n        const newHeight = round(savedHeight * ratioY);\n        transfOppositePoint = transf(...getOpposite(newWidth, newHeight));\n        const newX = oppositeX - transfOppositePoint[0];\n        const newY = oppositeY - transfOppositePoint[1];\n        this.#initialRect ||= [\n            this.x,\n            this.y,\n            this.width,\n            this.height\n        ];\n        this.width = newWidth;\n        this.height = newHeight;\n        this.x = newX;\n        this.y = newY;\n        this.setDims(parentWidth * newWidth, parentHeight * newHeight);\n        this.fixAndSetPosition();\n        this._onResizing();\n    }\n    _onResizing() {}\n    altTextFinish() {\n        this.#altText?.finish();\n    }\n    async addEditToolbar() {\n        if (this._editToolbar || this.#isInEditMode) {\n            return this._editToolbar;\n        }\n        this._editToolbar = new EditorToolbar(this);\n        this.div.append(this._editToolbar.render());\n        if (this.#altText) {\n            await this._editToolbar.addAltText(this.#altText);\n        }\n        return this._editToolbar;\n    }\n    removeEditToolbar() {\n        if (!this._editToolbar) {\n            return;\n        }\n        this._editToolbar.remove();\n        this._editToolbar = null;\n        this.#altText?.destroy();\n    }\n    addContainer(container) {\n        const editToolbarDiv = this._editToolbar?.div;\n        if (editToolbarDiv) {\n            editToolbarDiv.before(container);\n        } else {\n            this.div.append(container);\n        }\n    }\n    getClientDimensions() {\n        return this.div.getBoundingClientRect();\n    }\n    async addAltTextButton() {\n        if (this.#altText) {\n            return;\n        }\n        AltText.initialize(AnnotationEditor._l10n);\n        this.#altText = new AltText(this);\n        if (this.#accessibilityData) {\n            this.#altText.data = this.#accessibilityData;\n            this.#accessibilityData = null;\n        }\n        await this.addEditToolbar();\n    }\n    get altTextData() {\n        return this.#altText?.data;\n    }\n    set altTextData(data) {\n        if (!this.#altText) {\n            return;\n        }\n        this.#altText.data = data;\n    }\n    get guessedAltText() {\n        return this.#altText?.guessedText;\n    }\n    async setGuessedAltText(text) {\n        await this.#altText?.setGuessedText(text);\n    }\n    serializeAltText(isForCopying) {\n        return this.#altText?.serialize(isForCopying);\n    }\n    hasAltText() {\n        return !!this.#altText && !this.#altText.isEmpty();\n    }\n    hasAltTextData() {\n        return this.#altText?.hasData() ?? false;\n    }\n    render() {\n        this.div = document.createElement(\"div\");\n        this.div.setAttribute(\"data-editor-rotation\", (360 - this.rotation) % 360);\n        this.div.className = this.name;\n        this.div.setAttribute(\"id\", this.id);\n        this.div.tabIndex = this.#disabled ? -1 : 0;\n        if (!this._isVisible) {\n            this.div.classList.add(\"hidden\");\n        }\n        this.setInForeground();\n        this.#addFocusListeners();\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        if (this.parentRotation % 180 !== 0) {\n            this.div.style.maxWidth = `${(100 * parentHeight / parentWidth).toFixed(2)}%`;\n            this.div.style.maxHeight = `${(100 * parentWidth / parentHeight).toFixed(2)}%`;\n        }\n        const [tx, ty] = this.getInitialTranslation();\n        this.translate(tx, ty);\n        bindEvents(this, this.div, [\n            \"pointerdown\"\n        ]);\n        this._uiManager._editorUndoBar?.hide();\n        return this.div;\n    }\n    pointerdown(event) {\n        const { isMac } = util_FeatureTest.platform;\n        if (event.button !== 0 || event.ctrlKey && isMac) {\n            event.preventDefault();\n            return;\n        }\n        this.#hasBeenClicked = true;\n        if (this._isDraggable) {\n            this.#setUpDragSession(event);\n            return;\n        }\n        this.#selectOnPointerEvent(event);\n    }\n    get isSelected() {\n        return this._uiManager.isSelected(this);\n    }\n    #selectOnPointerEvent(event) {\n        const { isMac } = util_FeatureTest.platform;\n        if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {\n            this.parent.toggleSelected(this);\n        } else {\n            this.parent.setSelected(this);\n        }\n    }\n    #setUpDragSession(event) {\n        const { isSelected } = this;\n        this._uiManager.setUpDragSession();\n        const ac = new AbortController();\n        const signal = this._uiManager.combinedSignal(ac);\n        const opts = {\n            capture: true,\n            passive: false,\n            signal\n        };\n        const cancelDrag = (e)=>{\n            ac.abort();\n            this.#dragPointerId = null;\n            this.#hasBeenClicked = false;\n            if (!this._uiManager.endDragSession()) {\n                this.#selectOnPointerEvent(e);\n            }\n        };\n        if (isSelected) {\n            this.#prevDragX = event.clientX;\n            this.#prevDragY = event.clientY;\n            this.#dragPointerId = event.pointerId;\n            this.#dragPointerType = event.pointerType;\n            window.addEventListener(\"pointermove\", (e)=>{\n                const { clientX: x, clientY: y, pointerId } = e;\n                if (pointerId !== this.#dragPointerId) {\n                    stopEvent(e);\n                    return;\n                }\n                const [tx, ty] = this.screenToPageTranslation(x - this.#prevDragX, y - this.#prevDragY);\n                this.#prevDragX = x;\n                this.#prevDragY = y;\n                this._uiManager.dragSelectedEditors(tx, ty);\n            }, opts);\n            window.addEventListener(\"touchmove\", stopEvent, opts);\n            window.addEventListener(\"pointerdown\", (e)=>{\n                if (e.isPrimary && e.pointerType === this.#dragPointerType) {\n                    cancelDrag(e);\n                }\n                stopEvent(e);\n            }, opts);\n        }\n        this._onStartDragging();\n        const pointerUpCallback = (e)=>{\n            if (!this.#dragPointerId || this.#dragPointerId === e.pointerId) {\n                cancelDrag(e);\n                this._onStopDragging();\n                return;\n            }\n            stopEvent(e);\n        };\n        window.addEventListener(\"pointerup\", pointerUpCallback, {\n            signal\n        });\n        window.addEventListener(\"blur\", pointerUpCallback, {\n            signal\n        });\n    }\n    _onStartDragging() {}\n    _onStopDragging() {}\n    moveInDOM() {\n        if (this.#moveInDOMTimeout) {\n            clearTimeout(this.#moveInDOMTimeout);\n        }\n        this.#moveInDOMTimeout = setTimeout(()=>{\n            this.#moveInDOMTimeout = null;\n            this.parent?.moveEditorInDOM(this);\n        }, 0);\n    }\n    _setParentAndPosition(parent, x, y) {\n        parent.changeParent(this);\n        this.x = x;\n        this.y = y;\n        this.fixAndSetPosition();\n        this._onTranslated();\n    }\n    getRect(tx, ty, rotation = this.rotation) {\n        const scale = this.parentScale;\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        const [pageX, pageY] = this.pageTranslation;\n        const shiftX = tx / scale;\n        const shiftY = ty / scale;\n        const x = this.x * pageWidth;\n        const y = this.y * pageHeight;\n        const width = this.width * pageWidth;\n        const height = this.height * pageHeight;\n        switch(rotation){\n            case 0:\n                return [\n                    x + shiftX + pageX,\n                    pageHeight - y - shiftY - height + pageY,\n                    x + shiftX + width + pageX,\n                    pageHeight - y - shiftY + pageY\n                ];\n            case 90:\n                return [\n                    x + shiftY + pageX,\n                    pageHeight - y + shiftX + pageY,\n                    x + shiftY + height + pageX,\n                    pageHeight - y + shiftX + width + pageY\n                ];\n            case 180:\n                return [\n                    x - shiftX - width + pageX,\n                    pageHeight - y + shiftY + pageY,\n                    x - shiftX + pageX,\n                    pageHeight - y + shiftY + height + pageY\n                ];\n            case 270:\n                return [\n                    x - shiftY - height + pageX,\n                    pageHeight - y - shiftX - width + pageY,\n                    x - shiftY + pageX,\n                    pageHeight - y - shiftX + pageY\n                ];\n            default:\n                throw new Error(\"Invalid rotation\");\n        }\n    }\n    getRectInCurrentCoords(rect, pageHeight) {\n        const [x1, y1, x2, y2] = rect;\n        const width = x2 - x1;\n        const height = y2 - y1;\n        switch(this.rotation){\n            case 0:\n                return [\n                    x1,\n                    pageHeight - y2,\n                    width,\n                    height\n                ];\n            case 90:\n                return [\n                    x1,\n                    pageHeight - y1,\n                    height,\n                    width\n                ];\n            case 180:\n                return [\n                    x2,\n                    pageHeight - y1,\n                    width,\n                    height\n                ];\n            case 270:\n                return [\n                    x2,\n                    pageHeight - y2,\n                    height,\n                    width\n                ];\n            default:\n                throw new Error(\"Invalid rotation\");\n        }\n    }\n    onceAdded() {}\n    isEmpty() {\n        return false;\n    }\n    enableEditMode() {\n        this.#isInEditMode = true;\n    }\n    disableEditMode() {\n        this.#isInEditMode = false;\n    }\n    isInEditMode() {\n        return this.#isInEditMode;\n    }\n    shouldGetKeyboardEvents() {\n        return this.#isResizerEnabledForKeyboard;\n    }\n    needsToBeRebuilt() {\n        return this.div && !this.isAttachedToDOM;\n    }\n    get isOnScreen() {\n        const { top, left, bottom, right } = this.getClientDimensions();\n        const { innerHeight, innerWidth } = window;\n        return left < innerWidth && right > 0 && top < innerHeight && bottom > 0;\n    }\n    #addFocusListeners() {\n        if (this.#focusAC || !this.div) {\n            return;\n        }\n        this.#focusAC = new AbortController();\n        const signal = this._uiManager.combinedSignal(this.#focusAC);\n        this.div.addEventListener(\"focusin\", this.focusin.bind(this), {\n            signal\n        });\n        this.div.addEventListener(\"focusout\", this.focusout.bind(this), {\n            signal\n        });\n    }\n    rebuild() {\n        this.#addFocusListeners();\n    }\n    rotate(_angle) {}\n    resize() {}\n    serializeDeleted() {\n        return {\n            id: this.annotationElementId,\n            deleted: true,\n            pageIndex: this.pageIndex,\n            popupRef: this._initialData?.popupRef || \"\"\n        };\n    }\n    serialize(isForCopying = false, context = null) {\n        unreachable(\"An editor must be serializable\");\n    }\n    static async deserialize(data, parent, uiManager) {\n        const editor = new this.prototype.constructor({\n            parent,\n            id: parent.getNextId(),\n            uiManager\n        });\n        editor.rotation = data.rotation;\n        editor.#accessibilityData = data.accessibilityData;\n        const [pageWidth, pageHeight] = editor.pageDimensions;\n        const [x, y, width, height] = editor.getRectInCurrentCoords(data.rect, pageHeight);\n        editor.x = x / pageWidth;\n        editor.y = y / pageHeight;\n        editor.width = width / pageWidth;\n        editor.height = height / pageHeight;\n        return editor;\n    }\n    get hasBeenModified() {\n        return !!this.annotationElementId && (this.deleted || this.serialize() !== null);\n    }\n    remove() {\n        this.#focusAC?.abort();\n        this.#focusAC = null;\n        if (!this.isEmpty()) {\n            this.commit();\n        }\n        if (this.parent) {\n            this.parent.remove(this);\n        } else {\n            this._uiManager.removeEditor(this);\n        }\n        if (this.#moveInDOMTimeout) {\n            clearTimeout(this.#moveInDOMTimeout);\n            this.#moveInDOMTimeout = null;\n        }\n        this.#stopResizing();\n        this.removeEditToolbar();\n        if (this.#telemetryTimeouts) {\n            for (const timeout of this.#telemetryTimeouts.values()){\n                clearTimeout(timeout);\n            }\n            this.#telemetryTimeouts = null;\n        }\n        this.parent = null;\n    }\n    get isResizable() {\n        return false;\n    }\n    makeResizable() {\n        if (this.isResizable) {\n            this.#createResizers();\n            this.#resizersDiv.classList.remove(\"hidden\");\n            bindEvents(this, this.div, [\n                \"keydown\"\n            ]);\n        }\n    }\n    get toolbarPosition() {\n        return null;\n    }\n    keydown(event) {\n        if (!this.isResizable || event.target !== this.div || event.key !== \"Enter\") {\n            return;\n        }\n        this._uiManager.setSelected(this);\n        this.#savedDimensions = {\n            savedX: this.x,\n            savedY: this.y,\n            savedWidth: this.width,\n            savedHeight: this.height\n        };\n        const children = this.#resizersDiv.children;\n        if (!this.#allResizerDivs) {\n            this.#allResizerDivs = Array.from(children);\n            const boundResizerKeydown = this.#resizerKeydown.bind(this);\n            const boundResizerBlur = this.#resizerBlur.bind(this);\n            const signal = this._uiManager._signal;\n            for (const div of this.#allResizerDivs){\n                const name = div.getAttribute(\"data-resizer-name\");\n                div.setAttribute(\"role\", \"spinbutton\");\n                div.addEventListener(\"keydown\", boundResizerKeydown, {\n                    signal\n                });\n                div.addEventListener(\"blur\", boundResizerBlur, {\n                    signal\n                });\n                div.addEventListener(\"focus\", this.#resizerFocus.bind(this, name), {\n                    signal\n                });\n                div.setAttribute(\"data-l10n-id\", AnnotationEditor._l10nResizer[name]);\n            }\n        }\n        const first = this.#allResizerDivs[0];\n        let firstPosition = 0;\n        for (const div of children){\n            if (div === first) {\n                break;\n            }\n            firstPosition++;\n        }\n        const nextFirstPosition = (360 - this.rotation + this.parentRotation) % 360 / 90 * (this.#allResizerDivs.length / 4);\n        if (nextFirstPosition !== firstPosition) {\n            if (nextFirstPosition < firstPosition) {\n                for(let i = 0; i < firstPosition - nextFirstPosition; i++){\n                    this.#resizersDiv.append(this.#resizersDiv.firstChild);\n                }\n            } else if (nextFirstPosition > firstPosition) {\n                for(let i = 0; i < nextFirstPosition - firstPosition; i++){\n                    this.#resizersDiv.firstChild.before(this.#resizersDiv.lastChild);\n                }\n            }\n            let i = 0;\n            for (const child of children){\n                const div = this.#allResizerDivs[i++];\n                const name = div.getAttribute(\"data-resizer-name\");\n                child.setAttribute(\"data-l10n-id\", AnnotationEditor._l10nResizer[name]);\n            }\n        }\n        this.#setResizerTabIndex(0);\n        this.#isResizerEnabledForKeyboard = true;\n        this.#resizersDiv.firstChild.focus({\n            focusVisible: true\n        });\n        event.preventDefault();\n        event.stopImmediatePropagation();\n    }\n    #resizerKeydown(event) {\n        AnnotationEditor._resizerKeyboardManager.exec(this, event);\n    }\n    #resizerBlur(event) {\n        if (this.#isResizerEnabledForKeyboard && event.relatedTarget?.parentNode !== this.#resizersDiv) {\n            this.#stopResizing();\n        }\n    }\n    #resizerFocus(name) {\n        this.#focusedResizerName = this.#isResizerEnabledForKeyboard ? name : \"\";\n    }\n    #setResizerTabIndex(value) {\n        if (!this.#allResizerDivs) {\n            return;\n        }\n        for (const div of this.#allResizerDivs){\n            div.tabIndex = value;\n        }\n    }\n    _resizeWithKeyboard(x, y) {\n        if (!this.#isResizerEnabledForKeyboard) {\n            return;\n        }\n        this.#resizerPointermove(this.#focusedResizerName, {\n            deltaX: x,\n            deltaY: y,\n            fromKeyboard: true\n        });\n    }\n    #stopResizing() {\n        this.#isResizerEnabledForKeyboard = false;\n        this.#setResizerTabIndex(-1);\n        this.#addResizeToUndoStack();\n    }\n    _stopResizingWithKeyboard() {\n        this.#stopResizing();\n        this.div.focus();\n    }\n    select() {\n        this.makeResizable();\n        this.div?.classList.add(\"selectedEditor\");\n        if (!this._editToolbar) {\n            this.addEditToolbar().then(()=>{\n                if (this.div?.classList.contains(\"selectedEditor\")) {\n                    this._editToolbar?.show();\n                }\n            });\n            return;\n        }\n        this._editToolbar?.show();\n        this.#altText?.toggleAltTextBadge(false);\n    }\n    unselect() {\n        this.#resizersDiv?.classList.add(\"hidden\");\n        this.div?.classList.remove(\"selectedEditor\");\n        if (this.div?.contains(document.activeElement)) {\n            this._uiManager.currentLayer.div.focus({\n                preventScroll: true\n            });\n        }\n        this._editToolbar?.hide();\n        this.#altText?.toggleAltTextBadge(true);\n    }\n    updateParams(type, value) {}\n    disableEditing() {}\n    enableEditing() {}\n    enterInEditMode() {}\n    getImageForAltText() {\n        return null;\n    }\n    get contentDiv() {\n        return this.div;\n    }\n    get isEditing() {\n        return this.#isEditing;\n    }\n    set isEditing(value) {\n        this.#isEditing = value;\n        if (!this.parent) {\n            return;\n        }\n        if (value) {\n            this.parent.setSelected(this);\n            this.parent.setActiveEditor(this);\n        } else {\n            this.parent.setActiveEditor(null);\n        }\n    }\n    setAspectRatio(width, height) {\n        this.#keepAspectRatio = true;\n        const aspectRatio = width / height;\n        const { style } = this.div;\n        style.aspectRatio = aspectRatio;\n        style.height = \"auto\";\n    }\n    static get MIN_SIZE() {\n        return 16;\n    }\n    static canCreateNewEmptyEditor() {\n        return true;\n    }\n    get telemetryInitialData() {\n        return {\n            action: \"added\"\n        };\n    }\n    get telemetryFinalData() {\n        return null;\n    }\n    _reportTelemetry(data, mustWait = false) {\n        if (mustWait) {\n            this.#telemetryTimeouts ||= new Map();\n            const { action } = data;\n            let timeout = this.#telemetryTimeouts.get(action);\n            if (timeout) {\n                clearTimeout(timeout);\n            }\n            timeout = setTimeout(()=>{\n                this._reportTelemetry(data);\n                this.#telemetryTimeouts.delete(action);\n                if (this.#telemetryTimeouts.size === 0) {\n                    this.#telemetryTimeouts = null;\n                }\n            }, AnnotationEditor._telemetryTimeout);\n            this.#telemetryTimeouts.set(action, timeout);\n            return;\n        }\n        data.type ||= this.editorType;\n        this._uiManager._eventBus.dispatch(\"reporttelemetry\", {\n            source: this,\n            details: {\n                type: \"editing\",\n                data\n            }\n        });\n    }\n    show(visible = this._isVisible) {\n        this.div.classList.toggle(\"hidden\", !visible);\n        this._isVisible = visible;\n    }\n    enable() {\n        if (this.div) {\n            this.div.tabIndex = 0;\n        }\n        this.#disabled = false;\n    }\n    disable() {\n        if (this.div) {\n            this.div.tabIndex = -1;\n        }\n        this.#disabled = true;\n    }\n    renderAnnotationElement(annotation) {\n        let content = annotation.container.querySelector(\".annotationContent\");\n        if (!content) {\n            content = document.createElement(\"div\");\n            content.classList.add(\"annotationContent\", this.editorType);\n            annotation.container.prepend(content);\n        } else if (content.nodeName === \"CANVAS\") {\n            const canvas = content;\n            content = document.createElement(\"div\");\n            content.classList.add(\"annotationContent\", this.editorType);\n            canvas.before(content);\n        }\n        return content;\n    }\n    resetAnnotationElement(annotation) {\n        const { firstChild } = annotation.container;\n        if (firstChild?.nodeName === \"DIV\" && firstChild.classList.contains(\"annotationContent\")) {\n            firstChild.remove();\n        }\n    }\n}\nclass FakeEditor extends AnnotationEditor {\n    constructor(params){\n        super(params);\n        this.annotationElementId = params.annotationElementId;\n        this.deleted = true;\n    }\n    serialize() {\n        return this.serializeDeleted();\n    }\n}\n; // ./src/shared/murmurhash3.js\nconst SEED = 0xc3d2e1f0;\nconst MASK_HIGH = 0xffff0000;\nconst MASK_LOW = 0xffff;\nclass MurmurHash3_64 {\n    constructor(seed){\n        this.h1 = seed ? seed & 0xffffffff : SEED;\n        this.h2 = seed ? seed & 0xffffffff : SEED;\n    }\n    update(input) {\n        let data, length;\n        if (typeof input === \"string\") {\n            data = new Uint8Array(input.length * 2);\n            length = 0;\n            for(let i = 0, ii = input.length; i < ii; i++){\n                const code = input.charCodeAt(i);\n                if (code <= 0xff) {\n                    data[length++] = code;\n                } else {\n                    data[length++] = code >>> 8;\n                    data[length++] = code & 0xff;\n                }\n            }\n        } else if (ArrayBuffer.isView(input)) {\n            data = input.slice();\n            length = data.byteLength;\n        } else {\n            throw new Error(\"Invalid data format, must be a string or TypedArray.\");\n        }\n        const blockCounts = length >> 2;\n        const tailLength = length - blockCounts * 4;\n        const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);\n        let k1 = 0, k2 = 0;\n        let h1 = this.h1, h2 = this.h2;\n        const C1 = 0xcc9e2d51, C2 = 0x1b873593;\n        const C1_LOW = C1 & MASK_LOW, C2_LOW = C2 & MASK_LOW;\n        for(let i = 0; i < blockCounts; i++){\n            if (i & 1) {\n                k1 = dataUint32[i];\n                k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n                k1 = k1 << 15 | k1 >>> 17;\n                k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n                h1 ^= k1;\n                h1 = h1 << 13 | h1 >>> 19;\n                h1 = h1 * 5 + 0xe6546b64;\n            } else {\n                k2 = dataUint32[i];\n                k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;\n                k2 = k2 << 15 | k2 >>> 17;\n                k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;\n                h2 ^= k2;\n                h2 = h2 << 13 | h2 >>> 19;\n                h2 = h2 * 5 + 0xe6546b64;\n            }\n        }\n        k1 = 0;\n        switch(tailLength){\n            case 3:\n                k1 ^= data[blockCounts * 4 + 2] << 16;\n            case 2:\n                k1 ^= data[blockCounts * 4 + 1] << 8;\n            case 1:\n                k1 ^= data[blockCounts * 4];\n                k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n                k1 = k1 << 15 | k1 >>> 17;\n                k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n                if (blockCounts & 1) {\n                    h1 ^= k1;\n                } else {\n                    h2 ^= k1;\n                }\n        }\n        this.h1 = h1;\n        this.h2 = h2;\n    }\n    hexdigest() {\n        let h1 = this.h1, h2 = this.h2;\n        h1 ^= h2 >>> 1;\n        h1 = h1 * 0xed558ccd & MASK_HIGH | h1 * 0x8ccd & MASK_LOW;\n        h2 = h2 * 0xff51afd7 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xafd7ed55 & MASK_HIGH) >>> 16;\n        h1 ^= h2 >>> 1;\n        h1 = h1 * 0x1a85ec53 & MASK_HIGH | h1 * 0xec53 & MASK_LOW;\n        h2 = h2 * 0xc4ceb9fe & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xb9fe1a85 & MASK_HIGH) >>> 16;\n        h1 ^= h2 >>> 1;\n        return (h1 >>> 0).toString(16).padStart(8, \"0\") + (h2 >>> 0).toString(16).padStart(8, \"0\");\n    }\n}\n; // ./src/display/annotation_storage.js\nconst SerializableEmpty = Object.freeze({\n    map: null,\n    hash: \"\",\n    transfer: undefined\n});\nclass AnnotationStorage {\n    #modified;\n    #modifiedIds;\n    #storage;\n    constructor(){\n        this.#modified = false;\n        this.#modifiedIds = null;\n        this.#storage = new Map();\n        this.onSetModified = null;\n        this.onResetModified = null;\n        this.onAnnotationEditor = null;\n    }\n    getValue(key, defaultValue) {\n        const value = this.#storage.get(key);\n        if (value === undefined) {\n            return defaultValue;\n        }\n        return Object.assign(defaultValue, value);\n    }\n    getRawValue(key) {\n        return this.#storage.get(key);\n    }\n    remove(key) {\n        this.#storage.delete(key);\n        if (this.#storage.size === 0) {\n            this.resetModified();\n        }\n        if (typeof this.onAnnotationEditor === \"function\") {\n            for (const value of this.#storage.values()){\n                if (value instanceof AnnotationEditor) {\n                    return;\n                }\n            }\n            this.onAnnotationEditor(null);\n        }\n    }\n    setValue(key, value) {\n        const obj = this.#storage.get(key);\n        let modified = false;\n        if (obj !== undefined) {\n            for (const [entry, val] of Object.entries(value)){\n                if (obj[entry] !== val) {\n                    modified = true;\n                    obj[entry] = val;\n                }\n            }\n        } else {\n            modified = true;\n            this.#storage.set(key, value);\n        }\n        if (modified) {\n            this.#setModified();\n        }\n        if (value instanceof AnnotationEditor && typeof this.onAnnotationEditor === \"function\") {\n            this.onAnnotationEditor(value.constructor._type);\n        }\n    }\n    has(key) {\n        return this.#storage.has(key);\n    }\n    getAll() {\n        return this.#storage.size > 0 ? objectFromMap(this.#storage) : null;\n    }\n    setAll(obj) {\n        for (const [key, val] of Object.entries(obj)){\n            this.setValue(key, val);\n        }\n    }\n    get size() {\n        return this.#storage.size;\n    }\n    #setModified() {\n        if (!this.#modified) {\n            this.#modified = true;\n            if (typeof this.onSetModified === \"function\") {\n                this.onSetModified();\n            }\n        }\n    }\n    resetModified() {\n        if (this.#modified) {\n            this.#modified = false;\n            if (typeof this.onResetModified === \"function\") {\n                this.onResetModified();\n            }\n        }\n    }\n    get print() {\n        return new PrintAnnotationStorage(this);\n    }\n    get serializable() {\n        if (this.#storage.size === 0) {\n            return SerializableEmpty;\n        }\n        const map = new Map(), hash = new MurmurHash3_64(), transfer = [];\n        const context = Object.create(null);\n        let hasBitmap = false;\n        for (const [key, val] of this.#storage){\n            const serialized = val instanceof AnnotationEditor ? val.serialize(false, context) : val;\n            if (serialized) {\n                map.set(key, serialized);\n                hash.update(`${key}:${JSON.stringify(serialized)}`);\n                hasBitmap ||= !!serialized.bitmap;\n            }\n        }\n        if (hasBitmap) {\n            for (const value of map.values()){\n                if (value.bitmap) {\n                    transfer.push(value.bitmap);\n                }\n            }\n        }\n        return map.size > 0 ? {\n            map,\n            hash: hash.hexdigest(),\n            transfer\n        } : SerializableEmpty;\n    }\n    get editorStats() {\n        let stats = null;\n        const typeToEditor = new Map();\n        for (const value of this.#storage.values()){\n            if (!(value instanceof AnnotationEditor)) {\n                continue;\n            }\n            const editorStats = value.telemetryFinalData;\n            if (!editorStats) {\n                continue;\n            }\n            const { type } = editorStats;\n            if (!typeToEditor.has(type)) {\n                typeToEditor.set(type, Object.getPrototypeOf(value).constructor);\n            }\n            stats ||= Object.create(null);\n            const map = stats[type] ||= new Map();\n            for (const [key, val] of Object.entries(editorStats)){\n                if (key === \"type\") {\n                    continue;\n                }\n                let counters = map.get(key);\n                if (!counters) {\n                    counters = new Map();\n                    map.set(key, counters);\n                }\n                const count = counters.get(val) ?? 0;\n                counters.set(val, count + 1);\n            }\n        }\n        for (const [type, editor] of typeToEditor){\n            stats[type] = editor.computeTelemetryFinalData(stats[type]);\n        }\n        return stats;\n    }\n    resetModifiedIds() {\n        this.#modifiedIds = null;\n    }\n    get modifiedIds() {\n        if (this.#modifiedIds) {\n            return this.#modifiedIds;\n        }\n        const ids = [];\n        for (const value of this.#storage.values()){\n            if (!(value instanceof AnnotationEditor) || !value.annotationElementId || !value.serialize()) {\n                continue;\n            }\n            ids.push(value.annotationElementId);\n        }\n        return this.#modifiedIds = {\n            ids: new Set(ids),\n            hash: ids.join(\",\")\n        };\n    }\n}\nclass PrintAnnotationStorage extends AnnotationStorage {\n    #serializable;\n    constructor(parent){\n        super();\n        const { map, hash, transfer } = parent.serializable;\n        const clone = structuredClone(map, transfer ? {\n            transfer\n        } : null);\n        this.#serializable = {\n            map: clone,\n            hash,\n            transfer\n        };\n    }\n    get print() {\n        unreachable(\"Should not call PrintAnnotationStorage.print\");\n    }\n    get serializable() {\n        return this.#serializable;\n    }\n    get modifiedIds() {\n        return shadow(this, \"modifiedIds\", {\n            ids: new Set(),\n            hash: \"\"\n        });\n    }\n}\n; // ./src/display/font_loader.js\nclass FontLoader {\n    #systemFonts;\n    constructor({ ownerDocument = globalThis.document, styleElement = null }){\n        this.#systemFonts = new Set();\n        this._document = ownerDocument;\n        this.nativeFontFaces = new Set();\n        this.styleElement = null;\n        this.loadingRequests = [];\n        this.loadTestFontId = 0;\n    }\n    addNativeFontFace(nativeFontFace) {\n        this.nativeFontFaces.add(nativeFontFace);\n        this._document.fonts.add(nativeFontFace);\n    }\n    removeNativeFontFace(nativeFontFace) {\n        this.nativeFontFaces.delete(nativeFontFace);\n        this._document.fonts.delete(nativeFontFace);\n    }\n    insertRule(rule) {\n        if (!this.styleElement) {\n            this.styleElement = this._document.createElement(\"style\");\n            this._document.documentElement.getElementsByTagName(\"head\")[0].append(this.styleElement);\n        }\n        const styleSheet = this.styleElement.sheet;\n        styleSheet.insertRule(rule, styleSheet.cssRules.length);\n    }\n    clear() {\n        for (const nativeFontFace of this.nativeFontFaces){\n            this._document.fonts.delete(nativeFontFace);\n        }\n        this.nativeFontFaces.clear();\n        this.#systemFonts.clear();\n        if (this.styleElement) {\n            this.styleElement.remove();\n            this.styleElement = null;\n        }\n    }\n    async loadSystemFont({ systemFontInfo: info, _inspectFont }) {\n        if (!info || this.#systemFonts.has(info.loadedName)) {\n            return;\n        }\n        assert(!this.disableFontFace, \"loadSystemFont shouldn't be called when `disableFontFace` is set.\");\n        if (this.isFontLoadingAPISupported) {\n            const { loadedName, src, style } = info;\n            const fontFace = new FontFace(loadedName, src, style);\n            this.addNativeFontFace(fontFace);\n            try {\n                await fontFace.load();\n                this.#systemFonts.add(loadedName);\n                _inspectFont?.(info);\n            } catch  {\n                warn(`Cannot load system font: ${info.baseFontName}, installing it could help to improve PDF rendering.`);\n                this.removeNativeFontFace(fontFace);\n            }\n            return;\n        }\n        unreachable(\"Not implemented: loadSystemFont without the Font Loading API.\");\n    }\n    async bind(font) {\n        if (font.attached || font.missingFile && !font.systemFontInfo) {\n            return;\n        }\n        font.attached = true;\n        if (font.systemFontInfo) {\n            await this.loadSystemFont(font);\n            return;\n        }\n        if (this.isFontLoadingAPISupported) {\n            const nativeFontFace = font.createNativeFontFace();\n            if (nativeFontFace) {\n                this.addNativeFontFace(nativeFontFace);\n                try {\n                    await nativeFontFace.loaded;\n                } catch (ex) {\n                    warn(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);\n                    font.disableFontFace = true;\n                    throw ex;\n                }\n            }\n            return;\n        }\n        const rule = font.createFontFaceRule();\n        if (rule) {\n            this.insertRule(rule);\n            if (this.isSyncFontLoadingSupported) {\n                return;\n            }\n            await new Promise((resolve)=>{\n                const request = this._queueLoadingCallback(resolve);\n                this._prepareFontLoadEvent(font, request);\n            });\n        }\n    }\n    get isFontLoadingAPISupported() {\n        const hasFonts = !!this._document?.fonts;\n        return shadow(this, \"isFontLoadingAPISupported\", hasFonts);\n    }\n    get isSyncFontLoadingSupported() {\n        let supported = false;\n        if (isNodeJS) {\n            supported = true;\n        } else if (typeof navigator !== \"undefined\" && typeof navigator?.userAgent === \"string\" && /Mozilla\\/5.0.*?rv:\\d+.*? Gecko/.test(navigator.userAgent)) {\n            supported = true;\n        }\n        return shadow(this, \"isSyncFontLoadingSupported\", supported);\n    }\n    _queueLoadingCallback(callback) {\n        function completeRequest() {\n            assert(!request.done, \"completeRequest() cannot be called twice.\");\n            request.done = true;\n            while(loadingRequests.length > 0 && loadingRequests[0].done){\n                const otherRequest = loadingRequests.shift();\n                setTimeout(otherRequest.callback, 0);\n            }\n        }\n        const { loadingRequests } = this;\n        const request = {\n            done: false,\n            complete: completeRequest,\n            callback\n        };\n        loadingRequests.push(request);\n        return request;\n    }\n    get _loadTestFont() {\n        const testFont = atob(\"T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA\" + \"FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA\" + \"ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA\" + \"AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1\" + \"AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD\" + \"6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM\" + \"AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D\" + \"IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA\" + \"AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA\" + \"AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB\" + \"AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY\" + \"AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA\" + \"AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA\" + \"AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC\" + \"AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3\" + \"Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj\" + \"FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==\");\n        return shadow(this, \"_loadTestFont\", testFont);\n    }\n    _prepareFontLoadEvent(font, request) {\n        function int32(data, offset) {\n            return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;\n        }\n        function spliceString(s, offset, remove, insert) {\n            const chunk1 = s.substring(0, offset);\n            const chunk2 = s.substring(offset + remove);\n            return chunk1 + insert + chunk2;\n        }\n        let i, ii;\n        const canvas = this._document.createElement(\"canvas\");\n        canvas.width = 1;\n        canvas.height = 1;\n        const ctx = canvas.getContext(\"2d\");\n        let called = 0;\n        function isFontReady(name, callback) {\n            if (++called > 30) {\n                warn(\"Load test font never loaded.\");\n                callback();\n                return;\n            }\n            ctx.font = \"30px \" + name;\n            ctx.fillText(\".\", 0, 20);\n            const imageData = ctx.getImageData(0, 0, 1, 1);\n            if (imageData.data[3] > 0) {\n                callback();\n                return;\n            }\n            setTimeout(isFontReady.bind(null, name, callback));\n        }\n        const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;\n        let data = this._loadTestFont;\n        const COMMENT_OFFSET = 976;\n        data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);\n        const CFF_CHECKSUM_OFFSET = 16;\n        const XXXX_VALUE = 0x58585858;\n        let checksum = int32(data, CFF_CHECKSUM_OFFSET);\n        for(i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4){\n            checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;\n        }\n        if (i < loadTestFontId.length) {\n            checksum = checksum - XXXX_VALUE + int32(loadTestFontId + \"XXX\", i) | 0;\n        }\n        data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, string32(checksum));\n        const url = `url(data:font/opentype;base64,${btoa(data)});`;\n        const rule = `@font-face {font-family:\"${loadTestFontId}\";src:${url}}`;\n        this.insertRule(rule);\n        const div = this._document.createElement(\"div\");\n        div.style.visibility = \"hidden\";\n        div.style.width = div.style.height = \"10px\";\n        div.style.position = \"absolute\";\n        div.style.top = div.style.left = \"0px\";\n        for (const name of [\n            font.loadedName,\n            loadTestFontId\n        ]){\n            const span = this._document.createElement(\"span\");\n            span.textContent = \"Hi\";\n            span.style.fontFamily = name;\n            div.append(span);\n        }\n        this._document.body.append(div);\n        isFontReady(loadTestFontId, ()=>{\n            div.remove();\n            request.complete();\n        });\n    }\n}\nclass FontFaceObject {\n    constructor(translatedData, { disableFontFace = false, inspectFont = null }){\n        this.compiledGlyphs = Object.create(null);\n        for(const i in translatedData){\n            this[i] = translatedData[i];\n        }\n        this.disableFontFace = disableFontFace === true;\n        this._inspectFont = inspectFont;\n    }\n    createNativeFontFace() {\n        if (!this.data || this.disableFontFace) {\n            return null;\n        }\n        let nativeFontFace;\n        if (!this.cssFontInfo) {\n            nativeFontFace = new FontFace(this.loadedName, this.data, {});\n        } else {\n            const css = {\n                weight: this.cssFontInfo.fontWeight\n            };\n            if (this.cssFontInfo.italicAngle) {\n                css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;\n            }\n            nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);\n        }\n        this._inspectFont?.(this);\n        return nativeFontFace;\n    }\n    createFontFaceRule() {\n        if (!this.data || this.disableFontFace) {\n            return null;\n        }\n        const url = `url(data:${this.mimetype};base64,${toBase64Util(this.data)});`;\n        let rule;\n        if (!this.cssFontInfo) {\n            rule = `@font-face {font-family:\"${this.loadedName}\";src:${url}}`;\n        } else {\n            let css = `font-weight: ${this.cssFontInfo.fontWeight};`;\n            if (this.cssFontInfo.italicAngle) {\n                css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;\n            }\n            rule = `@font-face {font-family:\"${this.cssFontInfo.fontFamily}\";${css}src:${url}}`;\n        }\n        this._inspectFont?.(this, url);\n        return rule;\n    }\n    getPathGenerator(objs, character) {\n        if (this.compiledGlyphs[character] !== undefined) {\n            return this.compiledGlyphs[character];\n        }\n        let cmds;\n        try {\n            cmds = objs.get(this.loadedName + \"_path_\" + character);\n        } catch (ex) {\n            warn(`getPathGenerator - ignoring character: \"${ex}\".`);\n        }\n        if (!Array.isArray(cmds) || cmds.length === 0) {\n            return this.compiledGlyphs[character] = function(c, size) {};\n        }\n        const commands = [];\n        for(let i = 0, ii = cmds.length; i < ii;){\n            switch(cmds[i++]){\n                case FontRenderOps.BEZIER_CURVE_TO:\n                    {\n                        const [a, b, c, d, e, f] = cmds.slice(i, i + 6);\n                        commands.push((ctx)=>ctx.bezierCurveTo(a, b, c, d, e, f));\n                        i += 6;\n                    }\n                    break;\n                case FontRenderOps.MOVE_TO:\n                    {\n                        const [a, b] = cmds.slice(i, i + 2);\n                        commands.push((ctx)=>ctx.moveTo(a, b));\n                        i += 2;\n                    }\n                    break;\n                case FontRenderOps.LINE_TO:\n                    {\n                        const [a, b] = cmds.slice(i, i + 2);\n                        commands.push((ctx)=>ctx.lineTo(a, b));\n                        i += 2;\n                    }\n                    break;\n                case FontRenderOps.QUADRATIC_CURVE_TO:\n                    {\n                        const [a, b, c, d] = cmds.slice(i, i + 4);\n                        commands.push((ctx)=>ctx.quadraticCurveTo(a, b, c, d));\n                        i += 4;\n                    }\n                    break;\n                case FontRenderOps.RESTORE:\n                    commands.push((ctx)=>ctx.restore());\n                    break;\n                case FontRenderOps.SAVE:\n                    commands.push((ctx)=>ctx.save());\n                    break;\n                case FontRenderOps.SCALE:\n                    assert(commands.length === 2, \"Scale command is only valid at the third position.\");\n                    break;\n                case FontRenderOps.TRANSFORM:\n                    {\n                        const [a, b, c, d, e, f] = cmds.slice(i, i + 6);\n                        commands.push((ctx)=>ctx.transform(a, b, c, d, e, f));\n                        i += 6;\n                    }\n                    break;\n                case FontRenderOps.TRANSLATE:\n                    {\n                        const [a, b] = cmds.slice(i, i + 2);\n                        commands.push((ctx)=>ctx.translate(a, b));\n                        i += 2;\n                    }\n                    break;\n            }\n        }\n        commands.push((ctx)=>ctx.closePath());\n        return this.compiledGlyphs[character] = function glyphDrawer(ctx, size) {\n            commands[0](ctx);\n            commands[1](ctx);\n            ctx.scale(size, -size);\n            for(let i = 2, ii = commands.length; i < ii; i++){\n                commands[i](ctx);\n            }\n        };\n    }\n}\n; // ./src/display/canvas_factory.js\nclass BaseCanvasFactory {\n    #enableHWA;\n    constructor({ enableHWA = false }){\n        this.#enableHWA = false;\n        this.#enableHWA = enableHWA;\n    }\n    create(width, height) {\n        if (width <= 0 || height <= 0) {\n            throw new Error(\"Invalid canvas size\");\n        }\n        const canvas = this._createCanvas(width, height);\n        return {\n            canvas,\n            context: canvas.getContext(\"2d\", {\n                willReadFrequently: !this.#enableHWA\n            })\n        };\n    }\n    reset(canvasAndContext, width, height) {\n        if (!canvasAndContext.canvas) {\n            throw new Error(\"Canvas is not specified\");\n        }\n        if (width <= 0 || height <= 0) {\n            throw new Error(\"Invalid canvas size\");\n        }\n        canvasAndContext.canvas.width = width;\n        canvasAndContext.canvas.height = height;\n    }\n    destroy(canvasAndContext) {\n        if (!canvasAndContext.canvas) {\n            throw new Error(\"Canvas is not specified\");\n        }\n        canvasAndContext.canvas.width = 0;\n        canvasAndContext.canvas.height = 0;\n        canvasAndContext.canvas = null;\n        canvasAndContext.context = null;\n    }\n    _createCanvas(width, height) {\n        unreachable(\"Abstract method `_createCanvas` called.\");\n    }\n}\nclass DOMCanvasFactory extends BaseCanvasFactory {\n    constructor({ ownerDocument = globalThis.document, enableHWA = false }){\n        super({\n            enableHWA\n        });\n        this._document = ownerDocument;\n    }\n    _createCanvas(width, height) {\n        const canvas = this._document.createElement(\"canvas\");\n        canvas.width = width;\n        canvas.height = height;\n        return canvas;\n    }\n}\n; // ./src/display/cmap_reader_factory.js\nclass BaseCMapReaderFactory {\n    constructor({ baseUrl = null, isCompressed = true }){\n        this.baseUrl = baseUrl;\n        this.isCompressed = isCompressed;\n    }\n    async fetch({ name }) {\n        if (!this.baseUrl) {\n            throw new Error(\"Ensure that the `cMapUrl` and `cMapPacked` API parameters are provided.\");\n        }\n        if (!name) {\n            throw new Error(\"CMap name must be specified.\");\n        }\n        const url = this.baseUrl + name + (this.isCompressed ? \".bcmap\" : \"\");\n        return this._fetch(url).then((cMapData)=>({\n                cMapData,\n                isCompressed: this.isCompressed\n            })).catch((reason)=>{\n            throw new Error(`Unable to load ${this.isCompressed ? \"binary \" : \"\"}CMap at: ${url}`);\n        });\n    }\n    async _fetch(url) {\n        unreachable(\"Abstract method `_fetch` called.\");\n    }\n}\nclass DOMCMapReaderFactory extends BaseCMapReaderFactory {\n    async _fetch(url) {\n        const data = await fetchData(url, this.isCompressed ? \"arraybuffer\" : \"text\");\n        return data instanceof ArrayBuffer ? new Uint8Array(data) : stringToBytes(data);\n    }\n}\n; // ./src/display/filter_factory.js\nclass BaseFilterFactory {\n    addFilter(maps) {\n        return \"none\";\n    }\n    addHCMFilter(fgColor, bgColor) {\n        return \"none\";\n    }\n    addAlphaFilter(map) {\n        return \"none\";\n    }\n    addLuminosityFilter(map) {\n        return \"none\";\n    }\n    addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {\n        return \"none\";\n    }\n    destroy(keepHCM = false) {}\n}\nclass DOMFilterFactory extends BaseFilterFactory {\n    #baseUrl;\n    #_cache;\n    #_defs;\n    #docId;\n    #document;\n    #_hcmCache;\n    #id;\n    constructor({ docId, ownerDocument = globalThis.document }){\n        super();\n        this.#id = 0;\n        this.#docId = docId;\n        this.#document = ownerDocument;\n    }\n    get #cache() {\n        return this.#_cache ||= new Map();\n    }\n    get #hcmCache() {\n        return this.#_hcmCache ||= new Map();\n    }\n    get #defs() {\n        if (!this.#_defs) {\n            const div = this.#document.createElement(\"div\");\n            const { style } = div;\n            style.visibility = \"hidden\";\n            style.contain = \"strict\";\n            style.width = style.height = 0;\n            style.position = \"absolute\";\n            style.top = style.left = 0;\n            style.zIndex = -1;\n            const svg = this.#document.createElementNS(SVG_NS, \"svg\");\n            svg.setAttribute(\"width\", 0);\n            svg.setAttribute(\"height\", 0);\n            this.#_defs = this.#document.createElementNS(SVG_NS, \"defs\");\n            div.append(svg);\n            svg.append(this.#_defs);\n            this.#document.body.append(div);\n        }\n        return this.#_defs;\n    }\n    #createTables(maps) {\n        if (maps.length === 1) {\n            const mapR = maps[0];\n            const buffer = new Array(256);\n            for(let i = 0; i < 256; i++){\n                buffer[i] = mapR[i] / 255;\n            }\n            const table = buffer.join(\",\");\n            return [\n                table,\n                table,\n                table\n            ];\n        }\n        const [mapR, mapG, mapB] = maps;\n        const bufferR = new Array(256);\n        const bufferG = new Array(256);\n        const bufferB = new Array(256);\n        for(let i = 0; i < 256; i++){\n            bufferR[i] = mapR[i] / 255;\n            bufferG[i] = mapG[i] / 255;\n            bufferB[i] = mapB[i] / 255;\n        }\n        return [\n            bufferR.join(\",\"),\n            bufferG.join(\",\"),\n            bufferB.join(\",\")\n        ];\n    }\n    #createUrl(id) {\n        if (this.#baseUrl === undefined) {\n            this.#baseUrl = \"\";\n            const url = this.#document.URL;\n            if (url !== this.#document.baseURI) {\n                if (isDataScheme(url)) {\n                    warn('#createUrl: ignore \"data:\"-URL for performance reasons.');\n                } else {\n                    this.#baseUrl = url.split(\"#\", 1)[0];\n                }\n            }\n        }\n        return `url(${this.#baseUrl}#${id})`;\n    }\n    addFilter(maps) {\n        if (!maps) {\n            return \"none\";\n        }\n        let value = this.#cache.get(maps);\n        if (value) {\n            return value;\n        }\n        const [tableR, tableG, tableB] = this.#createTables(maps);\n        const key = maps.length === 1 ? tableR : `${tableR}${tableG}${tableB}`;\n        value = this.#cache.get(key);\n        if (value) {\n            this.#cache.set(maps, value);\n            return value;\n        }\n        const id = `g_${this.#docId}_transfer_map_${this.#id++}`;\n        const url = this.#createUrl(id);\n        this.#cache.set(maps, url);\n        this.#cache.set(key, url);\n        const filter = this.#createFilter(id);\n        this.#addTransferMapConversion(tableR, tableG, tableB, filter);\n        return url;\n    }\n    addHCMFilter(fgColor, bgColor) {\n        const key = `${fgColor}-${bgColor}`;\n        const filterName = \"base\";\n        let info = this.#hcmCache.get(filterName);\n        if (info?.key === key) {\n            return info.url;\n        }\n        if (info) {\n            info.filter?.remove();\n            info.key = key;\n            info.url = \"none\";\n            info.filter = null;\n        } else {\n            info = {\n                key,\n                url: \"none\",\n                filter: null\n            };\n            this.#hcmCache.set(filterName, info);\n        }\n        if (!fgColor || !bgColor) {\n            return info.url;\n        }\n        const fgRGB = this.#getRGB(fgColor);\n        fgColor = Util.makeHexColor(...fgRGB);\n        const bgRGB = this.#getRGB(bgColor);\n        bgColor = Util.makeHexColor(...bgRGB);\n        this.#defs.style.color = \"\";\n        if (fgColor === \"#000000\" && bgColor === \"#ffffff\" || fgColor === bgColor) {\n            return info.url;\n        }\n        const map = new Array(256);\n        for(let i = 0; i <= 255; i++){\n            const x = i / 255;\n            map[i] = x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;\n        }\n        const table = map.join(\",\");\n        const id = `g_${this.#docId}_hcm_filter`;\n        const filter = info.filter = this.#createFilter(id);\n        this.#addTransferMapConversion(table, table, table, filter);\n        this.#addGrayConversion(filter);\n        const getSteps = (c, n)=>{\n            const start = fgRGB[c] / 255;\n            const end = bgRGB[c] / 255;\n            const arr = new Array(n + 1);\n            for(let i = 0; i <= n; i++){\n                arr[i] = start + i / n * (end - start);\n            }\n            return arr.join(\",\");\n        };\n        this.#addTransferMapConversion(getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), filter);\n        info.url = this.#createUrl(id);\n        return info.url;\n    }\n    addAlphaFilter(map) {\n        let value = this.#cache.get(map);\n        if (value) {\n            return value;\n        }\n        const [tableA] = this.#createTables([\n            map\n        ]);\n        const key = `alpha_${tableA}`;\n        value = this.#cache.get(key);\n        if (value) {\n            this.#cache.set(map, value);\n            return value;\n        }\n        const id = `g_${this.#docId}_alpha_map_${this.#id++}`;\n        const url = this.#createUrl(id);\n        this.#cache.set(map, url);\n        this.#cache.set(key, url);\n        const filter = this.#createFilter(id);\n        this.#addTransferMapAlphaConversion(tableA, filter);\n        return url;\n    }\n    addLuminosityFilter(map) {\n        let value = this.#cache.get(map || \"luminosity\");\n        if (value) {\n            return value;\n        }\n        let tableA, key;\n        if (map) {\n            [tableA] = this.#createTables([\n                map\n            ]);\n            key = `luminosity_${tableA}`;\n        } else {\n            key = \"luminosity\";\n        }\n        value = this.#cache.get(key);\n        if (value) {\n            this.#cache.set(map, value);\n            return value;\n        }\n        const id = `g_${this.#docId}_luminosity_map_${this.#id++}`;\n        const url = this.#createUrl(id);\n        this.#cache.set(map, url);\n        this.#cache.set(key, url);\n        const filter = this.#createFilter(id);\n        this.#addLuminosityConversion(filter);\n        if (map) {\n            this.#addTransferMapAlphaConversion(tableA, filter);\n        }\n        return url;\n    }\n    addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {\n        const key = `${fgColor}-${bgColor}-${newFgColor}-${newBgColor}`;\n        let info = this.#hcmCache.get(filterName);\n        if (info?.key === key) {\n            return info.url;\n        }\n        if (info) {\n            info.filter?.remove();\n            info.key = key;\n            info.url = \"none\";\n            info.filter = null;\n        } else {\n            info = {\n                key,\n                url: \"none\",\n                filter: null\n            };\n            this.#hcmCache.set(filterName, info);\n        }\n        if (!fgColor || !bgColor) {\n            return info.url;\n        }\n        const [fgRGB, bgRGB] = [\n            fgColor,\n            bgColor\n        ].map(this.#getRGB.bind(this));\n        let fgGray = Math.round(0.2126 * fgRGB[0] + 0.7152 * fgRGB[1] + 0.0722 * fgRGB[2]);\n        let bgGray = Math.round(0.2126 * bgRGB[0] + 0.7152 * bgRGB[1] + 0.0722 * bgRGB[2]);\n        let [newFgRGB, newBgRGB] = [\n            newFgColor,\n            newBgColor\n        ].map(this.#getRGB.bind(this));\n        if (bgGray < fgGray) {\n            [fgGray, bgGray, newFgRGB, newBgRGB] = [\n                bgGray,\n                fgGray,\n                newBgRGB,\n                newFgRGB\n            ];\n        }\n        this.#defs.style.color = \"\";\n        const getSteps = (fg, bg, n)=>{\n            const arr = new Array(256);\n            const step = (bgGray - fgGray) / n;\n            const newStart = fg / 255;\n            const newStep = (bg - fg) / (255 * n);\n            let prev = 0;\n            for(let i = 0; i <= n; i++){\n                const k = Math.round(fgGray + i * step);\n                const value = newStart + i * newStep;\n                for(let j = prev; j <= k; j++){\n                    arr[j] = value;\n                }\n                prev = k + 1;\n            }\n            for(let i = prev; i < 256; i++){\n                arr[i] = arr[prev - 1];\n            }\n            return arr.join(\",\");\n        };\n        const id = `g_${this.#docId}_hcm_${filterName}_filter`;\n        const filter = info.filter = this.#createFilter(id);\n        this.#addGrayConversion(filter);\n        this.#addTransferMapConversion(getSteps(newFgRGB[0], newBgRGB[0], 5), getSteps(newFgRGB[1], newBgRGB[1], 5), getSteps(newFgRGB[2], newBgRGB[2], 5), filter);\n        info.url = this.#createUrl(id);\n        return info.url;\n    }\n    destroy(keepHCM = false) {\n        if (keepHCM && this.#_hcmCache?.size) {\n            return;\n        }\n        this.#_defs?.parentNode.parentNode.remove();\n        this.#_defs = null;\n        this.#_cache?.clear();\n        this.#_cache = null;\n        this.#_hcmCache?.clear();\n        this.#_hcmCache = null;\n        this.#id = 0;\n    }\n    #addLuminosityConversion(filter) {\n        const feColorMatrix = this.#document.createElementNS(SVG_NS, \"feColorMatrix\");\n        feColorMatrix.setAttribute(\"type\", \"matrix\");\n        feColorMatrix.setAttribute(\"values\", \"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0\");\n        filter.append(feColorMatrix);\n    }\n    #addGrayConversion(filter) {\n        const feColorMatrix = this.#document.createElementNS(SVG_NS, \"feColorMatrix\");\n        feColorMatrix.setAttribute(\"type\", \"matrix\");\n        feColorMatrix.setAttribute(\"values\", \"0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0\");\n        filter.append(feColorMatrix);\n    }\n    #createFilter(id) {\n        const filter = this.#document.createElementNS(SVG_NS, \"filter\");\n        filter.setAttribute(\"color-interpolation-filters\", \"sRGB\");\n        filter.setAttribute(\"id\", id);\n        this.#defs.append(filter);\n        return filter;\n    }\n    #appendFeFunc(feComponentTransfer, func, table) {\n        const feFunc = this.#document.createElementNS(SVG_NS, func);\n        feFunc.setAttribute(\"type\", \"discrete\");\n        feFunc.setAttribute(\"tableValues\", table);\n        feComponentTransfer.append(feFunc);\n    }\n    #addTransferMapConversion(rTable, gTable, bTable, filter) {\n        const feComponentTransfer = this.#document.createElementNS(SVG_NS, \"feComponentTransfer\");\n        filter.append(feComponentTransfer);\n        this.#appendFeFunc(feComponentTransfer, \"feFuncR\", rTable);\n        this.#appendFeFunc(feComponentTransfer, \"feFuncG\", gTable);\n        this.#appendFeFunc(feComponentTransfer, \"feFuncB\", bTable);\n    }\n    #addTransferMapAlphaConversion(aTable, filter) {\n        const feComponentTransfer = this.#document.createElementNS(SVG_NS, \"feComponentTransfer\");\n        filter.append(feComponentTransfer);\n        this.#appendFeFunc(feComponentTransfer, \"feFuncA\", aTable);\n    }\n    #getRGB(color) {\n        this.#defs.style.color = color;\n        return getRGB(getComputedStyle(this.#defs).getPropertyValue(\"color\"));\n    }\n}\n; // ./src/display/standard_fontdata_factory.js\nclass BaseStandardFontDataFactory {\n    constructor({ baseUrl = null }){\n        this.baseUrl = baseUrl;\n    }\n    async fetch({ filename }) {\n        if (!this.baseUrl) {\n            throw new Error(\"Ensure that the `standardFontDataUrl` API parameter is provided.\");\n        }\n        if (!filename) {\n            throw new Error(\"Font filename must be specified.\");\n        }\n        const url = `${this.baseUrl}${filename}`;\n        return this._fetch(url).catch((reason)=>{\n            throw new Error(`Unable to load font data at: ${url}`);\n        });\n    }\n    async _fetch(url) {\n        unreachable(\"Abstract method `_fetch` called.\");\n    }\n}\nclass DOMStandardFontDataFactory extends BaseStandardFontDataFactory {\n    async _fetch(url) {\n        const data = await fetchData(url, \"arraybuffer\");\n        return new Uint8Array(data);\n    }\n}\n; // ./src/display/node_utils.js\nasync function node_utils_fetchData(url) {\n    const fs = process.getBuiltinModule(\"fs\");\n    const data = await fs.promises.readFile(url);\n    return new Uint8Array(data);\n}\nclass NodeFilterFactory extends BaseFilterFactory {\n}\nclass NodeCanvasFactory extends BaseCanvasFactory {\n    _createCanvas(width, height) {\n        const require = process.getBuiltinModule(\"module\").createRequire(\"file:///C:/Users/18817/Desktop/code/text_error_correction/frontend/node_modules/pdfjs-dist/build/pdf.mjs\");\n        const canvas = require(\"@napi-rs/canvas\");\n        return canvas.createCanvas(width, height);\n    }\n}\nclass NodeCMapReaderFactory extends BaseCMapReaderFactory {\n    async _fetch(url) {\n        return node_utils_fetchData(url);\n    }\n}\nclass NodeStandardFontDataFactory extends BaseStandardFontDataFactory {\n    async _fetch(url) {\n        return node_utils_fetchData(url);\n    }\n}\n; // ./src/display/pattern_helper.js\nconst PathType = {\n    FILL: \"Fill\",\n    STROKE: \"Stroke\",\n    SHADING: \"Shading\"\n};\nfunction applyBoundingBox(ctx, bbox) {\n    if (!bbox) {\n        return;\n    }\n    const width = bbox[2] - bbox[0];\n    const height = bbox[3] - bbox[1];\n    const region = new Path2D();\n    region.rect(bbox[0], bbox[1], width, height);\n    ctx.clip(region);\n}\nclass BaseShadingPattern {\n    getPattern() {\n        unreachable(\"Abstract method `getPattern` called.\");\n    }\n}\nclass RadialAxialShadingPattern extends BaseShadingPattern {\n    constructor(IR){\n        super();\n        this._type = IR[1];\n        this._bbox = IR[2];\n        this._colorStops = IR[3];\n        this._p0 = IR[4];\n        this._p1 = IR[5];\n        this._r0 = IR[6];\n        this._r1 = IR[7];\n        this.matrix = null;\n    }\n    _createGradient(ctx) {\n        let grad;\n        if (this._type === \"axial\") {\n            grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);\n        } else if (this._type === \"radial\") {\n            grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);\n        }\n        for (const colorStop of this._colorStops){\n            grad.addColorStop(colorStop[0], colorStop[1]);\n        }\n        return grad;\n    }\n    getPattern(ctx, owner, inverse, pathType) {\n        let pattern;\n        if (pathType === PathType.STROKE || pathType === PathType.FILL) {\n            const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, getCurrentTransform(ctx)) || [\n                0,\n                0,\n                0,\n                0\n            ];\n            const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;\n            const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;\n            const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", width, height);\n            const tmpCtx = tmpCanvas.context;\n            tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n            tmpCtx.beginPath();\n            tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n            tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);\n            inverse = Util.transform(inverse, [\n                1,\n                0,\n                0,\n                1,\n                ownerBBox[0],\n                ownerBBox[1]\n            ]);\n            tmpCtx.transform(...owner.baseTransform);\n            if (this.matrix) {\n                tmpCtx.transform(...this.matrix);\n            }\n            applyBoundingBox(tmpCtx, this._bbox);\n            tmpCtx.fillStyle = this._createGradient(tmpCtx);\n            tmpCtx.fill();\n            pattern = ctx.createPattern(tmpCanvas.canvas, \"no-repeat\");\n            const domMatrix = new DOMMatrix(inverse);\n            pattern.setTransform(domMatrix);\n        } else {\n            applyBoundingBox(ctx, this._bbox);\n            pattern = this._createGradient(ctx);\n        }\n        return pattern;\n    }\n}\nfunction drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {\n    const coords = context.coords, colors = context.colors;\n    const bytes = data.data, rowSize = data.width * 4;\n    let tmp;\n    if (coords[p1 + 1] > coords[p2 + 1]) {\n        tmp = p1;\n        p1 = p2;\n        p2 = tmp;\n        tmp = c1;\n        c1 = c2;\n        c2 = tmp;\n    }\n    if (coords[p2 + 1] > coords[p3 + 1]) {\n        tmp = p2;\n        p2 = p3;\n        p3 = tmp;\n        tmp = c2;\n        c2 = c3;\n        c3 = tmp;\n    }\n    if (coords[p1 + 1] > coords[p2 + 1]) {\n        tmp = p1;\n        p1 = p2;\n        p2 = tmp;\n        tmp = c1;\n        c1 = c2;\n        c2 = tmp;\n    }\n    const x1 = (coords[p1] + context.offsetX) * context.scaleX;\n    const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;\n    const x2 = (coords[p2] + context.offsetX) * context.scaleX;\n    const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;\n    const x3 = (coords[p3] + context.offsetX) * context.scaleX;\n    const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;\n    if (y1 >= y3) {\n        return;\n    }\n    const c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2];\n    const c2r = colors[c2], c2g = colors[c2 + 1], c2b = colors[c2 + 2];\n    const c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2];\n    const minY = Math.round(y1), maxY = Math.round(y3);\n    let xa, car, cag, cab;\n    let xb, cbr, cbg, cbb;\n    for(let y = minY; y <= maxY; y++){\n        if (y < y2) {\n            const k = y < y1 ? 0 : (y1 - y) / (y1 - y2);\n            xa = x1 - (x1 - x2) * k;\n            car = c1r - (c1r - c2r) * k;\n            cag = c1g - (c1g - c2g) * k;\n            cab = c1b - (c1b - c2b) * k;\n        } else {\n            let k;\n            if (y > y3) {\n                k = 1;\n            } else if (y2 === y3) {\n                k = 0;\n            } else {\n                k = (y2 - y) / (y2 - y3);\n            }\n            xa = x2 - (x2 - x3) * k;\n            car = c2r - (c2r - c3r) * k;\n            cag = c2g - (c2g - c3g) * k;\n            cab = c2b - (c2b - c3b) * k;\n        }\n        let k;\n        if (y < y1) {\n            k = 0;\n        } else if (y > y3) {\n            k = 1;\n        } else {\n            k = (y1 - y) / (y1 - y3);\n        }\n        xb = x1 - (x1 - x3) * k;\n        cbr = c1r - (c1r - c3r) * k;\n        cbg = c1g - (c1g - c3g) * k;\n        cbb = c1b - (c1b - c3b) * k;\n        const x1_ = Math.round(Math.min(xa, xb));\n        const x2_ = Math.round(Math.max(xa, xb));\n        let j = rowSize * y + x1_ * 4;\n        for(let x = x1_; x <= x2_; x++){\n            k = (xa - x) / (xa - xb);\n            if (k < 0) {\n                k = 0;\n            } else if (k > 1) {\n                k = 1;\n            }\n            bytes[j++] = car - (car - cbr) * k | 0;\n            bytes[j++] = cag - (cag - cbg) * k | 0;\n            bytes[j++] = cab - (cab - cbb) * k | 0;\n            bytes[j++] = 255;\n        }\n    }\n}\nfunction drawFigure(data, figure, context) {\n    const ps = figure.coords;\n    const cs = figure.colors;\n    let i, ii;\n    switch(figure.type){\n        case \"lattice\":\n            const verticesPerRow = figure.verticesPerRow;\n            const rows = Math.floor(ps.length / verticesPerRow) - 1;\n            const cols = verticesPerRow - 1;\n            for(i = 0; i < rows; i++){\n                let q = i * verticesPerRow;\n                for(let j = 0; j < cols; j++, q++){\n                    drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);\n                    drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);\n                }\n            }\n            break;\n        case \"triangles\":\n            for(i = 0, ii = ps.length; i < ii; i += 3){\n                drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);\n            }\n            break;\n        default:\n            throw new Error(\"illegal figure\");\n    }\n}\nclass MeshShadingPattern extends BaseShadingPattern {\n    constructor(IR){\n        super();\n        this._coords = IR[2];\n        this._colors = IR[3];\n        this._figures = IR[4];\n        this._bounds = IR[5];\n        this._bbox = IR[7];\n        this._background = IR[8];\n        this.matrix = null;\n    }\n    _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {\n        const EXPECTED_SCALE = 1.1;\n        const MAX_PATTERN_SIZE = 3000;\n        const BORDER_SIZE = 2;\n        const offsetX = Math.floor(this._bounds[0]);\n        const offsetY = Math.floor(this._bounds[1]);\n        const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;\n        const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;\n        const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n        const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n        const scaleX = boundsWidth / width;\n        const scaleY = boundsHeight / height;\n        const context = {\n            coords: this._coords,\n            colors: this._colors,\n            offsetX: -offsetX,\n            offsetY: -offsetY,\n            scaleX: 1 / scaleX,\n            scaleY: 1 / scaleY\n        };\n        const paddedWidth = width + BORDER_SIZE * 2;\n        const paddedHeight = height + BORDER_SIZE * 2;\n        const tmpCanvas = cachedCanvases.getCanvas(\"mesh\", paddedWidth, paddedHeight);\n        const tmpCtx = tmpCanvas.context;\n        const data = tmpCtx.createImageData(width, height);\n        if (backgroundColor) {\n            const bytes = data.data;\n            for(let i = 0, ii = bytes.length; i < ii; i += 4){\n                bytes[i] = backgroundColor[0];\n                bytes[i + 1] = backgroundColor[1];\n                bytes[i + 2] = backgroundColor[2];\n                bytes[i + 3] = 255;\n            }\n        }\n        for (const figure of this._figures){\n            drawFigure(data, figure, context);\n        }\n        tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);\n        const canvas = tmpCanvas.canvas;\n        return {\n            canvas,\n            offsetX: offsetX - BORDER_SIZE * scaleX,\n            offsetY: offsetY - BORDER_SIZE * scaleY,\n            scaleX,\n            scaleY\n        };\n    }\n    getPattern(ctx, owner, inverse, pathType) {\n        applyBoundingBox(ctx, this._bbox);\n        let scale;\n        if (pathType === PathType.SHADING) {\n            scale = Util.singularValueDecompose2dScale(getCurrentTransform(ctx));\n        } else {\n            scale = Util.singularValueDecompose2dScale(owner.baseTransform);\n            if (this.matrix) {\n                const matrixScale = Util.singularValueDecompose2dScale(this.matrix);\n                scale = [\n                    scale[0] * matrixScale[0],\n                    scale[1] * matrixScale[1]\n                ];\n            }\n        }\n        const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);\n        if (pathType !== PathType.SHADING) {\n            ctx.setTransform(...owner.baseTransform);\n            if (this.matrix) {\n                ctx.transform(...this.matrix);\n            }\n        }\n        ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n        ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);\n        return ctx.createPattern(temporaryPatternCanvas.canvas, \"no-repeat\");\n    }\n}\nclass DummyShadingPattern extends BaseShadingPattern {\n    getPattern() {\n        return \"hotpink\";\n    }\n}\nfunction getShadingPattern(IR) {\n    switch(IR[0]){\n        case \"RadialAxial\":\n            return new RadialAxialShadingPattern(IR);\n        case \"Mesh\":\n            return new MeshShadingPattern(IR);\n        case \"Dummy\":\n            return new DummyShadingPattern();\n    }\n    throw new Error(`Unknown IR type: ${IR[0]}`);\n}\nconst PaintType = {\n    COLORED: 1,\n    UNCOLORED: 2\n};\nclass TilingPattern {\n    static{\n        this.MAX_PATTERN_SIZE = 3000;\n    }\n    constructor(IR, color, ctx, canvasGraphicsFactory, baseTransform){\n        this.operatorList = IR[2];\n        this.matrix = IR[3];\n        this.bbox = IR[4];\n        this.xstep = IR[5];\n        this.ystep = IR[6];\n        this.paintType = IR[7];\n        this.tilingType = IR[8];\n        this.color = color;\n        this.ctx = ctx;\n        this.canvasGraphicsFactory = canvasGraphicsFactory;\n        this.baseTransform = baseTransform;\n    }\n    createPatternCanvas(owner) {\n        const { bbox, operatorList, paintType, tilingType, color, canvasGraphicsFactory } = this;\n        let { xstep, ystep } = this;\n        xstep = Math.abs(xstep);\n        ystep = Math.abs(ystep);\n        info(\"TilingType: \" + tilingType);\n        const x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3];\n        const width = x1 - x0;\n        const height = y1 - y0;\n        const matrixScale = Util.singularValueDecompose2dScale(this.matrix);\n        const curMatrixScale = Util.singularValueDecompose2dScale(this.baseTransform);\n        const combinedScaleX = matrixScale[0] * curMatrixScale[0];\n        const combinedScaleY = matrixScale[1] * curMatrixScale[1];\n        let canvasWidth = width, canvasHeight = height, redrawHorizontally = false, redrawVertically = false;\n        const xScaledStep = Math.ceil(xstep * combinedScaleX);\n        const yScaledStep = Math.ceil(ystep * combinedScaleY);\n        const xScaledWidth = Math.ceil(width * combinedScaleX);\n        const yScaledHeight = Math.ceil(height * combinedScaleY);\n        if (xScaledStep >= xScaledWidth) {\n            canvasWidth = xstep;\n        } else {\n            redrawHorizontally = true;\n        }\n        if (yScaledStep >= yScaledHeight) {\n            canvasHeight = ystep;\n        } else {\n            redrawVertically = true;\n        }\n        const dimx = this.getSizeAndScale(canvasWidth, this.ctx.canvas.width, combinedScaleX);\n        const dimy = this.getSizeAndScale(canvasHeight, this.ctx.canvas.height, combinedScaleY);\n        const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", dimx.size, dimy.size);\n        const tmpCtx = tmpCanvas.context;\n        const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);\n        graphics.groupLevel = owner.groupLevel;\n        this.setFillAndStrokeStyleToContext(graphics, paintType, color);\n        tmpCtx.translate(-dimx.scale * x0, -dimy.scale * y0);\n        graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);\n        tmpCtx.save();\n        this.clipBbox(graphics, x0, y0, x1, y1);\n        graphics.baseTransform = getCurrentTransform(graphics.ctx);\n        graphics.executeOperatorList(operatorList);\n        graphics.endDrawing();\n        tmpCtx.restore();\n        if (redrawHorizontally || redrawVertically) {\n            const image = tmpCanvas.canvas;\n            if (redrawHorizontally) {\n                canvasWidth = xstep;\n            }\n            if (redrawVertically) {\n                canvasHeight = ystep;\n            }\n            const dimx2 = this.getSizeAndScale(canvasWidth, this.ctx.canvas.width, combinedScaleX);\n            const dimy2 = this.getSizeAndScale(canvasHeight, this.ctx.canvas.height, combinedScaleY);\n            const xSize = dimx2.size;\n            const ySize = dimy2.size;\n            const tmpCanvas2 = owner.cachedCanvases.getCanvas(\"pattern-workaround\", xSize, ySize);\n            const tmpCtx2 = tmpCanvas2.context;\n            const ii = redrawHorizontally ? Math.floor(width / xstep) : 0;\n            const jj = redrawVertically ? Math.floor(height / ystep) : 0;\n            for(let i = 0; i <= ii; i++){\n                for(let j = 0; j <= jj; j++){\n                    tmpCtx2.drawImage(image, xSize * i, ySize * j, xSize, ySize, 0, 0, xSize, ySize);\n                }\n            }\n            return {\n                canvas: tmpCanvas2.canvas,\n                scaleX: dimx2.scale,\n                scaleY: dimy2.scale,\n                offsetX: x0,\n                offsetY: y0\n            };\n        }\n        return {\n            canvas: tmpCanvas.canvas,\n            scaleX: dimx.scale,\n            scaleY: dimy.scale,\n            offsetX: x0,\n            offsetY: y0\n        };\n    }\n    getSizeAndScale(step, realOutputSize, scale) {\n        const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);\n        let size = Math.ceil(step * scale);\n        if (size >= maxSize) {\n            size = maxSize;\n        } else {\n            scale = size / step;\n        }\n        return {\n            scale,\n            size\n        };\n    }\n    clipBbox(graphics, x0, y0, x1, y1) {\n        const bboxWidth = x1 - x0;\n        const bboxHeight = y1 - y0;\n        graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);\n        graphics.current.updateRectMinMax(getCurrentTransform(graphics.ctx), [\n            x0,\n            y0,\n            x1,\n            y1\n        ]);\n        graphics.clip();\n        graphics.endPath();\n    }\n    setFillAndStrokeStyleToContext(graphics, paintType, color) {\n        const context = graphics.ctx, current = graphics.current;\n        switch(paintType){\n            case PaintType.COLORED:\n                const ctx = this.ctx;\n                context.fillStyle = ctx.fillStyle;\n                context.strokeStyle = ctx.strokeStyle;\n                current.fillColor = ctx.fillStyle;\n                current.strokeColor = ctx.strokeStyle;\n                break;\n            case PaintType.UNCOLORED:\n                const cssColor = Util.makeHexColor(color[0], color[1], color[2]);\n                context.fillStyle = cssColor;\n                context.strokeStyle = cssColor;\n                current.fillColor = cssColor;\n                current.strokeColor = cssColor;\n                break;\n            default:\n                throw new FormatError(`Unsupported paint type: ${paintType}`);\n        }\n    }\n    getPattern(ctx, owner, inverse, pathType) {\n        let matrix = inverse;\n        if (pathType !== PathType.SHADING) {\n            matrix = Util.transform(matrix, owner.baseTransform);\n            if (this.matrix) {\n                matrix = Util.transform(matrix, this.matrix);\n            }\n        }\n        const temporaryPatternCanvas = this.createPatternCanvas(owner);\n        let domMatrix = new DOMMatrix(matrix);\n        domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n        domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);\n        const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, \"repeat\");\n        pattern.setTransform(domMatrix);\n        return pattern;\n    }\n}\n; // ./src/shared/image_utils.js\nfunction convertToRGBA(params) {\n    switch(params.kind){\n        case ImageKind.GRAYSCALE_1BPP:\n            return convertBlackAndWhiteToRGBA(params);\n        case ImageKind.RGB_24BPP:\n            return convertRGBToRGBA(params);\n    }\n    return null;\n}\nfunction convertBlackAndWhiteToRGBA({ src, srcPos = 0, dest, width, height, nonBlackColor = 0xffffffff, inverseDecode = false }) {\n    const black = util_FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n    const [zeroMapping, oneMapping] = inverseDecode ? [\n        nonBlackColor,\n        black\n    ] : [\n        black,\n        nonBlackColor\n    ];\n    const widthInSource = width >> 3;\n    const widthRemainder = width & 7;\n    const srcLength = src.length;\n    dest = new Uint32Array(dest.buffer);\n    let destPos = 0;\n    for(let i = 0; i < height; i++){\n        for(const max = srcPos + widthInSource; srcPos < max; srcPos++){\n            const elem = srcPos < srcLength ? src[srcPos] : 255;\n            dest[destPos++] = elem & 128 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 64 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 32 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 16 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 8 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 4 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 2 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 1 ? oneMapping : zeroMapping;\n        }\n        if (widthRemainder === 0) {\n            continue;\n        }\n        const elem = srcPos < srcLength ? src[srcPos++] : 255;\n        for(let j = 0; j < widthRemainder; j++){\n            dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;\n        }\n    }\n    return {\n        srcPos,\n        destPos\n    };\n}\nfunction convertRGBToRGBA({ src, srcPos = 0, dest, destPos = 0, width, height }) {\n    let i = 0;\n    const len = width * height * 3;\n    const len32 = len >> 2;\n    const src32 = new Uint32Array(src.buffer, srcPos, len32);\n    if (FeatureTest.isLittleEndian) {\n        for(; i < len32 - 2; i += 3, destPos += 4){\n            const s1 = src32[i];\n            const s2 = src32[i + 1];\n            const s3 = src32[i + 2];\n            dest[destPos] = s1 | 0xff000000;\n            dest[destPos + 1] = s1 >>> 24 | s2 << 8 | 0xff000000;\n            dest[destPos + 2] = s2 >>> 16 | s3 << 16 | 0xff000000;\n            dest[destPos + 3] = s3 >>> 8 | 0xff000000;\n        }\n        for(let j = i * 4, jj = srcPos + len; j < jj; j += 3){\n            dest[destPos++] = src[j] | src[j + 1] << 8 | src[j + 2] << 16 | 0xff000000;\n        }\n    } else {\n        for(; i < len32 - 2; i += 3, destPos += 4){\n            const s1 = src32[i];\n            const s2 = src32[i + 1];\n            const s3 = src32[i + 2];\n            dest[destPos] = s1 | 0xff;\n            dest[destPos + 1] = s1 << 24 | s2 >>> 8 | 0xff;\n            dest[destPos + 2] = s2 << 16 | s3 >>> 16 | 0xff;\n            dest[destPos + 3] = s3 << 8 | 0xff;\n        }\n        for(let j = i * 4, jj = srcPos + len; j < jj; j += 3){\n            dest[destPos++] = src[j] << 24 | src[j + 1] << 16 | src[j + 2] << 8 | 0xff;\n        }\n    }\n    return {\n        srcPos: srcPos + len,\n        destPos\n    };\n}\nfunction grayToRGBA(src, dest) {\n    if (FeatureTest.isLittleEndian) {\n        for(let i = 0, ii = src.length; i < ii; i++){\n            dest[i] = src[i] * 0x10101 | 0xff000000;\n        }\n    } else {\n        for(let i = 0, ii = src.length; i < ii; i++){\n            dest[i] = src[i] * 0x1010100 | 0x000000ff;\n        }\n    }\n}\n; // ./src/display/canvas.js\nconst MIN_FONT_SIZE = 16;\nconst MAX_FONT_SIZE = 100;\nconst EXECUTION_TIME = 15;\nconst EXECUTION_STEPS = 10;\nconst MAX_SIZE_TO_COMPILE = 1000;\nconst FULL_CHUNK_HEIGHT = 16;\nfunction mirrorContextOperations(ctx, destCtx) {\n    if (ctx._removeMirroring) {\n        throw new Error(\"Context is already forwarding operations.\");\n    }\n    ctx.__originalSave = ctx.save;\n    ctx.__originalRestore = ctx.restore;\n    ctx.__originalRotate = ctx.rotate;\n    ctx.__originalScale = ctx.scale;\n    ctx.__originalTranslate = ctx.translate;\n    ctx.__originalTransform = ctx.transform;\n    ctx.__originalSetTransform = ctx.setTransform;\n    ctx.__originalResetTransform = ctx.resetTransform;\n    ctx.__originalClip = ctx.clip;\n    ctx.__originalMoveTo = ctx.moveTo;\n    ctx.__originalLineTo = ctx.lineTo;\n    ctx.__originalBezierCurveTo = ctx.bezierCurveTo;\n    ctx.__originalRect = ctx.rect;\n    ctx.__originalClosePath = ctx.closePath;\n    ctx.__originalBeginPath = ctx.beginPath;\n    ctx._removeMirroring = ()=>{\n        ctx.save = ctx.__originalSave;\n        ctx.restore = ctx.__originalRestore;\n        ctx.rotate = ctx.__originalRotate;\n        ctx.scale = ctx.__originalScale;\n        ctx.translate = ctx.__originalTranslate;\n        ctx.transform = ctx.__originalTransform;\n        ctx.setTransform = ctx.__originalSetTransform;\n        ctx.resetTransform = ctx.__originalResetTransform;\n        ctx.clip = ctx.__originalClip;\n        ctx.moveTo = ctx.__originalMoveTo;\n        ctx.lineTo = ctx.__originalLineTo;\n        ctx.bezierCurveTo = ctx.__originalBezierCurveTo;\n        ctx.rect = ctx.__originalRect;\n        ctx.closePath = ctx.__originalClosePath;\n        ctx.beginPath = ctx.__originalBeginPath;\n        delete ctx._removeMirroring;\n    };\n    ctx.save = function ctxSave() {\n        destCtx.save();\n        this.__originalSave();\n    };\n    ctx.restore = function ctxRestore() {\n        destCtx.restore();\n        this.__originalRestore();\n    };\n    ctx.translate = function ctxTranslate(x, y) {\n        destCtx.translate(x, y);\n        this.__originalTranslate(x, y);\n    };\n    ctx.scale = function ctxScale(x, y) {\n        destCtx.scale(x, y);\n        this.__originalScale(x, y);\n    };\n    ctx.transform = function ctxTransform(a, b, c, d, e, f) {\n        destCtx.transform(a, b, c, d, e, f);\n        this.__originalTransform(a, b, c, d, e, f);\n    };\n    ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {\n        destCtx.setTransform(a, b, c, d, e, f);\n        this.__originalSetTransform(a, b, c, d, e, f);\n    };\n    ctx.resetTransform = function ctxResetTransform() {\n        destCtx.resetTransform();\n        this.__originalResetTransform();\n    };\n    ctx.rotate = function ctxRotate(angle) {\n        destCtx.rotate(angle);\n        this.__originalRotate(angle);\n    };\n    ctx.clip = function ctxRotate(rule) {\n        destCtx.clip(rule);\n        this.__originalClip(rule);\n    };\n    ctx.moveTo = function(x, y) {\n        destCtx.moveTo(x, y);\n        this.__originalMoveTo(x, y);\n    };\n    ctx.lineTo = function(x, y) {\n        destCtx.lineTo(x, y);\n        this.__originalLineTo(x, y);\n    };\n    ctx.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {\n        destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n        this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n    };\n    ctx.rect = function(x, y, width, height) {\n        destCtx.rect(x, y, width, height);\n        this.__originalRect(x, y, width, height);\n    };\n    ctx.closePath = function() {\n        destCtx.closePath();\n        this.__originalClosePath();\n    };\n    ctx.beginPath = function() {\n        destCtx.beginPath();\n        this.__originalBeginPath();\n    };\n}\nclass CachedCanvases {\n    constructor(canvasFactory){\n        this.canvasFactory = canvasFactory;\n        this.cache = Object.create(null);\n    }\n    getCanvas(id, width, height) {\n        let canvasEntry;\n        if (this.cache[id] !== undefined) {\n            canvasEntry = this.cache[id];\n            this.canvasFactory.reset(canvasEntry, width, height);\n        } else {\n            canvasEntry = this.canvasFactory.create(width, height);\n            this.cache[id] = canvasEntry;\n        }\n        return canvasEntry;\n    }\n    delete(id) {\n        delete this.cache[id];\n    }\n    clear() {\n        for(const id in this.cache){\n            const canvasEntry = this.cache[id];\n            this.canvasFactory.destroy(canvasEntry);\n            delete this.cache[id];\n        }\n    }\n}\nfunction drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {\n    const [a, b, c, d, tx, ty] = getCurrentTransform(ctx);\n    if (b === 0 && c === 0) {\n        const tlX = destX * a + tx;\n        const rTlX = Math.round(tlX);\n        const tlY = destY * d + ty;\n        const rTlY = Math.round(tlY);\n        const brX = (destX + destW) * a + tx;\n        const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n        const brY = (destY + destH) * d + ty;\n        const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n        ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);\n        ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);\n        ctx.setTransform(a, b, c, d, tx, ty);\n        return [\n            rWidth,\n            rHeight\n        ];\n    }\n    if (a === 0 && d === 0) {\n        const tlX = destY * c + tx;\n        const rTlX = Math.round(tlX);\n        const tlY = destX * b + ty;\n        const rTlY = Math.round(tlY);\n        const brX = (destY + destH) * c + tx;\n        const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n        const brY = (destX + destW) * b + ty;\n        const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n        ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);\n        ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);\n        ctx.setTransform(a, b, c, d, tx, ty);\n        return [\n            rHeight,\n            rWidth\n        ];\n    }\n    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);\n    const scaleX = Math.hypot(a, b);\n    const scaleY = Math.hypot(c, d);\n    return [\n        scaleX * destW,\n        scaleY * destH\n    ];\n}\nfunction compileType3Glyph(imgData) {\n    const { width, height } = imgData;\n    if (width > MAX_SIZE_TO_COMPILE || height > MAX_SIZE_TO_COMPILE) {\n        return null;\n    }\n    const POINT_TO_PROCESS_LIMIT = 1000;\n    const POINT_TYPES = new Uint8Array([\n        0,\n        2,\n        4,\n        0,\n        1,\n        0,\n        5,\n        4,\n        8,\n        10,\n        0,\n        8,\n        0,\n        2,\n        1,\n        0\n    ]);\n    const width1 = width + 1;\n    let points = new Uint8Array(width1 * (height + 1));\n    let i, j, j0;\n    const lineSize = width + 7 & ~7;\n    let data = new Uint8Array(lineSize * height), pos = 0;\n    for (const elem of imgData.data){\n        let mask = 128;\n        while(mask > 0){\n            data[pos++] = elem & mask ? 0 : 255;\n            mask >>= 1;\n        }\n    }\n    let count = 0;\n    pos = 0;\n    if (data[pos] !== 0) {\n        points[0] = 1;\n        ++count;\n    }\n    for(j = 1; j < width; j++){\n        if (data[pos] !== data[pos + 1]) {\n            points[j] = data[pos] ? 2 : 1;\n            ++count;\n        }\n        pos++;\n    }\n    if (data[pos] !== 0) {\n        points[j] = 2;\n        ++count;\n    }\n    for(i = 1; i < height; i++){\n        pos = i * lineSize;\n        j0 = i * width1;\n        if (data[pos - lineSize] !== data[pos]) {\n            points[j0] = data[pos] ? 1 : 8;\n            ++count;\n        }\n        let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);\n        for(j = 1; j < width; j++){\n            sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);\n            if (POINT_TYPES[sum]) {\n                points[j0 + j] = POINT_TYPES[sum];\n                ++count;\n            }\n            pos++;\n        }\n        if (data[pos - lineSize] !== data[pos]) {\n            points[j0 + j] = data[pos] ? 2 : 4;\n            ++count;\n        }\n        if (count > POINT_TO_PROCESS_LIMIT) {\n            return null;\n        }\n    }\n    pos = lineSize * (height - 1);\n    j0 = i * width1;\n    if (data[pos] !== 0) {\n        points[j0] = 8;\n        ++count;\n    }\n    for(j = 1; j < width; j++){\n        if (data[pos] !== data[pos + 1]) {\n            points[j0 + j] = data[pos] ? 4 : 8;\n            ++count;\n        }\n        pos++;\n    }\n    if (data[pos] !== 0) {\n        points[j0 + j] = 4;\n        ++count;\n    }\n    if (count > POINT_TO_PROCESS_LIMIT) {\n        return null;\n    }\n    const steps = new Int32Array([\n        0,\n        width1,\n        -1,\n        0,\n        -width1,\n        0,\n        0,\n        0,\n        1\n    ]);\n    const path = new Path2D();\n    for(i = 0; count && i <= height; i++){\n        let p = i * width1;\n        const end = p + width;\n        while(p < end && !points[p]){\n            p++;\n        }\n        if (p === end) {\n            continue;\n        }\n        path.moveTo(p % width1, i);\n        const p0 = p;\n        let type = points[p];\n        do {\n            const step = steps[type];\n            do {\n                p += step;\n            }while (!points[p]);\n            const pp = points[p];\n            if (pp !== 5 && pp !== 10) {\n                type = pp;\n                points[p] = 0;\n            } else {\n                type = pp & 0x33 * type >> 4;\n                points[p] &= type >> 2 | type << 2;\n            }\n            path.lineTo(p % width1, p / width1 | 0);\n            if (!points[p]) {\n                --count;\n            }\n        }while (p0 !== p);\n        --i;\n    }\n    data = null;\n    points = null;\n    const drawOutline = function(c) {\n        c.save();\n        c.scale(1 / width, -1 / height);\n        c.translate(0, -height);\n        c.fill(path);\n        c.beginPath();\n        c.restore();\n    };\n    return drawOutline;\n}\nclass CanvasExtraState {\n    constructor(width, height){\n        this.alphaIsShape = false;\n        this.fontSize = 0;\n        this.fontSizeScale = 1;\n        this.textMatrix = IDENTITY_MATRIX;\n        this.textMatrixScale = 1;\n        this.fontMatrix = FONT_IDENTITY_MATRIX;\n        this.leading = 0;\n        this.x = 0;\n        this.y = 0;\n        this.lineX = 0;\n        this.lineY = 0;\n        this.charSpacing = 0;\n        this.wordSpacing = 0;\n        this.textHScale = 1;\n        this.textRenderingMode = TextRenderingMode.FILL;\n        this.textRise = 0;\n        this.fillColor = \"#000000\";\n        this.strokeColor = \"#000000\";\n        this.patternFill = false;\n        this.patternStroke = false;\n        this.fillAlpha = 1;\n        this.strokeAlpha = 1;\n        this.lineWidth = 1;\n        this.activeSMask = null;\n        this.transferMaps = \"none\";\n        this.startNewPathAndClipBox([\n            0,\n            0,\n            width,\n            height\n        ]);\n    }\n    clone() {\n        const clone = Object.create(this);\n        clone.clipBox = this.clipBox.slice();\n        return clone;\n    }\n    setCurrentPoint(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    updatePathMinMax(transform, x, y) {\n        [x, y] = Util.applyTransform([\n            x,\n            y\n        ], transform);\n        this.minX = Math.min(this.minX, x);\n        this.minY = Math.min(this.minY, y);\n        this.maxX = Math.max(this.maxX, x);\n        this.maxY = Math.max(this.maxY, y);\n    }\n    updateRectMinMax(transform, rect) {\n        const p1 = Util.applyTransform(rect, transform);\n        const p2 = Util.applyTransform(rect.slice(2), transform);\n        const p3 = Util.applyTransform([\n            rect[0],\n            rect[3]\n        ], transform);\n        const p4 = Util.applyTransform([\n            rect[2],\n            rect[1]\n        ], transform);\n        this.minX = Math.min(this.minX, p1[0], p2[0], p3[0], p4[0]);\n        this.minY = Math.min(this.minY, p1[1], p2[1], p3[1], p4[1]);\n        this.maxX = Math.max(this.maxX, p1[0], p2[0], p3[0], p4[0]);\n        this.maxY = Math.max(this.maxY, p1[1], p2[1], p3[1], p4[1]);\n    }\n    updateScalingPathMinMax(transform, minMax) {\n        Util.scaleMinMax(transform, minMax);\n        this.minX = Math.min(this.minX, minMax[0]);\n        this.minY = Math.min(this.minY, minMax[1]);\n        this.maxX = Math.max(this.maxX, minMax[2]);\n        this.maxY = Math.max(this.maxY, minMax[3]);\n    }\n    updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3, minMax) {\n        const box = Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3, minMax);\n        if (minMax) {\n            return;\n        }\n        this.updateRectMinMax(transform, box);\n    }\n    getPathBoundingBox(pathType = PathType.FILL, transform = null) {\n        const box = [\n            this.minX,\n            this.minY,\n            this.maxX,\n            this.maxY\n        ];\n        if (pathType === PathType.STROKE) {\n            if (!transform) {\n                unreachable(\"Stroke bounding box must include transform.\");\n            }\n            const scale = Util.singularValueDecompose2dScale(transform);\n            const xStrokePad = scale[0] * this.lineWidth / 2;\n            const yStrokePad = scale[1] * this.lineWidth / 2;\n            box[0] -= xStrokePad;\n            box[1] -= yStrokePad;\n            box[2] += xStrokePad;\n            box[3] += yStrokePad;\n        }\n        return box;\n    }\n    updateClipFromPath() {\n        const intersect = Util.intersect(this.clipBox, this.getPathBoundingBox());\n        this.startNewPathAndClipBox(intersect || [\n            0,\n            0,\n            0,\n            0\n        ]);\n    }\n    isEmptyClip() {\n        return this.minX === Infinity;\n    }\n    startNewPathAndClipBox(box) {\n        this.clipBox = box;\n        this.minX = Infinity;\n        this.minY = Infinity;\n        this.maxX = 0;\n        this.maxY = 0;\n    }\n    getClippedPathBoundingBox(pathType = PathType.FILL, transform = null) {\n        return Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));\n    }\n}\nfunction putBinaryImageData(ctx, imgData) {\n    if (imgData instanceof ImageData) {\n        ctx.putImageData(imgData, 0, 0);\n        return;\n    }\n    const height = imgData.height, width = imgData.width;\n    const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n    const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n    const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n    const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n    let srcPos = 0, destPos;\n    const src = imgData.data;\n    const dest = chunkImgData.data;\n    let i, j, thisChunkHeight, elemsInThisChunk;\n    if (imgData.kind === util_ImageKind.GRAYSCALE_1BPP) {\n        const srcLength = src.byteLength;\n        const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);\n        const dest32DataLength = dest32.length;\n        const fullSrcDiff = width + 7 >> 3;\n        const white = 0xffffffff;\n        const black = util_FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n        for(i = 0; i < totalChunks; i++){\n            thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n            destPos = 0;\n            for(j = 0; j < thisChunkHeight; j++){\n                const srcDiff = srcLength - srcPos;\n                let k = 0;\n                const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;\n                const kEndUnrolled = kEnd & ~7;\n                let mask = 0;\n                let srcByte = 0;\n                for(; k < kEndUnrolled; k += 8){\n                    srcByte = src[srcPos++];\n                    dest32[destPos++] = srcByte & 128 ? white : black;\n                    dest32[destPos++] = srcByte & 64 ? white : black;\n                    dest32[destPos++] = srcByte & 32 ? white : black;\n                    dest32[destPos++] = srcByte & 16 ? white : black;\n                    dest32[destPos++] = srcByte & 8 ? white : black;\n                    dest32[destPos++] = srcByte & 4 ? white : black;\n                    dest32[destPos++] = srcByte & 2 ? white : black;\n                    dest32[destPos++] = srcByte & 1 ? white : black;\n                }\n                for(; k < kEnd; k++){\n                    if (mask === 0) {\n                        srcByte = src[srcPos++];\n                        mask = 128;\n                    }\n                    dest32[destPos++] = srcByte & mask ? white : black;\n                    mask >>= 1;\n                }\n            }\n            while(destPos < dest32DataLength){\n                dest32[destPos++] = 0;\n            }\n            ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n        }\n    } else if (imgData.kind === util_ImageKind.RGBA_32BPP) {\n        j = 0;\n        elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;\n        for(i = 0; i < fullChunks; i++){\n            dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n            srcPos += elemsInThisChunk;\n            ctx.putImageData(chunkImgData, 0, j);\n            j += FULL_CHUNK_HEIGHT;\n        }\n        if (i < totalChunks) {\n            elemsInThisChunk = width * partialChunkHeight * 4;\n            dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n            ctx.putImageData(chunkImgData, 0, j);\n        }\n    } else if (imgData.kind === util_ImageKind.RGB_24BPP) {\n        thisChunkHeight = FULL_CHUNK_HEIGHT;\n        elemsInThisChunk = width * thisChunkHeight;\n        for(i = 0; i < totalChunks; i++){\n            if (i >= fullChunks) {\n                thisChunkHeight = partialChunkHeight;\n                elemsInThisChunk = width * thisChunkHeight;\n            }\n            destPos = 0;\n            for(j = elemsInThisChunk; j--;){\n                dest[destPos++] = src[srcPos++];\n                dest[destPos++] = src[srcPos++];\n                dest[destPos++] = src[srcPos++];\n                dest[destPos++] = 255;\n            }\n            ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n        }\n    } else {\n        throw new Error(`bad image kind: ${imgData.kind}`);\n    }\n}\nfunction putBinaryImageMask(ctx, imgData) {\n    if (imgData.bitmap) {\n        ctx.drawImage(imgData.bitmap, 0, 0);\n        return;\n    }\n    const height = imgData.height, width = imgData.width;\n    const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n    const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n    const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n    const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n    let srcPos = 0;\n    const src = imgData.data;\n    const dest = chunkImgData.data;\n    for(let i = 0; i < totalChunks; i++){\n        const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n        ({ srcPos } = convertBlackAndWhiteToRGBA({\n            src,\n            srcPos,\n            dest,\n            width,\n            height: thisChunkHeight,\n            nonBlackColor: 0\n        }));\n        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n    }\n}\nfunction copyCtxState(sourceCtx, destCtx) {\n    const properties = [\n        \"strokeStyle\",\n        \"fillStyle\",\n        \"fillRule\",\n        \"globalAlpha\",\n        \"lineWidth\",\n        \"lineCap\",\n        \"lineJoin\",\n        \"miterLimit\",\n        \"globalCompositeOperation\",\n        \"font\",\n        \"filter\"\n    ];\n    for (const property of properties){\n        if (sourceCtx[property] !== undefined) {\n            destCtx[property] = sourceCtx[property];\n        }\n    }\n    if (sourceCtx.setLineDash !== undefined) {\n        destCtx.setLineDash(sourceCtx.getLineDash());\n        destCtx.lineDashOffset = sourceCtx.lineDashOffset;\n    }\n}\nfunction resetCtxToDefault(ctx) {\n    ctx.strokeStyle = ctx.fillStyle = \"#000000\";\n    ctx.fillRule = \"nonzero\";\n    ctx.globalAlpha = 1;\n    ctx.lineWidth = 1;\n    ctx.lineCap = \"butt\";\n    ctx.lineJoin = \"miter\";\n    ctx.miterLimit = 10;\n    ctx.globalCompositeOperation = \"source-over\";\n    ctx.font = \"10px sans-serif\";\n    if (ctx.setLineDash !== undefined) {\n        ctx.setLineDash([]);\n        ctx.lineDashOffset = 0;\n    }\n    if (!isNodeJS) {\n        const { filter } = ctx;\n        if (filter !== \"none\" && filter !== \"\") {\n            ctx.filter = \"none\";\n        }\n    }\n}\nfunction getImageSmoothingEnabled(transform, interpolate) {\n    if (interpolate) {\n        return true;\n    }\n    const scale = Util.singularValueDecompose2dScale(transform);\n    scale[0] = Math.fround(scale[0]);\n    scale[1] = Math.fround(scale[1]);\n    const actualScale = Math.fround((globalThis.devicePixelRatio || 1) * PixelsPerInch.PDF_TO_CSS_UNITS);\n    return scale[0] <= actualScale && scale[1] <= actualScale;\n}\nconst LINE_CAP_STYLES = [\n    \"butt\",\n    \"round\",\n    \"square\"\n];\nconst LINE_JOIN_STYLES = [\n    \"miter\",\n    \"round\",\n    \"bevel\"\n];\nconst NORMAL_CLIP = {};\nconst EO_CLIP = {};\nclass CanvasGraphics {\n    constructor(canvasCtx, commonObjs, objs, canvasFactory, filterFactory, { optionalContentConfig, markedContentStack = null }, annotationCanvasMap, pageColors){\n        this.ctx = canvasCtx;\n        this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n        this.stateStack = [];\n        this.pendingClip = null;\n        this.pendingEOFill = false;\n        this.res = null;\n        this.xobjs = null;\n        this.commonObjs = commonObjs;\n        this.objs = objs;\n        this.canvasFactory = canvasFactory;\n        this.filterFactory = filterFactory;\n        this.groupStack = [];\n        this.processingType3 = null;\n        this.baseTransform = null;\n        this.baseTransformStack = [];\n        this.groupLevel = 0;\n        this.smaskStack = [];\n        this.smaskCounter = 0;\n        this.tempSMask = null;\n        this.suspendedCtx = null;\n        this.contentVisible = true;\n        this.markedContentStack = markedContentStack || [];\n        this.optionalContentConfig = optionalContentConfig;\n        this.cachedCanvases = new CachedCanvases(this.canvasFactory);\n        this.cachedPatterns = new Map();\n        this.annotationCanvasMap = annotationCanvasMap;\n        this.viewportScale = 1;\n        this.outputScaleX = 1;\n        this.outputScaleY = 1;\n        this.pageColors = pageColors;\n        this._cachedScaleForStroking = [\n            -1,\n            0\n        ];\n        this._cachedGetSinglePixelWidth = null;\n        this._cachedBitmapsMap = new Map();\n    }\n    getObject(data, fallback = null) {\n        if (typeof data === \"string\") {\n            return data.startsWith(\"g_\") ? this.commonObjs.get(data) : this.objs.get(data);\n        }\n        return fallback;\n    }\n    beginDrawing({ transform, viewport, transparency = false, background = null }) {\n        const width = this.ctx.canvas.width;\n        const height = this.ctx.canvas.height;\n        const savedFillStyle = this.ctx.fillStyle;\n        this.ctx.fillStyle = background || \"#ffffff\";\n        this.ctx.fillRect(0, 0, width, height);\n        this.ctx.fillStyle = savedFillStyle;\n        if (transparency) {\n            const transparentCanvas = this.cachedCanvases.getCanvas(\"transparent\", width, height);\n            this.compositeCtx = this.ctx;\n            this.transparentCanvas = transparentCanvas.canvas;\n            this.ctx = transparentCanvas.context;\n            this.ctx.save();\n            this.ctx.transform(...getCurrentTransform(this.compositeCtx));\n        }\n        this.ctx.save();\n        resetCtxToDefault(this.ctx);\n        if (transform) {\n            this.ctx.transform(...transform);\n            this.outputScaleX = transform[0];\n            this.outputScaleY = transform[0];\n        }\n        this.ctx.transform(...viewport.transform);\n        this.viewportScale = viewport.scale;\n        this.baseTransform = getCurrentTransform(this.ctx);\n    }\n    executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {\n        const argsArray = operatorList.argsArray;\n        const fnArray = operatorList.fnArray;\n        let i = executionStartIdx || 0;\n        const argsArrayLen = argsArray.length;\n        if (argsArrayLen === i) {\n            return i;\n        }\n        const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === \"function\";\n        const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;\n        let steps = 0;\n        const commonObjs = this.commonObjs;\n        const objs = this.objs;\n        let fnId;\n        while(true){\n            if (stepper !== undefined && i === stepper.nextBreakPoint) {\n                stepper.breakIt(i, continueCallback);\n                return i;\n            }\n            fnId = fnArray[i];\n            if (fnId !== OPS.dependency) {\n                this[fnId].apply(this, argsArray[i]);\n            } else {\n                for (const depObjId of argsArray[i]){\n                    const objsPool = depObjId.startsWith(\"g_\") ? commonObjs : objs;\n                    if (!objsPool.has(depObjId)) {\n                        objsPool.get(depObjId, continueCallback);\n                        return i;\n                    }\n                }\n            }\n            i++;\n            if (i === argsArrayLen) {\n                return i;\n            }\n            if (chunkOperations && ++steps > EXECUTION_STEPS) {\n                if (Date.now() > endTime) {\n                    continueCallback();\n                    return i;\n                }\n                steps = 0;\n            }\n        }\n    }\n    #restoreInitialState() {\n        while(this.stateStack.length || this.inSMaskMode){\n            this.restore();\n        }\n        this.current.activeSMask = null;\n        this.ctx.restore();\n        if (this.transparentCanvas) {\n            this.ctx = this.compositeCtx;\n            this.ctx.save();\n            this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n            this.ctx.drawImage(this.transparentCanvas, 0, 0);\n            this.ctx.restore();\n            this.transparentCanvas = null;\n        }\n    }\n    endDrawing() {\n        this.#restoreInitialState();\n        this.cachedCanvases.clear();\n        this.cachedPatterns.clear();\n        for (const cache of this._cachedBitmapsMap.values()){\n            for (const canvas of cache.values()){\n                if (typeof HTMLCanvasElement !== \"undefined\" && canvas instanceof HTMLCanvasElement) {\n                    canvas.width = canvas.height = 0;\n                }\n            }\n            cache.clear();\n        }\n        this._cachedBitmapsMap.clear();\n        this.#drawFilter();\n    }\n    #drawFilter() {\n        if (this.pageColors) {\n            const hcmFilterId = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);\n            if (hcmFilterId !== \"none\") {\n                const savedFilter = this.ctx.filter;\n                this.ctx.filter = hcmFilterId;\n                this.ctx.drawImage(this.ctx.canvas, 0, 0);\n                this.ctx.filter = savedFilter;\n            }\n        }\n    }\n    _scaleImage(img, inverseTransform) {\n        const width = img.width ?? img.displayWidth;\n        const height = img.height ?? img.displayHeight;\n        let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);\n        let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);\n        let paintWidth = width, paintHeight = height;\n        let tmpCanvasId = \"prescale1\";\n        let tmpCanvas, tmpCtx;\n        while(widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1){\n            let newWidth = paintWidth, newHeight = paintHeight;\n            if (widthScale > 2 && paintWidth > 1) {\n                newWidth = paintWidth >= 16384 ? Math.floor(paintWidth / 2) - 1 || 1 : Math.ceil(paintWidth / 2);\n                widthScale /= paintWidth / newWidth;\n            }\n            if (heightScale > 2 && paintHeight > 1) {\n                newHeight = paintHeight >= 16384 ? Math.floor(paintHeight / 2) - 1 || 1 : Math.ceil(paintHeight) / 2;\n                heightScale /= paintHeight / newHeight;\n            }\n            tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);\n            tmpCtx = tmpCanvas.context;\n            tmpCtx.clearRect(0, 0, newWidth, newHeight);\n            tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);\n            img = tmpCanvas.canvas;\n            paintWidth = newWidth;\n            paintHeight = newHeight;\n            tmpCanvasId = tmpCanvasId === \"prescale1\" ? \"prescale2\" : \"prescale1\";\n        }\n        return {\n            img,\n            paintWidth,\n            paintHeight\n        };\n    }\n    _createMaskCanvas(img) {\n        const ctx = this.ctx;\n        const { width, height } = img;\n        const fillColor = this.current.fillColor;\n        const isPatternFill = this.current.patternFill;\n        const currentTransform = getCurrentTransform(ctx);\n        let cache, cacheKey, scaled, maskCanvas;\n        if ((img.bitmap || img.data) && img.count > 1) {\n            const mainKey = img.bitmap || img.data.buffer;\n            cacheKey = JSON.stringify(isPatternFill ? currentTransform : [\n                currentTransform.slice(0, 4),\n                fillColor\n            ]);\n            cache = this._cachedBitmapsMap.get(mainKey);\n            if (!cache) {\n                cache = new Map();\n                this._cachedBitmapsMap.set(mainKey, cache);\n            }\n            const cachedImage = cache.get(cacheKey);\n            if (cachedImage && !isPatternFill) {\n                const offsetX = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);\n                const offsetY = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);\n                return {\n                    canvas: cachedImage,\n                    offsetX,\n                    offsetY\n                };\n            }\n            scaled = cachedImage;\n        }\n        if (!scaled) {\n            maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n            putBinaryImageMask(maskCanvas.context, img);\n        }\n        let maskToCanvas = Util.transform(currentTransform, [\n            1 / width,\n            0,\n            0,\n            -1 / height,\n            0,\n            0\n        ]);\n        maskToCanvas = Util.transform(maskToCanvas, [\n            1,\n            0,\n            0,\n            1,\n            0,\n            -height\n        ]);\n        const [minX, minY, maxX, maxY] = Util.getAxialAlignedBoundingBox([\n            0,\n            0,\n            width,\n            height\n        ], maskToCanvas);\n        const drawnWidth = Math.round(maxX - minX) || 1;\n        const drawnHeight = Math.round(maxY - minY) || 1;\n        const fillCanvas = this.cachedCanvases.getCanvas(\"fillCanvas\", drawnWidth, drawnHeight);\n        const fillCtx = fillCanvas.context;\n        const offsetX = minX;\n        const offsetY = minY;\n        fillCtx.translate(-offsetX, -offsetY);\n        fillCtx.transform(...maskToCanvas);\n        if (!scaled) {\n            scaled = this._scaleImage(maskCanvas.canvas, getCurrentTransformInverse(fillCtx));\n            scaled = scaled.img;\n            if (cache && isPatternFill) {\n                cache.set(cacheKey, scaled);\n            }\n        }\n        fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(fillCtx), img.interpolate);\n        drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);\n        fillCtx.globalCompositeOperation = \"source-in\";\n        const inverse = Util.transform(getCurrentTransformInverse(fillCtx), [\n            1,\n            0,\n            0,\n            1,\n            -offsetX,\n            -offsetY\n        ]);\n        fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, PathType.FILL) : fillColor;\n        fillCtx.fillRect(0, 0, width, height);\n        if (cache && !isPatternFill) {\n            this.cachedCanvases.delete(\"fillCanvas\");\n            cache.set(cacheKey, fillCanvas.canvas);\n        }\n        return {\n            canvas: fillCanvas.canvas,\n            offsetX: Math.round(offsetX),\n            offsetY: Math.round(offsetY)\n        };\n    }\n    setLineWidth(width) {\n        if (width !== this.current.lineWidth) {\n            this._cachedScaleForStroking[0] = -1;\n        }\n        this.current.lineWidth = width;\n        this.ctx.lineWidth = width;\n    }\n    setLineCap(style) {\n        this.ctx.lineCap = LINE_CAP_STYLES[style];\n    }\n    setLineJoin(style) {\n        this.ctx.lineJoin = LINE_JOIN_STYLES[style];\n    }\n    setMiterLimit(limit) {\n        this.ctx.miterLimit = limit;\n    }\n    setDash(dashArray, dashPhase) {\n        const ctx = this.ctx;\n        if (ctx.setLineDash !== undefined) {\n            ctx.setLineDash(dashArray);\n            ctx.lineDashOffset = dashPhase;\n        }\n    }\n    setRenderingIntent(intent) {}\n    setFlatness(flatness) {}\n    setGState(states) {\n        for (const [key, value] of states){\n            switch(key){\n                case \"LW\":\n                    this.setLineWidth(value);\n                    break;\n                case \"LC\":\n                    this.setLineCap(value);\n                    break;\n                case \"LJ\":\n                    this.setLineJoin(value);\n                    break;\n                case \"ML\":\n                    this.setMiterLimit(value);\n                    break;\n                case \"D\":\n                    this.setDash(value[0], value[1]);\n                    break;\n                case \"RI\":\n                    this.setRenderingIntent(value);\n                    break;\n                case \"FL\":\n                    this.setFlatness(value);\n                    break;\n                case \"Font\":\n                    this.setFont(value[0], value[1]);\n                    break;\n                case \"CA\":\n                    this.current.strokeAlpha = value;\n                    break;\n                case \"ca\":\n                    this.current.fillAlpha = value;\n                    this.ctx.globalAlpha = value;\n                    break;\n                case \"BM\":\n                    this.ctx.globalCompositeOperation = value;\n                    break;\n                case \"SMask\":\n                    this.current.activeSMask = value ? this.tempSMask : null;\n                    this.tempSMask = null;\n                    this.checkSMaskState();\n                    break;\n                case \"TR\":\n                    this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(value);\n                    break;\n            }\n        }\n    }\n    get inSMaskMode() {\n        return !!this.suspendedCtx;\n    }\n    checkSMaskState() {\n        const inSMaskMode = this.inSMaskMode;\n        if (this.current.activeSMask && !inSMaskMode) {\n            this.beginSMaskMode();\n        } else if (!this.current.activeSMask && inSMaskMode) {\n            this.endSMaskMode();\n        }\n    }\n    beginSMaskMode() {\n        if (this.inSMaskMode) {\n            throw new Error(\"beginSMaskMode called while already in smask mode\");\n        }\n        const drawnWidth = this.ctx.canvas.width;\n        const drawnHeight = this.ctx.canvas.height;\n        const cacheId = \"smaskGroupAt\" + this.groupLevel;\n        const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n        this.suspendedCtx = this.ctx;\n        this.ctx = scratchCanvas.context;\n        const ctx = this.ctx;\n        ctx.setTransform(...getCurrentTransform(this.suspendedCtx));\n        copyCtxState(this.suspendedCtx, ctx);\n        mirrorContextOperations(ctx, this.suspendedCtx);\n        this.setGState([\n            [\n                \"BM\",\n                \"source-over\"\n            ],\n            [\n                \"ca\",\n                1\n            ],\n            [\n                \"CA\",\n                1\n            ]\n        ]);\n    }\n    endSMaskMode() {\n        if (!this.inSMaskMode) {\n            throw new Error(\"endSMaskMode called while not in smask mode\");\n        }\n        this.ctx._removeMirroring();\n        copyCtxState(this.ctx, this.suspendedCtx);\n        this.ctx = this.suspendedCtx;\n        this.suspendedCtx = null;\n    }\n    compose(dirtyBox) {\n        if (!this.current.activeSMask) {\n            return;\n        }\n        if (!dirtyBox) {\n            dirtyBox = [\n                0,\n                0,\n                this.ctx.canvas.width,\n                this.ctx.canvas.height\n            ];\n        } else {\n            dirtyBox[0] = Math.floor(dirtyBox[0]);\n            dirtyBox[1] = Math.floor(dirtyBox[1]);\n            dirtyBox[2] = Math.ceil(dirtyBox[2]);\n            dirtyBox[3] = Math.ceil(dirtyBox[3]);\n        }\n        const smask = this.current.activeSMask;\n        const suspendedCtx = this.suspendedCtx;\n        this.composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);\n        this.ctx.save();\n        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n        this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n        this.ctx.restore();\n    }\n    composeSMask(ctx, smask, layerCtx, layerBox) {\n        const layerOffsetX = layerBox[0];\n        const layerOffsetY = layerBox[1];\n        const layerWidth = layerBox[2] - layerOffsetX;\n        const layerHeight = layerBox[3] - layerOffsetY;\n        if (layerWidth === 0 || layerHeight === 0) {\n            return;\n        }\n        this.genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);\n        ctx.save();\n        ctx.globalAlpha = 1;\n        ctx.globalCompositeOperation = \"source-over\";\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.drawImage(layerCtx.canvas, 0, 0);\n        ctx.restore();\n    }\n    genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {\n        let maskCanvas = maskCtx.canvas;\n        let maskX = layerOffsetX - maskOffsetX;\n        let maskY = layerOffsetY - maskOffsetY;\n        if (backdrop) {\n            const backdropRGB = Util.makeHexColor(...backdrop);\n            if (maskX < 0 || maskY < 0 || maskX + width > maskCanvas.width || maskY + height > maskCanvas.height) {\n                const canvas = this.cachedCanvases.getCanvas(\"maskExtension\", width, height);\n                const ctx = canvas.context;\n                ctx.drawImage(maskCanvas, -maskX, -maskY);\n                ctx.globalCompositeOperation = \"destination-atop\";\n                ctx.fillStyle = backdropRGB;\n                ctx.fillRect(0, 0, width, height);\n                ctx.globalCompositeOperation = \"source-over\";\n                maskCanvas = canvas.canvas;\n                maskX = maskY = 0;\n            } else {\n                maskCtx.save();\n                maskCtx.globalAlpha = 1;\n                maskCtx.setTransform(1, 0, 0, 1, 0, 0);\n                const clip = new Path2D();\n                clip.rect(maskX, maskY, width, height);\n                maskCtx.clip(clip);\n                maskCtx.globalCompositeOperation = \"destination-atop\";\n                maskCtx.fillStyle = backdropRGB;\n                maskCtx.fillRect(maskX, maskY, width, height);\n                maskCtx.restore();\n            }\n        }\n        layerCtx.save();\n        layerCtx.globalAlpha = 1;\n        layerCtx.setTransform(1, 0, 0, 1, 0, 0);\n        if (subtype === \"Alpha\" && transferMap) {\n            layerCtx.filter = this.filterFactory.addAlphaFilter(transferMap);\n        } else if (subtype === \"Luminosity\") {\n            layerCtx.filter = this.filterFactory.addLuminosityFilter(transferMap);\n        }\n        const clip = new Path2D();\n        clip.rect(layerOffsetX, layerOffsetY, width, height);\n        layerCtx.clip(clip);\n        layerCtx.globalCompositeOperation = \"destination-in\";\n        layerCtx.drawImage(maskCanvas, maskX, maskY, width, height, layerOffsetX, layerOffsetY, width, height);\n        layerCtx.restore();\n    }\n    save() {\n        if (this.inSMaskMode) {\n            copyCtxState(this.ctx, this.suspendedCtx);\n            this.suspendedCtx.save();\n        } else {\n            this.ctx.save();\n        }\n        const old = this.current;\n        this.stateStack.push(old);\n        this.current = old.clone();\n    }\n    restore() {\n        if (this.stateStack.length === 0 && this.inSMaskMode) {\n            this.endSMaskMode();\n        }\n        if (this.stateStack.length !== 0) {\n            this.current = this.stateStack.pop();\n            if (this.inSMaskMode) {\n                this.suspendedCtx.restore();\n                copyCtxState(this.suspendedCtx, this.ctx);\n            } else {\n                this.ctx.restore();\n            }\n            this.checkSMaskState();\n            this.pendingClip = null;\n            this._cachedScaleForStroking[0] = -1;\n            this._cachedGetSinglePixelWidth = null;\n        }\n    }\n    transform(a, b, c, d, e, f) {\n        this.ctx.transform(a, b, c, d, e, f);\n        this._cachedScaleForStroking[0] = -1;\n        this._cachedGetSinglePixelWidth = null;\n    }\n    constructPath(ops, args, minMax) {\n        const ctx = this.ctx;\n        const current = this.current;\n        let x = current.x, y = current.y;\n        let startX, startY;\n        const currentTransform = getCurrentTransform(ctx);\n        const isScalingMatrix = currentTransform[0] === 0 && currentTransform[3] === 0 || currentTransform[1] === 0 && currentTransform[2] === 0;\n        const minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null;\n        for(let i = 0, j = 0, ii = ops.length; i < ii; i++){\n            switch(ops[i] | 0){\n                case OPS.rectangle:\n                    x = args[j++];\n                    y = args[j++];\n                    const width = args[j++];\n                    const height = args[j++];\n                    const xw = x + width;\n                    const yh = y + height;\n                    ctx.moveTo(x, y);\n                    if (width === 0 || height === 0) {\n                        ctx.lineTo(xw, yh);\n                    } else {\n                        ctx.lineTo(xw, y);\n                        ctx.lineTo(xw, yh);\n                        ctx.lineTo(x, yh);\n                    }\n                    if (!isScalingMatrix) {\n                        current.updateRectMinMax(currentTransform, [\n                            x,\n                            y,\n                            xw,\n                            yh\n                        ]);\n                    }\n                    ctx.closePath();\n                    break;\n                case OPS.moveTo:\n                    x = args[j++];\n                    y = args[j++];\n                    ctx.moveTo(x, y);\n                    if (!isScalingMatrix) {\n                        current.updatePathMinMax(currentTransform, x, y);\n                    }\n                    break;\n                case OPS.lineTo:\n                    x = args[j++];\n                    y = args[j++];\n                    ctx.lineTo(x, y);\n                    if (!isScalingMatrix) {\n                        current.updatePathMinMax(currentTransform, x, y);\n                    }\n                    break;\n                case OPS.curveTo:\n                    startX = x;\n                    startY = y;\n                    x = args[j + 4];\n                    y = args[j + 5];\n                    ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);\n                    current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], args[j + 2], args[j + 3], x, y, minMaxForBezier);\n                    j += 6;\n                    break;\n                case OPS.curveTo2:\n                    startX = x;\n                    startY = y;\n                    ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);\n                    current.updateCurvePathMinMax(currentTransform, startX, startY, x, y, args[j], args[j + 1], args[j + 2], args[j + 3], minMaxForBezier);\n                    x = args[j + 2];\n                    y = args[j + 3];\n                    j += 4;\n                    break;\n                case OPS.curveTo3:\n                    startX = x;\n                    startY = y;\n                    x = args[j + 2];\n                    y = args[j + 3];\n                    ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);\n                    current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], x, y, x, y, minMaxForBezier);\n                    j += 4;\n                    break;\n                case OPS.closePath:\n                    ctx.closePath();\n                    break;\n            }\n        }\n        if (isScalingMatrix) {\n            current.updateScalingPathMinMax(currentTransform, minMaxForBezier);\n        }\n        current.setCurrentPoint(x, y);\n    }\n    closePath() {\n        this.ctx.closePath();\n    }\n    stroke(consumePath = true) {\n        const ctx = this.ctx;\n        const strokeColor = this.current.strokeColor;\n        ctx.globalAlpha = this.current.strokeAlpha;\n        if (this.contentVisible) {\n            if (typeof strokeColor === \"object\" && strokeColor?.getPattern) {\n                ctx.save();\n                ctx.strokeStyle = strokeColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.STROKE);\n                this.rescaleAndStroke(false);\n                ctx.restore();\n            } else {\n                this.rescaleAndStroke(true);\n            }\n        }\n        if (consumePath) {\n            this.consumePath(this.current.getClippedPathBoundingBox());\n        }\n        ctx.globalAlpha = this.current.fillAlpha;\n    }\n    closeStroke() {\n        this.closePath();\n        this.stroke();\n    }\n    fill(consumePath = true) {\n        const ctx = this.ctx;\n        const fillColor = this.current.fillColor;\n        const isPatternFill = this.current.patternFill;\n        let needRestore = false;\n        if (isPatternFill) {\n            ctx.save();\n            ctx.fillStyle = fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL);\n            needRestore = true;\n        }\n        const intersect = this.current.getClippedPathBoundingBox();\n        if (this.contentVisible && intersect !== null) {\n            if (this.pendingEOFill) {\n                ctx.fill(\"evenodd\");\n                this.pendingEOFill = false;\n            } else {\n                ctx.fill();\n            }\n        }\n        if (needRestore) {\n            ctx.restore();\n        }\n        if (consumePath) {\n            this.consumePath(intersect);\n        }\n    }\n    eoFill() {\n        this.pendingEOFill = true;\n        this.fill();\n    }\n    fillStroke() {\n        this.fill(false);\n        this.stroke(false);\n        this.consumePath();\n    }\n    eoFillStroke() {\n        this.pendingEOFill = true;\n        this.fillStroke();\n    }\n    closeFillStroke() {\n        this.closePath();\n        this.fillStroke();\n    }\n    closeEOFillStroke() {\n        this.pendingEOFill = true;\n        this.closePath();\n        this.fillStroke();\n    }\n    endPath() {\n        this.consumePath();\n    }\n    clip() {\n        this.pendingClip = NORMAL_CLIP;\n    }\n    eoClip() {\n        this.pendingClip = EO_CLIP;\n    }\n    beginText() {\n        this.current.textMatrix = IDENTITY_MATRIX;\n        this.current.textMatrixScale = 1;\n        this.current.x = this.current.lineX = 0;\n        this.current.y = this.current.lineY = 0;\n    }\n    endText() {\n        const paths = this.pendingTextPaths;\n        const ctx = this.ctx;\n        if (paths === undefined) {\n            ctx.beginPath();\n            return;\n        }\n        ctx.save();\n        ctx.beginPath();\n        for (const path of paths){\n            ctx.setTransform(...path.transform);\n            ctx.translate(path.x, path.y);\n            path.addToPath(ctx, path.fontSize);\n        }\n        ctx.restore();\n        ctx.clip();\n        ctx.beginPath();\n        delete this.pendingTextPaths;\n    }\n    setCharSpacing(spacing) {\n        this.current.charSpacing = spacing;\n    }\n    setWordSpacing(spacing) {\n        this.current.wordSpacing = spacing;\n    }\n    setHScale(scale) {\n        this.current.textHScale = scale / 100;\n    }\n    setLeading(leading) {\n        this.current.leading = -leading;\n    }\n    setFont(fontRefName, size) {\n        const fontObj = this.commonObjs.get(fontRefName);\n        const current = this.current;\n        if (!fontObj) {\n            throw new Error(`Can't find font for ${fontRefName}`);\n        }\n        current.fontMatrix = fontObj.fontMatrix || FONT_IDENTITY_MATRIX;\n        if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {\n            warn(\"Invalid font matrix for font \" + fontRefName);\n        }\n        if (size < 0) {\n            size = -size;\n            current.fontDirection = -1;\n        } else {\n            current.fontDirection = 1;\n        }\n        this.current.font = fontObj;\n        this.current.fontSize = size;\n        if (fontObj.isType3Font) {\n            return;\n        }\n        const name = fontObj.loadedName || \"sans-serif\";\n        const typeface = fontObj.systemFontInfo?.css || `\"${name}\", ${fontObj.fallbackName}`;\n        let bold = \"normal\";\n        if (fontObj.black) {\n            bold = \"900\";\n        } else if (fontObj.bold) {\n            bold = \"bold\";\n        }\n        const italic = fontObj.italic ? \"italic\" : \"normal\";\n        let browserFontSize = size;\n        if (size < MIN_FONT_SIZE) {\n            browserFontSize = MIN_FONT_SIZE;\n        } else if (size > MAX_FONT_SIZE) {\n            browserFontSize = MAX_FONT_SIZE;\n        }\n        this.current.fontSizeScale = size / browserFontSize;\n        this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;\n    }\n    setTextRenderingMode(mode) {\n        this.current.textRenderingMode = mode;\n    }\n    setTextRise(rise) {\n        this.current.textRise = rise;\n    }\n    moveText(x, y) {\n        this.current.x = this.current.lineX += x;\n        this.current.y = this.current.lineY += y;\n    }\n    setLeadingMoveText(x, y) {\n        this.setLeading(-y);\n        this.moveText(x, y);\n    }\n    setTextMatrix(a, b, c, d, e, f) {\n        this.current.textMatrix = [\n            a,\n            b,\n            c,\n            d,\n            e,\n            f\n        ];\n        this.current.textMatrixScale = Math.hypot(a, b);\n        this.current.x = this.current.lineX = 0;\n        this.current.y = this.current.lineY = 0;\n    }\n    nextLine() {\n        this.moveText(0, this.current.leading);\n    }\n    paintChar(character, x, y, patternFillTransform, patternStrokeTransform) {\n        const ctx = this.ctx;\n        const current = this.current;\n        const font = current.font;\n        const textRenderingMode = current.textRenderingMode;\n        const fontSize = current.fontSize / current.fontSizeScale;\n        const fillStrokeMode = textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;\n        const isAddToPathSet = !!(textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG);\n        const patternFill = current.patternFill && !font.missingFile;\n        const patternStroke = current.patternStroke && !font.missingFile;\n        let addToPath;\n        if (font.disableFontFace || isAddToPathSet || patternFill || patternStroke) {\n            addToPath = font.getPathGenerator(this.commonObjs, character);\n        }\n        if (font.disableFontFace || patternFill || patternStroke) {\n            ctx.save();\n            ctx.translate(x, y);\n            ctx.beginPath();\n            addToPath(ctx, fontSize);\n            if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                if (patternFillTransform) {\n                    ctx.setTransform(...patternFillTransform);\n                }\n                ctx.fill();\n            }\n            if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                if (patternStrokeTransform) {\n                    ctx.setTransform(...patternStrokeTransform);\n                }\n                ctx.stroke();\n            }\n            ctx.restore();\n        } else {\n            if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                ctx.fillText(character, x, y);\n            }\n            if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                ctx.strokeText(character, x, y);\n            }\n        }\n        if (isAddToPathSet) {\n            const paths = this.pendingTextPaths ||= [];\n            paths.push({\n                transform: getCurrentTransform(ctx),\n                x,\n                y,\n                fontSize,\n                addToPath\n            });\n        }\n    }\n    get isFontSubpixelAAEnabled() {\n        const { context: ctx } = this.cachedCanvases.getCanvas(\"isFontSubpixelAAEnabled\", 10, 10);\n        ctx.scale(1.5, 1);\n        ctx.fillText(\"I\", 0, 10);\n        const data = ctx.getImageData(0, 0, 10, 10).data;\n        let enabled = false;\n        for(let i = 3; i < data.length; i += 4){\n            if (data[i] > 0 && data[i] < 255) {\n                enabled = true;\n                break;\n            }\n        }\n        return shadow(this, \"isFontSubpixelAAEnabled\", enabled);\n    }\n    showText(glyphs) {\n        const current = this.current;\n        const font = current.font;\n        if (font.isType3Font) {\n            return this.showType3Text(glyphs);\n        }\n        const fontSize = current.fontSize;\n        if (fontSize === 0) {\n            return undefined;\n        }\n        const ctx = this.ctx;\n        const fontSizeScale = current.fontSizeScale;\n        const charSpacing = current.charSpacing;\n        const wordSpacing = current.wordSpacing;\n        const fontDirection = current.fontDirection;\n        const textHScale = current.textHScale * fontDirection;\n        const glyphsLength = glyphs.length;\n        const vertical = font.vertical;\n        const spacingDir = vertical ? 1 : -1;\n        const defaultVMetrics = font.defaultVMetrics;\n        const widthAdvanceScale = fontSize * current.fontMatrix[0];\n        const simpleFillText = current.textRenderingMode === TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;\n        ctx.save();\n        ctx.transform(...current.textMatrix);\n        ctx.translate(current.x, current.y + current.textRise);\n        if (fontDirection > 0) {\n            ctx.scale(textHScale, -1);\n        } else {\n            ctx.scale(textHScale, 1);\n        }\n        let patternFillTransform, patternStrokeTransform;\n        if (current.patternFill) {\n            ctx.save();\n            const pattern = current.fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL);\n            patternFillTransform = getCurrentTransform(ctx);\n            ctx.restore();\n            ctx.fillStyle = pattern;\n        }\n        if (current.patternStroke) {\n            ctx.save();\n            const pattern = current.strokeColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.STROKE);\n            patternStrokeTransform = getCurrentTransform(ctx);\n            ctx.restore();\n            ctx.strokeStyle = pattern;\n        }\n        let lineWidth = current.lineWidth;\n        const scale = current.textMatrixScale;\n        if (scale === 0 || lineWidth === 0) {\n            const fillStrokeMode = current.textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;\n            if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                lineWidth = this.getSinglePixelWidth();\n            }\n        } else {\n            lineWidth /= scale;\n        }\n        if (fontSizeScale !== 1.0) {\n            ctx.scale(fontSizeScale, fontSizeScale);\n            lineWidth /= fontSizeScale;\n        }\n        ctx.lineWidth = lineWidth;\n        if (font.isInvalidPDFjsFont) {\n            const chars = [];\n            let width = 0;\n            for (const glyph of glyphs){\n                chars.push(glyph.unicode);\n                width += glyph.width;\n            }\n            ctx.fillText(chars.join(\"\"), 0, 0);\n            current.x += width * widthAdvanceScale * textHScale;\n            ctx.restore();\n            this.compose();\n            return undefined;\n        }\n        let x = 0, i;\n        for(i = 0; i < glyphsLength; ++i){\n            const glyph = glyphs[i];\n            if (typeof glyph === \"number\") {\n                x += spacingDir * glyph * fontSize / 1000;\n                continue;\n            }\n            let restoreNeeded = false;\n            const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n            const character = glyph.fontChar;\n            const accent = glyph.accent;\n            let scaledX, scaledY;\n            let width = glyph.width;\n            if (vertical) {\n                const vmetric = glyph.vmetric || defaultVMetrics;\n                const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;\n                const vy = vmetric[2] * widthAdvanceScale;\n                width = vmetric ? -vmetric[0] : width;\n                scaledX = vx / fontSizeScale;\n                scaledY = (x + vy) / fontSizeScale;\n            } else {\n                scaledX = x / fontSizeScale;\n                scaledY = 0;\n            }\n            if (font.remeasure && width > 0) {\n                const measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;\n                if (width < measuredWidth && this.isFontSubpixelAAEnabled) {\n                    const characterScaleX = width / measuredWidth;\n                    restoreNeeded = true;\n                    ctx.save();\n                    ctx.scale(characterScaleX, 1);\n                    scaledX /= characterScaleX;\n                } else if (width !== measuredWidth) {\n                    scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;\n                }\n            }\n            if (this.contentVisible && (glyph.isInFont || font.missingFile)) {\n                if (simpleFillText && !accent) {\n                    ctx.fillText(character, scaledX, scaledY);\n                } else {\n                    this.paintChar(character, scaledX, scaledY, patternFillTransform, patternStrokeTransform);\n                    if (accent) {\n                        const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;\n                        const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;\n                        this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternFillTransform, patternStrokeTransform);\n                    }\n                }\n            }\n            const charWidth = vertical ? width * widthAdvanceScale - spacing * fontDirection : width * widthAdvanceScale + spacing * fontDirection;\n            x += charWidth;\n            if (restoreNeeded) {\n                ctx.restore();\n            }\n        }\n        if (vertical) {\n            current.y -= x;\n        } else {\n            current.x += x * textHScale;\n        }\n        ctx.restore();\n        this.compose();\n        return undefined;\n    }\n    showType3Text(glyphs) {\n        const ctx = this.ctx;\n        const current = this.current;\n        const font = current.font;\n        const fontSize = current.fontSize;\n        const fontDirection = current.fontDirection;\n        const spacingDir = font.vertical ? 1 : -1;\n        const charSpacing = current.charSpacing;\n        const wordSpacing = current.wordSpacing;\n        const textHScale = current.textHScale * fontDirection;\n        const fontMatrix = current.fontMatrix || FONT_IDENTITY_MATRIX;\n        const glyphsLength = glyphs.length;\n        const isTextInvisible = current.textRenderingMode === TextRenderingMode.INVISIBLE;\n        let i, glyph, width, spacingLength;\n        if (isTextInvisible || fontSize === 0) {\n            return;\n        }\n        this._cachedScaleForStroking[0] = -1;\n        this._cachedGetSinglePixelWidth = null;\n        ctx.save();\n        ctx.transform(...current.textMatrix);\n        ctx.translate(current.x, current.y);\n        ctx.scale(textHScale, fontDirection);\n        for(i = 0; i < glyphsLength; ++i){\n            glyph = glyphs[i];\n            if (typeof glyph === \"number\") {\n                spacingLength = spacingDir * glyph * fontSize / 1000;\n                this.ctx.translate(spacingLength, 0);\n                current.x += spacingLength * textHScale;\n                continue;\n            }\n            const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n            const operatorList = font.charProcOperatorList[glyph.operatorListId];\n            if (!operatorList) {\n                warn(`Type3 character \"${glyph.operatorListId}\" is not available.`);\n                continue;\n            }\n            if (this.contentVisible) {\n                this.processingType3 = glyph;\n                this.save();\n                ctx.scale(fontSize, fontSize);\n                ctx.transform(...fontMatrix);\n                this.executeOperatorList(operatorList);\n                this.restore();\n            }\n            const transformed = Util.applyTransform([\n                glyph.width,\n                0\n            ], fontMatrix);\n            width = transformed[0] * fontSize + spacing;\n            ctx.translate(width, 0);\n            current.x += width * textHScale;\n        }\n        ctx.restore();\n        this.processingType3 = null;\n    }\n    setCharWidth(xWidth, yWidth) {}\n    setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {\n        this.ctx.rect(llx, lly, urx - llx, ury - lly);\n        this.ctx.clip();\n        this.endPath();\n    }\n    getColorN_Pattern(IR) {\n        let pattern;\n        if (IR[0] === \"TilingPattern\") {\n            const color = IR[1];\n            const baseTransform = this.baseTransform || getCurrentTransform(this.ctx);\n            const canvasGraphicsFactory = {\n                createCanvasGraphics: (ctx)=>new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {\n                        optionalContentConfig: this.optionalContentConfig,\n                        markedContentStack: this.markedContentStack\n                    })\n            };\n            pattern = new TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);\n        } else {\n            pattern = this._getPattern(IR[1], IR[2]);\n        }\n        return pattern;\n    }\n    setStrokeColorN() {\n        this.current.strokeColor = this.getColorN_Pattern(arguments);\n        this.current.patternStroke = true;\n    }\n    setFillColorN() {\n        this.current.fillColor = this.getColorN_Pattern(arguments);\n        this.current.patternFill = true;\n    }\n    setStrokeRGBColor(r, g, b) {\n        this.ctx.strokeStyle = this.current.strokeColor = Util.makeHexColor(r, g, b);\n        this.current.patternStroke = false;\n    }\n    setStrokeTransparent() {\n        this.ctx.strokeStyle = this.current.strokeColor = \"transparent\";\n        this.current.patternStroke = false;\n    }\n    setFillRGBColor(r, g, b) {\n        this.ctx.fillStyle = this.current.fillColor = Util.makeHexColor(r, g, b);\n        this.current.patternFill = false;\n    }\n    setFillTransparent() {\n        this.ctx.fillStyle = this.current.fillColor = \"transparent\";\n        this.current.patternFill = false;\n    }\n    _getPattern(objId, matrix = null) {\n        let pattern;\n        if (this.cachedPatterns.has(objId)) {\n            pattern = this.cachedPatterns.get(objId);\n        } else {\n            pattern = getShadingPattern(this.getObject(objId));\n            this.cachedPatterns.set(objId, pattern);\n        }\n        if (matrix) {\n            pattern.matrix = matrix;\n        }\n        return pattern;\n    }\n    shadingFill(objId) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const ctx = this.ctx;\n        this.save();\n        const pattern = this._getPattern(objId);\n        ctx.fillStyle = pattern.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.SHADING);\n        const inv = getCurrentTransformInverse(ctx);\n        if (inv) {\n            const { width, height } = ctx.canvas;\n            const [x0, y0, x1, y1] = Util.getAxialAlignedBoundingBox([\n                0,\n                0,\n                width,\n                height\n            ], inv);\n            this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);\n        } else {\n            this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);\n        }\n        this.compose(this.current.getClippedPathBoundingBox());\n        this.restore();\n    }\n    beginInlineImage() {\n        unreachable(\"Should not call beginInlineImage\");\n    }\n    beginImageData() {\n        unreachable(\"Should not call beginImageData\");\n    }\n    paintFormXObjectBegin(matrix, bbox) {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.save();\n        this.baseTransformStack.push(this.baseTransform);\n        if (matrix) {\n            this.transform(...matrix);\n        }\n        this.baseTransform = getCurrentTransform(this.ctx);\n        if (bbox) {\n            const width = bbox[2] - bbox[0];\n            const height = bbox[3] - bbox[1];\n            this.ctx.rect(bbox[0], bbox[1], width, height);\n            this.current.updateRectMinMax(getCurrentTransform(this.ctx), bbox);\n            this.clip();\n            this.endPath();\n        }\n    }\n    paintFormXObjectEnd() {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.restore();\n        this.baseTransform = this.baseTransformStack.pop();\n    }\n    beginGroup(group) {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.save();\n        if (this.inSMaskMode) {\n            this.endSMaskMode();\n            this.current.activeSMask = null;\n        }\n        const currentCtx = this.ctx;\n        if (!group.isolated) {\n            info(\"TODO: Support non-isolated groups.\");\n        }\n        if (group.knockout) {\n            warn(\"Knockout groups not supported.\");\n        }\n        const currentTransform = getCurrentTransform(currentCtx);\n        if (group.matrix) {\n            currentCtx.transform(...group.matrix);\n        }\n        if (!group.bbox) {\n            throw new Error(\"Bounding box is required.\");\n        }\n        let bounds = Util.getAxialAlignedBoundingBox(group.bbox, getCurrentTransform(currentCtx));\n        const canvasBounds = [\n            0,\n            0,\n            currentCtx.canvas.width,\n            currentCtx.canvas.height\n        ];\n        bounds = Util.intersect(bounds, canvasBounds) || [\n            0,\n            0,\n            0,\n            0\n        ];\n        const offsetX = Math.floor(bounds[0]);\n        const offsetY = Math.floor(bounds[1]);\n        const drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);\n        const drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);\n        this.current.startNewPathAndClipBox([\n            0,\n            0,\n            drawnWidth,\n            drawnHeight\n        ]);\n        let cacheId = \"groupAt\" + this.groupLevel;\n        if (group.smask) {\n            cacheId += \"_smask_\" + this.smaskCounter++ % 2;\n        }\n        const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n        const groupCtx = scratchCanvas.context;\n        groupCtx.translate(-offsetX, -offsetY);\n        groupCtx.transform(...currentTransform);\n        if (group.smask) {\n            this.smaskStack.push({\n                canvas: scratchCanvas.canvas,\n                context: groupCtx,\n                offsetX,\n                offsetY,\n                subtype: group.smask.subtype,\n                backdrop: group.smask.backdrop,\n                transferMap: group.smask.transferMap || null,\n                startTransformInverse: null\n            });\n        } else {\n            currentCtx.setTransform(1, 0, 0, 1, 0, 0);\n            currentCtx.translate(offsetX, offsetY);\n            currentCtx.save();\n        }\n        copyCtxState(currentCtx, groupCtx);\n        this.ctx = groupCtx;\n        this.setGState([\n            [\n                \"BM\",\n                \"source-over\"\n            ],\n            [\n                \"ca\",\n                1\n            ],\n            [\n                \"CA\",\n                1\n            ]\n        ]);\n        this.groupStack.push(currentCtx);\n        this.groupLevel++;\n    }\n    endGroup(group) {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.groupLevel--;\n        const groupCtx = this.ctx;\n        const ctx = this.groupStack.pop();\n        this.ctx = ctx;\n        this.ctx.imageSmoothingEnabled = false;\n        if (group.smask) {\n            this.tempSMask = this.smaskStack.pop();\n            this.restore();\n        } else {\n            this.ctx.restore();\n            const currentMtx = getCurrentTransform(this.ctx);\n            this.restore();\n            this.ctx.save();\n            this.ctx.setTransform(...currentMtx);\n            const dirtyBox = Util.getAxialAlignedBoundingBox([\n                0,\n                0,\n                groupCtx.canvas.width,\n                groupCtx.canvas.height\n            ], currentMtx);\n            this.ctx.drawImage(groupCtx.canvas, 0, 0);\n            this.ctx.restore();\n            this.compose(dirtyBox);\n        }\n    }\n    beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {\n        this.#restoreInitialState();\n        resetCtxToDefault(this.ctx);\n        this.ctx.save();\n        this.save();\n        if (this.baseTransform) {\n            this.ctx.setTransform(...this.baseTransform);\n        }\n        if (rect) {\n            const width = rect[2] - rect[0];\n            const height = rect[3] - rect[1];\n            if (hasOwnCanvas && this.annotationCanvasMap) {\n                transform = transform.slice();\n                transform[4] -= rect[0];\n                transform[5] -= rect[1];\n                rect = rect.slice();\n                rect[0] = rect[1] = 0;\n                rect[2] = width;\n                rect[3] = height;\n                const [scaleX, scaleY] = Util.singularValueDecompose2dScale(getCurrentTransform(this.ctx));\n                const { viewportScale } = this;\n                const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);\n                const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);\n                this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);\n                const { canvas, context } = this.annotationCanvas;\n                this.annotationCanvasMap.set(id, canvas);\n                this.annotationCanvas.savedCtx = this.ctx;\n                this.ctx = context;\n                this.ctx.save();\n                this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);\n                resetCtxToDefault(this.ctx);\n            } else {\n                resetCtxToDefault(this.ctx);\n                this.endPath();\n                this.ctx.rect(rect[0], rect[1], width, height);\n                this.ctx.clip();\n                this.ctx.beginPath();\n            }\n        }\n        this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n        this.transform(...transform);\n        this.transform(...matrix);\n    }\n    endAnnotation() {\n        if (this.annotationCanvas) {\n            this.ctx.restore();\n            this.#drawFilter();\n            this.ctx = this.annotationCanvas.savedCtx;\n            delete this.annotationCanvas.savedCtx;\n            delete this.annotationCanvas;\n        }\n    }\n    paintImageMaskXObject(img) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const count = img.count;\n        img = this.getObject(img.data, img);\n        img.count = count;\n        const ctx = this.ctx;\n        const glyph = this.processingType3;\n        if (glyph) {\n            if (glyph.compiled === undefined) {\n                glyph.compiled = compileType3Glyph(img);\n            }\n            if (glyph.compiled) {\n                glyph.compiled(ctx);\n                return;\n            }\n        }\n        const mask = this._createMaskCanvas(img);\n        const maskCanvas = mask.canvas;\n        ctx.save();\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);\n        ctx.restore();\n        this.compose();\n    }\n    paintImageMaskXObjectRepeat(img, scaleX, skewX = 0, skewY = 0, scaleY, positions) {\n        if (!this.contentVisible) {\n            return;\n        }\n        img = this.getObject(img.data, img);\n        const ctx = this.ctx;\n        ctx.save();\n        const currentTransform = getCurrentTransform(ctx);\n        ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);\n        const mask = this._createMaskCanvas(img);\n        ctx.setTransform(1, 0, 0, 1, mask.offsetX - currentTransform[4], mask.offsetY - currentTransform[5]);\n        for(let i = 0, ii = positions.length; i < ii; i += 2){\n            const trans = Util.transform(currentTransform, [\n                scaleX,\n                skewX,\n                skewY,\n                scaleY,\n                positions[i],\n                positions[i + 1]\n            ]);\n            const [x, y] = Util.applyTransform([\n                0,\n                0\n            ], trans);\n            ctx.drawImage(mask.canvas, x, y);\n        }\n        ctx.restore();\n        this.compose();\n    }\n    paintImageMaskXObjectGroup(images) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const ctx = this.ctx;\n        const fillColor = this.current.fillColor;\n        const isPatternFill = this.current.patternFill;\n        for (const image of images){\n            const { data, width, height, transform } = image;\n            const maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n            const maskCtx = maskCanvas.context;\n            maskCtx.save();\n            const img = this.getObject(data, image);\n            putBinaryImageMask(maskCtx, img);\n            maskCtx.globalCompositeOperation = \"source-in\";\n            maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, getCurrentTransformInverse(ctx), PathType.FILL) : fillColor;\n            maskCtx.fillRect(0, 0, width, height);\n            maskCtx.restore();\n            ctx.save();\n            ctx.transform(...transform);\n            ctx.scale(1, -1);\n            drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\n            ctx.restore();\n        }\n        this.compose();\n    }\n    paintImageXObject(objId) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const imgData = this.getObject(objId);\n        if (!imgData) {\n            warn(\"Dependent image isn't ready yet\");\n            return;\n        }\n        this.paintInlineImageXObject(imgData);\n    }\n    paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const imgData = this.getObject(objId);\n        if (!imgData) {\n            warn(\"Dependent image isn't ready yet\");\n            return;\n        }\n        const width = imgData.width;\n        const height = imgData.height;\n        const map = [];\n        for(let i = 0, ii = positions.length; i < ii; i += 2){\n            map.push({\n                transform: [\n                    scaleX,\n                    0,\n                    0,\n                    scaleY,\n                    positions[i],\n                    positions[i + 1]\n                ],\n                x: 0,\n                y: 0,\n                w: width,\n                h: height\n            });\n        }\n        this.paintInlineImageXObjectGroup(imgData, map);\n    }\n    applyTransferMapsToCanvas(ctx) {\n        if (this.current.transferMaps !== \"none\") {\n            ctx.filter = this.current.transferMaps;\n            ctx.drawImage(ctx.canvas, 0, 0);\n            ctx.filter = \"none\";\n        }\n        return ctx.canvas;\n    }\n    applyTransferMapsToBitmap(imgData) {\n        if (this.current.transferMaps === \"none\") {\n            return imgData.bitmap;\n        }\n        const { bitmap, width, height } = imgData;\n        const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n        const tmpCtx = tmpCanvas.context;\n        tmpCtx.filter = this.current.transferMaps;\n        tmpCtx.drawImage(bitmap, 0, 0);\n        tmpCtx.filter = \"none\";\n        return tmpCanvas.canvas;\n    }\n    paintInlineImageXObject(imgData) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const width = imgData.width;\n        const height = imgData.height;\n        const ctx = this.ctx;\n        this.save();\n        if (!isNodeJS) {\n            const { filter } = ctx;\n            if (filter !== \"none\" && filter !== \"\") {\n                ctx.filter = \"none\";\n            }\n        }\n        ctx.scale(1 / width, -1 / height);\n        let imgToPaint;\n        if (imgData.bitmap) {\n            imgToPaint = this.applyTransferMapsToBitmap(imgData);\n        } else if (typeof HTMLElement === \"function\" && imgData instanceof HTMLElement || !imgData.data) {\n            imgToPaint = imgData;\n        } else {\n            const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n            const tmpCtx = tmpCanvas.context;\n            putBinaryImageData(tmpCtx, imgData);\n            imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);\n        }\n        const scaled = this._scaleImage(imgToPaint, getCurrentTransformInverse(ctx));\n        ctx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(ctx), imgData.interpolate);\n        drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);\n        this.compose();\n        this.restore();\n    }\n    paintInlineImageXObjectGroup(imgData, map) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const ctx = this.ctx;\n        let imgToPaint;\n        if (imgData.bitmap) {\n            imgToPaint = imgData.bitmap;\n        } else {\n            const w = imgData.width;\n            const h = imgData.height;\n            const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", w, h);\n            const tmpCtx = tmpCanvas.context;\n            putBinaryImageData(tmpCtx, imgData);\n            imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);\n        }\n        for (const entry of map){\n            ctx.save();\n            ctx.transform(...entry.transform);\n            ctx.scale(1, -1);\n            drawImageAtIntegerCoords(ctx, imgToPaint, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);\n            ctx.restore();\n        }\n        this.compose();\n    }\n    paintSolidColorImageMask() {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.ctx.fillRect(0, 0, 1, 1);\n        this.compose();\n    }\n    markPoint(tag) {}\n    markPointProps(tag, properties) {}\n    beginMarkedContent(tag) {\n        this.markedContentStack.push({\n            visible: true\n        });\n    }\n    beginMarkedContentProps(tag, properties) {\n        if (tag === \"OC\") {\n            this.markedContentStack.push({\n                visible: this.optionalContentConfig.isVisible(properties)\n            });\n        } else {\n            this.markedContentStack.push({\n                visible: true\n            });\n        }\n        this.contentVisible = this.isContentVisible();\n    }\n    endMarkedContent() {\n        this.markedContentStack.pop();\n        this.contentVisible = this.isContentVisible();\n    }\n    beginCompat() {}\n    endCompat() {}\n    consumePath(clipBox) {\n        const isEmpty = this.current.isEmptyClip();\n        if (this.pendingClip) {\n            this.current.updateClipFromPath();\n        }\n        if (!this.pendingClip) {\n            this.compose(clipBox);\n        }\n        const ctx = this.ctx;\n        if (this.pendingClip) {\n            if (!isEmpty) {\n                if (this.pendingClip === EO_CLIP) {\n                    ctx.clip(\"evenodd\");\n                } else {\n                    ctx.clip();\n                }\n            }\n            this.pendingClip = null;\n        }\n        this.current.startNewPathAndClipBox(this.current.clipBox);\n        ctx.beginPath();\n    }\n    getSinglePixelWidth() {\n        if (!this._cachedGetSinglePixelWidth) {\n            const m = getCurrentTransform(this.ctx);\n            if (m[1] === 0 && m[2] === 0) {\n                this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));\n            } else {\n                const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);\n                const normX = Math.hypot(m[0], m[2]);\n                const normY = Math.hypot(m[1], m[3]);\n                this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;\n            }\n        }\n        return this._cachedGetSinglePixelWidth;\n    }\n    getScaleForStroking() {\n        if (this._cachedScaleForStroking[0] === -1) {\n            const { lineWidth } = this.current;\n            const { a, b, c, d } = this.ctx.getTransform();\n            let scaleX, scaleY;\n            if (b === 0 && c === 0) {\n                const normX = Math.abs(a);\n                const normY = Math.abs(d);\n                if (normX === normY) {\n                    if (lineWidth === 0) {\n                        scaleX = scaleY = 1 / normX;\n                    } else {\n                        const scaledLineWidth = normX * lineWidth;\n                        scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;\n                    }\n                } else if (lineWidth === 0) {\n                    scaleX = 1 / normX;\n                    scaleY = 1 / normY;\n                } else {\n                    const scaledXLineWidth = normX * lineWidth;\n                    const scaledYLineWidth = normY * lineWidth;\n                    scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;\n                    scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;\n                }\n            } else {\n                const absDet = Math.abs(a * d - b * c);\n                const normX = Math.hypot(a, b);\n                const normY = Math.hypot(c, d);\n                if (lineWidth === 0) {\n                    scaleX = normY / absDet;\n                    scaleY = normX / absDet;\n                } else {\n                    const baseArea = lineWidth * absDet;\n                    scaleX = normY > baseArea ? normY / baseArea : 1;\n                    scaleY = normX > baseArea ? normX / baseArea : 1;\n                }\n            }\n            this._cachedScaleForStroking[0] = scaleX;\n            this._cachedScaleForStroking[1] = scaleY;\n        }\n        return this._cachedScaleForStroking;\n    }\n    rescaleAndStroke(saveRestore) {\n        const { ctx } = this;\n        const { lineWidth } = this.current;\n        const [scaleX, scaleY] = this.getScaleForStroking();\n        ctx.lineWidth = lineWidth || 1;\n        if (scaleX === 1 && scaleY === 1) {\n            ctx.stroke();\n            return;\n        }\n        const dashes = ctx.getLineDash();\n        if (saveRestore) {\n            ctx.save();\n        }\n        ctx.scale(scaleX, scaleY);\n        if (dashes.length > 0) {\n            const scale = Math.max(scaleX, scaleY);\n            ctx.setLineDash(dashes.map((x)=>x / scale));\n            ctx.lineDashOffset /= scale;\n        }\n        ctx.stroke();\n        if (saveRestore) {\n            ctx.restore();\n        }\n    }\n    isContentVisible() {\n        for(let i = this.markedContentStack.length - 1; i >= 0; i--){\n            if (!this.markedContentStack[i].visible) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nfor(const op in OPS){\n    if (CanvasGraphics.prototype[op] !== undefined) {\n        CanvasGraphics.prototype[OPS[op]] = CanvasGraphics.prototype[op];\n    }\n}\n; // ./src/display/worker_options.js\nclass GlobalWorkerOptions {\n    static #port = null;\n    static #src = \"\";\n    static get workerPort() {\n        return this.#port;\n    }\n    static set workerPort(val) {\n        if (!(typeof Worker !== \"undefined\" && val instanceof Worker) && val !== null) {\n            throw new Error(\"Invalid `workerPort` type.\");\n        }\n        this.#port = val;\n    }\n    static get workerSrc() {\n        return this.#src;\n    }\n    static set workerSrc(val) {\n        if (typeof val !== \"string\") {\n            throw new Error(\"Invalid `workerSrc` type.\");\n        }\n        this.#src = val;\n    }\n}\n; // ./src/shared/message_handler.js\nconst CallbackKind = {\n    UNKNOWN: 0,\n    DATA: 1,\n    ERROR: 2\n};\nconst StreamKind = {\n    UNKNOWN: 0,\n    CANCEL: 1,\n    CANCEL_COMPLETE: 2,\n    CLOSE: 3,\n    ENQUEUE: 4,\n    ERROR: 5,\n    PULL: 6,\n    PULL_COMPLETE: 7,\n    START_COMPLETE: 8\n};\nfunction onFn() {}\nfunction wrapReason(reason) {\n    if (!(reason instanceof Error || typeof reason === \"object\" && reason !== null)) {\n        unreachable('wrapReason: Expected \"reason\" to be a (possibly cloned) Error.');\n    }\n    switch(reason.name){\n        case \"AbortException\":\n            return new AbortException(reason.message);\n        case \"MissingPDFException\":\n            return new MissingPDFException(reason.message);\n        case \"PasswordException\":\n            return new PasswordException(reason.message, reason.code);\n        case \"UnexpectedResponseException\":\n            return new UnexpectedResponseException(reason.message, reason.status);\n        case \"UnknownErrorException\":\n            return new UnknownErrorException(reason.message, reason.details);\n        default:\n            return new UnknownErrorException(reason.message, reason.toString());\n    }\n}\nclass MessageHandler {\n    #messageAC;\n    constructor(sourceName, targetName, comObj){\n        this.#messageAC = new AbortController();\n        this.sourceName = sourceName;\n        this.targetName = targetName;\n        this.comObj = comObj;\n        this.callbackId = 1;\n        this.streamId = 1;\n        this.streamSinks = Object.create(null);\n        this.streamControllers = Object.create(null);\n        this.callbackCapabilities = Object.create(null);\n        this.actionHandler = Object.create(null);\n        comObj.addEventListener(\"message\", this.#onMessage.bind(this), {\n            signal: this.#messageAC.signal\n        });\n    }\n    #onMessage({ data }) {\n        if (data.targetName !== this.sourceName) {\n            return;\n        }\n        if (data.stream) {\n            this.#processStreamMessage(data);\n            return;\n        }\n        if (data.callback) {\n            const callbackId = data.callbackId;\n            const capability = this.callbackCapabilities[callbackId];\n            if (!capability) {\n                throw new Error(`Cannot resolve callback ${callbackId}`);\n            }\n            delete this.callbackCapabilities[callbackId];\n            if (data.callback === CallbackKind.DATA) {\n                capability.resolve(data.data);\n            } else if (data.callback === CallbackKind.ERROR) {\n                capability.reject(wrapReason(data.reason));\n            } else {\n                throw new Error(\"Unexpected callback case\");\n            }\n            return;\n        }\n        const action = this.actionHandler[data.action];\n        if (!action) {\n            throw new Error(`Unknown action from worker: ${data.action}`);\n        }\n        if (data.callbackId) {\n            const sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;\n            Promise.try(action, data.data).then(function(result) {\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    callback: CallbackKind.DATA,\n                    callbackId: data.callbackId,\n                    data: result\n                });\n            }, function(reason) {\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    callback: CallbackKind.ERROR,\n                    callbackId: data.callbackId,\n                    reason: wrapReason(reason)\n                });\n            });\n            return;\n        }\n        if (data.streamId) {\n            this.#createStreamSink(data);\n            return;\n        }\n        action(data.data);\n    }\n    on(actionName, handler) {\n        const ah = this.actionHandler;\n        if (ah[actionName]) {\n            throw new Error(`There is already an actionName called \"${actionName}\"`);\n        }\n        ah[actionName] = handler;\n    }\n    send(actionName, data, transfers) {\n        this.comObj.postMessage({\n            sourceName: this.sourceName,\n            targetName: this.targetName,\n            action: actionName,\n            data\n        }, transfers);\n    }\n    sendWithPromise(actionName, data, transfers) {\n        const callbackId = this.callbackId++;\n        const capability = Promise.withResolvers();\n        this.callbackCapabilities[callbackId] = capability;\n        try {\n            this.comObj.postMessage({\n                sourceName: this.sourceName,\n                targetName: this.targetName,\n                action: actionName,\n                callbackId,\n                data\n            }, transfers);\n        } catch (ex) {\n            capability.reject(ex);\n        }\n        return capability.promise;\n    }\n    sendWithStream(actionName, data, queueingStrategy, transfers) {\n        const streamId = this.streamId++, sourceName = this.sourceName, targetName = this.targetName, comObj = this.comObj;\n        return new ReadableStream({\n            start: (controller)=>{\n                const startCapability = Promise.withResolvers();\n                this.streamControllers[streamId] = {\n                    controller,\n                    startCall: startCapability,\n                    pullCall: null,\n                    cancelCall: null,\n                    isClosed: false\n                };\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    action: actionName,\n                    streamId,\n                    data,\n                    desiredSize: controller.desiredSize\n                }, transfers);\n                return startCapability.promise;\n            },\n            pull: (controller)=>{\n                const pullCapability = Promise.withResolvers();\n                this.streamControllers[streamId].pullCall = pullCapability;\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.PULL,\n                    streamId,\n                    desiredSize: controller.desiredSize\n                });\n                return pullCapability.promise;\n            },\n            cancel: (reason)=>{\n                assert(reason instanceof Error, \"cancel must have a valid reason\");\n                const cancelCapability = Promise.withResolvers();\n                this.streamControllers[streamId].cancelCall = cancelCapability;\n                this.streamControllers[streamId].isClosed = true;\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.CANCEL,\n                    streamId,\n                    reason: wrapReason(reason)\n                });\n                return cancelCapability.promise;\n            }\n        }, queueingStrategy);\n    }\n    #createStreamSink(data) {\n        const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;\n        const self = this, action = this.actionHandler[data.action];\n        const streamSink = {\n            enqueue (chunk, size = 1, transfers) {\n                if (this.isCancelled) {\n                    return;\n                }\n                const lastDesiredSize = this.desiredSize;\n                this.desiredSize -= size;\n                if (lastDesiredSize > 0 && this.desiredSize <= 0) {\n                    this.sinkCapability = Promise.withResolvers();\n                    this.ready = this.sinkCapability.promise;\n                }\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.ENQUEUE,\n                    streamId,\n                    chunk\n                }, transfers);\n            },\n            close () {\n                if (this.isCancelled) {\n                    return;\n                }\n                this.isCancelled = true;\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.CLOSE,\n                    streamId\n                });\n                delete self.streamSinks[streamId];\n            },\n            error (reason) {\n                assert(reason instanceof Error, \"error must have a valid reason\");\n                if (this.isCancelled) {\n                    return;\n                }\n                this.isCancelled = true;\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.ERROR,\n                    streamId,\n                    reason: wrapReason(reason)\n                });\n            },\n            sinkCapability: Promise.withResolvers(),\n            onPull: null,\n            onCancel: null,\n            isCancelled: false,\n            desiredSize: data.desiredSize,\n            ready: null\n        };\n        streamSink.sinkCapability.resolve();\n        streamSink.ready = streamSink.sinkCapability.promise;\n        this.streamSinks[streamId] = streamSink;\n        Promise.try(action, data.data, streamSink).then(function() {\n            comObj.postMessage({\n                sourceName,\n                targetName,\n                stream: StreamKind.START_COMPLETE,\n                streamId,\n                success: true\n            });\n        }, function(reason) {\n            comObj.postMessage({\n                sourceName,\n                targetName,\n                stream: StreamKind.START_COMPLETE,\n                streamId,\n                reason: wrapReason(reason)\n            });\n        });\n    }\n    #processStreamMessage(data) {\n        const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;\n        const streamController = this.streamControllers[streamId], streamSink = this.streamSinks[streamId];\n        switch(data.stream){\n            case StreamKind.START_COMPLETE:\n                if (data.success) {\n                    streamController.startCall.resolve();\n                } else {\n                    streamController.startCall.reject(wrapReason(data.reason));\n                }\n                break;\n            case StreamKind.PULL_COMPLETE:\n                if (data.success) {\n                    streamController.pullCall.resolve();\n                } else {\n                    streamController.pullCall.reject(wrapReason(data.reason));\n                }\n                break;\n            case StreamKind.PULL:\n                if (!streamSink) {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.PULL_COMPLETE,\n                        streamId,\n                        success: true\n                    });\n                    break;\n                }\n                if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {\n                    streamSink.sinkCapability.resolve();\n                }\n                streamSink.desiredSize = data.desiredSize;\n                Promise.try(streamSink.onPull || onFn).then(function() {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.PULL_COMPLETE,\n                        streamId,\n                        success: true\n                    });\n                }, function(reason) {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.PULL_COMPLETE,\n                        streamId,\n                        reason: wrapReason(reason)\n                    });\n                });\n                break;\n            case StreamKind.ENQUEUE:\n                assert(streamController, \"enqueue should have stream controller\");\n                if (streamController.isClosed) {\n                    break;\n                }\n                streamController.controller.enqueue(data.chunk);\n                break;\n            case StreamKind.CLOSE:\n                assert(streamController, \"close should have stream controller\");\n                if (streamController.isClosed) {\n                    break;\n                }\n                streamController.isClosed = true;\n                streamController.controller.close();\n                this.#deleteStreamController(streamController, streamId);\n                break;\n            case StreamKind.ERROR:\n                assert(streamController, \"error should have stream controller\");\n                streamController.controller.error(wrapReason(data.reason));\n                this.#deleteStreamController(streamController, streamId);\n                break;\n            case StreamKind.CANCEL_COMPLETE:\n                if (data.success) {\n                    streamController.cancelCall.resolve();\n                } else {\n                    streamController.cancelCall.reject(wrapReason(data.reason));\n                }\n                this.#deleteStreamController(streamController, streamId);\n                break;\n            case StreamKind.CANCEL:\n                if (!streamSink) {\n                    break;\n                }\n                const dataReason = wrapReason(data.reason);\n                Promise.try(streamSink.onCancel || onFn, dataReason).then(function() {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.CANCEL_COMPLETE,\n                        streamId,\n                        success: true\n                    });\n                }, function(reason) {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.CANCEL_COMPLETE,\n                        streamId,\n                        reason: wrapReason(reason)\n                    });\n                });\n                streamSink.sinkCapability.reject(dataReason);\n                streamSink.isCancelled = true;\n                delete this.streamSinks[streamId];\n                break;\n            default:\n                throw new Error(\"Unexpected stream case\");\n        }\n    }\n    async #deleteStreamController(streamController, streamId) {\n        await Promise.allSettled([\n            streamController.startCall?.promise,\n            streamController.pullCall?.promise,\n            streamController.cancelCall?.promise\n        ]);\n        delete this.streamControllers[streamId];\n    }\n    destroy() {\n        this.#messageAC?.abort();\n        this.#messageAC = null;\n    }\n}\n; // ./src/display/metadata.js\nclass Metadata {\n    #metadataMap;\n    #data;\n    constructor({ parsedData, rawData }){\n        this.#metadataMap = parsedData;\n        this.#data = rawData;\n    }\n    getRaw() {\n        return this.#data;\n    }\n    get(name) {\n        return this.#metadataMap.get(name) ?? null;\n    }\n    getAll() {\n        return objectFromMap(this.#metadataMap);\n    }\n    has(name) {\n        return this.#metadataMap.has(name);\n    }\n}\n; // ./src/display/optional_content_config.js\nconst INTERNAL = Symbol(\"INTERNAL\");\nclass OptionalContentGroup {\n    #isDisplay;\n    #isPrint;\n    #userSet;\n    #visible;\n    constructor(renderingIntent, { name, intent, usage, rbGroups }){\n        this.#isDisplay = false;\n        this.#isPrint = false;\n        this.#userSet = false;\n        this.#visible = true;\n        this.#isDisplay = !!(renderingIntent & RenderingIntentFlag.DISPLAY);\n        this.#isPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);\n        this.name = name;\n        this.intent = intent;\n        this.usage = usage;\n        this.rbGroups = rbGroups;\n    }\n    get visible() {\n        if (this.#userSet) {\n            return this.#visible;\n        }\n        if (!this.#visible) {\n            return false;\n        }\n        const { print, view } = this.usage;\n        if (this.#isDisplay) {\n            return view?.viewState !== \"OFF\";\n        } else if (this.#isPrint) {\n            return print?.printState !== \"OFF\";\n        }\n        return true;\n    }\n    _setVisible(internal, visible, userSet = false) {\n        if (internal !== INTERNAL) {\n            unreachable(\"Internal method `_setVisible` called.\");\n        }\n        this.#userSet = userSet;\n        this.#visible = visible;\n    }\n}\nclass OptionalContentConfig {\n    #cachedGetHash;\n    #groups;\n    #initialHash;\n    #order;\n    constructor(data, renderingIntent = RenderingIntentFlag.DISPLAY){\n        this.#cachedGetHash = null;\n        this.#groups = new Map();\n        this.#initialHash = null;\n        this.#order = null;\n        this.renderingIntent = renderingIntent;\n        this.name = null;\n        this.creator = null;\n        if (data === null) {\n            return;\n        }\n        this.name = data.name;\n        this.creator = data.creator;\n        this.#order = data.order;\n        for (const group of data.groups){\n            this.#groups.set(group.id, new OptionalContentGroup(renderingIntent, group));\n        }\n        if (data.baseState === \"OFF\") {\n            for (const group of this.#groups.values()){\n                group._setVisible(INTERNAL, false);\n            }\n        }\n        for (const on of data.on){\n            this.#groups.get(on)._setVisible(INTERNAL, true);\n        }\n        for (const off of data.off){\n            this.#groups.get(off)._setVisible(INTERNAL, false);\n        }\n        this.#initialHash = this.getHash();\n    }\n    #evaluateVisibilityExpression(array) {\n        const length = array.length;\n        if (length < 2) {\n            return true;\n        }\n        const operator = array[0];\n        for(let i = 1; i < length; i++){\n            const element = array[i];\n            let state;\n            if (Array.isArray(element)) {\n                state = this.#evaluateVisibilityExpression(element);\n            } else if (this.#groups.has(element)) {\n                state = this.#groups.get(element).visible;\n            } else {\n                warn(`Optional content group not found: ${element}`);\n                return true;\n            }\n            switch(operator){\n                case \"And\":\n                    if (!state) {\n                        return false;\n                    }\n                    break;\n                case \"Or\":\n                    if (state) {\n                        return true;\n                    }\n                    break;\n                case \"Not\":\n                    return !state;\n                default:\n                    return true;\n            }\n        }\n        return operator === \"And\";\n    }\n    isVisible(group) {\n        if (this.#groups.size === 0) {\n            return true;\n        }\n        if (!group) {\n            info(\"Optional content group not defined.\");\n            return true;\n        }\n        if (group.type === \"OCG\") {\n            if (!this.#groups.has(group.id)) {\n                warn(`Optional content group not found: ${group.id}`);\n                return true;\n            }\n            return this.#groups.get(group.id).visible;\n        } else if (group.type === \"OCMD\") {\n            if (group.expression) {\n                return this.#evaluateVisibilityExpression(group.expression);\n            }\n            if (!group.policy || group.policy === \"AnyOn\") {\n                for (const id of group.ids){\n                    if (!this.#groups.has(id)) {\n                        warn(`Optional content group not found: ${id}`);\n                        return true;\n                    }\n                    if (this.#groups.get(id).visible) {\n                        return true;\n                    }\n                }\n                return false;\n            } else if (group.policy === \"AllOn\") {\n                for (const id of group.ids){\n                    if (!this.#groups.has(id)) {\n                        warn(`Optional content group not found: ${id}`);\n                        return true;\n                    }\n                    if (!this.#groups.get(id).visible) {\n                        return false;\n                    }\n                }\n                return true;\n            } else if (group.policy === \"AnyOff\") {\n                for (const id of group.ids){\n                    if (!this.#groups.has(id)) {\n                        warn(`Optional content group not found: ${id}`);\n                        return true;\n                    }\n                    if (!this.#groups.get(id).visible) {\n                        return true;\n                    }\n                }\n                return false;\n            } else if (group.policy === \"AllOff\") {\n                for (const id of group.ids){\n                    if (!this.#groups.has(id)) {\n                        warn(`Optional content group not found: ${id}`);\n                        return true;\n                    }\n                    if (this.#groups.get(id).visible) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            warn(`Unknown optional content policy ${group.policy}.`);\n            return true;\n        }\n        warn(`Unknown group type ${group.type}.`);\n        return true;\n    }\n    setVisibility(id, visible = true, preserveRB = true) {\n        const group = this.#groups.get(id);\n        if (!group) {\n            warn(`Optional content group not found: ${id}`);\n            return;\n        }\n        if (preserveRB && visible && group.rbGroups.length) {\n            for (const rbGroup of group.rbGroups){\n                for (const otherId of rbGroup){\n                    if (otherId !== id) {\n                        this.#groups.get(otherId)?._setVisible(INTERNAL, false, true);\n                    }\n                }\n            }\n        }\n        group._setVisible(INTERNAL, !!visible, true);\n        this.#cachedGetHash = null;\n    }\n    setOCGState({ state, preserveRB }) {\n        let operator;\n        for (const elem of state){\n            switch(elem){\n                case \"ON\":\n                case \"OFF\":\n                case \"Toggle\":\n                    operator = elem;\n                    continue;\n            }\n            const group = this.#groups.get(elem);\n            if (!group) {\n                continue;\n            }\n            switch(operator){\n                case \"ON\":\n                    this.setVisibility(elem, true, preserveRB);\n                    break;\n                case \"OFF\":\n                    this.setVisibility(elem, false, preserveRB);\n                    break;\n                case \"Toggle\":\n                    this.setVisibility(elem, !group.visible, preserveRB);\n                    break;\n            }\n        }\n        this.#cachedGetHash = null;\n    }\n    get hasInitialVisibility() {\n        return this.#initialHash === null || this.getHash() === this.#initialHash;\n    }\n    getOrder() {\n        if (!this.#groups.size) {\n            return null;\n        }\n        if (this.#order) {\n            return this.#order.slice();\n        }\n        return [\n            ...this.#groups.keys()\n        ];\n    }\n    getGroups() {\n        return this.#groups.size > 0 ? objectFromMap(this.#groups) : null;\n    }\n    getGroup(id) {\n        return this.#groups.get(id) || null;\n    }\n    getHash() {\n        if (this.#cachedGetHash !== null) {\n            return this.#cachedGetHash;\n        }\n        const hash = new MurmurHash3_64();\n        for (const [id, group] of this.#groups){\n            hash.update(`${id}:${group.visible}`);\n        }\n        return this.#cachedGetHash = hash.hexdigest();\n    }\n}\n; // ./src/display/transport_stream.js\nclass PDFDataTransportStream {\n    constructor(pdfDataRangeTransport, { disableRange = false, disableStream = false }){\n        assert(pdfDataRangeTransport, 'PDFDataTransportStream - missing required \"pdfDataRangeTransport\" argument.');\n        const { length, initialData, progressiveDone, contentDispositionFilename } = pdfDataRangeTransport;\n        this._queuedChunks = [];\n        this._progressiveDone = progressiveDone;\n        this._contentDispositionFilename = contentDispositionFilename;\n        if (initialData?.length > 0) {\n            const buffer = initialData instanceof Uint8Array && initialData.byteLength === initialData.buffer.byteLength ? initialData.buffer : new Uint8Array(initialData).buffer;\n            this._queuedChunks.push(buffer);\n        }\n        this._pdfDataRangeTransport = pdfDataRangeTransport;\n        this._isStreamingSupported = !disableStream;\n        this._isRangeSupported = !disableRange;\n        this._contentLength = length;\n        this._fullRequestReader = null;\n        this._rangeReaders = [];\n        pdfDataRangeTransport.addRangeListener((begin, chunk)=>{\n            this._onReceiveData({\n                begin,\n                chunk\n            });\n        });\n        pdfDataRangeTransport.addProgressListener((loaded, total)=>{\n            this._onProgress({\n                loaded,\n                total\n            });\n        });\n        pdfDataRangeTransport.addProgressiveReadListener((chunk)=>{\n            this._onReceiveData({\n                chunk\n            });\n        });\n        pdfDataRangeTransport.addProgressiveDoneListener(()=>{\n            this._onProgressiveDone();\n        });\n        pdfDataRangeTransport.transportReady();\n    }\n    _onReceiveData({ begin, chunk }) {\n        const buffer = chunk instanceof Uint8Array && chunk.byteLength === chunk.buffer.byteLength ? chunk.buffer : new Uint8Array(chunk).buffer;\n        if (begin === undefined) {\n            if (this._fullRequestReader) {\n                this._fullRequestReader._enqueue(buffer);\n            } else {\n                this._queuedChunks.push(buffer);\n            }\n        } else {\n            const found = this._rangeReaders.some(function(rangeReader) {\n                if (rangeReader._begin !== begin) {\n                    return false;\n                }\n                rangeReader._enqueue(buffer);\n                return true;\n            });\n            assert(found, \"_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.\");\n        }\n    }\n    get _progressiveDataLength() {\n        return this._fullRequestReader?._loaded ?? 0;\n    }\n    _onProgress(evt) {\n        if (evt.total === undefined) {\n            this._rangeReaders[0]?.onProgress?.({\n                loaded: evt.loaded\n            });\n        } else {\n            this._fullRequestReader?.onProgress?.({\n                loaded: evt.loaded,\n                total: evt.total\n            });\n        }\n    }\n    _onProgressiveDone() {\n        this._fullRequestReader?.progressiveDone();\n        this._progressiveDone = true;\n    }\n    _removeRangeReader(reader) {\n        const i = this._rangeReaders.indexOf(reader);\n        if (i >= 0) {\n            this._rangeReaders.splice(i, 1);\n        }\n    }\n    getFullReader() {\n        assert(!this._fullRequestReader, \"PDFDataTransportStream.getFullReader can only be called once.\");\n        const queuedChunks = this._queuedChunks;\n        this._queuedChunks = null;\n        return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);\n    }\n    getRangeReader(begin, end) {\n        if (end <= this._progressiveDataLength) {\n            return null;\n        }\n        const reader = new PDFDataTransportStreamRangeReader(this, begin, end);\n        this._pdfDataRangeTransport.requestDataRange(begin, end);\n        this._rangeReaders.push(reader);\n        return reader;\n    }\n    cancelAllRequests(reason) {\n        this._fullRequestReader?.cancel(reason);\n        for (const reader of this._rangeReaders.slice(0)){\n            reader.cancel(reason);\n        }\n        this._pdfDataRangeTransport.abort();\n    }\n}\nclass PDFDataTransportStreamReader {\n    constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null){\n        this._stream = stream;\n        this._done = progressiveDone || false;\n        this._filename = isPdfFile(contentDispositionFilename) ? contentDispositionFilename : null;\n        this._queuedChunks = queuedChunks || [];\n        this._loaded = 0;\n        for (const chunk of this._queuedChunks){\n            this._loaded += chunk.byteLength;\n        }\n        this._requests = [];\n        this._headersReady = Promise.resolve();\n        stream._fullRequestReader = this;\n        this.onProgress = null;\n    }\n    _enqueue(chunk) {\n        if (this._done) {\n            return;\n        }\n        if (this._requests.length > 0) {\n            const requestCapability = this._requests.shift();\n            requestCapability.resolve({\n                value: chunk,\n                done: false\n            });\n        } else {\n            this._queuedChunks.push(chunk);\n        }\n        this._loaded += chunk.byteLength;\n    }\n    get headersReady() {\n        return this._headersReady;\n    }\n    get filename() {\n        return this._filename;\n    }\n    get isRangeSupported() {\n        return this._stream._isRangeSupported;\n    }\n    get isStreamingSupported() {\n        return this._stream._isStreamingSupported;\n    }\n    get contentLength() {\n        return this._stream._contentLength;\n    }\n    async read() {\n        if (this._queuedChunks.length > 0) {\n            const chunk = this._queuedChunks.shift();\n            return {\n                value: chunk,\n                done: false\n            };\n        }\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        const requestCapability = Promise.withResolvers();\n        this._requests.push(requestCapability);\n        return requestCapability.promise;\n    }\n    cancel(reason) {\n        this._done = true;\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n    }\n    progressiveDone() {\n        if (this._done) {\n            return;\n        }\n        this._done = true;\n    }\n}\nclass PDFDataTransportStreamRangeReader {\n    constructor(stream, begin, end){\n        this._stream = stream;\n        this._begin = begin;\n        this._end = end;\n        this._queuedChunk = null;\n        this._requests = [];\n        this._done = false;\n        this.onProgress = null;\n    }\n    _enqueue(chunk) {\n        if (this._done) {\n            return;\n        }\n        if (this._requests.length === 0) {\n            this._queuedChunk = chunk;\n        } else {\n            const requestsCapability = this._requests.shift();\n            requestsCapability.resolve({\n                value: chunk,\n                done: false\n            });\n            for (const requestCapability of this._requests){\n                requestCapability.resolve({\n                    value: undefined,\n                    done: true\n                });\n            }\n            this._requests.length = 0;\n        }\n        this._done = true;\n        this._stream._removeRangeReader(this);\n    }\n    get isStreamingSupported() {\n        return false;\n    }\n    async read() {\n        if (this._queuedChunk) {\n            const chunk = this._queuedChunk;\n            this._queuedChunk = null;\n            return {\n                value: chunk,\n                done: false\n            };\n        }\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        const requestCapability = Promise.withResolvers();\n        this._requests.push(requestCapability);\n        return requestCapability.promise;\n    }\n    cancel(reason) {\n        this._done = true;\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n        this._stream._removeRangeReader(this);\n    }\n}\n; // ./src/display/content_disposition.js\nfunction getFilenameFromContentDispositionHeader(contentDisposition) {\n    let needsEncodingFixup = true;\n    let tmp = toParamRegExp(\"filename\\\\*\", \"i\").exec(contentDisposition);\n    if (tmp) {\n        tmp = tmp[1];\n        let filename = rfc2616unquote(tmp);\n        filename = unescape(filename);\n        filename = rfc5987decode(filename);\n        filename = rfc2047decode(filename);\n        return fixupEncoding(filename);\n    }\n    tmp = rfc2231getparam(contentDisposition);\n    if (tmp) {\n        const filename = rfc2047decode(tmp);\n        return fixupEncoding(filename);\n    }\n    tmp = toParamRegExp(\"filename\", \"i\").exec(contentDisposition);\n    if (tmp) {\n        tmp = tmp[1];\n        let filename = rfc2616unquote(tmp);\n        filename = rfc2047decode(filename);\n        return fixupEncoding(filename);\n    }\n    function toParamRegExp(attributePattern, flags) {\n        return new RegExp(\"(?:^|;)\\\\s*\" + attributePattern + \"\\\\s*=\\\\s*\" + \"(\" + '[^\";\\\\s][^;\\\\s]*' + \"|\" + '\"(?:[^\"\\\\\\\\]|\\\\\\\\\"?)+\"?' + \")\", flags);\n    }\n    function textdecode(encoding, value) {\n        if (encoding) {\n            if (!/^[\\x00-\\xFF]+$/.test(value)) {\n                return value;\n            }\n            try {\n                const decoder = new TextDecoder(encoding, {\n                    fatal: true\n                });\n                const buffer = stringToBytes(value);\n                value = decoder.decode(buffer);\n                needsEncodingFixup = false;\n            } catch  {}\n        }\n        return value;\n    }\n    function fixupEncoding(value) {\n        if (needsEncodingFixup && /[\\x80-\\xff]/.test(value)) {\n            value = textdecode(\"utf-8\", value);\n            if (needsEncodingFixup) {\n                value = textdecode(\"iso-8859-1\", value);\n            }\n        }\n        return value;\n    }\n    function rfc2231getparam(contentDispositionStr) {\n        const matches = [];\n        let match;\n        const iter = toParamRegExp(\"filename\\\\*((?!0\\\\d)\\\\d+)(\\\\*?)\", \"ig\");\n        while((match = iter.exec(contentDispositionStr)) !== null){\n            let [, n, quot, part] = match;\n            n = parseInt(n, 10);\n            if (n in matches) {\n                if (n === 0) {\n                    break;\n                }\n                continue;\n            }\n            matches[n] = [\n                quot,\n                part\n            ];\n        }\n        const parts = [];\n        for(let n = 0; n < matches.length; ++n){\n            if (!(n in matches)) {\n                break;\n            }\n            let [quot, part] = matches[n];\n            part = rfc2616unquote(part);\n            if (quot) {\n                part = unescape(part);\n                if (n === 0) {\n                    part = rfc5987decode(part);\n                }\n            }\n            parts.push(part);\n        }\n        return parts.join(\"\");\n    }\n    function rfc2616unquote(value) {\n        if (value.startsWith('\"')) {\n            const parts = value.slice(1).split('\\\\\"');\n            for(let i = 0; i < parts.length; ++i){\n                const quotindex = parts[i].indexOf('\"');\n                if (quotindex !== -1) {\n                    parts[i] = parts[i].slice(0, quotindex);\n                    parts.length = i + 1;\n                }\n                parts[i] = parts[i].replaceAll(/\\\\(.)/g, \"$1\");\n            }\n            value = parts.join('\"');\n        }\n        return value;\n    }\n    function rfc5987decode(extvalue) {\n        const encodingend = extvalue.indexOf(\"'\");\n        if (encodingend === -1) {\n            return extvalue;\n        }\n        const encoding = extvalue.slice(0, encodingend);\n        const langvalue = extvalue.slice(encodingend + 1);\n        const value = langvalue.replace(/^[^']*'/, \"\");\n        return textdecode(encoding, value);\n    }\n    function rfc2047decode(value) {\n        if (!value.startsWith(\"=?\") || /[\\x00-\\x19\\x80-\\xff]/.test(value)) {\n            return value;\n        }\n        return value.replaceAll(/=\\?([\\w-]*)\\?([QqBb])\\?((?:[^?]|\\?(?!=))*)\\?=/g, function(matches, charset, encoding, text) {\n            if (encoding === \"q\" || encoding === \"Q\") {\n                text = text.replaceAll(\"_\", \" \");\n                text = text.replaceAll(/=([0-9a-fA-F]{2})/g, function(match, hex) {\n                    return String.fromCharCode(parseInt(hex, 16));\n                });\n                return textdecode(charset, text);\n            }\n            try {\n                text = atob(text);\n            } catch  {}\n            return textdecode(charset, text);\n        });\n    }\n    return \"\";\n}\n; // ./src/display/network_utils.js\nfunction createHeaders(isHttp, httpHeaders) {\n    const headers = new Headers();\n    if (!isHttp || !httpHeaders || typeof httpHeaders !== \"object\") {\n        return headers;\n    }\n    for(const key in httpHeaders){\n        const val = httpHeaders[key];\n        if (val !== undefined) {\n            headers.append(key, val);\n        }\n    }\n    return headers;\n}\nfunction getResponseOrigin(url) {\n    try {\n        return new URL(url).origin;\n    } catch  {}\n    return null;\n}\nfunction validateRangeRequestCapabilities({ responseHeaders, isHttp, rangeChunkSize, disableRange }) {\n    const returnValues = {\n        allowRangeRequests: false,\n        suggestedLength: undefined\n    };\n    const length = parseInt(responseHeaders.get(\"Content-Length\"), 10);\n    if (!Number.isInteger(length)) {\n        return returnValues;\n    }\n    returnValues.suggestedLength = length;\n    if (length <= 2 * rangeChunkSize) {\n        return returnValues;\n    }\n    if (disableRange || !isHttp) {\n        return returnValues;\n    }\n    if (responseHeaders.get(\"Accept-Ranges\") !== \"bytes\") {\n        return returnValues;\n    }\n    const contentEncoding = responseHeaders.get(\"Content-Encoding\") || \"identity\";\n    if (contentEncoding !== \"identity\") {\n        return returnValues;\n    }\n    returnValues.allowRangeRequests = true;\n    return returnValues;\n}\nfunction extractFilenameFromHeader(responseHeaders) {\n    const contentDisposition = responseHeaders.get(\"Content-Disposition\");\n    if (contentDisposition) {\n        let filename = getFilenameFromContentDispositionHeader(contentDisposition);\n        if (filename.includes(\"%\")) {\n            try {\n                filename = decodeURIComponent(filename);\n            } catch  {}\n        }\n        if (isPdfFile(filename)) {\n            return filename;\n        }\n    }\n    return null;\n}\nfunction createResponseStatusError(status, url) {\n    if (status === 404 || status === 0 && url.startsWith(\"file:\")) {\n        return new MissingPDFException('Missing PDF \"' + url + '\".');\n    }\n    return new UnexpectedResponseException(`Unexpected server response (${status}) while retrieving PDF \"${url}\".`, status);\n}\nfunction validateResponseStatus(status) {\n    return status === 200 || status === 206;\n}\n; // ./src/display/fetch_stream.js\nfunction createFetchOptions(headers, withCredentials, abortController) {\n    return {\n        method: \"GET\",\n        headers,\n        signal: abortController.signal,\n        mode: \"cors\",\n        credentials: withCredentials ? \"include\" : \"same-origin\",\n        redirect: \"follow\"\n    };\n}\nfunction getArrayBuffer(val) {\n    if (val instanceof Uint8Array) {\n        return val.buffer;\n    }\n    if (val instanceof ArrayBuffer) {\n        return val;\n    }\n    warn(`getArrayBuffer - unexpected data format: ${val}`);\n    return new Uint8Array(val).buffer;\n}\nclass PDFFetchStream {\n    constructor(source){\n        this._responseOrigin = null;\n        this.source = source;\n        this.isHttp = /^https?:/i.test(source.url);\n        this.headers = createHeaders(this.isHttp, source.httpHeaders);\n        this._fullRequestReader = null;\n        this._rangeRequestReaders = [];\n    }\n    get _progressiveDataLength() {\n        return this._fullRequestReader?._loaded ?? 0;\n    }\n    getFullReader() {\n        assert(!this._fullRequestReader, \"PDFFetchStream.getFullReader can only be called once.\");\n        this._fullRequestReader = new PDFFetchStreamReader(this);\n        return this._fullRequestReader;\n    }\n    getRangeReader(begin, end) {\n        if (end <= this._progressiveDataLength) {\n            return null;\n        }\n        const reader = new PDFFetchStreamRangeReader(this, begin, end);\n        this._rangeRequestReaders.push(reader);\n        return reader;\n    }\n    cancelAllRequests(reason) {\n        this._fullRequestReader?.cancel(reason);\n        for (const reader of this._rangeRequestReaders.slice(0)){\n            reader.cancel(reason);\n        }\n    }\n}\nclass PDFFetchStreamReader {\n    constructor(stream){\n        this._stream = stream;\n        this._reader = null;\n        this._loaded = 0;\n        this._filename = null;\n        const source = stream.source;\n        this._withCredentials = source.withCredentials || false;\n        this._contentLength = source.length;\n        this._headersCapability = Promise.withResolvers();\n        this._disableRange = source.disableRange || false;\n        this._rangeChunkSize = source.rangeChunkSize;\n        if (!this._rangeChunkSize && !this._disableRange) {\n            this._disableRange = true;\n        }\n        this._abortController = new AbortController();\n        this._isStreamingSupported = !source.disableStream;\n        this._isRangeSupported = !source.disableRange;\n        const headers = new Headers(stream.headers);\n        const url = source.url;\n        fetch(url, createFetchOptions(headers, this._withCredentials, this._abortController)).then((response)=>{\n            stream._responseOrigin = getResponseOrigin(response.url);\n            if (!validateResponseStatus(response.status)) {\n                throw createResponseStatusError(response.status, url);\n            }\n            this._reader = response.body.getReader();\n            this._headersCapability.resolve();\n            const responseHeaders = response.headers;\n            const { allowRangeRequests, suggestedLength } = validateRangeRequestCapabilities({\n                responseHeaders,\n                isHttp: stream.isHttp,\n                rangeChunkSize: this._rangeChunkSize,\n                disableRange: this._disableRange\n            });\n            this._isRangeSupported = allowRangeRequests;\n            this._contentLength = suggestedLength || this._contentLength;\n            this._filename = extractFilenameFromHeader(responseHeaders);\n            if (!this._isStreamingSupported && this._isRangeSupported) {\n                this.cancel(new AbortException(\"Streaming is disabled.\"));\n            }\n        }).catch(this._headersCapability.reject);\n        this.onProgress = null;\n    }\n    get headersReady() {\n        return this._headersCapability.promise;\n    }\n    get filename() {\n        return this._filename;\n    }\n    get contentLength() {\n        return this._contentLength;\n    }\n    get isRangeSupported() {\n        return this._isRangeSupported;\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    async read() {\n        await this._headersCapability.promise;\n        const { value, done } = await this._reader.read();\n        if (done) {\n            return {\n                value,\n                done\n            };\n        }\n        this._loaded += value.byteLength;\n        this.onProgress?.({\n            loaded: this._loaded,\n            total: this._contentLength\n        });\n        return {\n            value: getArrayBuffer(value),\n            done: false\n        };\n    }\n    cancel(reason) {\n        this._reader?.cancel(reason);\n        this._abortController.abort();\n    }\n}\nclass PDFFetchStreamRangeReader {\n    constructor(stream, begin, end){\n        this._stream = stream;\n        this._reader = null;\n        this._loaded = 0;\n        const source = stream.source;\n        this._withCredentials = source.withCredentials || false;\n        this._readCapability = Promise.withResolvers();\n        this._isStreamingSupported = !source.disableStream;\n        this._abortController = new AbortController();\n        const headers = new Headers(stream.headers);\n        headers.append(\"Range\", `bytes=${begin}-${end - 1}`);\n        const url = source.url;\n        fetch(url, createFetchOptions(headers, this._withCredentials, this._abortController)).then((response)=>{\n            const responseOrigin = getResponseOrigin(response.url);\n            if (responseOrigin !== stream._responseOrigin) {\n                throw new Error(`Expected range response-origin \"${responseOrigin}\" to match \"${stream._responseOrigin}\".`);\n            }\n            if (!validateResponseStatus(response.status)) {\n                throw createResponseStatusError(response.status, url);\n            }\n            this._readCapability.resolve();\n            this._reader = response.body.getReader();\n        }).catch(this._readCapability.reject);\n        this.onProgress = null;\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    async read() {\n        await this._readCapability.promise;\n        const { value, done } = await this._reader.read();\n        if (done) {\n            return {\n                value,\n                done\n            };\n        }\n        this._loaded += value.byteLength;\n        this.onProgress?.({\n            loaded: this._loaded\n        });\n        return {\n            value: getArrayBuffer(value),\n            done: false\n        };\n    }\n    cancel(reason) {\n        this._reader?.cancel(reason);\n        this._abortController.abort();\n    }\n}\n; // ./src/display/network.js\nconst OK_RESPONSE = 200;\nconst PARTIAL_CONTENT_RESPONSE = 206;\nfunction network_getArrayBuffer(xhr) {\n    const data = xhr.response;\n    if (typeof data !== \"string\") {\n        return data;\n    }\n    return stringToBytes(data).buffer;\n}\nclass NetworkManager {\n    constructor({ url, httpHeaders, withCredentials }){\n        this._responseOrigin = null;\n        this.url = url;\n        this.isHttp = /^https?:/i.test(url);\n        this.headers = createHeaders(this.isHttp, httpHeaders);\n        this.withCredentials = withCredentials || false;\n        this.currXhrId = 0;\n        this.pendingRequests = Object.create(null);\n    }\n    requestRange(begin, end, listeners) {\n        const args = {\n            begin,\n            end\n        };\n        for(const prop in listeners){\n            args[prop] = listeners[prop];\n        }\n        return this.request(args);\n    }\n    requestFull(listeners) {\n        return this.request(listeners);\n    }\n    request(args) {\n        const xhr = new XMLHttpRequest();\n        const xhrId = this.currXhrId++;\n        const pendingRequest = this.pendingRequests[xhrId] = {\n            xhr\n        };\n        xhr.open(\"GET\", this.url);\n        xhr.withCredentials = this.withCredentials;\n        for (const [key, val] of this.headers){\n            xhr.setRequestHeader(key, val);\n        }\n        if (this.isHttp && \"begin\" in args && \"end\" in args) {\n            xhr.setRequestHeader(\"Range\", `bytes=${args.begin}-${args.end - 1}`);\n            pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;\n        } else {\n            pendingRequest.expectedStatus = OK_RESPONSE;\n        }\n        xhr.responseType = \"arraybuffer\";\n        if (args.onError) {\n            xhr.onerror = function(evt) {\n                args.onError(xhr.status);\n            };\n        }\n        xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);\n        xhr.onprogress = this.onProgress.bind(this, xhrId);\n        pendingRequest.onHeadersReceived = args.onHeadersReceived;\n        pendingRequest.onDone = args.onDone;\n        pendingRequest.onError = args.onError;\n        pendingRequest.onProgress = args.onProgress;\n        xhr.send(null);\n        return xhrId;\n    }\n    onProgress(xhrId, evt) {\n        const pendingRequest = this.pendingRequests[xhrId];\n        if (!pendingRequest) {\n            return;\n        }\n        pendingRequest.onProgress?.(evt);\n    }\n    onStateChange(xhrId, evt) {\n        const pendingRequest = this.pendingRequests[xhrId];\n        if (!pendingRequest) {\n            return;\n        }\n        const xhr = pendingRequest.xhr;\n        if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {\n            pendingRequest.onHeadersReceived();\n            delete pendingRequest.onHeadersReceived;\n        }\n        if (xhr.readyState !== 4) {\n            return;\n        }\n        if (!(xhrId in this.pendingRequests)) {\n            return;\n        }\n        delete this.pendingRequests[xhrId];\n        if (xhr.status === 0 && this.isHttp) {\n            pendingRequest.onError?.(xhr.status);\n            return;\n        }\n        const xhrStatus = xhr.status || OK_RESPONSE;\n        const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;\n        if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {\n            pendingRequest.onError?.(xhr.status);\n            return;\n        }\n        const chunk = network_getArrayBuffer(xhr);\n        if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {\n            const rangeHeader = xhr.getResponseHeader(\"Content-Range\");\n            const matches = /bytes (\\d+)-(\\d+)\\/(\\d+)/.exec(rangeHeader);\n            pendingRequest.onDone({\n                begin: parseInt(matches[1], 10),\n                chunk\n            });\n        } else if (chunk) {\n            pendingRequest.onDone({\n                begin: 0,\n                chunk\n            });\n        } else {\n            pendingRequest.onError?.(xhr.status);\n        }\n    }\n    getRequestXhr(xhrId) {\n        return this.pendingRequests[xhrId].xhr;\n    }\n    isPendingRequest(xhrId) {\n        return xhrId in this.pendingRequests;\n    }\n    abortRequest(xhrId) {\n        const xhr = this.pendingRequests[xhrId].xhr;\n        delete this.pendingRequests[xhrId];\n        xhr.abort();\n    }\n}\nclass PDFNetworkStream {\n    constructor(source){\n        this._source = source;\n        this._manager = new NetworkManager(source);\n        this._rangeChunkSize = source.rangeChunkSize;\n        this._fullRequestReader = null;\n        this._rangeRequestReaders = [];\n    }\n    _onRangeRequestReaderClosed(reader) {\n        const i = this._rangeRequestReaders.indexOf(reader);\n        if (i >= 0) {\n            this._rangeRequestReaders.splice(i, 1);\n        }\n    }\n    getFullReader() {\n        assert(!this._fullRequestReader, \"PDFNetworkStream.getFullReader can only be called once.\");\n        this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);\n        return this._fullRequestReader;\n    }\n    getRangeReader(begin, end) {\n        const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);\n        reader.onClosed = this._onRangeRequestReaderClosed.bind(this);\n        this._rangeRequestReaders.push(reader);\n        return reader;\n    }\n    cancelAllRequests(reason) {\n        this._fullRequestReader?.cancel(reason);\n        for (const reader of this._rangeRequestReaders.slice(0)){\n            reader.cancel(reason);\n        }\n    }\n}\nclass PDFNetworkStreamFullRequestReader {\n    constructor(manager, source){\n        this._manager = manager;\n        const args = {\n            onHeadersReceived: this._onHeadersReceived.bind(this),\n            onDone: this._onDone.bind(this),\n            onError: this._onError.bind(this),\n            onProgress: this._onProgress.bind(this)\n        };\n        this._url = source.url;\n        this._fullRequestId = manager.requestFull(args);\n        this._headersCapability = Promise.withResolvers();\n        this._disableRange = source.disableRange || false;\n        this._contentLength = source.length;\n        this._rangeChunkSize = source.rangeChunkSize;\n        if (!this._rangeChunkSize && !this._disableRange) {\n            this._disableRange = true;\n        }\n        this._isStreamingSupported = false;\n        this._isRangeSupported = false;\n        this._cachedChunks = [];\n        this._requests = [];\n        this._done = false;\n        this._storedError = undefined;\n        this._filename = null;\n        this.onProgress = null;\n    }\n    _onHeadersReceived() {\n        const fullRequestXhrId = this._fullRequestId;\n        const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);\n        this._manager._responseOrigin = getResponseOrigin(fullRequestXhr.responseURL);\n        const rawResponseHeaders = fullRequestXhr.getAllResponseHeaders();\n        const responseHeaders = new Headers(rawResponseHeaders ? rawResponseHeaders.trim().split(/[\\r\\n]+/).map((x)=>{\n            const [key, ...val] = x.split(\": \");\n            return [\n                key,\n                val.join(\": \")\n            ];\n        }) : []);\n        const { allowRangeRequests, suggestedLength } = validateRangeRequestCapabilities({\n            responseHeaders,\n            isHttp: this._manager.isHttp,\n            rangeChunkSize: this._rangeChunkSize,\n            disableRange: this._disableRange\n        });\n        if (allowRangeRequests) {\n            this._isRangeSupported = true;\n        }\n        this._contentLength = suggestedLength || this._contentLength;\n        this._filename = extractFilenameFromHeader(responseHeaders);\n        if (this._isRangeSupported) {\n            this._manager.abortRequest(fullRequestXhrId);\n        }\n        this._headersCapability.resolve();\n    }\n    _onDone(data) {\n        if (data) {\n            if (this._requests.length > 0) {\n                const requestCapability = this._requests.shift();\n                requestCapability.resolve({\n                    value: data.chunk,\n                    done: false\n                });\n            } else {\n                this._cachedChunks.push(data.chunk);\n            }\n        }\n        this._done = true;\n        if (this._cachedChunks.length > 0) {\n            return;\n        }\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n    }\n    _onError(status) {\n        this._storedError = createResponseStatusError(status, this._url);\n        this._headersCapability.reject(this._storedError);\n        for (const requestCapability of this._requests){\n            requestCapability.reject(this._storedError);\n        }\n        this._requests.length = 0;\n        this._cachedChunks.length = 0;\n    }\n    _onProgress(evt) {\n        this.onProgress?.({\n            loaded: evt.loaded,\n            total: evt.lengthComputable ? evt.total : this._contentLength\n        });\n    }\n    get filename() {\n        return this._filename;\n    }\n    get isRangeSupported() {\n        return this._isRangeSupported;\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    get contentLength() {\n        return this._contentLength;\n    }\n    get headersReady() {\n        return this._headersCapability.promise;\n    }\n    async read() {\n        await this._headersCapability.promise;\n        if (this._storedError) {\n            throw this._storedError;\n        }\n        if (this._cachedChunks.length > 0) {\n            const chunk = this._cachedChunks.shift();\n            return {\n                value: chunk,\n                done: false\n            };\n        }\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        const requestCapability = Promise.withResolvers();\n        this._requests.push(requestCapability);\n        return requestCapability.promise;\n    }\n    cancel(reason) {\n        this._done = true;\n        this._headersCapability.reject(reason);\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n        if (this._manager.isPendingRequest(this._fullRequestId)) {\n            this._manager.abortRequest(this._fullRequestId);\n        }\n        this._fullRequestReader = null;\n    }\n}\nclass PDFNetworkStreamRangeRequestReader {\n    constructor(manager, begin, end){\n        this._manager = manager;\n        const args = {\n            onHeadersReceived: this._onHeadersReceived.bind(this),\n            onDone: this._onDone.bind(this),\n            onError: this._onError.bind(this),\n            onProgress: this._onProgress.bind(this)\n        };\n        this._url = manager.url;\n        this._requestId = manager.requestRange(begin, end, args);\n        this._requests = [];\n        this._queuedChunk = null;\n        this._done = false;\n        this._storedError = undefined;\n        this.onProgress = null;\n        this.onClosed = null;\n    }\n    _onHeadersReceived() {\n        const responseOrigin = getResponseOrigin(this._manager.getRequestXhr(this._requestId)?.responseURL);\n        if (responseOrigin !== this._manager._responseOrigin) {\n            this._storedError = new Error(`Expected range response-origin \"${responseOrigin}\" to match \"${this._manager._responseOrigin}\".`);\n            this._onError(0);\n        }\n    }\n    _close() {\n        this.onClosed?.(this);\n    }\n    _onDone(data) {\n        const chunk = data.chunk;\n        if (this._requests.length > 0) {\n            const requestCapability = this._requests.shift();\n            requestCapability.resolve({\n                value: chunk,\n                done: false\n            });\n        } else {\n            this._queuedChunk = chunk;\n        }\n        this._done = true;\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n        this._close();\n    }\n    _onError(status) {\n        this._storedError ??= createResponseStatusError(status, this._url);\n        for (const requestCapability of this._requests){\n            requestCapability.reject(this._storedError);\n        }\n        this._requests.length = 0;\n        this._queuedChunk = null;\n    }\n    _onProgress(evt) {\n        if (!this.isStreamingSupported) {\n            this.onProgress?.({\n                loaded: evt.loaded\n            });\n        }\n    }\n    get isStreamingSupported() {\n        return false;\n    }\n    async read() {\n        if (this._storedError) {\n            throw this._storedError;\n        }\n        if (this._queuedChunk !== null) {\n            const chunk = this._queuedChunk;\n            this._queuedChunk = null;\n            return {\n                value: chunk,\n                done: false\n            };\n        }\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        const requestCapability = Promise.withResolvers();\n        this._requests.push(requestCapability);\n        return requestCapability.promise;\n    }\n    cancel(reason) {\n        this._done = true;\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n        if (this._manager.isPendingRequest(this._requestId)) {\n            this._manager.abortRequest(this._requestId);\n        }\n        this._close();\n    }\n}\n; // ./src/display/node_stream.js\nconst urlRegex = /^[a-z][a-z0-9\\-+.]+:/i;\nfunction parseUrlOrPath(sourceUrl) {\n    if (urlRegex.test(sourceUrl)) {\n        return new URL(sourceUrl);\n    }\n    const url = process.getBuiltinModule(\"url\");\n    return new URL(url.pathToFileURL(sourceUrl));\n}\nclass PDFNodeStream {\n    constructor(source){\n        this.source = source;\n        this.url = parseUrlOrPath(source.url);\n        assert(this.url.protocol === \"file:\", \"PDFNodeStream only supports file:// URLs.\");\n        this._fullRequestReader = null;\n        this._rangeRequestReaders = [];\n    }\n    get _progressiveDataLength() {\n        return this._fullRequestReader?._loaded ?? 0;\n    }\n    getFullReader() {\n        assert(!this._fullRequestReader, \"PDFNodeStream.getFullReader can only be called once.\");\n        this._fullRequestReader = new PDFNodeStreamFsFullReader(this);\n        return this._fullRequestReader;\n    }\n    getRangeReader(start, end) {\n        if (end <= this._progressiveDataLength) {\n            return null;\n        }\n        const rangeReader = new PDFNodeStreamFsRangeReader(this, start, end);\n        this._rangeRequestReaders.push(rangeReader);\n        return rangeReader;\n    }\n    cancelAllRequests(reason) {\n        this._fullRequestReader?.cancel(reason);\n        for (const reader of this._rangeRequestReaders.slice(0)){\n            reader.cancel(reason);\n        }\n    }\n}\nclass PDFNodeStreamFsFullReader {\n    constructor(stream){\n        this._url = stream.url;\n        this._done = false;\n        this._storedError = null;\n        this.onProgress = null;\n        const source = stream.source;\n        this._contentLength = source.length;\n        this._loaded = 0;\n        this._filename = null;\n        this._disableRange = source.disableRange || false;\n        this._rangeChunkSize = source.rangeChunkSize;\n        if (!this._rangeChunkSize && !this._disableRange) {\n            this._disableRange = true;\n        }\n        this._isStreamingSupported = !source.disableStream;\n        this._isRangeSupported = !source.disableRange;\n        this._readableStream = null;\n        this._readCapability = Promise.withResolvers();\n        this._headersCapability = Promise.withResolvers();\n        const fs = process.getBuiltinModule(\"fs\");\n        fs.promises.lstat(this._url).then((stat)=>{\n            this._contentLength = stat.size;\n            this._setReadableStream(fs.createReadStream(this._url));\n            this._headersCapability.resolve();\n        }, (error)=>{\n            if (error.code === \"ENOENT\") {\n                error = new MissingPDFException(`Missing PDF \"${this._url}\".`);\n            }\n            this._storedError = error;\n            this._headersCapability.reject(error);\n        });\n    }\n    get headersReady() {\n        return this._headersCapability.promise;\n    }\n    get filename() {\n        return this._filename;\n    }\n    get contentLength() {\n        return this._contentLength;\n    }\n    get isRangeSupported() {\n        return this._isRangeSupported;\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    async read() {\n        await this._readCapability.promise;\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        if (this._storedError) {\n            throw this._storedError;\n        }\n        const chunk = this._readableStream.read();\n        if (chunk === null) {\n            this._readCapability = Promise.withResolvers();\n            return this.read();\n        }\n        this._loaded += chunk.length;\n        this.onProgress?.({\n            loaded: this._loaded,\n            total: this._contentLength\n        });\n        const buffer = new Uint8Array(chunk).buffer;\n        return {\n            value: buffer,\n            done: false\n        };\n    }\n    cancel(reason) {\n        if (!this._readableStream) {\n            this._error(reason);\n            return;\n        }\n        this._readableStream.destroy(reason);\n    }\n    _error(reason) {\n        this._storedError = reason;\n        this._readCapability.resolve();\n    }\n    _setReadableStream(readableStream) {\n        this._readableStream = readableStream;\n        readableStream.on(\"readable\", ()=>{\n            this._readCapability.resolve();\n        });\n        readableStream.on(\"end\", ()=>{\n            readableStream.destroy();\n            this._done = true;\n            this._readCapability.resolve();\n        });\n        readableStream.on(\"error\", (reason)=>{\n            this._error(reason);\n        });\n        if (!this._isStreamingSupported && this._isRangeSupported) {\n            this._error(new AbortException(\"streaming is disabled\"));\n        }\n        if (this._storedError) {\n            this._readableStream.destroy(this._storedError);\n        }\n    }\n}\nclass PDFNodeStreamFsRangeReader {\n    constructor(stream, start, end){\n        this._url = stream.url;\n        this._done = false;\n        this._storedError = null;\n        this.onProgress = null;\n        this._loaded = 0;\n        this._readableStream = null;\n        this._readCapability = Promise.withResolvers();\n        const source = stream.source;\n        this._isStreamingSupported = !source.disableStream;\n        const fs = process.getBuiltinModule(\"fs\");\n        this._setReadableStream(fs.createReadStream(this._url, {\n            start,\n            end: end - 1\n        }));\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    async read() {\n        await this._readCapability.promise;\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        if (this._storedError) {\n            throw this._storedError;\n        }\n        const chunk = this._readableStream.read();\n        if (chunk === null) {\n            this._readCapability = Promise.withResolvers();\n            return this.read();\n        }\n        this._loaded += chunk.length;\n        this.onProgress?.({\n            loaded: this._loaded\n        });\n        const buffer = new Uint8Array(chunk).buffer;\n        return {\n            value: buffer,\n            done: false\n        };\n    }\n    cancel(reason) {\n        if (!this._readableStream) {\n            this._error(reason);\n            return;\n        }\n        this._readableStream.destroy(reason);\n    }\n    _error(reason) {\n        this._storedError = reason;\n        this._readCapability.resolve();\n    }\n    _setReadableStream(readableStream) {\n        this._readableStream = readableStream;\n        readableStream.on(\"readable\", ()=>{\n            this._readCapability.resolve();\n        });\n        readableStream.on(\"end\", ()=>{\n            readableStream.destroy();\n            this._done = true;\n            this._readCapability.resolve();\n        });\n        readableStream.on(\"error\", (reason)=>{\n            this._error(reason);\n        });\n        if (this._storedError) {\n            this._readableStream.destroy(this._storedError);\n        }\n    }\n}\n; // ./src/display/text_layer.js\nconst MAX_TEXT_DIVS_TO_RENDER = 100000;\nconst DEFAULT_FONT_SIZE = 30;\nconst DEFAULT_FONT_ASCENT = 0.8;\nclass TextLayer {\n    #capability;\n    #container;\n    #disableProcessItems;\n    #fontInspectorEnabled;\n    #lang;\n    #layoutTextParams;\n    #pageHeight;\n    #pageWidth;\n    #reader;\n    #rootContainer;\n    #rotation;\n    #scale;\n    #styleCache;\n    #textContentItemsStr;\n    #textContentSource;\n    #textDivs;\n    #textDivProperties;\n    #transform;\n    static #ascentCache = new Map();\n    static #canvasContexts = new Map();\n    static #canvasCtxFonts = new WeakMap();\n    static #minFontSize = null;\n    static #pendingTextLayers = new Set();\n    constructor({ textContentSource, container, viewport }){\n        this.#capability = Promise.withResolvers();\n        this.#container = null;\n        this.#disableProcessItems = false;\n        this.#fontInspectorEnabled = !!globalThis.FontInspector?.enabled;\n        this.#lang = null;\n        this.#layoutTextParams = null;\n        this.#pageHeight = 0;\n        this.#pageWidth = 0;\n        this.#reader = null;\n        this.#rootContainer = null;\n        this.#rotation = 0;\n        this.#scale = 0;\n        this.#styleCache = Object.create(null);\n        this.#textContentItemsStr = [];\n        this.#textContentSource = null;\n        this.#textDivs = [];\n        this.#textDivProperties = new WeakMap();\n        this.#transform = null;\n        if (textContentSource instanceof ReadableStream) {\n            this.#textContentSource = textContentSource;\n        } else if (typeof textContentSource === \"object\") {\n            this.#textContentSource = new ReadableStream({\n                start (controller) {\n                    controller.enqueue(textContentSource);\n                    controller.close();\n                }\n            });\n        } else {\n            throw new Error('No \"textContentSource\" parameter specified.');\n        }\n        this.#container = this.#rootContainer = container;\n        this.#scale = viewport.scale * (globalThis.devicePixelRatio || 1);\n        this.#rotation = viewport.rotation;\n        this.#layoutTextParams = {\n            div: null,\n            properties: null,\n            ctx: null\n        };\n        const { pageWidth, pageHeight, pageX, pageY } = viewport.rawDims;\n        this.#transform = [\n            1,\n            0,\n            0,\n            -1,\n            -pageX,\n            pageY + pageHeight\n        ];\n        this.#pageWidth = pageWidth;\n        this.#pageHeight = pageHeight;\n        TextLayer.#ensureMinFontSizeComputed();\n        setLayerDimensions(container, viewport);\n        this.#capability.promise.finally(()=>{\n            TextLayer.#pendingTextLayers.delete(this);\n            this.#layoutTextParams = null;\n            this.#styleCache = null;\n        }).catch(()=>{});\n    }\n    static get fontFamilyMap() {\n        const { isWindows, isFirefox } = util_FeatureTest.platform;\n        return shadow(this, \"fontFamilyMap\", new Map([\n            [\n                \"sans-serif\",\n                `${isWindows && isFirefox ? \"Calibri, \" : \"\"}sans-serif`\n            ],\n            [\n                \"monospace\",\n                `${isWindows && isFirefox ? \"Lucida Console, \" : \"\"}monospace`\n            ]\n        ]));\n    }\n    render() {\n        const pump = ()=>{\n            this.#reader.read().then(({ value, done })=>{\n                if (done) {\n                    this.#capability.resolve();\n                    return;\n                }\n                this.#lang ??= value.lang;\n                Object.assign(this.#styleCache, value.styles);\n                this.#processItems(value.items);\n                pump();\n            }, this.#capability.reject);\n        };\n        this.#reader = this.#textContentSource.getReader();\n        TextLayer.#pendingTextLayers.add(this);\n        pump();\n        return this.#capability.promise;\n    }\n    update({ viewport, onBefore = null }) {\n        const scale = viewport.scale * (globalThis.devicePixelRatio || 1);\n        const rotation = viewport.rotation;\n        if (rotation !== this.#rotation) {\n            onBefore?.();\n            this.#rotation = rotation;\n            setLayerDimensions(this.#rootContainer, {\n                rotation\n            });\n        }\n        if (scale !== this.#scale) {\n            onBefore?.();\n            this.#scale = scale;\n            const params = {\n                div: null,\n                properties: null,\n                ctx: TextLayer.#getCtx(this.#lang)\n            };\n            for (const div of this.#textDivs){\n                params.properties = this.#textDivProperties.get(div);\n                params.div = div;\n                this.#layout(params);\n            }\n        }\n    }\n    cancel() {\n        const abortEx = new AbortException(\"TextLayer task cancelled.\");\n        this.#reader?.cancel(abortEx).catch(()=>{});\n        this.#reader = null;\n        this.#capability.reject(abortEx);\n    }\n    get textDivs() {\n        return this.#textDivs;\n    }\n    get textContentItemsStr() {\n        return this.#textContentItemsStr;\n    }\n    #processItems(items) {\n        if (this.#disableProcessItems) {\n            return;\n        }\n        this.#layoutTextParams.ctx ??= TextLayer.#getCtx(this.#lang);\n        const textDivs = this.#textDivs, textContentItemsStr = this.#textContentItemsStr;\n        for (const item of items){\n            if (textDivs.length > MAX_TEXT_DIVS_TO_RENDER) {\n                warn(\"Ignoring additional textDivs for performance reasons.\");\n                this.#disableProcessItems = true;\n                return;\n            }\n            if (item.str === undefined) {\n                if (item.type === \"beginMarkedContentProps\" || item.type === \"beginMarkedContent\") {\n                    const parent = this.#container;\n                    this.#container = document.createElement(\"span\");\n                    this.#container.classList.add(\"markedContent\");\n                    if (item.id !== null) {\n                        this.#container.setAttribute(\"id\", `${item.id}`);\n                    }\n                    parent.append(this.#container);\n                } else if (item.type === \"endMarkedContent\") {\n                    this.#container = this.#container.parentNode;\n                }\n                continue;\n            }\n            textContentItemsStr.push(item.str);\n            this.#appendText(item);\n        }\n    }\n    #appendText(geom) {\n        const textDiv = document.createElement(\"span\");\n        const textDivProperties = {\n            angle: 0,\n            canvasWidth: 0,\n            hasText: geom.str !== \"\",\n            hasEOL: geom.hasEOL,\n            fontSize: 0\n        };\n        this.#textDivs.push(textDiv);\n        const tx = Util.transform(this.#transform, geom.transform);\n        let angle = Math.atan2(tx[1], tx[0]);\n        const style = this.#styleCache[geom.fontName];\n        if (style.vertical) {\n            angle += Math.PI / 2;\n        }\n        let fontFamily = this.#fontInspectorEnabled && style.fontSubstitution || style.fontFamily;\n        fontFamily = TextLayer.fontFamilyMap.get(fontFamily) || fontFamily;\n        const fontHeight = Math.hypot(tx[2], tx[3]);\n        const fontAscent = fontHeight * TextLayer.#getAscent(fontFamily, this.#lang);\n        let left, top;\n        if (angle === 0) {\n            left = tx[4];\n            top = tx[5] - fontAscent;\n        } else {\n            left = tx[4] + fontAscent * Math.sin(angle);\n            top = tx[5] - fontAscent * Math.cos(angle);\n        }\n        const scaleFactorStr = \"calc(var(--scale-factor)*\";\n        const divStyle = textDiv.style;\n        if (this.#container === this.#rootContainer) {\n            divStyle.left = `${(100 * left / this.#pageWidth).toFixed(2)}%`;\n            divStyle.top = `${(100 * top / this.#pageHeight).toFixed(2)}%`;\n        } else {\n            divStyle.left = `${scaleFactorStr}${left.toFixed(2)}px)`;\n            divStyle.top = `${scaleFactorStr}${top.toFixed(2)}px)`;\n        }\n        divStyle.fontSize = `${scaleFactorStr}${(TextLayer.#minFontSize * fontHeight).toFixed(2)}px)`;\n        divStyle.fontFamily = fontFamily;\n        textDivProperties.fontSize = fontHeight;\n        textDiv.setAttribute(\"role\", \"presentation\");\n        textDiv.textContent = geom.str;\n        textDiv.dir = geom.dir;\n        if (this.#fontInspectorEnabled) {\n            textDiv.dataset.fontName = style.fontSubstitutionLoadedName || geom.fontName;\n        }\n        if (angle !== 0) {\n            textDivProperties.angle = angle * (180 / Math.PI);\n        }\n        let shouldScaleText = false;\n        if (geom.str.length > 1) {\n            shouldScaleText = true;\n        } else if (geom.str !== \" \" && geom.transform[0] !== geom.transform[3]) {\n            const absScaleX = Math.abs(geom.transform[0]), absScaleY = Math.abs(geom.transform[3]);\n            if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {\n                shouldScaleText = true;\n            }\n        }\n        if (shouldScaleText) {\n            textDivProperties.canvasWidth = style.vertical ? geom.height : geom.width;\n        }\n        this.#textDivProperties.set(textDiv, textDivProperties);\n        this.#layoutTextParams.div = textDiv;\n        this.#layoutTextParams.properties = textDivProperties;\n        this.#layout(this.#layoutTextParams);\n        if (textDivProperties.hasText) {\n            this.#container.append(textDiv);\n        }\n        if (textDivProperties.hasEOL) {\n            const br = document.createElement(\"br\");\n            br.setAttribute(\"role\", \"presentation\");\n            this.#container.append(br);\n        }\n    }\n    #layout(params) {\n        const { div, properties, ctx } = params;\n        const { style } = div;\n        let transform = \"\";\n        if (TextLayer.#minFontSize > 1) {\n            transform = `scale(${1 / TextLayer.#minFontSize})`;\n        }\n        if (properties.canvasWidth !== 0 && properties.hasText) {\n            const { fontFamily } = style;\n            const { canvasWidth, fontSize } = properties;\n            TextLayer.#ensureCtxFont(ctx, fontSize * this.#scale, fontFamily);\n            const { width } = ctx.measureText(div.textContent);\n            if (width > 0) {\n                transform = `scaleX(${canvasWidth * this.#scale / width}) ${transform}`;\n            }\n        }\n        if (properties.angle !== 0) {\n            transform = `rotate(${properties.angle}deg) ${transform}`;\n        }\n        if (transform.length > 0) {\n            style.transform = transform;\n        }\n    }\n    static cleanup() {\n        if (this.#pendingTextLayers.size > 0) {\n            return;\n        }\n        this.#ascentCache.clear();\n        for (const { canvas } of this.#canvasContexts.values()){\n            canvas.remove();\n        }\n        this.#canvasContexts.clear();\n    }\n    static #getCtx(lang = null) {\n        let ctx = this.#canvasContexts.get(lang ||= \"\");\n        if (!ctx) {\n            const canvas = document.createElement(\"canvas\");\n            canvas.className = \"hiddenCanvasElement\";\n            canvas.lang = lang;\n            document.body.append(canvas);\n            ctx = canvas.getContext(\"2d\", {\n                alpha: false,\n                willReadFrequently: true\n            });\n            this.#canvasContexts.set(lang, ctx);\n            this.#canvasCtxFonts.set(ctx, {\n                size: 0,\n                family: \"\"\n            });\n        }\n        return ctx;\n    }\n    static #ensureCtxFont(ctx, size, family) {\n        const cached = this.#canvasCtxFonts.get(ctx);\n        if (size === cached.size && family === cached.family) {\n            return;\n        }\n        ctx.font = `${size}px ${family}`;\n        cached.size = size;\n        cached.family = family;\n    }\n    static #ensureMinFontSizeComputed() {\n        if (this.#minFontSize !== null) {\n            return;\n        }\n        const div = document.createElement(\"div\");\n        div.style.opacity = 0;\n        div.style.lineHeight = 1;\n        div.style.fontSize = \"1px\";\n        div.style.position = \"absolute\";\n        div.textContent = \"X\";\n        document.body.append(div);\n        this.#minFontSize = div.getBoundingClientRect().height;\n        div.remove();\n    }\n    static #getAscent(fontFamily, lang) {\n        const cachedAscent = this.#ascentCache.get(fontFamily);\n        if (cachedAscent) {\n            return cachedAscent;\n        }\n        const ctx = this.#getCtx(lang);\n        ctx.canvas.width = ctx.canvas.height = DEFAULT_FONT_SIZE;\n        this.#ensureCtxFont(ctx, DEFAULT_FONT_SIZE, fontFamily);\n        const metrics = ctx.measureText(\"\");\n        let ascent = metrics.fontBoundingBoxAscent;\n        let descent = Math.abs(metrics.fontBoundingBoxDescent);\n        if (ascent) {\n            const ratio = ascent / (ascent + descent);\n            this.#ascentCache.set(fontFamily, ratio);\n            ctx.canvas.width = ctx.canvas.height = 0;\n            return ratio;\n        }\n        ctx.strokeStyle = \"red\";\n        ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);\n        ctx.strokeText(\"g\", 0, 0);\n        let pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;\n        descent = 0;\n        for(let i = pixels.length - 1 - 3; i >= 0; i -= 4){\n            if (pixels[i] > 0) {\n                descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);\n                break;\n            }\n        }\n        ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);\n        ctx.strokeText(\"A\", 0, DEFAULT_FONT_SIZE);\n        pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;\n        ascent = 0;\n        for(let i = 0, ii = pixels.length; i < ii; i += 4){\n            if (pixels[i] > 0) {\n                ascent = DEFAULT_FONT_SIZE - Math.floor(i / 4 / DEFAULT_FONT_SIZE);\n                break;\n            }\n        }\n        ctx.canvas.width = ctx.canvas.height = 0;\n        const ratio = ascent ? ascent / (ascent + descent) : DEFAULT_FONT_ASCENT;\n        this.#ascentCache.set(fontFamily, ratio);\n        return ratio;\n    }\n}\n; // ./src/display/xfa_text.js\nclass XfaText {\n    static textContent(xfa) {\n        const items = [];\n        const output = {\n            items,\n            styles: Object.create(null)\n        };\n        function walk(node) {\n            if (!node) {\n                return;\n            }\n            let str = null;\n            const name = node.name;\n            if (name === \"#text\") {\n                str = node.value;\n            } else if (!XfaText.shouldBuildText(name)) {\n                return;\n            } else if (node?.attributes?.textContent) {\n                str = node.attributes.textContent;\n            } else if (node.value) {\n                str = node.value;\n            }\n            if (str !== null) {\n                items.push({\n                    str\n                });\n            }\n            if (!node.children) {\n                return;\n            }\n            for (const child of node.children){\n                walk(child);\n            }\n        }\n        walk(xfa);\n        return output;\n    }\n    static shouldBuildText(name) {\n        return !(name === \"textarea\" || name === \"input\" || name === \"option\" || name === \"select\");\n    }\n}\n; // ./src/display/api.js\nconst DEFAULT_RANGE_CHUNK_SIZE = 65536;\nconst RENDERING_CANCELLED_TIMEOUT = 100;\nconst DELAYED_CLEANUP_TIMEOUT = 5000;\nconst DefaultCanvasFactory = isNodeJS ? NodeCanvasFactory : DOMCanvasFactory;\nconst DefaultCMapReaderFactory = isNodeJS ? NodeCMapReaderFactory : DOMCMapReaderFactory;\nconst DefaultFilterFactory = isNodeJS ? NodeFilterFactory : DOMFilterFactory;\nconst DefaultStandardFontDataFactory = isNodeJS ? NodeStandardFontDataFactory : DOMStandardFontDataFactory;\nfunction getDocument(src = {}) {\n    if (typeof src === \"string\" || src instanceof URL) {\n        src = {\n            url: src\n        };\n    } else if (src instanceof ArrayBuffer || ArrayBuffer.isView(src)) {\n        src = {\n            data: src\n        };\n    }\n    const task = new PDFDocumentLoadingTask();\n    const { docId } = task;\n    const url = src.url ? getUrlProp(src.url) : null;\n    const data = src.data ? getDataProp(src.data) : null;\n    const httpHeaders = src.httpHeaders || null;\n    const withCredentials = src.withCredentials === true;\n    const password = src.password ?? null;\n    const rangeTransport = src.range instanceof PDFDataRangeTransport ? src.range : null;\n    const rangeChunkSize = Number.isInteger(src.rangeChunkSize) && src.rangeChunkSize > 0 ? src.rangeChunkSize : DEFAULT_RANGE_CHUNK_SIZE;\n    let worker = src.worker instanceof PDFWorker ? src.worker : null;\n    const verbosity = src.verbosity;\n    const docBaseUrl = typeof src.docBaseUrl === \"string\" && !isDataScheme(src.docBaseUrl) ? src.docBaseUrl : null;\n    const cMapUrl = typeof src.cMapUrl === \"string\" ? src.cMapUrl : null;\n    const cMapPacked = src.cMapPacked !== false;\n    const CMapReaderFactory = src.CMapReaderFactory || DefaultCMapReaderFactory;\n    const standardFontDataUrl = typeof src.standardFontDataUrl === \"string\" ? src.standardFontDataUrl : null;\n    const StandardFontDataFactory = src.StandardFontDataFactory || DefaultStandardFontDataFactory;\n    const ignoreErrors = src.stopAtErrors !== true;\n    const maxImageSize = Number.isInteger(src.maxImageSize) && src.maxImageSize > -1 ? src.maxImageSize : -1;\n    const isEvalSupported = src.isEvalSupported !== false;\n    const isOffscreenCanvasSupported = typeof src.isOffscreenCanvasSupported === \"boolean\" ? src.isOffscreenCanvasSupported : !isNodeJS;\n    const isImageDecoderSupported = typeof src.isImageDecoderSupported === \"boolean\" ? src.isImageDecoderSupported : !isNodeJS && (util_FeatureTest.platform.isFirefox || !globalThis.chrome);\n    const canvasMaxAreaInBytes = Number.isInteger(src.canvasMaxAreaInBytes) ? src.canvasMaxAreaInBytes : -1;\n    const disableFontFace = typeof src.disableFontFace === \"boolean\" ? src.disableFontFace : isNodeJS;\n    const fontExtraProperties = src.fontExtraProperties === true;\n    const enableXfa = src.enableXfa === true;\n    const ownerDocument = src.ownerDocument || globalThis.document;\n    const disableRange = src.disableRange === true;\n    const disableStream = src.disableStream === true;\n    const disableAutoFetch = src.disableAutoFetch === true;\n    const pdfBug = src.pdfBug === true;\n    const CanvasFactory = src.CanvasFactory || DefaultCanvasFactory;\n    const FilterFactory = src.FilterFactory || DefaultFilterFactory;\n    const enableHWA = src.enableHWA === true;\n    const length = rangeTransport ? rangeTransport.length : src.length ?? NaN;\n    const useSystemFonts = typeof src.useSystemFonts === \"boolean\" ? src.useSystemFonts : !isNodeJS && !disableFontFace;\n    const useWorkerFetch = typeof src.useWorkerFetch === \"boolean\" ? src.useWorkerFetch : CMapReaderFactory === DOMCMapReaderFactory && StandardFontDataFactory === DOMStandardFontDataFactory && cMapUrl && standardFontDataUrl && isValidFetchUrl(cMapUrl, document.baseURI) && isValidFetchUrl(standardFontDataUrl, document.baseURI);\n    if (src.canvasFactory) {\n        deprecated(\"`canvasFactory`-instance option, please use `CanvasFactory` instead.\");\n    }\n    if (src.filterFactory) {\n        deprecated(\"`filterFactory`-instance option, please use `FilterFactory` instead.\");\n    }\n    const styleElement = null;\n    setVerbosityLevel(verbosity);\n    const transportFactory = {\n        canvasFactory: new CanvasFactory({\n            ownerDocument,\n            enableHWA\n        }),\n        filterFactory: new FilterFactory({\n            docId,\n            ownerDocument\n        }),\n        cMapReaderFactory: useWorkerFetch ? null : new CMapReaderFactory({\n            baseUrl: cMapUrl,\n            isCompressed: cMapPacked\n        }),\n        standardFontDataFactory: useWorkerFetch ? null : new StandardFontDataFactory({\n            baseUrl: standardFontDataUrl\n        })\n    };\n    if (!worker) {\n        const workerParams = {\n            verbosity,\n            port: GlobalWorkerOptions.workerPort\n        };\n        worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);\n        task._worker = worker;\n    }\n    const docParams = {\n        docId,\n        apiVersion: \"4.9.155\",\n        data,\n        password,\n        disableAutoFetch,\n        rangeChunkSize,\n        length,\n        docBaseUrl,\n        enableXfa,\n        evaluatorOptions: {\n            maxImageSize,\n            disableFontFace,\n            ignoreErrors,\n            isEvalSupported,\n            isOffscreenCanvasSupported,\n            isImageDecoderSupported,\n            canvasMaxAreaInBytes,\n            fontExtraProperties,\n            useSystemFonts,\n            cMapUrl: useWorkerFetch ? cMapUrl : null,\n            standardFontDataUrl: useWorkerFetch ? standardFontDataUrl : null\n        }\n    };\n    const transportParams = {\n        disableFontFace,\n        fontExtraProperties,\n        ownerDocument,\n        pdfBug,\n        styleElement,\n        loadingParams: {\n            disableAutoFetch,\n            enableXfa\n        }\n    };\n    worker.promise.then(function() {\n        if (task.destroyed) {\n            throw new Error(\"Loading aborted\");\n        }\n        if (worker.destroyed) {\n            throw new Error(\"Worker was destroyed\");\n        }\n        const workerIdPromise = worker.messageHandler.sendWithPromise(\"GetDocRequest\", docParams, data ? [\n            data.buffer\n        ] : null);\n        let networkStream;\n        if (rangeTransport) {\n            networkStream = new PDFDataTransportStream(rangeTransport, {\n                disableRange,\n                disableStream\n            });\n        } else if (!data) {\n            if (!url) {\n                throw new Error(\"getDocument - no `url` parameter provided.\");\n            }\n            let NetworkStream;\n            if (isNodeJS) {\n                if (isValidFetchUrl(url)) {\n                    if (typeof fetch === \"undefined\" || typeof Response === \"undefined\" || !(\"body\" in Response.prototype)) {\n                        throw new Error(\"getDocument - the Fetch API was disabled in Node.js, see `--no-experimental-fetch`.\");\n                    }\n                    NetworkStream = PDFFetchStream;\n                } else {\n                    NetworkStream = PDFNodeStream;\n                }\n            } else {\n                NetworkStream = isValidFetchUrl(url) ? PDFFetchStream : PDFNetworkStream;\n            }\n            networkStream = new NetworkStream({\n                url,\n                length,\n                httpHeaders,\n                withCredentials,\n                rangeChunkSize,\n                disableRange,\n                disableStream\n            });\n        }\n        return workerIdPromise.then((workerId)=>{\n            if (task.destroyed) {\n                throw new Error(\"Loading aborted\");\n            }\n            if (worker.destroyed) {\n                throw new Error(\"Worker was destroyed\");\n            }\n            const messageHandler = new MessageHandler(docId, workerId, worker.port);\n            const transport = new WorkerTransport(messageHandler, task, networkStream, transportParams, transportFactory);\n            task._transport = transport;\n            messageHandler.send(\"Ready\", null);\n        });\n    }).catch(task._capability.reject);\n    return task;\n}\nfunction getUrlProp(val) {\n    if (val instanceof URL) {\n        return val.href;\n    }\n    try {\n        return new URL(val, window.location).href;\n    } catch  {\n        if (isNodeJS && typeof val === \"string\") {\n            return val;\n        }\n    }\n    throw new Error(\"Invalid PDF url data: \" + \"either string or URL-object is expected in the url property.\");\n}\nfunction getDataProp(val) {\n    if (isNodeJS && typeof Buffer !== \"undefined\" && val instanceof Buffer) {\n        throw new Error(\"Please provide binary data as `Uint8Array`, rather than `Buffer`.\");\n    }\n    if (val instanceof Uint8Array && val.byteLength === val.buffer.byteLength) {\n        return val;\n    }\n    if (typeof val === \"string\") {\n        return stringToBytes(val);\n    }\n    if (val instanceof ArrayBuffer || ArrayBuffer.isView(val) || typeof val === \"object\" && !isNaN(val?.length)) {\n        return new Uint8Array(val);\n    }\n    throw new Error(\"Invalid PDF binary data: either TypedArray, \" + \"string, or array-like object is expected in the data property.\");\n}\nfunction isRefProxy(ref) {\n    return typeof ref === \"object\" && Number.isInteger(ref?.num) && ref.num >= 0 && Number.isInteger(ref?.gen) && ref.gen >= 0;\n}\nclass PDFDocumentLoadingTask {\n    static #docId = 0;\n    constructor(){\n        this._capability = Promise.withResolvers();\n        this._transport = null;\n        this._worker = null;\n        this.docId = `d${PDFDocumentLoadingTask.#docId++}`;\n        this.destroyed = false;\n        this.onPassword = null;\n        this.onProgress = null;\n    }\n    get promise() {\n        return this._capability.promise;\n    }\n    async destroy() {\n        this.destroyed = true;\n        try {\n            if (this._worker?.port) {\n                this._worker._pendingDestroy = true;\n            }\n            await this._transport?.destroy();\n        } catch (ex) {\n            if (this._worker?.port) {\n                delete this._worker._pendingDestroy;\n            }\n            throw ex;\n        }\n        this._transport = null;\n        this._worker?.destroy();\n        this._worker = null;\n    }\n}\nclass PDFDataRangeTransport {\n    constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null){\n        this.length = length;\n        this.initialData = initialData;\n        this.progressiveDone = progressiveDone;\n        this.contentDispositionFilename = contentDispositionFilename;\n        this._rangeListeners = [];\n        this._progressListeners = [];\n        this._progressiveReadListeners = [];\n        this._progressiveDoneListeners = [];\n        this._readyCapability = Promise.withResolvers();\n    }\n    addRangeListener(listener) {\n        this._rangeListeners.push(listener);\n    }\n    addProgressListener(listener) {\n        this._progressListeners.push(listener);\n    }\n    addProgressiveReadListener(listener) {\n        this._progressiveReadListeners.push(listener);\n    }\n    addProgressiveDoneListener(listener) {\n        this._progressiveDoneListeners.push(listener);\n    }\n    onDataRange(begin, chunk) {\n        for (const listener of this._rangeListeners){\n            listener(begin, chunk);\n        }\n    }\n    onDataProgress(loaded, total) {\n        this._readyCapability.promise.then(()=>{\n            for (const listener of this._progressListeners){\n                listener(loaded, total);\n            }\n        });\n    }\n    onDataProgressiveRead(chunk) {\n        this._readyCapability.promise.then(()=>{\n            for (const listener of this._progressiveReadListeners){\n                listener(chunk);\n            }\n        });\n    }\n    onDataProgressiveDone() {\n        this._readyCapability.promise.then(()=>{\n            for (const listener of this._progressiveDoneListeners){\n                listener();\n            }\n        });\n    }\n    transportReady() {\n        this._readyCapability.resolve();\n    }\n    requestDataRange(begin, end) {\n        unreachable(\"Abstract method PDFDataRangeTransport.requestDataRange\");\n    }\n    abort() {}\n}\nclass PDFDocumentProxy {\n    constructor(pdfInfo, transport){\n        this._pdfInfo = pdfInfo;\n        this._transport = transport;\n    }\n    get annotationStorage() {\n        return this._transport.annotationStorage;\n    }\n    get canvasFactory() {\n        return this._transport.canvasFactory;\n    }\n    get filterFactory() {\n        return this._transport.filterFactory;\n    }\n    get numPages() {\n        return this._pdfInfo.numPages;\n    }\n    get fingerprints() {\n        return this._pdfInfo.fingerprints;\n    }\n    get isPureXfa() {\n        return shadow(this, \"isPureXfa\", !!this._transport._htmlForXfa);\n    }\n    get allXfaHtml() {\n        return this._transport._htmlForXfa;\n    }\n    getPage(pageNumber) {\n        return this._transport.getPage(pageNumber);\n    }\n    getPageIndex(ref) {\n        return this._transport.getPageIndex(ref);\n    }\n    getDestinations() {\n        return this._transport.getDestinations();\n    }\n    getDestination(id) {\n        return this._transport.getDestination(id);\n    }\n    getPageLabels() {\n        return this._transport.getPageLabels();\n    }\n    getPageLayout() {\n        return this._transport.getPageLayout();\n    }\n    getPageMode() {\n        return this._transport.getPageMode();\n    }\n    getViewerPreferences() {\n        return this._transport.getViewerPreferences();\n    }\n    getOpenAction() {\n        return this._transport.getOpenAction();\n    }\n    getAttachments() {\n        return this._transport.getAttachments();\n    }\n    getJSActions() {\n        return this._transport.getDocJSActions();\n    }\n    getOutline() {\n        return this._transport.getOutline();\n    }\n    getOptionalContentConfig({ intent = \"display\" } = {}) {\n        const { renderingIntent } = this._transport.getRenderingIntent(intent);\n        return this._transport.getOptionalContentConfig(renderingIntent);\n    }\n    getPermissions() {\n        return this._transport.getPermissions();\n    }\n    getMetadata() {\n        return this._transport.getMetadata();\n    }\n    getMarkInfo() {\n        return this._transport.getMarkInfo();\n    }\n    getData() {\n        return this._transport.getData();\n    }\n    saveDocument() {\n        return this._transport.saveDocument();\n    }\n    getDownloadInfo() {\n        return this._transport.downloadInfoCapability.promise;\n    }\n    cleanup(keepLoadedFonts = false) {\n        return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);\n    }\n    destroy() {\n        return this.loadingTask.destroy();\n    }\n    cachedPageNumber(ref) {\n        return this._transport.cachedPageNumber(ref);\n    }\n    get loadingParams() {\n        return this._transport.loadingParams;\n    }\n    get loadingTask() {\n        return this._transport.loadingTask;\n    }\n    getFieldObjects() {\n        return this._transport.getFieldObjects();\n    }\n    hasJSActions() {\n        return this._transport.hasJSActions();\n    }\n    getCalculationOrderIds() {\n        return this._transport.getCalculationOrderIds();\n    }\n}\nclass PDFPageProxy {\n    #delayedCleanupTimeout;\n    #pendingCleanup;\n    constructor(pageIndex, pageInfo, transport, pdfBug = false){\n        this.#delayedCleanupTimeout = null;\n        this.#pendingCleanup = false;\n        this._pageIndex = pageIndex;\n        this._pageInfo = pageInfo;\n        this._transport = transport;\n        this._stats = pdfBug ? new StatTimer() : null;\n        this._pdfBug = pdfBug;\n        this.commonObjs = transport.commonObjs;\n        this.objs = new PDFObjects();\n        this._maybeCleanupAfterRender = false;\n        this._intentStates = new Map();\n        this.destroyed = false;\n    }\n    get pageNumber() {\n        return this._pageIndex + 1;\n    }\n    get rotate() {\n        return this._pageInfo.rotate;\n    }\n    get ref() {\n        return this._pageInfo.ref;\n    }\n    get userUnit() {\n        return this._pageInfo.userUnit;\n    }\n    get view() {\n        return this._pageInfo.view;\n    }\n    getViewport({ scale, rotation = this.rotate, offsetX = 0, offsetY = 0, dontFlip = false } = {}) {\n        return new PageViewport({\n            viewBox: this.view,\n            scale,\n            rotation,\n            offsetX,\n            offsetY,\n            dontFlip\n        });\n    }\n    getAnnotations({ intent = \"display\" } = {}) {\n        const { renderingIntent } = this._transport.getRenderingIntent(intent);\n        return this._transport.getAnnotations(this._pageIndex, renderingIntent);\n    }\n    getJSActions() {\n        return this._transport.getPageJSActions(this._pageIndex);\n    }\n    get filterFactory() {\n        return this._transport.filterFactory;\n    }\n    get isPureXfa() {\n        return shadow(this, \"isPureXfa\", !!this._transport._htmlForXfa);\n    }\n    async getXfa() {\n        return this._transport._htmlForXfa?.children[this._pageIndex] || null;\n    }\n    render({ canvasContext, viewport, intent = \"display\", annotationMode = AnnotationMode.ENABLE, transform = null, background = null, optionalContentConfigPromise = null, annotationCanvasMap = null, pageColors = null, printAnnotationStorage = null, isEditing = false }) {\n        this._stats?.time(\"Overall\");\n        const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, isEditing);\n        const { renderingIntent, cacheKey } = intentArgs;\n        this.#pendingCleanup = false;\n        this.#abortDelayedCleanup();\n        optionalContentConfigPromise ||= this._transport.getOptionalContentConfig(renderingIntent);\n        let intentState = this._intentStates.get(cacheKey);\n        if (!intentState) {\n            intentState = Object.create(null);\n            this._intentStates.set(cacheKey, intentState);\n        }\n        if (intentState.streamReaderCancelTimeout) {\n            clearTimeout(intentState.streamReaderCancelTimeout);\n            intentState.streamReaderCancelTimeout = null;\n        }\n        const intentPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);\n        if (!intentState.displayReadyCapability) {\n            intentState.displayReadyCapability = Promise.withResolvers();\n            intentState.operatorList = {\n                fnArray: [],\n                argsArray: [],\n                lastChunk: false,\n                separateAnnots: null\n            };\n            this._stats?.time(\"Page Request\");\n            this._pumpOperatorList(intentArgs);\n        }\n        const complete = (error)=>{\n            intentState.renderTasks.delete(internalRenderTask);\n            if (this._maybeCleanupAfterRender || intentPrint) {\n                this.#pendingCleanup = true;\n            }\n            this.#tryCleanup(!intentPrint);\n            if (error) {\n                internalRenderTask.capability.reject(error);\n                this._abortOperatorList({\n                    intentState,\n                    reason: error instanceof Error ? error : new Error(error)\n                });\n            } else {\n                internalRenderTask.capability.resolve();\n            }\n            if (this._stats) {\n                this._stats.timeEnd(\"Rendering\");\n                this._stats.timeEnd(\"Overall\");\n                if (globalThis.Stats?.enabled) {\n                    globalThis.Stats.add(this.pageNumber, this._stats);\n                }\n            }\n        };\n        const internalRenderTask = new InternalRenderTask({\n            callback: complete,\n            params: {\n                canvasContext,\n                viewport,\n                transform,\n                background\n            },\n            objs: this.objs,\n            commonObjs: this.commonObjs,\n            annotationCanvasMap,\n            operatorList: intentState.operatorList,\n            pageIndex: this._pageIndex,\n            canvasFactory: this._transport.canvasFactory,\n            filterFactory: this._transport.filterFactory,\n            useRequestAnimationFrame: !intentPrint,\n            pdfBug: this._pdfBug,\n            pageColors\n        });\n        (intentState.renderTasks ||= new Set()).add(internalRenderTask);\n        const renderTask = internalRenderTask.task;\n        Promise.all([\n            intentState.displayReadyCapability.promise,\n            optionalContentConfigPromise\n        ]).then(([transparency, optionalContentConfig])=>{\n            if (this.destroyed) {\n                complete();\n                return;\n            }\n            this._stats?.time(\"Rendering\");\n            if (!(optionalContentConfig.renderingIntent & renderingIntent)) {\n                throw new Error(\"Must use the same `intent`-argument when calling the `PDFPageProxy.render` \" + \"and `PDFDocumentProxy.getOptionalContentConfig` methods.\");\n            }\n            internalRenderTask.initializeGraphics({\n                transparency,\n                optionalContentConfig\n            });\n            internalRenderTask.operatorListChanged();\n        }).catch(complete);\n        return renderTask;\n    }\n    getOperatorList({ intent = \"display\", annotationMode = AnnotationMode.ENABLE, printAnnotationStorage = null, isEditing = false } = {}) {\n        function operatorListChanged() {\n            if (intentState.operatorList.lastChunk) {\n                intentState.opListReadCapability.resolve(intentState.operatorList);\n                intentState.renderTasks.delete(opListTask);\n            }\n        }\n        const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, isEditing, true);\n        let intentState = this._intentStates.get(intentArgs.cacheKey);\n        if (!intentState) {\n            intentState = Object.create(null);\n            this._intentStates.set(intentArgs.cacheKey, intentState);\n        }\n        let opListTask;\n        if (!intentState.opListReadCapability) {\n            opListTask = Object.create(null);\n            opListTask.operatorListChanged = operatorListChanged;\n            intentState.opListReadCapability = Promise.withResolvers();\n            (intentState.renderTasks ||= new Set()).add(opListTask);\n            intentState.operatorList = {\n                fnArray: [],\n                argsArray: [],\n                lastChunk: false,\n                separateAnnots: null\n            };\n            this._stats?.time(\"Page Request\");\n            this._pumpOperatorList(intentArgs);\n        }\n        return intentState.opListReadCapability.promise;\n    }\n    streamTextContent({ includeMarkedContent = false, disableNormalization = false } = {}) {\n        const TEXT_CONTENT_CHUNK_SIZE = 100;\n        return this._transport.messageHandler.sendWithStream(\"GetTextContent\", {\n            pageIndex: this._pageIndex,\n            includeMarkedContent: includeMarkedContent === true,\n            disableNormalization: disableNormalization === true\n        }, {\n            highWaterMark: TEXT_CONTENT_CHUNK_SIZE,\n            size (textContent) {\n                return textContent.items.length;\n            }\n        });\n    }\n    getTextContent(params = {}) {\n        if (this._transport._htmlForXfa) {\n            return this.getXfa().then((xfa)=>XfaText.textContent(xfa));\n        }\n        const readableStream = this.streamTextContent(params);\n        return new Promise(function(resolve, reject) {\n            function pump() {\n                reader.read().then(function({ value, done }) {\n                    if (done) {\n                        resolve(textContent);\n                        return;\n                    }\n                    textContent.lang ??= value.lang;\n                    Object.assign(textContent.styles, value.styles);\n                    textContent.items.push(...value.items);\n                    pump();\n                }, reject);\n            }\n            const reader = readableStream.getReader();\n            const textContent = {\n                items: [],\n                styles: Object.create(null),\n                lang: null\n            };\n            pump();\n        });\n    }\n    getStructTree() {\n        return this._transport.getStructTree(this._pageIndex);\n    }\n    _destroy() {\n        this.destroyed = true;\n        const waitOn = [];\n        for (const intentState of this._intentStates.values()){\n            this._abortOperatorList({\n                intentState,\n                reason: new Error(\"Page was destroyed.\"),\n                force: true\n            });\n            if (intentState.opListReadCapability) {\n                continue;\n            }\n            for (const internalRenderTask of intentState.renderTasks){\n                waitOn.push(internalRenderTask.completed);\n                internalRenderTask.cancel();\n            }\n        }\n        this.objs.clear();\n        this.#pendingCleanup = false;\n        this.#abortDelayedCleanup();\n        return Promise.all(waitOn);\n    }\n    cleanup(resetStats = false) {\n        this.#pendingCleanup = true;\n        const success = this.#tryCleanup(false);\n        if (resetStats && success) {\n            this._stats &&= new StatTimer();\n        }\n        return success;\n    }\n    #tryCleanup(delayed = false) {\n        this.#abortDelayedCleanup();\n        if (!this.#pendingCleanup || this.destroyed) {\n            return false;\n        }\n        if (delayed) {\n            this.#delayedCleanupTimeout = setTimeout(()=>{\n                this.#delayedCleanupTimeout = null;\n                this.#tryCleanup(false);\n            }, DELAYED_CLEANUP_TIMEOUT);\n            return false;\n        }\n        for (const { renderTasks, operatorList } of this._intentStates.values()){\n            if (renderTasks.size > 0 || !operatorList.lastChunk) {\n                return false;\n            }\n        }\n        this._intentStates.clear();\n        this.objs.clear();\n        this.#pendingCleanup = false;\n        return true;\n    }\n    #abortDelayedCleanup() {\n        if (this.#delayedCleanupTimeout) {\n            clearTimeout(this.#delayedCleanupTimeout);\n            this.#delayedCleanupTimeout = null;\n        }\n    }\n    _startRenderPage(transparency, cacheKey) {\n        const intentState = this._intentStates.get(cacheKey);\n        if (!intentState) {\n            return;\n        }\n        this._stats?.timeEnd(\"Page Request\");\n        intentState.displayReadyCapability?.resolve(transparency);\n    }\n    _renderPageChunk(operatorListChunk, intentState) {\n        for(let i = 0, ii = operatorListChunk.length; i < ii; i++){\n            intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);\n            intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);\n        }\n        intentState.operatorList.lastChunk = operatorListChunk.lastChunk;\n        intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;\n        for (const internalRenderTask of intentState.renderTasks){\n            internalRenderTask.operatorListChanged();\n        }\n        if (operatorListChunk.lastChunk) {\n            this.#tryCleanup(true);\n        }\n    }\n    _pumpOperatorList({ renderingIntent, cacheKey, annotationStorageSerializable, modifiedIds }) {\n        const { map, transfer } = annotationStorageSerializable;\n        const readableStream = this._transport.messageHandler.sendWithStream(\"GetOperatorList\", {\n            pageIndex: this._pageIndex,\n            intent: renderingIntent,\n            cacheKey,\n            annotationStorage: map,\n            modifiedIds\n        }, transfer);\n        const reader = readableStream.getReader();\n        const intentState = this._intentStates.get(cacheKey);\n        intentState.streamReader = reader;\n        const pump = ()=>{\n            reader.read().then(({ value, done })=>{\n                if (done) {\n                    intentState.streamReader = null;\n                    return;\n                }\n                if (this._transport.destroyed) {\n                    return;\n                }\n                this._renderPageChunk(value, intentState);\n                pump();\n            }, (reason)=>{\n                intentState.streamReader = null;\n                if (this._transport.destroyed) {\n                    return;\n                }\n                if (intentState.operatorList) {\n                    intentState.operatorList.lastChunk = true;\n                    for (const internalRenderTask of intentState.renderTasks){\n                        internalRenderTask.operatorListChanged();\n                    }\n                    this.#tryCleanup(true);\n                }\n                if (intentState.displayReadyCapability) {\n                    intentState.displayReadyCapability.reject(reason);\n                } else if (intentState.opListReadCapability) {\n                    intentState.opListReadCapability.reject(reason);\n                } else {\n                    throw reason;\n                }\n            });\n        };\n        pump();\n    }\n    _abortOperatorList({ intentState, reason, force = false }) {\n        if (!intentState.streamReader) {\n            return;\n        }\n        if (intentState.streamReaderCancelTimeout) {\n            clearTimeout(intentState.streamReaderCancelTimeout);\n            intentState.streamReaderCancelTimeout = null;\n        }\n        if (!force) {\n            if (intentState.renderTasks.size > 0) {\n                return;\n            }\n            if (reason instanceof RenderingCancelledException) {\n                let delay = RENDERING_CANCELLED_TIMEOUT;\n                if (reason.extraDelay > 0 && reason.extraDelay < 1000) {\n                    delay += reason.extraDelay;\n                }\n                intentState.streamReaderCancelTimeout = setTimeout(()=>{\n                    intentState.streamReaderCancelTimeout = null;\n                    this._abortOperatorList({\n                        intentState,\n                        reason,\n                        force: true\n                    });\n                }, delay);\n                return;\n            }\n        }\n        intentState.streamReader.cancel(new AbortException(reason.message)).catch(()=>{});\n        intentState.streamReader = null;\n        if (this._transport.destroyed) {\n            return;\n        }\n        for (const [curCacheKey, curIntentState] of this._intentStates){\n            if (curIntentState === intentState) {\n                this._intentStates.delete(curCacheKey);\n                break;\n            }\n        }\n        this.cleanup();\n    }\n    get stats() {\n        return this._stats;\n    }\n}\nclass LoopbackPort {\n    #listeners;\n    #deferred;\n    postMessage(obj, transfer) {\n        const event = {\n            data: structuredClone(obj, transfer ? {\n                transfer\n            } : null)\n        };\n        this.#deferred.then(()=>{\n            for (const [listener] of this.#listeners){\n                listener.call(this, event);\n            }\n        });\n    }\n    addEventListener(name, listener, options = null) {\n        let rmAbort = null;\n        if (options?.signal instanceof AbortSignal) {\n            const { signal } = options;\n            if (signal.aborted) {\n                warn(\"LoopbackPort - cannot use an `aborted` signal.\");\n                return;\n            }\n            const onAbort = ()=>this.removeEventListener(name, listener);\n            rmAbort = ()=>signal.removeEventListener(\"abort\", onAbort);\n            signal.addEventListener(\"abort\", onAbort);\n        }\n        this.#listeners.set(listener, rmAbort);\n    }\n    removeEventListener(name, listener) {\n        const rmAbort = this.#listeners.get(listener);\n        rmAbort?.();\n        this.#listeners.delete(listener);\n    }\n    terminate() {\n        for (const [, rmAbort] of this.#listeners){\n            rmAbort?.();\n        }\n        this.#listeners.clear();\n    }\n    constructor(){\n        this.#listeners = new Map();\n        this.#deferred = Promise.resolve();\n    }\n}\nclass PDFWorker {\n    static #fakeWorkerId = 0;\n    static #isWorkerDisabled = false;\n    static #workerPorts;\n    static{\n        if (isNodeJS) {\n            this.#isWorkerDisabled = true;\n            GlobalWorkerOptions.workerSrc ||= \"./pdf.worker.mjs\";\n        }\n        this._isSameOrigin = (baseUrl, otherUrl)=>{\n            let base;\n            try {\n                base = new URL(baseUrl);\n                if (!base.origin || base.origin === \"null\") {\n                    return false;\n                }\n            } catch  {\n                return false;\n            }\n            const other = new URL(otherUrl, base);\n            return base.origin === other.origin;\n        };\n        this._createCDNWrapper = (url)=>{\n            const wrapper = `await import(\"${url}\");`;\n            return URL.createObjectURL(new Blob([\n                wrapper\n            ], {\n                type: \"text/javascript\"\n            }));\n        };\n    }\n    constructor({ name = null, port = null, verbosity = getVerbosityLevel() } = {}){\n        this.name = name;\n        this.destroyed = false;\n        this.verbosity = verbosity;\n        this._readyCapability = Promise.withResolvers();\n        this._port = null;\n        this._webWorker = null;\n        this._messageHandler = null;\n        if (port) {\n            if (PDFWorker.#workerPorts?.has(port)) {\n                throw new Error(\"Cannot use more than one PDFWorker per port.\");\n            }\n            (PDFWorker.#workerPorts ||= new WeakMap()).set(port, this);\n            this._initializeFromPort(port);\n            return;\n        }\n        this._initialize();\n    }\n    get promise() {\n        return this._readyCapability.promise;\n    }\n    #resolve() {\n        this._readyCapability.resolve();\n        this._messageHandler.send(\"configure\", {\n            verbosity: this.verbosity\n        });\n    }\n    get port() {\n        return this._port;\n    }\n    get messageHandler() {\n        return this._messageHandler;\n    }\n    _initializeFromPort(port) {\n        this._port = port;\n        this._messageHandler = new MessageHandler(\"main\", \"worker\", port);\n        this._messageHandler.on(\"ready\", function() {});\n        this.#resolve();\n    }\n    _initialize() {\n        if (PDFWorker.#isWorkerDisabled || PDFWorker.#mainThreadWorkerMessageHandler) {\n            this._setupFakeWorker();\n            return;\n        }\n        let { workerSrc } = PDFWorker;\n        try {\n            if (!PDFWorker._isSameOrigin(window.location.href, workerSrc)) {\n                workerSrc = PDFWorker._createCDNWrapper(new URL(workerSrc, window.location).href);\n            }\n            const worker = new Worker(workerSrc, {\n                type: \"module\"\n            });\n            const messageHandler = new MessageHandler(\"main\", \"worker\", worker);\n            const terminateEarly = ()=>{\n                ac.abort();\n                messageHandler.destroy();\n                worker.terminate();\n                if (this.destroyed) {\n                    this._readyCapability.reject(new Error(\"Worker was destroyed\"));\n                } else {\n                    this._setupFakeWorker();\n                }\n            };\n            const ac = new AbortController();\n            worker.addEventListener(\"error\", ()=>{\n                if (!this._webWorker) {\n                    terminateEarly();\n                }\n            }, {\n                signal: ac.signal\n            });\n            messageHandler.on(\"test\", (data)=>{\n                ac.abort();\n                if (this.destroyed || !data) {\n                    terminateEarly();\n                    return;\n                }\n                this._messageHandler = messageHandler;\n                this._port = worker;\n                this._webWorker = worker;\n                this.#resolve();\n            });\n            messageHandler.on(\"ready\", (data)=>{\n                ac.abort();\n                if (this.destroyed) {\n                    terminateEarly();\n                    return;\n                }\n                try {\n                    sendTest();\n                } catch  {\n                    this._setupFakeWorker();\n                }\n            });\n            const sendTest = ()=>{\n                const testObj = new Uint8Array();\n                messageHandler.send(\"test\", testObj, [\n                    testObj.buffer\n                ]);\n            };\n            sendTest();\n            return;\n        } catch  {\n            info(\"The worker has been disabled.\");\n        }\n        this._setupFakeWorker();\n    }\n    _setupFakeWorker() {\n        if (!PDFWorker.#isWorkerDisabled) {\n            warn(\"Setting up fake worker.\");\n            PDFWorker.#isWorkerDisabled = true;\n        }\n        PDFWorker._setupFakeWorkerGlobal.then((WorkerMessageHandler)=>{\n            if (this.destroyed) {\n                this._readyCapability.reject(new Error(\"Worker was destroyed\"));\n                return;\n            }\n            const port = new LoopbackPort();\n            this._port = port;\n            const id = `fake${PDFWorker.#fakeWorkerId++}`;\n            const workerHandler = new MessageHandler(id + \"_worker\", id, port);\n            WorkerMessageHandler.setup(workerHandler, port);\n            this._messageHandler = new MessageHandler(id, id + \"_worker\", port);\n            this.#resolve();\n        }).catch((reason)=>{\n            this._readyCapability.reject(new Error(`Setting up fake worker failed: \"${reason.message}\".`));\n        });\n    }\n    destroy() {\n        this.destroyed = true;\n        this._webWorker?.terminate();\n        this._webWorker = null;\n        PDFWorker.#workerPorts?.delete(this._port);\n        this._port = null;\n        this._messageHandler?.destroy();\n        this._messageHandler = null;\n    }\n    static fromPort(params) {\n        if (!params?.port) {\n            throw new Error(\"PDFWorker.fromPort - invalid method signature.\");\n        }\n        const cachedPort = this.#workerPorts?.get(params.port);\n        if (cachedPort) {\n            if (cachedPort._pendingDestroy) {\n                throw new Error(\"PDFWorker.fromPort - the worker is being destroyed.\\n\" + \"Please remember to await `PDFDocumentLoadingTask.destroy()`-calls.\");\n            }\n            return cachedPort;\n        }\n        return new PDFWorker(params);\n    }\n    static get workerSrc() {\n        if (GlobalWorkerOptions.workerSrc) {\n            return GlobalWorkerOptions.workerSrc;\n        }\n        throw new Error('No \"GlobalWorkerOptions.workerSrc\" specified.');\n    }\n    static get #mainThreadWorkerMessageHandler() {\n        try {\n            return globalThis.pdfjsWorker?.WorkerMessageHandler || null;\n        } catch  {\n            return null;\n        }\n    }\n    static get _setupFakeWorkerGlobal() {\n        const loader = async ()=>{\n            if (this.#mainThreadWorkerMessageHandler) {\n                return this.#mainThreadWorkerMessageHandler;\n            }\n            const worker = await import(/*webpackIgnore: true*/ this.workerSrc);\n            return worker.WorkerMessageHandler;\n        };\n        return shadow(this, \"_setupFakeWorkerGlobal\", loader());\n    }\n}\nclass WorkerTransport {\n    #methodPromises;\n    #pageCache;\n    #pagePromises;\n    #pageRefCache;\n    #passwordCapability;\n    constructor(messageHandler, loadingTask, networkStream, params, factory){\n        this.#methodPromises = new Map();\n        this.#pageCache = new Map();\n        this.#pagePromises = new Map();\n        this.#pageRefCache = new Map();\n        this.#passwordCapability = null;\n        this.messageHandler = messageHandler;\n        this.loadingTask = loadingTask;\n        this.commonObjs = new PDFObjects();\n        this.fontLoader = new FontLoader({\n            ownerDocument: params.ownerDocument,\n            styleElement: params.styleElement\n        });\n        this.loadingParams = params.loadingParams;\n        this._params = params;\n        this.canvasFactory = factory.canvasFactory;\n        this.filterFactory = factory.filterFactory;\n        this.cMapReaderFactory = factory.cMapReaderFactory;\n        this.standardFontDataFactory = factory.standardFontDataFactory;\n        this.destroyed = false;\n        this.destroyCapability = null;\n        this._networkStream = networkStream;\n        this._fullReader = null;\n        this._lastProgress = null;\n        this.downloadInfoCapability = Promise.withResolvers();\n        this.setupMessageHandler();\n    }\n    #cacheSimpleMethod(name, data = null) {\n        const cachedPromise = this.#methodPromises.get(name);\n        if (cachedPromise) {\n            return cachedPromise;\n        }\n        const promise = this.messageHandler.sendWithPromise(name, data);\n        this.#methodPromises.set(name, promise);\n        return promise;\n    }\n    get annotationStorage() {\n        return shadow(this, \"annotationStorage\", new AnnotationStorage());\n    }\n    getRenderingIntent(intent, annotationMode = AnnotationMode.ENABLE, printAnnotationStorage = null, isEditing = false, isOpList = false) {\n        let renderingIntent = RenderingIntentFlag.DISPLAY;\n        let annotationStorageSerializable = SerializableEmpty;\n        switch(intent){\n            case \"any\":\n                renderingIntent = RenderingIntentFlag.ANY;\n                break;\n            case \"display\":\n                break;\n            case \"print\":\n                renderingIntent = RenderingIntentFlag.PRINT;\n                break;\n            default:\n                warn(`getRenderingIntent - invalid intent: ${intent}`);\n        }\n        const annotationStorage = renderingIntent & RenderingIntentFlag.PRINT && printAnnotationStorage instanceof PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;\n        switch(annotationMode){\n            case AnnotationMode.DISABLE:\n                renderingIntent += RenderingIntentFlag.ANNOTATIONS_DISABLE;\n                break;\n            case AnnotationMode.ENABLE:\n                break;\n            case AnnotationMode.ENABLE_FORMS:\n                renderingIntent += RenderingIntentFlag.ANNOTATIONS_FORMS;\n                break;\n            case AnnotationMode.ENABLE_STORAGE:\n                renderingIntent += RenderingIntentFlag.ANNOTATIONS_STORAGE;\n                annotationStorageSerializable = annotationStorage.serializable;\n                break;\n            default:\n                warn(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);\n        }\n        if (isEditing) {\n            renderingIntent += RenderingIntentFlag.IS_EDITING;\n        }\n        if (isOpList) {\n            renderingIntent += RenderingIntentFlag.OPLIST;\n        }\n        const { ids: modifiedIds, hash: modifiedIdsHash } = annotationStorage.modifiedIds;\n        const cacheKeyBuf = [\n            renderingIntent,\n            annotationStorageSerializable.hash,\n            modifiedIdsHash\n        ];\n        return {\n            renderingIntent,\n            cacheKey: cacheKeyBuf.join(\"_\"),\n            annotationStorageSerializable,\n            modifiedIds\n        };\n    }\n    destroy() {\n        if (this.destroyCapability) {\n            return this.destroyCapability.promise;\n        }\n        this.destroyed = true;\n        this.destroyCapability = Promise.withResolvers();\n        this.#passwordCapability?.reject(new Error(\"Worker was destroyed during onPassword callback\"));\n        const waitOn = [];\n        for (const page of this.#pageCache.values()){\n            waitOn.push(page._destroy());\n        }\n        this.#pageCache.clear();\n        this.#pagePromises.clear();\n        this.#pageRefCache.clear();\n        if (this.hasOwnProperty(\"annotationStorage\")) {\n            this.annotationStorage.resetModified();\n        }\n        const terminated = this.messageHandler.sendWithPromise(\"Terminate\", null);\n        waitOn.push(terminated);\n        Promise.all(waitOn).then(()=>{\n            this.commonObjs.clear();\n            this.fontLoader.clear();\n            this.#methodPromises.clear();\n            this.filterFactory.destroy();\n            TextLayer.cleanup();\n            this._networkStream?.cancelAllRequests(new AbortException(\"Worker was terminated.\"));\n            this.messageHandler?.destroy();\n            this.messageHandler = null;\n            this.destroyCapability.resolve();\n        }, this.destroyCapability.reject);\n        return this.destroyCapability.promise;\n    }\n    setupMessageHandler() {\n        const { messageHandler, loadingTask } = this;\n        messageHandler.on(\"GetReader\", (data, sink)=>{\n            assert(this._networkStream, \"GetReader - no `IPDFStream` instance available.\");\n            this._fullReader = this._networkStream.getFullReader();\n            this._fullReader.onProgress = (evt)=>{\n                this._lastProgress = {\n                    loaded: evt.loaded,\n                    total: evt.total\n                };\n            };\n            sink.onPull = ()=>{\n                this._fullReader.read().then(function({ value, done }) {\n                    if (done) {\n                        sink.close();\n                        return;\n                    }\n                    assert(value instanceof ArrayBuffer, \"GetReader - expected an ArrayBuffer.\");\n                    sink.enqueue(new Uint8Array(value), 1, [\n                        value\n                    ]);\n                }).catch((reason)=>{\n                    sink.error(reason);\n                });\n            };\n            sink.onCancel = (reason)=>{\n                this._fullReader.cancel(reason);\n                sink.ready.catch((readyReason)=>{\n                    if (this.destroyed) {\n                        return;\n                    }\n                    throw readyReason;\n                });\n            };\n        });\n        messageHandler.on(\"ReaderHeadersReady\", async (data)=>{\n            await this._fullReader.headersReady;\n            const { isStreamingSupported, isRangeSupported, contentLength } = this._fullReader;\n            if (!isStreamingSupported || !isRangeSupported) {\n                if (this._lastProgress) {\n                    loadingTask.onProgress?.(this._lastProgress);\n                }\n                this._fullReader.onProgress = (evt)=>{\n                    loadingTask.onProgress?.({\n                        loaded: evt.loaded,\n                        total: evt.total\n                    });\n                };\n            }\n            return {\n                isStreamingSupported,\n                isRangeSupported,\n                contentLength\n            };\n        });\n        messageHandler.on(\"GetRangeReader\", (data, sink)=>{\n            assert(this._networkStream, \"GetRangeReader - no `IPDFStream` instance available.\");\n            const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);\n            if (!rangeReader) {\n                sink.close();\n                return;\n            }\n            sink.onPull = ()=>{\n                rangeReader.read().then(function({ value, done }) {\n                    if (done) {\n                        sink.close();\n                        return;\n                    }\n                    assert(value instanceof ArrayBuffer, \"GetRangeReader - expected an ArrayBuffer.\");\n                    sink.enqueue(new Uint8Array(value), 1, [\n                        value\n                    ]);\n                }).catch((reason)=>{\n                    sink.error(reason);\n                });\n            };\n            sink.onCancel = (reason)=>{\n                rangeReader.cancel(reason);\n                sink.ready.catch((readyReason)=>{\n                    if (this.destroyed) {\n                        return;\n                    }\n                    throw readyReason;\n                });\n            };\n        });\n        messageHandler.on(\"GetDoc\", ({ pdfInfo })=>{\n            this._numPages = pdfInfo.numPages;\n            this._htmlForXfa = pdfInfo.htmlForXfa;\n            delete pdfInfo.htmlForXfa;\n            loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));\n        });\n        messageHandler.on(\"DocException\", function(ex) {\n            let reason;\n            switch(ex.name){\n                case \"PasswordException\":\n                    reason = new PasswordException(ex.message, ex.code);\n                    break;\n                case \"InvalidPDFException\":\n                    reason = new InvalidPDFException(ex.message);\n                    break;\n                case \"MissingPDFException\":\n                    reason = new MissingPDFException(ex.message);\n                    break;\n                case \"UnexpectedResponseException\":\n                    reason = new UnexpectedResponseException(ex.message, ex.status);\n                    break;\n                case \"UnknownErrorException\":\n                    reason = new UnknownErrorException(ex.message, ex.details);\n                    break;\n                default:\n                    unreachable(\"DocException - expected a valid Error.\");\n            }\n            loadingTask._capability.reject(reason);\n        });\n        messageHandler.on(\"PasswordRequest\", (exception)=>{\n            this.#passwordCapability = Promise.withResolvers();\n            if (loadingTask.onPassword) {\n                const updatePassword = (password)=>{\n                    if (password instanceof Error) {\n                        this.#passwordCapability.reject(password);\n                    } else {\n                        this.#passwordCapability.resolve({\n                            password\n                        });\n                    }\n                };\n                try {\n                    loadingTask.onPassword(updatePassword, exception.code);\n                } catch (ex) {\n                    this.#passwordCapability.reject(ex);\n                }\n            } else {\n                this.#passwordCapability.reject(new PasswordException(exception.message, exception.code));\n            }\n            return this.#passwordCapability.promise;\n        });\n        messageHandler.on(\"DataLoaded\", (data)=>{\n            loadingTask.onProgress?.({\n                loaded: data.length,\n                total: data.length\n            });\n            this.downloadInfoCapability.resolve(data);\n        });\n        messageHandler.on(\"StartRenderPage\", (data)=>{\n            if (this.destroyed) {\n                return;\n            }\n            const page = this.#pageCache.get(data.pageIndex);\n            page._startRenderPage(data.transparency, data.cacheKey);\n        });\n        messageHandler.on(\"commonobj\", ([id, type, exportedData])=>{\n            if (this.destroyed) {\n                return null;\n            }\n            if (this.commonObjs.has(id)) {\n                return null;\n            }\n            switch(type){\n                case \"Font\":\n                    const { disableFontFace, fontExtraProperties, pdfBug } = this._params;\n                    if (\"error\" in exportedData) {\n                        const exportedError = exportedData.error;\n                        warn(`Error during font loading: ${exportedError}`);\n                        this.commonObjs.resolve(id, exportedError);\n                        break;\n                    }\n                    const inspectFont = pdfBug && globalThis.FontInspector?.enabled ? (font, url)=>globalThis.FontInspector.fontAdded(font, url) : null;\n                    const font = new FontFaceObject(exportedData, {\n                        disableFontFace,\n                        inspectFont\n                    });\n                    this.fontLoader.bind(font).catch(()=>messageHandler.sendWithPromise(\"FontFallback\", {\n                            id\n                        })).finally(()=>{\n                        if (!fontExtraProperties && font.data) {\n                            font.data = null;\n                        }\n                        this.commonObjs.resolve(id, font);\n                    });\n                    break;\n                case \"CopyLocalImage\":\n                    const { imageRef } = exportedData;\n                    assert(imageRef, \"The imageRef must be defined.\");\n                    for (const pageProxy of this.#pageCache.values()){\n                        for (const [, data] of pageProxy.objs){\n                            if (data?.ref !== imageRef) {\n                                continue;\n                            }\n                            if (!data.dataLen) {\n                                return null;\n                            }\n                            this.commonObjs.resolve(id, structuredClone(data));\n                            return data.dataLen;\n                        }\n                    }\n                    break;\n                case \"FontPath\":\n                case \"Image\":\n                case \"Pattern\":\n                    this.commonObjs.resolve(id, exportedData);\n                    break;\n                default:\n                    throw new Error(`Got unknown common object type ${type}`);\n            }\n            return null;\n        });\n        messageHandler.on(\"obj\", ([id, pageIndex, type, imageData])=>{\n            if (this.destroyed) {\n                return;\n            }\n            const pageProxy = this.#pageCache.get(pageIndex);\n            if (pageProxy.objs.has(id)) {\n                return;\n            }\n            if (pageProxy._intentStates.size === 0) {\n                imageData?.bitmap?.close();\n                return;\n            }\n            switch(type){\n                case \"Image\":\n                    pageProxy.objs.resolve(id, imageData);\n                    if (imageData?.dataLen > MAX_IMAGE_SIZE_TO_CACHE) {\n                        pageProxy._maybeCleanupAfterRender = true;\n                    }\n                    break;\n                case \"Pattern\":\n                    pageProxy.objs.resolve(id, imageData);\n                    break;\n                default:\n                    throw new Error(`Got unknown object type ${type}`);\n            }\n        });\n        messageHandler.on(\"DocProgress\", (data)=>{\n            if (this.destroyed) {\n                return;\n            }\n            loadingTask.onProgress?.({\n                loaded: data.loaded,\n                total: data.total\n            });\n        });\n        messageHandler.on(\"FetchBuiltInCMap\", async (data)=>{\n            if (this.destroyed) {\n                throw new Error(\"Worker was destroyed.\");\n            }\n            if (!this.cMapReaderFactory) {\n                throw new Error(\"CMapReaderFactory not initialized, see the `useWorkerFetch` parameter.\");\n            }\n            return this.cMapReaderFactory.fetch(data);\n        });\n        messageHandler.on(\"FetchStandardFontData\", async (data)=>{\n            if (this.destroyed) {\n                throw new Error(\"Worker was destroyed.\");\n            }\n            if (!this.standardFontDataFactory) {\n                throw new Error(\"StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.\");\n            }\n            return this.standardFontDataFactory.fetch(data);\n        });\n    }\n    getData() {\n        return this.messageHandler.sendWithPromise(\"GetData\", null);\n    }\n    saveDocument() {\n        if (this.annotationStorage.size <= 0) {\n            warn(\"saveDocument called while `annotationStorage` is empty, \" + \"please use the getData-method instead.\");\n        }\n        const { map, transfer } = this.annotationStorage.serializable;\n        return this.messageHandler.sendWithPromise(\"SaveDocument\", {\n            isPureXfa: !!this._htmlForXfa,\n            numPages: this._numPages,\n            annotationStorage: map,\n            filename: this._fullReader?.filename ?? null\n        }, transfer).finally(()=>{\n            this.annotationStorage.resetModified();\n        });\n    }\n    getPage(pageNumber) {\n        if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {\n            return Promise.reject(new Error(\"Invalid page request.\"));\n        }\n        const pageIndex = pageNumber - 1, cachedPromise = this.#pagePromises.get(pageIndex);\n        if (cachedPromise) {\n            return cachedPromise;\n        }\n        const promise = this.messageHandler.sendWithPromise(\"GetPage\", {\n            pageIndex\n        }).then((pageInfo)=>{\n            if (this.destroyed) {\n                throw new Error(\"Transport destroyed\");\n            }\n            if (pageInfo.refStr) {\n                this.#pageRefCache.set(pageInfo.refStr, pageNumber);\n            }\n            const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.pdfBug);\n            this.#pageCache.set(pageIndex, page);\n            return page;\n        });\n        this.#pagePromises.set(pageIndex, promise);\n        return promise;\n    }\n    getPageIndex(ref) {\n        if (!isRefProxy(ref)) {\n            return Promise.reject(new Error(\"Invalid pageIndex request.\"));\n        }\n        return this.messageHandler.sendWithPromise(\"GetPageIndex\", {\n            num: ref.num,\n            gen: ref.gen\n        });\n    }\n    getAnnotations(pageIndex, intent) {\n        return this.messageHandler.sendWithPromise(\"GetAnnotations\", {\n            pageIndex,\n            intent\n        });\n    }\n    getFieldObjects() {\n        return this.#cacheSimpleMethod(\"GetFieldObjects\");\n    }\n    hasJSActions() {\n        return this.#cacheSimpleMethod(\"HasJSActions\");\n    }\n    getCalculationOrderIds() {\n        return this.messageHandler.sendWithPromise(\"GetCalculationOrderIds\", null);\n    }\n    getDestinations() {\n        return this.messageHandler.sendWithPromise(\"GetDestinations\", null);\n    }\n    getDestination(id) {\n        if (typeof id !== \"string\") {\n            return Promise.reject(new Error(\"Invalid destination request.\"));\n        }\n        return this.messageHandler.sendWithPromise(\"GetDestination\", {\n            id\n        });\n    }\n    getPageLabels() {\n        return this.messageHandler.sendWithPromise(\"GetPageLabels\", null);\n    }\n    getPageLayout() {\n        return this.messageHandler.sendWithPromise(\"GetPageLayout\", null);\n    }\n    getPageMode() {\n        return this.messageHandler.sendWithPromise(\"GetPageMode\", null);\n    }\n    getViewerPreferences() {\n        return this.messageHandler.sendWithPromise(\"GetViewerPreferences\", null);\n    }\n    getOpenAction() {\n        return this.messageHandler.sendWithPromise(\"GetOpenAction\", null);\n    }\n    getAttachments() {\n        return this.messageHandler.sendWithPromise(\"GetAttachments\", null);\n    }\n    getDocJSActions() {\n        return this.#cacheSimpleMethod(\"GetDocJSActions\");\n    }\n    getPageJSActions(pageIndex) {\n        return this.messageHandler.sendWithPromise(\"GetPageJSActions\", {\n            pageIndex\n        });\n    }\n    getStructTree(pageIndex) {\n        return this.messageHandler.sendWithPromise(\"GetStructTree\", {\n            pageIndex\n        });\n    }\n    getOutline() {\n        return this.messageHandler.sendWithPromise(\"GetOutline\", null);\n    }\n    getOptionalContentConfig(renderingIntent) {\n        return this.#cacheSimpleMethod(\"GetOptionalContentConfig\").then((data)=>new OptionalContentConfig(data, renderingIntent));\n    }\n    getPermissions() {\n        return this.messageHandler.sendWithPromise(\"GetPermissions\", null);\n    }\n    getMetadata() {\n        const name = \"GetMetadata\", cachedPromise = this.#methodPromises.get(name);\n        if (cachedPromise) {\n            return cachedPromise;\n        }\n        const promise = this.messageHandler.sendWithPromise(name, null).then((results)=>({\n                info: results[0],\n                metadata: results[1] ? new Metadata(results[1]) : null,\n                contentDispositionFilename: this._fullReader?.filename ?? null,\n                contentLength: this._fullReader?.contentLength ?? null\n            }));\n        this.#methodPromises.set(name, promise);\n        return promise;\n    }\n    getMarkInfo() {\n        return this.messageHandler.sendWithPromise(\"GetMarkInfo\", null);\n    }\n    async startCleanup(keepLoadedFonts = false) {\n        if (this.destroyed) {\n            return;\n        }\n        await this.messageHandler.sendWithPromise(\"Cleanup\", null);\n        for (const page of this.#pageCache.values()){\n            const cleanupSuccessful = page.cleanup();\n            if (!cleanupSuccessful) {\n                throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);\n            }\n        }\n        this.commonObjs.clear();\n        if (!keepLoadedFonts) {\n            this.fontLoader.clear();\n        }\n        this.#methodPromises.clear();\n        this.filterFactory.destroy(true);\n        TextLayer.cleanup();\n    }\n    cachedPageNumber(ref) {\n        if (!isRefProxy(ref)) {\n            return null;\n        }\n        const refStr = ref.gen === 0 ? `${ref.num}R` : `${ref.num}R${ref.gen}`;\n        return this.#pageRefCache.get(refStr) ?? null;\n    }\n}\nconst INITIAL_DATA = Symbol(\"INITIAL_DATA\");\nclass PDFObjects {\n    #objs;\n    #ensureObj(objId) {\n        return this.#objs[objId] ||= {\n            ...Promise.withResolvers(),\n            data: INITIAL_DATA\n        };\n    }\n    get(objId, callback = null) {\n        if (callback) {\n            const obj = this.#ensureObj(objId);\n            obj.promise.then(()=>callback(obj.data));\n            return null;\n        }\n        const obj = this.#objs[objId];\n        if (!obj || obj.data === INITIAL_DATA) {\n            throw new Error(`Requesting object that isn't resolved yet ${objId}.`);\n        }\n        return obj.data;\n    }\n    has(objId) {\n        const obj = this.#objs[objId];\n        return !!obj && obj.data !== INITIAL_DATA;\n    }\n    resolve(objId, data = null) {\n        const obj = this.#ensureObj(objId);\n        obj.data = data;\n        obj.resolve();\n    }\n    clear() {\n        for(const objId in this.#objs){\n            const { data } = this.#objs[objId];\n            data?.bitmap?.close();\n        }\n        this.#objs = Object.create(null);\n    }\n    *[Symbol.iterator]() {\n        for(const objId in this.#objs){\n            const { data } = this.#objs[objId];\n            if (data === INITIAL_DATA) {\n                continue;\n            }\n            yield [\n                objId,\n                data\n            ];\n        }\n    }\n    constructor(){\n        this.#objs = Object.create(null);\n    }\n}\nclass RenderTask {\n    #internalRenderTask;\n    constructor(internalRenderTask){\n        this.#internalRenderTask = null;\n        this.#internalRenderTask = internalRenderTask;\n        this.onContinue = null;\n    }\n    get promise() {\n        return this.#internalRenderTask.capability.promise;\n    }\n    cancel(extraDelay = 0) {\n        this.#internalRenderTask.cancel(null, extraDelay);\n    }\n    get separateAnnots() {\n        const { separateAnnots } = this.#internalRenderTask.operatorList;\n        if (!separateAnnots) {\n            return false;\n        }\n        const { annotationCanvasMap } = this.#internalRenderTask;\n        return separateAnnots.form || separateAnnots.canvas && annotationCanvasMap?.size > 0;\n    }\n}\nclass InternalRenderTask {\n    #rAF;\n    static #canvasInUse = new WeakSet();\n    constructor({ callback, params, objs, commonObjs, annotationCanvasMap, operatorList, pageIndex, canvasFactory, filterFactory, useRequestAnimationFrame = false, pdfBug = false, pageColors = null }){\n        this.#rAF = null;\n        this.callback = callback;\n        this.params = params;\n        this.objs = objs;\n        this.commonObjs = commonObjs;\n        this.annotationCanvasMap = annotationCanvasMap;\n        this.operatorListIdx = null;\n        this.operatorList = operatorList;\n        this._pageIndex = pageIndex;\n        this.canvasFactory = canvasFactory;\n        this.filterFactory = filterFactory;\n        this._pdfBug = pdfBug;\n        this.pageColors = pageColors;\n        this.running = false;\n        this.graphicsReadyCallback = null;\n        this.graphicsReady = false;\n        this._useRequestAnimationFrame = useRequestAnimationFrame === true && \"undefined\" !== \"undefined\";\n        this.cancelled = false;\n        this.capability = Promise.withResolvers();\n        this.task = new RenderTask(this);\n        this._cancelBound = this.cancel.bind(this);\n        this._continueBound = this._continue.bind(this);\n        this._scheduleNextBound = this._scheduleNext.bind(this);\n        this._nextBound = this._next.bind(this);\n        this._canvas = params.canvasContext.canvas;\n    }\n    get completed() {\n        return this.capability.promise.catch(function() {});\n    }\n    initializeGraphics({ transparency = false, optionalContentConfig }) {\n        if (this.cancelled) {\n            return;\n        }\n        if (this._canvas) {\n            if (InternalRenderTask.#canvasInUse.has(this._canvas)) {\n                throw new Error(\"Cannot use the same canvas during multiple render() operations. \" + \"Use different canvas or ensure previous operations were \" + \"cancelled or completed.\");\n            }\n            InternalRenderTask.#canvasInUse.add(this._canvas);\n        }\n        if (this._pdfBug && globalThis.StepperManager?.enabled) {\n            this.stepper = globalThis.StepperManager.create(this._pageIndex);\n            this.stepper.init(this.operatorList);\n            this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();\n        }\n        const { canvasContext, viewport, transform, background } = this.params;\n        this.gfx = new CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {\n            optionalContentConfig\n        }, this.annotationCanvasMap, this.pageColors);\n        this.gfx.beginDrawing({\n            transform,\n            viewport,\n            transparency,\n            background\n        });\n        this.operatorListIdx = 0;\n        this.graphicsReady = true;\n        this.graphicsReadyCallback?.();\n    }\n    cancel(error = null, extraDelay = 0) {\n        this.running = false;\n        this.cancelled = true;\n        this.gfx?.endDrawing();\n        if (this.#rAF) {\n            window.cancelAnimationFrame(this.#rAF);\n            this.#rAF = null;\n        }\n        InternalRenderTask.#canvasInUse.delete(this._canvas);\n        this.callback(error || new RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, extraDelay));\n    }\n    operatorListChanged() {\n        if (!this.graphicsReady) {\n            this.graphicsReadyCallback ||= this._continueBound;\n            return;\n        }\n        this.stepper?.updateOperatorList(this.operatorList);\n        if (this.running) {\n            return;\n        }\n        this._continue();\n    }\n    _continue() {\n        this.running = true;\n        if (this.cancelled) {\n            return;\n        }\n        if (this.task.onContinue) {\n            this.task.onContinue(this._scheduleNextBound);\n        } else {\n            this._scheduleNext();\n        }\n    }\n    _scheduleNext() {\n        if (this._useRequestAnimationFrame) {\n            this.#rAF = window.requestAnimationFrame(()=>{\n                this.#rAF = null;\n                this._nextBound().catch(this._cancelBound);\n            });\n        } else {\n            Promise.resolve().then(this._nextBound).catch(this._cancelBound);\n        }\n    }\n    async _next() {\n        if (this.cancelled) {\n            return;\n        }\n        this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);\n        if (this.operatorListIdx === this.operatorList.argsArray.length) {\n            this.running = false;\n            if (this.operatorList.lastChunk) {\n                this.gfx.endDrawing();\n                InternalRenderTask.#canvasInUse.delete(this._canvas);\n                this.callback();\n            }\n        }\n    }\n}\nconst version = \"4.9.155\";\nconst build = \"a4eb8407c\";\n; // ./src/shared/scripting_utils.js\nfunction makeColorComp(n) {\n    return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, \"0\");\n}\nfunction scaleAndClamp(x) {\n    return Math.max(0, Math.min(255, 255 * x));\n}\nclass ColorConverters {\n    static CMYK_G([c, y, m, k]) {\n        return [\n            \"G\",\n            1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)\n        ];\n    }\n    static G_CMYK([g]) {\n        return [\n            \"CMYK\",\n            0,\n            0,\n            0,\n            1 - g\n        ];\n    }\n    static G_RGB([g]) {\n        return [\n            \"RGB\",\n            g,\n            g,\n            g\n        ];\n    }\n    static G_rgb([g]) {\n        g = scaleAndClamp(g);\n        return [\n            g,\n            g,\n            g\n        ];\n    }\n    static G_HTML([g]) {\n        const G = makeColorComp(g);\n        return `#${G}${G}${G}`;\n    }\n    static RGB_G([r, g, b]) {\n        return [\n            \"G\",\n            0.3 * r + 0.59 * g + 0.11 * b\n        ];\n    }\n    static RGB_rgb(color) {\n        return color.map(scaleAndClamp);\n    }\n    static RGB_HTML(color) {\n        return `#${color.map(makeColorComp).join(\"\")}`;\n    }\n    static T_HTML() {\n        return \"#00000000\";\n    }\n    static T_rgb() {\n        return [\n            null\n        ];\n    }\n    static CMYK_RGB([c, y, m, k]) {\n        return [\n            \"RGB\",\n            1 - Math.min(1, c + k),\n            1 - Math.min(1, m + k),\n            1 - Math.min(1, y + k)\n        ];\n    }\n    static CMYK_rgb([c, y, m, k]) {\n        return [\n            scaleAndClamp(1 - Math.min(1, c + k)),\n            scaleAndClamp(1 - Math.min(1, m + k)),\n            scaleAndClamp(1 - Math.min(1, y + k))\n        ];\n    }\n    static CMYK_HTML(components) {\n        const rgb = this.CMYK_RGB(components).slice(1);\n        return this.RGB_HTML(rgb);\n    }\n    static RGB_CMYK([r, g, b]) {\n        const c = 1 - r;\n        const m = 1 - g;\n        const y = 1 - b;\n        const k = Math.min(c, m, y);\n        return [\n            \"CMYK\",\n            c,\n            m,\n            y,\n            k\n        ];\n    }\n}\n; // ./src/display/svg_factory.js\nclass BaseSVGFactory {\n    create(width, height, skipDimensions = false) {\n        if (width <= 0 || height <= 0) {\n            throw new Error(\"Invalid SVG dimensions\");\n        }\n        const svg = this._createSVG(\"svg:svg\");\n        svg.setAttribute(\"version\", \"1.1\");\n        if (!skipDimensions) {\n            svg.setAttribute(\"width\", `${width}px`);\n            svg.setAttribute(\"height\", `${height}px`);\n        }\n        svg.setAttribute(\"preserveAspectRatio\", \"none\");\n        svg.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n        return svg;\n    }\n    createElement(type) {\n        if (typeof type !== \"string\") {\n            throw new Error(\"Invalid SVG element type\");\n        }\n        return this._createSVG(type);\n    }\n    _createSVG(type) {\n        unreachable(\"Abstract method `_createSVG` called.\");\n    }\n}\nclass DOMSVGFactory extends BaseSVGFactory {\n    _createSVG(type) {\n        return document.createElementNS(SVG_NS, type);\n    }\n}\n; // ./src/display/xfa_layer.js\nclass XfaLayer {\n    static setupStorage(html, id, element, storage, intent) {\n        const storedData = storage.getValue(id, {\n            value: null\n        });\n        switch(element.name){\n            case \"textarea\":\n                if (storedData.value !== null) {\n                    html.textContent = storedData.value;\n                }\n                if (intent === \"print\") {\n                    break;\n                }\n                html.addEventListener(\"input\", (event)=>{\n                    storage.setValue(id, {\n                        value: event.target.value\n                    });\n                });\n                break;\n            case \"input\":\n                if (element.attributes.type === \"radio\" || element.attributes.type === \"checkbox\") {\n                    if (storedData.value === element.attributes.xfaOn) {\n                        html.setAttribute(\"checked\", true);\n                    } else if (storedData.value === element.attributes.xfaOff) {\n                        html.removeAttribute(\"checked\");\n                    }\n                    if (intent === \"print\") {\n                        break;\n                    }\n                    html.addEventListener(\"change\", (event)=>{\n                        storage.setValue(id, {\n                            value: event.target.checked ? event.target.getAttribute(\"xfaOn\") : event.target.getAttribute(\"xfaOff\")\n                        });\n                    });\n                } else {\n                    if (storedData.value !== null) {\n                        html.setAttribute(\"value\", storedData.value);\n                    }\n                    if (intent === \"print\") {\n                        break;\n                    }\n                    html.addEventListener(\"input\", (event)=>{\n                        storage.setValue(id, {\n                            value: event.target.value\n                        });\n                    });\n                }\n                break;\n            case \"select\":\n                if (storedData.value !== null) {\n                    html.setAttribute(\"value\", storedData.value);\n                    for (const option of element.children){\n                        if (option.attributes.value === storedData.value) {\n                            option.attributes.selected = true;\n                        } else if (option.attributes.hasOwnProperty(\"selected\")) {\n                            delete option.attributes.selected;\n                        }\n                    }\n                }\n                html.addEventListener(\"input\", (event)=>{\n                    const options = event.target.options;\n                    const value = options.selectedIndex === -1 ? \"\" : options[options.selectedIndex].value;\n                    storage.setValue(id, {\n                        value\n                    });\n                });\n                break;\n        }\n    }\n    static setAttributes({ html, element, storage = null, intent, linkService }) {\n        const { attributes } = element;\n        const isHTMLAnchorElement = html instanceof HTMLAnchorElement;\n        if (attributes.type === \"radio\") {\n            attributes.name = `${attributes.name}-${intent}`;\n        }\n        for (const [key, value] of Object.entries(attributes)){\n            if (value === null || value === undefined) {\n                continue;\n            }\n            switch(key){\n                case \"class\":\n                    if (value.length) {\n                        html.setAttribute(key, value.join(\" \"));\n                    }\n                    break;\n                case \"dataId\":\n                    break;\n                case \"id\":\n                    html.setAttribute(\"data-element-id\", value);\n                    break;\n                case \"style\":\n                    Object.assign(html.style, value);\n                    break;\n                case \"textContent\":\n                    html.textContent = value;\n                    break;\n                default:\n                    if (!isHTMLAnchorElement || key !== \"href\" && key !== \"newWindow\") {\n                        html.setAttribute(key, value);\n                    }\n            }\n        }\n        if (isHTMLAnchorElement) {\n            linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);\n        }\n        if (storage && attributes.dataId) {\n            this.setupStorage(html, attributes.dataId, element, storage);\n        }\n    }\n    static render(parameters) {\n        const storage = parameters.annotationStorage;\n        const linkService = parameters.linkService;\n        const root = parameters.xfaHtml;\n        const intent = parameters.intent || \"display\";\n        const rootHtml = document.createElement(root.name);\n        if (root.attributes) {\n            this.setAttributes({\n                html: rootHtml,\n                element: root,\n                intent,\n                linkService\n            });\n        }\n        const isNotForRichText = intent !== \"richText\";\n        const rootDiv = parameters.div;\n        rootDiv.append(rootHtml);\n        if (parameters.viewport) {\n            const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n            rootDiv.style.transform = transform;\n        }\n        if (isNotForRichText) {\n            rootDiv.setAttribute(\"class\", \"xfaLayer xfaFont\");\n        }\n        const textDivs = [];\n        if (root.children.length === 0) {\n            if (root.value) {\n                const node = document.createTextNode(root.value);\n                rootHtml.append(node);\n                if (isNotForRichText && XfaText.shouldBuildText(root.name)) {\n                    textDivs.push(node);\n                }\n            }\n            return {\n                textDivs\n            };\n        }\n        const stack = [\n            [\n                root,\n                -1,\n                rootHtml\n            ]\n        ];\n        while(stack.length > 0){\n            const [parent, i, html] = stack.at(-1);\n            if (i + 1 === parent.children.length) {\n                stack.pop();\n                continue;\n            }\n            const child = parent.children[++stack.at(-1)[1]];\n            if (child === null) {\n                continue;\n            }\n            const { name } = child;\n            if (name === \"#text\") {\n                const node = document.createTextNode(child.value);\n                textDivs.push(node);\n                html.append(node);\n                continue;\n            }\n            const childHtml = child?.attributes?.xmlns ? document.createElementNS(child.attributes.xmlns, name) : document.createElement(name);\n            html.append(childHtml);\n            if (child.attributes) {\n                this.setAttributes({\n                    html: childHtml,\n                    element: child,\n                    storage,\n                    intent,\n                    linkService\n                });\n            }\n            if (child.children?.length > 0) {\n                stack.push([\n                    child,\n                    -1,\n                    childHtml\n                ]);\n            } else if (child.value) {\n                const node = document.createTextNode(child.value);\n                if (isNotForRichText && XfaText.shouldBuildText(name)) {\n                    textDivs.push(node);\n                }\n                childHtml.append(node);\n            }\n        }\n        for (const el of rootDiv.querySelectorAll(\".xfaNonInteractive input, .xfaNonInteractive textarea\")){\n            el.setAttribute(\"readOnly\", true);\n        }\n        return {\n            textDivs\n        };\n    }\n    static update(parameters) {\n        const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n        parameters.div.style.transform = transform;\n        parameters.div.hidden = false;\n    }\n}\n; // ./src/display/annotation_layer.js\nconst DEFAULT_TAB_INDEX = 1000;\nconst annotation_layer_DEFAULT_FONT_SIZE = 9;\nconst GetElementsByNameSet = new WeakSet();\nfunction getRectDims(rect) {\n    return {\n        width: rect[2] - rect[0],\n        height: rect[3] - rect[1]\n    };\n}\nclass AnnotationElementFactory {\n    static create(parameters) {\n        const subtype = parameters.data.annotationType;\n        switch(subtype){\n            case AnnotationType.LINK:\n                return new LinkAnnotationElement(parameters);\n            case AnnotationType.TEXT:\n                return new TextAnnotationElement(parameters);\n            case AnnotationType.WIDGET:\n                const fieldType = parameters.data.fieldType;\n                switch(fieldType){\n                    case \"Tx\":\n                        return new TextWidgetAnnotationElement(parameters);\n                    case \"Btn\":\n                        if (parameters.data.radioButton) {\n                            return new RadioButtonWidgetAnnotationElement(parameters);\n                        } else if (parameters.data.checkBox) {\n                            return new CheckboxWidgetAnnotationElement(parameters);\n                        }\n                        return new PushButtonWidgetAnnotationElement(parameters);\n                    case \"Ch\":\n                        return new ChoiceWidgetAnnotationElement(parameters);\n                    case \"Sig\":\n                        return new SignatureWidgetAnnotationElement(parameters);\n                }\n                return new WidgetAnnotationElement(parameters);\n            case AnnotationType.POPUP:\n                return new PopupAnnotationElement(parameters);\n            case AnnotationType.FREETEXT:\n                return new FreeTextAnnotationElement(parameters);\n            case AnnotationType.LINE:\n                return new LineAnnotationElement(parameters);\n            case AnnotationType.SQUARE:\n                return new SquareAnnotationElement(parameters);\n            case AnnotationType.CIRCLE:\n                return new CircleAnnotationElement(parameters);\n            case AnnotationType.POLYLINE:\n                return new PolylineAnnotationElement(parameters);\n            case AnnotationType.CARET:\n                return new CaretAnnotationElement(parameters);\n            case AnnotationType.INK:\n                return new InkAnnotationElement(parameters);\n            case AnnotationType.POLYGON:\n                return new PolygonAnnotationElement(parameters);\n            case AnnotationType.HIGHLIGHT:\n                return new HighlightAnnotationElement(parameters);\n            case AnnotationType.UNDERLINE:\n                return new UnderlineAnnotationElement(parameters);\n            case AnnotationType.SQUIGGLY:\n                return new SquigglyAnnotationElement(parameters);\n            case AnnotationType.STRIKEOUT:\n                return new StrikeOutAnnotationElement(parameters);\n            case AnnotationType.STAMP:\n                return new StampAnnotationElement(parameters);\n            case AnnotationType.FILEATTACHMENT:\n                return new FileAttachmentAnnotationElement(parameters);\n            default:\n                return new AnnotationElement(parameters);\n        }\n    }\n}\nclass AnnotationElement {\n    #updates;\n    #hasBorder;\n    #popupElement;\n    constructor(parameters, { isRenderable = false, ignoreBorder = false, createQuadrilaterals = false } = {}){\n        this.#updates = null;\n        this.#hasBorder = false;\n        this.#popupElement = null;\n        this.isRenderable = isRenderable;\n        this.data = parameters.data;\n        this.layer = parameters.layer;\n        this.linkService = parameters.linkService;\n        this.downloadManager = parameters.downloadManager;\n        this.imageResourcesPath = parameters.imageResourcesPath;\n        this.renderForms = parameters.renderForms;\n        this.svgFactory = parameters.svgFactory;\n        this.annotationStorage = parameters.annotationStorage;\n        this.enableScripting = parameters.enableScripting;\n        this.hasJSActions = parameters.hasJSActions;\n        this._fieldObjects = parameters.fieldObjects;\n        this.parent = parameters.parent;\n        if (isRenderable) {\n            this.container = this._createContainer(ignoreBorder);\n        }\n        if (createQuadrilaterals) {\n            this._createQuadrilaterals();\n        }\n    }\n    static _hasPopupData({ titleObj, contentsObj, richText }) {\n        return !!(titleObj?.str || contentsObj?.str || richText?.str);\n    }\n    get _isEditable() {\n        return this.data.isEditable;\n    }\n    get hasPopupData() {\n        return AnnotationElement._hasPopupData(this.data);\n    }\n    updateEdited(params) {\n        if (!this.container) {\n            return;\n        }\n        this.#updates ||= {\n            rect: this.data.rect.slice(0)\n        };\n        const { rect } = params;\n        if (rect) {\n            this.#setRectEdited(rect);\n        }\n        this.#popupElement?.popup.updateEdited(params);\n    }\n    resetEdited() {\n        if (!this.#updates) {\n            return;\n        }\n        this.#setRectEdited(this.#updates.rect);\n        this.#popupElement?.popup.resetEdited();\n        this.#updates = null;\n    }\n    #setRectEdited(rect) {\n        const { container: { style }, data: { rect: currentRect, rotation }, parent: { viewport: { rawDims: { pageWidth, pageHeight, pageX, pageY } } } } = this;\n        currentRect?.splice(0, 4, ...rect);\n        const { width, height } = getRectDims(rect);\n        style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;\n        style.top = `${100 * (pageHeight - rect[3] + pageY) / pageHeight}%`;\n        if (rotation === 0) {\n            style.width = `${100 * width / pageWidth}%`;\n            style.height = `${100 * height / pageHeight}%`;\n        } else {\n            this.setRotation(rotation);\n        }\n    }\n    _createContainer(ignoreBorder) {\n        const { data, parent: { page, viewport } } = this;\n        const container = document.createElement(\"section\");\n        container.setAttribute(\"data-annotation-id\", data.id);\n        if (!(this instanceof WidgetAnnotationElement)) {\n            container.tabIndex = DEFAULT_TAB_INDEX;\n        }\n        const { style } = container;\n        style.zIndex = this.parent.zIndex++;\n        if (data.alternativeText) {\n            container.title = data.alternativeText;\n        }\n        if (data.noRotate) {\n            container.classList.add(\"norotate\");\n        }\n        if (!data.rect || this instanceof PopupAnnotationElement) {\n            const { rotation } = data;\n            if (!data.hasOwnCanvas && rotation !== 0) {\n                this.setRotation(rotation, container);\n            }\n            return container;\n        }\n        const { width, height } = getRectDims(data.rect);\n        if (!ignoreBorder && data.borderStyle.width > 0) {\n            style.borderWidth = `${data.borderStyle.width}px`;\n            const horizontalRadius = data.borderStyle.horizontalCornerRadius;\n            const verticalRadius = data.borderStyle.verticalCornerRadius;\n            if (horizontalRadius > 0 || verticalRadius > 0) {\n                const radius = `calc(${horizontalRadius}px * var(--scale-factor)) / calc(${verticalRadius}px * var(--scale-factor))`;\n                style.borderRadius = radius;\n            } else if (this instanceof RadioButtonWidgetAnnotationElement) {\n                const radius = `calc(${width}px * var(--scale-factor)) / calc(${height}px * var(--scale-factor))`;\n                style.borderRadius = radius;\n            }\n            switch(data.borderStyle.style){\n                case AnnotationBorderStyleType.SOLID:\n                    style.borderStyle = \"solid\";\n                    break;\n                case AnnotationBorderStyleType.DASHED:\n                    style.borderStyle = \"dashed\";\n                    break;\n                case AnnotationBorderStyleType.BEVELED:\n                    warn(\"Unimplemented border style: beveled\");\n                    break;\n                case AnnotationBorderStyleType.INSET:\n                    warn(\"Unimplemented border style: inset\");\n                    break;\n                case AnnotationBorderStyleType.UNDERLINE:\n                    style.borderBottomStyle = \"solid\";\n                    break;\n                default:\n                    break;\n            }\n            const borderColor = data.borderColor || null;\n            if (borderColor) {\n                this.#hasBorder = true;\n                style.borderColor = Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);\n            } else {\n                style.borderWidth = 0;\n            }\n        }\n        const rect = Util.normalizeRect([\n            data.rect[0],\n            page.view[3] - data.rect[1] + page.view[1],\n            data.rect[2],\n            page.view[3] - data.rect[3] + page.view[1]\n        ]);\n        const { pageWidth, pageHeight, pageX, pageY } = viewport.rawDims;\n        style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;\n        style.top = `${100 * (rect[1] - pageY) / pageHeight}%`;\n        const { rotation } = data;\n        if (data.hasOwnCanvas || rotation === 0) {\n            style.width = `${100 * width / pageWidth}%`;\n            style.height = `${100 * height / pageHeight}%`;\n        } else {\n            this.setRotation(rotation, container);\n        }\n        return container;\n    }\n    setRotation(angle, container = this.container) {\n        if (!this.data.rect) {\n            return;\n        }\n        const { pageWidth, pageHeight } = this.parent.viewport.rawDims;\n        const { width, height } = getRectDims(this.data.rect);\n        let elementWidth, elementHeight;\n        if (angle % 180 === 0) {\n            elementWidth = 100 * width / pageWidth;\n            elementHeight = 100 * height / pageHeight;\n        } else {\n            elementWidth = 100 * height / pageWidth;\n            elementHeight = 100 * width / pageHeight;\n        }\n        container.style.width = `${elementWidth}%`;\n        container.style.height = `${elementHeight}%`;\n        container.setAttribute(\"data-main-rotation\", (360 - angle) % 360);\n    }\n    get _commonActions() {\n        const setColor = (jsName, styleName, event)=>{\n            const color = event.detail[jsName];\n            const colorType = color[0];\n            const colorArray = color.slice(1);\n            event.target.style[styleName] = ColorConverters[`${colorType}_HTML`](colorArray);\n            this.annotationStorage.setValue(this.data.id, {\n                [styleName]: ColorConverters[`${colorType}_rgb`](colorArray)\n            });\n        };\n        return shadow(this, \"_commonActions\", {\n            display: (event)=>{\n                const { display } = event.detail;\n                const hidden = display % 2 === 1;\n                this.container.style.visibility = hidden ? \"hidden\" : \"visible\";\n                this.annotationStorage.setValue(this.data.id, {\n                    noView: hidden,\n                    noPrint: display === 1 || display === 2\n                });\n            },\n            print: (event)=>{\n                this.annotationStorage.setValue(this.data.id, {\n                    noPrint: !event.detail.print\n                });\n            },\n            hidden: (event)=>{\n                const { hidden } = event.detail;\n                this.container.style.visibility = hidden ? \"hidden\" : \"visible\";\n                this.annotationStorage.setValue(this.data.id, {\n                    noPrint: hidden,\n                    noView: hidden\n                });\n            },\n            focus: (event)=>{\n                setTimeout(()=>event.target.focus({\n                        preventScroll: false\n                    }), 0);\n            },\n            userName: (event)=>{\n                event.target.title = event.detail.userName;\n            },\n            readonly: (event)=>{\n                event.target.disabled = event.detail.readonly;\n            },\n            required: (event)=>{\n                this._setRequired(event.target, event.detail.required);\n            },\n            bgColor: (event)=>{\n                setColor(\"bgColor\", \"backgroundColor\", event);\n            },\n            fillColor: (event)=>{\n                setColor(\"fillColor\", \"backgroundColor\", event);\n            },\n            fgColor: (event)=>{\n                setColor(\"fgColor\", \"color\", event);\n            },\n            textColor: (event)=>{\n                setColor(\"textColor\", \"color\", event);\n            },\n            borderColor: (event)=>{\n                setColor(\"borderColor\", \"borderColor\", event);\n            },\n            strokeColor: (event)=>{\n                setColor(\"strokeColor\", \"borderColor\", event);\n            },\n            rotation: (event)=>{\n                const angle = event.detail.rotation;\n                this.setRotation(angle);\n                this.annotationStorage.setValue(this.data.id, {\n                    rotation: angle\n                });\n            }\n        });\n    }\n    _dispatchEventFromSandbox(actions, jsEvent) {\n        const commonActions = this._commonActions;\n        for (const name of Object.keys(jsEvent.detail)){\n            const action = actions[name] || commonActions[name];\n            action?.(jsEvent);\n        }\n    }\n    _setDefaultPropertiesFromJS(element) {\n        if (!this.enableScripting) {\n            return;\n        }\n        const storedData = this.annotationStorage.getRawValue(this.data.id);\n        if (!storedData) {\n            return;\n        }\n        const commonActions = this._commonActions;\n        for (const [actionName, detail] of Object.entries(storedData)){\n            const action = commonActions[actionName];\n            if (action) {\n                const eventProxy = {\n                    detail: {\n                        [actionName]: detail\n                    },\n                    target: element\n                };\n                action(eventProxy);\n                delete storedData[actionName];\n            }\n        }\n    }\n    _createQuadrilaterals() {\n        if (!this.container) {\n            return;\n        }\n        const { quadPoints } = this.data;\n        if (!quadPoints) {\n            return;\n        }\n        const [rectBlX, rectBlY, rectTrX, rectTrY] = this.data.rect.map((x)=>Math.fround(x));\n        if (quadPoints.length === 8) {\n            const [trX, trY, blX, blY] = quadPoints.subarray(2, 6);\n            if (rectTrX === trX && rectTrY === trY && rectBlX === blX && rectBlY === blY) {\n                return;\n            }\n        }\n        const { style } = this.container;\n        let svgBuffer;\n        if (this.#hasBorder) {\n            const { borderColor, borderWidth } = style;\n            style.borderWidth = 0;\n            svgBuffer = [\n                \"url('data:image/svg+xml;utf8,\",\n                `<svg xmlns=\"http://www.w3.org/2000/svg\"`,\n                ` preserveAspectRatio=\"none\" viewBox=\"0 0 1 1\">`,\n                `<g fill=\"transparent\" stroke=\"${borderColor}\" stroke-width=\"${borderWidth}\">`\n            ];\n            this.container.classList.add(\"hasBorder\");\n        }\n        const width = rectTrX - rectBlX;\n        const height = rectTrY - rectBlY;\n        const { svgFactory } = this;\n        const svg = svgFactory.createElement(\"svg\");\n        svg.classList.add(\"quadrilateralsContainer\");\n        svg.setAttribute(\"width\", 0);\n        svg.setAttribute(\"height\", 0);\n        const defs = svgFactory.createElement(\"defs\");\n        svg.append(defs);\n        const clipPath = svgFactory.createElement(\"clipPath\");\n        const id = `clippath_${this.data.id}`;\n        clipPath.setAttribute(\"id\", id);\n        clipPath.setAttribute(\"clipPathUnits\", \"objectBoundingBox\");\n        defs.append(clipPath);\n        for(let i = 2, ii = quadPoints.length; i < ii; i += 8){\n            const trX = quadPoints[i];\n            const trY = quadPoints[i + 1];\n            const blX = quadPoints[i + 2];\n            const blY = quadPoints[i + 3];\n            const rect = svgFactory.createElement(\"rect\");\n            const x = (blX - rectBlX) / width;\n            const y = (rectTrY - trY) / height;\n            const rectWidth = (trX - blX) / width;\n            const rectHeight = (trY - blY) / height;\n            rect.setAttribute(\"x\", x);\n            rect.setAttribute(\"y\", y);\n            rect.setAttribute(\"width\", rectWidth);\n            rect.setAttribute(\"height\", rectHeight);\n            clipPath.append(rect);\n            svgBuffer?.push(`<rect vector-effect=\"non-scaling-stroke\" x=\"${x}\" y=\"${y}\" width=\"${rectWidth}\" height=\"${rectHeight}\"/>`);\n        }\n        if (this.#hasBorder) {\n            svgBuffer.push(`</g></svg>')`);\n            style.backgroundImage = svgBuffer.join(\"\");\n        }\n        this.container.append(svg);\n        this.container.style.clipPath = `url(#${id})`;\n    }\n    _createPopup() {\n        const { data } = this;\n        const popup = this.#popupElement = new PopupAnnotationElement({\n            data: {\n                color: data.color,\n                titleObj: data.titleObj,\n                modificationDate: data.modificationDate,\n                contentsObj: data.contentsObj,\n                richText: data.richText,\n                parentRect: data.rect,\n                borderStyle: 0,\n                id: `popup_${data.id}`,\n                rotation: data.rotation\n            },\n            parent: this.parent,\n            elements: [\n                this\n            ]\n        });\n        this.parent.div.append(popup.render());\n    }\n    render() {\n        unreachable(\"Abstract method `AnnotationElement.render` called\");\n    }\n    _getElementsByName(name, skipId = null) {\n        const fields = [];\n        if (this._fieldObjects) {\n            const fieldObj = this._fieldObjects[name];\n            if (fieldObj) {\n                for (const { page, id, exportValues } of fieldObj){\n                    if (page === -1) {\n                        continue;\n                    }\n                    if (id === skipId) {\n                        continue;\n                    }\n                    const exportValue = typeof exportValues === \"string\" ? exportValues : null;\n                    const domElement = document.querySelector(`[data-element-id=\"${id}\"]`);\n                    if (domElement && !GetElementsByNameSet.has(domElement)) {\n                        warn(`_getElementsByName - element not allowed: ${id}`);\n                        continue;\n                    }\n                    fields.push({\n                        id,\n                        exportValue,\n                        domElement\n                    });\n                }\n            }\n            return fields;\n        }\n        for (const domElement of document.getElementsByName(name)){\n            const { exportValue } = domElement;\n            const id = domElement.getAttribute(\"data-element-id\");\n            if (id === skipId) {\n                continue;\n            }\n            if (!GetElementsByNameSet.has(domElement)) {\n                continue;\n            }\n            fields.push({\n                id,\n                exportValue,\n                domElement\n            });\n        }\n        return fields;\n    }\n    show() {\n        if (this.container) {\n            this.container.hidden = false;\n        }\n        this.popup?.maybeShow();\n    }\n    hide() {\n        if (this.container) {\n            this.container.hidden = true;\n        }\n        this.popup?.forceHide();\n    }\n    getElementsToTriggerPopup() {\n        return this.container;\n    }\n    addHighlightArea() {\n        const triggers = this.getElementsToTriggerPopup();\n        if (Array.isArray(triggers)) {\n            for (const element of triggers){\n                element.classList.add(\"highlightArea\");\n            }\n        } else {\n            triggers.classList.add(\"highlightArea\");\n        }\n    }\n    _editOnDoubleClick() {\n        if (!this._isEditable) {\n            return;\n        }\n        const { annotationEditorType: mode, data: { id: editId } } = this;\n        this.container.addEventListener(\"dblclick\", ()=>{\n            this.linkService.eventBus?.dispatch(\"switchannotationeditormode\", {\n                source: this,\n                mode,\n                editId\n            });\n        });\n    }\n}\nclass LinkAnnotationElement extends AnnotationElement {\n    constructor(parameters, options = null){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: !!options?.ignoreBorder,\n            createQuadrilaterals: true\n        });\n        this.isTooltipOnly = parameters.data.isTooltipOnly;\n    }\n    render() {\n        const { data, linkService } = this;\n        const link = document.createElement(\"a\");\n        link.setAttribute(\"data-element-id\", data.id);\n        let isBound = false;\n        if (data.url) {\n            linkService.addLinkAttributes(link, data.url, data.newWindow);\n            isBound = true;\n        } else if (data.action) {\n            this._bindNamedAction(link, data.action);\n            isBound = true;\n        } else if (data.attachment) {\n            this.#bindAttachment(link, data.attachment, data.attachmentDest);\n            isBound = true;\n        } else if (data.setOCGState) {\n            this.#bindSetOCGState(link, data.setOCGState);\n            isBound = true;\n        } else if (data.dest) {\n            this._bindLink(link, data.dest);\n            isBound = true;\n        } else {\n            if (data.actions && (data.actions.Action || data.actions[\"Mouse Up\"] || data.actions[\"Mouse Down\"]) && this.enableScripting && this.hasJSActions) {\n                this._bindJSAction(link, data);\n                isBound = true;\n            }\n            if (data.resetForm) {\n                this._bindResetFormAction(link, data.resetForm);\n                isBound = true;\n            } else if (this.isTooltipOnly && !isBound) {\n                this._bindLink(link, \"\");\n                isBound = true;\n            }\n        }\n        this.container.classList.add(\"linkAnnotation\");\n        if (isBound) {\n            this.container.append(link);\n        }\n        return this.container;\n    }\n    #setInternalLink() {\n        this.container.setAttribute(\"data-internal-link\", \"\");\n    }\n    _bindLink(link, destination) {\n        link.href = this.linkService.getDestinationHash(destination);\n        link.onclick = ()=>{\n            if (destination) {\n                this.linkService.goToDestination(destination);\n            }\n            return false;\n        };\n        if (destination || destination === \"\") {\n            this.#setInternalLink();\n        }\n    }\n    _bindNamedAction(link, action) {\n        link.href = this.linkService.getAnchorUrl(\"\");\n        link.onclick = ()=>{\n            this.linkService.executeNamedAction(action);\n            return false;\n        };\n        this.#setInternalLink();\n    }\n    #bindAttachment(link, attachment, dest = null) {\n        link.href = this.linkService.getAnchorUrl(\"\");\n        if (attachment.description) {\n            link.title = attachment.description;\n        }\n        link.onclick = ()=>{\n            this.downloadManager?.openOrDownloadData(attachment.content, attachment.filename, dest);\n            return false;\n        };\n        this.#setInternalLink();\n    }\n    #bindSetOCGState(link, action) {\n        link.href = this.linkService.getAnchorUrl(\"\");\n        link.onclick = ()=>{\n            this.linkService.executeSetOCGState(action);\n            return false;\n        };\n        this.#setInternalLink();\n    }\n    _bindJSAction(link, data) {\n        link.href = this.linkService.getAnchorUrl(\"\");\n        const map = new Map([\n            [\n                \"Action\",\n                \"onclick\"\n            ],\n            [\n                \"Mouse Up\",\n                \"onmouseup\"\n            ],\n            [\n                \"Mouse Down\",\n                \"onmousedown\"\n            ]\n        ]);\n        for (const name of Object.keys(data.actions)){\n            const jsName = map.get(name);\n            if (!jsName) {\n                continue;\n            }\n            link[jsName] = ()=>{\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id: data.id,\n                        name\n                    }\n                });\n                return false;\n            };\n        }\n        if (!link.onclick) {\n            link.onclick = ()=>false;\n        }\n        this.#setInternalLink();\n    }\n    _bindResetFormAction(link, resetForm) {\n        const otherClickAction = link.onclick;\n        if (!otherClickAction) {\n            link.href = this.linkService.getAnchorUrl(\"\");\n        }\n        this.#setInternalLink();\n        if (!this._fieldObjects) {\n            warn(`_bindResetFormAction - \"resetForm\" action not supported, ` + \"ensure that the `fieldObjects` parameter is provided.\");\n            if (!otherClickAction) {\n                link.onclick = ()=>false;\n            }\n            return;\n        }\n        link.onclick = ()=>{\n            otherClickAction?.();\n            const { fields: resetFormFields, refs: resetFormRefs, include } = resetForm;\n            const allFields = [];\n            if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {\n                const fieldIds = new Set(resetFormRefs);\n                for (const fieldName of resetFormFields){\n                    const fields = this._fieldObjects[fieldName] || [];\n                    for (const { id } of fields){\n                        fieldIds.add(id);\n                    }\n                }\n                for (const fields of Object.values(this._fieldObjects)){\n                    for (const field of fields){\n                        if (fieldIds.has(field.id) === include) {\n                            allFields.push(field);\n                        }\n                    }\n                }\n            } else {\n                for (const fields of Object.values(this._fieldObjects)){\n                    allFields.push(...fields);\n                }\n            }\n            const storage = this.annotationStorage;\n            const allIds = [];\n            for (const field of allFields){\n                const { id } = field;\n                allIds.push(id);\n                switch(field.type){\n                    case \"text\":\n                        {\n                            const value = field.defaultValue || \"\";\n                            storage.setValue(id, {\n                                value\n                            });\n                            break;\n                        }\n                    case \"checkbox\":\n                    case \"radiobutton\":\n                        {\n                            const value = field.defaultValue === field.exportValues;\n                            storage.setValue(id, {\n                                value\n                            });\n                            break;\n                        }\n                    case \"combobox\":\n                    case \"listbox\":\n                        {\n                            const value = field.defaultValue || \"\";\n                            storage.setValue(id, {\n                                value\n                            });\n                            break;\n                        }\n                    default:\n                        continue;\n                }\n                const domElement = document.querySelector(`[data-element-id=\"${id}\"]`);\n                if (!domElement) {\n                    continue;\n                } else if (!GetElementsByNameSet.has(domElement)) {\n                    warn(`_bindResetFormAction - element not allowed: ${id}`);\n                    continue;\n                }\n                domElement.dispatchEvent(new Event(\"resetform\"));\n            }\n            if (this.enableScripting) {\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id: \"app\",\n                        ids: allIds,\n                        name: \"ResetForm\"\n                    }\n                });\n            }\n            return false;\n        };\n    }\n}\nclass TextAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true\n        });\n    }\n    render() {\n        this.container.classList.add(\"textAnnotation\");\n        const image = document.createElement(\"img\");\n        image.src = this.imageResourcesPath + \"annotation-\" + this.data.name.toLowerCase() + \".svg\";\n        image.setAttribute(\"data-l10n-id\", \"pdfjs-text-annotation-type\");\n        image.setAttribute(\"data-l10n-args\", JSON.stringify({\n            type: this.data.name\n        }));\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.append(image);\n        return this.container;\n    }\n}\nclass WidgetAnnotationElement extends AnnotationElement {\n    render() {\n        return this.container;\n    }\n    showElementAndHideCanvas(element) {\n        if (this.data.hasOwnCanvas) {\n            if (element.previousSibling?.nodeName === \"CANVAS\") {\n                element.previousSibling.hidden = true;\n            }\n            element.hidden = false;\n        }\n    }\n    _getKeyModifier(event) {\n        return util_FeatureTest.platform.isMac ? event.metaKey : event.ctrlKey;\n    }\n    _setEventListener(element, elementData, baseName, eventName, valueGetter) {\n        if (baseName.includes(\"mouse\")) {\n            element.addEventListener(baseName, (event)=>{\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id: this.data.id,\n                        name: eventName,\n                        value: valueGetter(event),\n                        shift: event.shiftKey,\n                        modifier: this._getKeyModifier(event)\n                    }\n                });\n            });\n        } else {\n            element.addEventListener(baseName, (event)=>{\n                if (baseName === \"blur\") {\n                    if (!elementData.focused || !event.relatedTarget) {\n                        return;\n                    }\n                    elementData.focused = false;\n                } else if (baseName === \"focus\") {\n                    if (elementData.focused) {\n                        return;\n                    }\n                    elementData.focused = true;\n                }\n                if (!valueGetter) {\n                    return;\n                }\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id: this.data.id,\n                        name: eventName,\n                        value: valueGetter(event)\n                    }\n                });\n            });\n        }\n    }\n    _setEventListeners(element, elementData, names, getter) {\n        for (const [baseName, eventName] of names){\n            if (eventName === \"Action\" || this.data.actions?.[eventName]) {\n                if (eventName === \"Focus\" || eventName === \"Blur\") {\n                    elementData ||= {\n                        focused: false\n                    };\n                }\n                this._setEventListener(element, elementData, baseName, eventName, getter);\n                if (eventName === \"Focus\" && !this.data.actions?.Blur) {\n                    this._setEventListener(element, elementData, \"blur\", \"Blur\", null);\n                } else if (eventName === \"Blur\" && !this.data.actions?.Focus) {\n                    this._setEventListener(element, elementData, \"focus\", \"Focus\", null);\n                }\n            }\n        }\n    }\n    _setBackgroundColor(element) {\n        const color = this.data.backgroundColor || null;\n        element.style.backgroundColor = color === null ? \"transparent\" : Util.makeHexColor(color[0], color[1], color[2]);\n    }\n    _setTextStyle(element) {\n        const TEXT_ALIGNMENT = [\n            \"left\",\n            \"center\",\n            \"right\"\n        ];\n        const { fontColor } = this.data.defaultAppearanceData;\n        const fontSize = this.data.defaultAppearanceData.fontSize || annotation_layer_DEFAULT_FONT_SIZE;\n        const style = element.style;\n        let computedFontSize;\n        const BORDER_SIZE = 2;\n        const roundToOneDecimal = (x)=>Math.round(10 * x) / 10;\n        if (this.data.multiLine) {\n            const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);\n            const numberOfLines = Math.round(height / (LINE_FACTOR * fontSize)) || 1;\n            const lineHeight = height / numberOfLines;\n            computedFontSize = Math.min(fontSize, roundToOneDecimal(lineHeight / LINE_FACTOR));\n        } else {\n            const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);\n            computedFontSize = Math.min(fontSize, roundToOneDecimal(height / LINE_FACTOR));\n        }\n        style.fontSize = `calc(${computedFontSize}px * var(--scale-factor))`;\n        style.color = Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);\n        if (this.data.textAlignment !== null) {\n            style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];\n        }\n    }\n    _setRequired(element, isRequired) {\n        if (isRequired) {\n            element.setAttribute(\"required\", true);\n        } else {\n            element.removeAttribute(\"required\");\n        }\n        element.setAttribute(\"aria-required\", isRequired);\n    }\n}\nclass TextWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        const isRenderable = parameters.renderForms || parameters.data.hasOwnCanvas || !parameters.data.hasAppearance && !!parameters.data.fieldValue;\n        super(parameters, {\n            isRenderable\n        });\n    }\n    setPropertyOnSiblings(base, key, value, keyInStorage) {\n        const storage = this.annotationStorage;\n        for (const element of this._getElementsByName(base.name, base.id)){\n            if (element.domElement) {\n                element.domElement[key] = value;\n            }\n            storage.setValue(element.id, {\n                [keyInStorage]: value\n            });\n        }\n    }\n    render() {\n        const storage = this.annotationStorage;\n        const id = this.data.id;\n        this.container.classList.add(\"textWidgetAnnotation\");\n        let element = null;\n        if (this.renderForms) {\n            const storedData = storage.getValue(id, {\n                value: this.data.fieldValue\n            });\n            let textContent = storedData.value || \"\";\n            const maxLen = storage.getValue(id, {\n                charLimit: this.data.maxLen\n            }).charLimit;\n            if (maxLen && textContent.length > maxLen) {\n                textContent = textContent.slice(0, maxLen);\n            }\n            let fieldFormattedValues = storedData.formattedValue || this.data.textContent?.join(\"\\n\") || null;\n            if (fieldFormattedValues && this.data.comb) {\n                fieldFormattedValues = fieldFormattedValues.replaceAll(/\\s+/g, \"\");\n            }\n            const elementData = {\n                userValue: textContent,\n                formattedValue: fieldFormattedValues,\n                lastCommittedValue: null,\n                commitKey: 1,\n                focused: false\n            };\n            if (this.data.multiLine) {\n                element = document.createElement(\"textarea\");\n                element.textContent = fieldFormattedValues ?? textContent;\n                if (this.data.doNotScroll) {\n                    element.style.overflowY = \"hidden\";\n                }\n            } else {\n                element = document.createElement(\"input\");\n                element.type = \"text\";\n                element.setAttribute(\"value\", fieldFormattedValues ?? textContent);\n                if (this.data.doNotScroll) {\n                    element.style.overflowX = \"hidden\";\n                }\n            }\n            if (this.data.hasOwnCanvas) {\n                element.hidden = true;\n            }\n            GetElementsByNameSet.add(element);\n            element.setAttribute(\"data-element-id\", id);\n            element.disabled = this.data.readOnly;\n            element.name = this.data.fieldName;\n            element.tabIndex = DEFAULT_TAB_INDEX;\n            this._setRequired(element, this.data.required);\n            if (maxLen) {\n                element.maxLength = maxLen;\n            }\n            element.addEventListener(\"input\", (event)=>{\n                storage.setValue(id, {\n                    value: event.target.value\n                });\n                this.setPropertyOnSiblings(element, \"value\", event.target.value, \"value\");\n                elementData.formattedValue = null;\n            });\n            element.addEventListener(\"resetform\", (event)=>{\n                const defaultValue = this.data.defaultFieldValue ?? \"\";\n                element.value = elementData.userValue = defaultValue;\n                elementData.formattedValue = null;\n            });\n            let blurListener = (event)=>{\n                const { formattedValue } = elementData;\n                if (formattedValue !== null && formattedValue !== undefined) {\n                    event.target.value = formattedValue;\n                }\n                event.target.scrollLeft = 0;\n            };\n            if (this.enableScripting && this.hasJSActions) {\n                element.addEventListener(\"focus\", (event)=>{\n                    if (elementData.focused) {\n                        return;\n                    }\n                    const { target } = event;\n                    if (elementData.userValue) {\n                        target.value = elementData.userValue;\n                    }\n                    elementData.lastCommittedValue = target.value;\n                    elementData.commitKey = 1;\n                    if (!this.data.actions?.Focus) {\n                        elementData.focused = true;\n                    }\n                });\n                element.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                    this.showElementAndHideCanvas(jsEvent.target);\n                    const actions = {\n                        value (event) {\n                            elementData.userValue = event.detail.value ?? \"\";\n                            storage.setValue(id, {\n                                value: elementData.userValue.toString()\n                            });\n                            event.target.value = elementData.userValue;\n                        },\n                        formattedValue (event) {\n                            const { formattedValue } = event.detail;\n                            elementData.formattedValue = formattedValue;\n                            if (formattedValue !== null && formattedValue !== undefined && event.target !== document.activeElement) {\n                                event.target.value = formattedValue;\n                            }\n                            storage.setValue(id, {\n                                formattedValue\n                            });\n                        },\n                        selRange (event) {\n                            event.target.setSelectionRange(...event.detail.selRange);\n                        },\n                        charLimit: (event)=>{\n                            const { charLimit } = event.detail;\n                            const { target } = event;\n                            if (charLimit === 0) {\n                                target.removeAttribute(\"maxLength\");\n                                return;\n                            }\n                            target.setAttribute(\"maxLength\", charLimit);\n                            let value = elementData.userValue;\n                            if (!value || value.length <= charLimit) {\n                                return;\n                            }\n                            value = value.slice(0, charLimit);\n                            target.value = elementData.userValue = value;\n                            storage.setValue(id, {\n                                value\n                            });\n                            this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                source: this,\n                                detail: {\n                                    id,\n                                    name: \"Keystroke\",\n                                    value,\n                                    willCommit: true,\n                                    commitKey: 1,\n                                    selStart: target.selectionStart,\n                                    selEnd: target.selectionEnd\n                                }\n                            });\n                        }\n                    };\n                    this._dispatchEventFromSandbox(actions, jsEvent);\n                });\n                element.addEventListener(\"keydown\", (event)=>{\n                    elementData.commitKey = 1;\n                    let commitKey = -1;\n                    if (event.key === \"Escape\") {\n                        commitKey = 0;\n                    } else if (event.key === \"Enter\" && !this.data.multiLine) {\n                        commitKey = 2;\n                    } else if (event.key === \"Tab\") {\n                        elementData.commitKey = 3;\n                    }\n                    if (commitKey === -1) {\n                        return;\n                    }\n                    const { value } = event.target;\n                    if (elementData.lastCommittedValue === value) {\n                        return;\n                    }\n                    elementData.lastCommittedValue = value;\n                    elementData.userValue = value;\n                    this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                        source: this,\n                        detail: {\n                            id,\n                            name: \"Keystroke\",\n                            value,\n                            willCommit: true,\n                            commitKey,\n                            selStart: event.target.selectionStart,\n                            selEnd: event.target.selectionEnd\n                        }\n                    });\n                });\n                const _blurListener = blurListener;\n                blurListener = null;\n                element.addEventListener(\"blur\", (event)=>{\n                    if (!elementData.focused || !event.relatedTarget) {\n                        return;\n                    }\n                    if (!this.data.actions?.Blur) {\n                        elementData.focused = false;\n                    }\n                    const { value } = event.target;\n                    elementData.userValue = value;\n                    if (elementData.lastCommittedValue !== value) {\n                        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                            source: this,\n                            detail: {\n                                id,\n                                name: \"Keystroke\",\n                                value,\n                                willCommit: true,\n                                commitKey: elementData.commitKey,\n                                selStart: event.target.selectionStart,\n                                selEnd: event.target.selectionEnd\n                            }\n                        });\n                    }\n                    _blurListener(event);\n                });\n                if (this.data.actions?.Keystroke) {\n                    element.addEventListener(\"beforeinput\", (event)=>{\n                        elementData.lastCommittedValue = null;\n                        const { data, target } = event;\n                        const { value, selectionStart, selectionEnd } = target;\n                        let selStart = selectionStart, selEnd = selectionEnd;\n                        switch(event.inputType){\n                            case \"deleteWordBackward\":\n                                {\n                                    const match = value.substring(0, selectionStart).match(/\\w*[^\\w]*$/);\n                                    if (match) {\n                                        selStart -= match[0].length;\n                                    }\n                                    break;\n                                }\n                            case \"deleteWordForward\":\n                                {\n                                    const match = value.substring(selectionStart).match(/^[^\\w]*\\w*/);\n                                    if (match) {\n                                        selEnd += match[0].length;\n                                    }\n                                    break;\n                                }\n                            case \"deleteContentBackward\":\n                                if (selectionStart === selectionEnd) {\n                                    selStart -= 1;\n                                }\n                                break;\n                            case \"deleteContentForward\":\n                                if (selectionStart === selectionEnd) {\n                                    selEnd += 1;\n                                }\n                                break;\n                        }\n                        event.preventDefault();\n                        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                            source: this,\n                            detail: {\n                                id,\n                                name: \"Keystroke\",\n                                value,\n                                change: data || \"\",\n                                willCommit: false,\n                                selStart,\n                                selEnd\n                            }\n                        });\n                    });\n                }\n                this._setEventListeners(element, elementData, [\n                    [\n                        \"focus\",\n                        \"Focus\"\n                    ],\n                    [\n                        \"blur\",\n                        \"Blur\"\n                    ],\n                    [\n                        \"mousedown\",\n                        \"Mouse Down\"\n                    ],\n                    [\n                        \"mouseenter\",\n                        \"Mouse Enter\"\n                    ],\n                    [\n                        \"mouseleave\",\n                        \"Mouse Exit\"\n                    ],\n                    [\n                        \"mouseup\",\n                        \"Mouse Up\"\n                    ]\n                ], (event)=>event.target.value);\n            }\n            if (blurListener) {\n                element.addEventListener(\"blur\", blurListener);\n            }\n            if (this.data.comb) {\n                const fieldWidth = this.data.rect[2] - this.data.rect[0];\n                const combWidth = fieldWidth / maxLen;\n                element.classList.add(\"comb\");\n                element.style.letterSpacing = `calc(${combWidth}px * var(--scale-factor) - 1ch)`;\n            }\n        } else {\n            element = document.createElement(\"div\");\n            element.textContent = this.data.fieldValue;\n            element.style.verticalAlign = \"middle\";\n            element.style.display = \"table-cell\";\n            if (this.data.hasOwnCanvas) {\n                element.hidden = true;\n            }\n        }\n        this._setTextStyle(element);\n        this._setBackgroundColor(element);\n        this._setDefaultPropertiesFromJS(element);\n        this.container.append(element);\n        return this.container;\n    }\n}\nclass SignatureWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: !!parameters.data.hasOwnCanvas\n        });\n    }\n}\nclass CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: parameters.renderForms\n        });\n    }\n    render() {\n        const storage = this.annotationStorage;\n        const data = this.data;\n        const id = data.id;\n        let value = storage.getValue(id, {\n            value: data.exportValue === data.fieldValue\n        }).value;\n        if (typeof value === \"string\") {\n            value = value !== \"Off\";\n            storage.setValue(id, {\n                value\n            });\n        }\n        this.container.classList.add(\"buttonWidgetAnnotation\", \"checkBox\");\n        const element = document.createElement(\"input\");\n        GetElementsByNameSet.add(element);\n        element.setAttribute(\"data-element-id\", id);\n        element.disabled = data.readOnly;\n        this._setRequired(element, this.data.required);\n        element.type = \"checkbox\";\n        element.name = data.fieldName;\n        if (value) {\n            element.setAttribute(\"checked\", true);\n        }\n        element.setAttribute(\"exportValue\", data.exportValue);\n        element.tabIndex = DEFAULT_TAB_INDEX;\n        element.addEventListener(\"change\", (event)=>{\n            const { name, checked } = event.target;\n            for (const checkbox of this._getElementsByName(name, id)){\n                const curChecked = checked && checkbox.exportValue === data.exportValue;\n                if (checkbox.domElement) {\n                    checkbox.domElement.checked = curChecked;\n                }\n                storage.setValue(checkbox.id, {\n                    value: curChecked\n                });\n            }\n            storage.setValue(id, {\n                value: checked\n            });\n        });\n        element.addEventListener(\"resetform\", (event)=>{\n            const defaultValue = data.defaultFieldValue || \"Off\";\n            event.target.checked = defaultValue === data.exportValue;\n        });\n        if (this.enableScripting && this.hasJSActions) {\n            element.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                const actions = {\n                    value (event) {\n                        event.target.checked = event.detail.value !== \"Off\";\n                        storage.setValue(id, {\n                            value: event.target.checked\n                        });\n                    }\n                };\n                this._dispatchEventFromSandbox(actions, jsEvent);\n            });\n            this._setEventListeners(element, null, [\n                [\n                    \"change\",\n                    \"Validate\"\n                ],\n                [\n                    \"change\",\n                    \"Action\"\n                ],\n                [\n                    \"focus\",\n                    \"Focus\"\n                ],\n                [\n                    \"blur\",\n                    \"Blur\"\n                ],\n                [\n                    \"mousedown\",\n                    \"Mouse Down\"\n                ],\n                [\n                    \"mouseenter\",\n                    \"Mouse Enter\"\n                ],\n                [\n                    \"mouseleave\",\n                    \"Mouse Exit\"\n                ],\n                [\n                    \"mouseup\",\n                    \"Mouse Up\"\n                ]\n            ], (event)=>event.target.checked);\n        }\n        this._setBackgroundColor(element);\n        this._setDefaultPropertiesFromJS(element);\n        this.container.append(element);\n        return this.container;\n    }\n}\nclass RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: parameters.renderForms\n        });\n    }\n    render() {\n        this.container.classList.add(\"buttonWidgetAnnotation\", \"radioButton\");\n        const storage = this.annotationStorage;\n        const data = this.data;\n        const id = data.id;\n        let value = storage.getValue(id, {\n            value: data.fieldValue === data.buttonValue\n        }).value;\n        if (typeof value === \"string\") {\n            value = value !== data.buttonValue;\n            storage.setValue(id, {\n                value\n            });\n        }\n        if (value) {\n            for (const radio of this._getElementsByName(data.fieldName, id)){\n                storage.setValue(radio.id, {\n                    value: false\n                });\n            }\n        }\n        const element = document.createElement(\"input\");\n        GetElementsByNameSet.add(element);\n        element.setAttribute(\"data-element-id\", id);\n        element.disabled = data.readOnly;\n        this._setRequired(element, this.data.required);\n        element.type = \"radio\";\n        element.name = data.fieldName;\n        if (value) {\n            element.setAttribute(\"checked\", true);\n        }\n        element.tabIndex = DEFAULT_TAB_INDEX;\n        element.addEventListener(\"change\", (event)=>{\n            const { name, checked } = event.target;\n            for (const radio of this._getElementsByName(name, id)){\n                storage.setValue(radio.id, {\n                    value: false\n                });\n            }\n            storage.setValue(id, {\n                value: checked\n            });\n        });\n        element.addEventListener(\"resetform\", (event)=>{\n            const defaultValue = data.defaultFieldValue;\n            event.target.checked = defaultValue !== null && defaultValue !== undefined && defaultValue === data.buttonValue;\n        });\n        if (this.enableScripting && this.hasJSActions) {\n            const pdfButtonValue = data.buttonValue;\n            element.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                const actions = {\n                    value: (event)=>{\n                        const checked = pdfButtonValue === event.detail.value;\n                        for (const radio of this._getElementsByName(event.target.name)){\n                            const curChecked = checked && radio.id === id;\n                            if (radio.domElement) {\n                                radio.domElement.checked = curChecked;\n                            }\n                            storage.setValue(radio.id, {\n                                value: curChecked\n                            });\n                        }\n                    }\n                };\n                this._dispatchEventFromSandbox(actions, jsEvent);\n            });\n            this._setEventListeners(element, null, [\n                [\n                    \"change\",\n                    \"Validate\"\n                ],\n                [\n                    \"change\",\n                    \"Action\"\n                ],\n                [\n                    \"focus\",\n                    \"Focus\"\n                ],\n                [\n                    \"blur\",\n                    \"Blur\"\n                ],\n                [\n                    \"mousedown\",\n                    \"Mouse Down\"\n                ],\n                [\n                    \"mouseenter\",\n                    \"Mouse Enter\"\n                ],\n                [\n                    \"mouseleave\",\n                    \"Mouse Exit\"\n                ],\n                [\n                    \"mouseup\",\n                    \"Mouse Up\"\n                ]\n            ], (event)=>event.target.checked);\n        }\n        this._setBackgroundColor(element);\n        this._setDefaultPropertiesFromJS(element);\n        this.container.append(element);\n        return this.container;\n    }\n}\nclass PushButtonWidgetAnnotationElement extends LinkAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            ignoreBorder: parameters.data.hasAppearance\n        });\n    }\n    render() {\n        const container = super.render();\n        container.classList.add(\"buttonWidgetAnnotation\", \"pushButton\");\n        const linkElement = container.lastChild;\n        if (this.enableScripting && this.hasJSActions && linkElement) {\n            this._setDefaultPropertiesFromJS(linkElement);\n            linkElement.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                this._dispatchEventFromSandbox({}, jsEvent);\n            });\n        }\n        return container;\n    }\n}\nclass ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: parameters.renderForms\n        });\n    }\n    render() {\n        this.container.classList.add(\"choiceWidgetAnnotation\");\n        const storage = this.annotationStorage;\n        const id = this.data.id;\n        const storedData = storage.getValue(id, {\n            value: this.data.fieldValue\n        });\n        const selectElement = document.createElement(\"select\");\n        GetElementsByNameSet.add(selectElement);\n        selectElement.setAttribute(\"data-element-id\", id);\n        selectElement.disabled = this.data.readOnly;\n        this._setRequired(selectElement, this.data.required);\n        selectElement.name = this.data.fieldName;\n        selectElement.tabIndex = DEFAULT_TAB_INDEX;\n        let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;\n        if (!this.data.combo) {\n            selectElement.size = this.data.options.length;\n            if (this.data.multiSelect) {\n                selectElement.multiple = true;\n            }\n        }\n        selectElement.addEventListener(\"resetform\", (event)=>{\n            const defaultValue = this.data.defaultFieldValue;\n            for (const option of selectElement.options){\n                option.selected = option.value === defaultValue;\n            }\n        });\n        for (const option of this.data.options){\n            const optionElement = document.createElement(\"option\");\n            optionElement.textContent = option.displayValue;\n            optionElement.value = option.exportValue;\n            if (storedData.value.includes(option.exportValue)) {\n                optionElement.setAttribute(\"selected\", true);\n                addAnEmptyEntry = false;\n            }\n            selectElement.append(optionElement);\n        }\n        let removeEmptyEntry = null;\n        if (addAnEmptyEntry) {\n            const noneOptionElement = document.createElement(\"option\");\n            noneOptionElement.value = \" \";\n            noneOptionElement.setAttribute(\"hidden\", true);\n            noneOptionElement.setAttribute(\"selected\", true);\n            selectElement.prepend(noneOptionElement);\n            removeEmptyEntry = ()=>{\n                noneOptionElement.remove();\n                selectElement.removeEventListener(\"input\", removeEmptyEntry);\n                removeEmptyEntry = null;\n            };\n            selectElement.addEventListener(\"input\", removeEmptyEntry);\n        }\n        const getValue = (isExport)=>{\n            const name = isExport ? \"value\" : \"textContent\";\n            const { options, multiple } = selectElement;\n            if (!multiple) {\n                return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];\n            }\n            return Array.prototype.filter.call(options, (option)=>option.selected).map((option)=>option[name]);\n        };\n        let selectedValues = getValue(false);\n        const getItems = (event)=>{\n            const options = event.target.options;\n            return Array.prototype.map.call(options, (option)=>({\n                    displayValue: option.textContent,\n                    exportValue: option.value\n                }));\n        };\n        if (this.enableScripting && this.hasJSActions) {\n            selectElement.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                const actions = {\n                    value (event) {\n                        removeEmptyEntry?.();\n                        const value = event.detail.value;\n                        const values = new Set(Array.isArray(value) ? value : [\n                            value\n                        ]);\n                        for (const option of selectElement.options){\n                            option.selected = values.has(option.value);\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    multipleSelection (event) {\n                        selectElement.multiple = true;\n                    },\n                    remove (event) {\n                        const options = selectElement.options;\n                        const index = event.detail.remove;\n                        options[index].selected = false;\n                        selectElement.remove(index);\n                        if (options.length > 0) {\n                            const i = Array.prototype.findIndex.call(options, (option)=>option.selected);\n                            if (i === -1) {\n                                options[0].selected = true;\n                            }\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true),\n                            items: getItems(event)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    clear (event) {\n                        while(selectElement.length !== 0){\n                            selectElement.remove(0);\n                        }\n                        storage.setValue(id, {\n                            value: null,\n                            items: []\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    insert (event) {\n                        const { index, displayValue, exportValue } = event.detail.insert;\n                        const selectChild = selectElement.children[index];\n                        const optionElement = document.createElement(\"option\");\n                        optionElement.textContent = displayValue;\n                        optionElement.value = exportValue;\n                        if (selectChild) {\n                            selectChild.before(optionElement);\n                        } else {\n                            selectElement.append(optionElement);\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true),\n                            items: getItems(event)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    items (event) {\n                        const { items } = event.detail;\n                        while(selectElement.length !== 0){\n                            selectElement.remove(0);\n                        }\n                        for (const item of items){\n                            const { displayValue, exportValue } = item;\n                            const optionElement = document.createElement(\"option\");\n                            optionElement.textContent = displayValue;\n                            optionElement.value = exportValue;\n                            selectElement.append(optionElement);\n                        }\n                        if (selectElement.options.length > 0) {\n                            selectElement.options[0].selected = true;\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true),\n                            items: getItems(event)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    indices (event) {\n                        const indices = new Set(event.detail.indices);\n                        for (const option of event.target.options){\n                            option.selected = indices.has(option.index);\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    editable (event) {\n                        event.target.disabled = !event.detail.editable;\n                    }\n                };\n                this._dispatchEventFromSandbox(actions, jsEvent);\n            });\n            selectElement.addEventListener(\"input\", (event)=>{\n                const exportValue = getValue(true);\n                const change = getValue(false);\n                storage.setValue(id, {\n                    value: exportValue\n                });\n                event.preventDefault();\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id,\n                        name: \"Keystroke\",\n                        value: selectedValues,\n                        change,\n                        changeEx: exportValue,\n                        willCommit: false,\n                        commitKey: 1,\n                        keyDown: false\n                    }\n                });\n            });\n            this._setEventListeners(selectElement, null, [\n                [\n                    \"focus\",\n                    \"Focus\"\n                ],\n                [\n                    \"blur\",\n                    \"Blur\"\n                ],\n                [\n                    \"mousedown\",\n                    \"Mouse Down\"\n                ],\n                [\n                    \"mouseenter\",\n                    \"Mouse Enter\"\n                ],\n                [\n                    \"mouseleave\",\n                    \"Mouse Exit\"\n                ],\n                [\n                    \"mouseup\",\n                    \"Mouse Up\"\n                ],\n                [\n                    \"input\",\n                    \"Action\"\n                ],\n                [\n                    \"input\",\n                    \"Validate\"\n                ]\n            ], (event)=>event.target.value);\n        } else {\n            selectElement.addEventListener(\"input\", function(event) {\n                storage.setValue(id, {\n                    value: getValue(true)\n                });\n            });\n        }\n        if (this.data.combo) {\n            this._setTextStyle(selectElement);\n        } else {}\n        this._setBackgroundColor(selectElement);\n        this._setDefaultPropertiesFromJS(selectElement);\n        this.container.append(selectElement);\n        return this.container;\n    }\n}\nclass PopupAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        const { data, elements } = parameters;\n        super(parameters, {\n            isRenderable: AnnotationElement._hasPopupData(data)\n        });\n        this.elements = elements;\n        this.popup = null;\n    }\n    render() {\n        this.container.classList.add(\"popupAnnotation\");\n        const popup = this.popup = new PopupElement({\n            container: this.container,\n            color: this.data.color,\n            titleObj: this.data.titleObj,\n            modificationDate: this.data.modificationDate,\n            contentsObj: this.data.contentsObj,\n            richText: this.data.richText,\n            rect: this.data.rect,\n            parentRect: this.data.parentRect || null,\n            parent: this.parent,\n            elements: this.elements,\n            open: this.data.open\n        });\n        const elementIds = [];\n        for (const element of this.elements){\n            element.popup = popup;\n            element.container.ariaHasPopup = \"dialog\";\n            elementIds.push(element.data.id);\n            element.addHighlightArea();\n        }\n        this.container.setAttribute(\"aria-controls\", elementIds.map((id)=>`${AnnotationPrefix}${id}`).join(\",\"));\n        return this.container;\n    }\n}\nclass PopupElement {\n    #boundKeyDown;\n    #boundHide;\n    #boundShow;\n    #boundToggle;\n    #color;\n    #container;\n    #contentsObj;\n    #dateObj;\n    #elements;\n    #parent;\n    #parentRect;\n    #pinned;\n    #popup;\n    #position;\n    #rect;\n    #richText;\n    #titleObj;\n    #updates;\n    #wasVisible;\n    constructor({ container, color, elements, titleObj, modificationDate, contentsObj, richText, parent, rect, parentRect, open }){\n        this.#boundKeyDown = this.#keyDown.bind(this);\n        this.#boundHide = this.#hide.bind(this);\n        this.#boundShow = this.#show.bind(this);\n        this.#boundToggle = this.#toggle.bind(this);\n        this.#color = null;\n        this.#container = null;\n        this.#contentsObj = null;\n        this.#dateObj = null;\n        this.#elements = null;\n        this.#parent = null;\n        this.#parentRect = null;\n        this.#pinned = false;\n        this.#popup = null;\n        this.#position = null;\n        this.#rect = null;\n        this.#richText = null;\n        this.#titleObj = null;\n        this.#updates = null;\n        this.#wasVisible = false;\n        this.#container = container;\n        this.#titleObj = titleObj;\n        this.#contentsObj = contentsObj;\n        this.#richText = richText;\n        this.#parent = parent;\n        this.#color = color;\n        this.#rect = rect;\n        this.#parentRect = parentRect;\n        this.#elements = elements;\n        this.#dateObj = PDFDateString.toDateObject(modificationDate);\n        this.trigger = elements.flatMap((e)=>e.getElementsToTriggerPopup());\n        for (const element of this.trigger){\n            element.addEventListener(\"click\", this.#boundToggle);\n            element.addEventListener(\"mouseenter\", this.#boundShow);\n            element.addEventListener(\"mouseleave\", this.#boundHide);\n            element.classList.add(\"popupTriggerArea\");\n        }\n        for (const element of elements){\n            element.container?.addEventListener(\"keydown\", this.#boundKeyDown);\n        }\n        this.#container.hidden = true;\n        if (open) {\n            this.#toggle();\n        }\n    }\n    render() {\n        if (this.#popup) {\n            return;\n        }\n        const popup = this.#popup = document.createElement(\"div\");\n        popup.className = \"popup\";\n        if (this.#color) {\n            const baseColor = popup.style.outlineColor = Util.makeHexColor(...this.#color);\n            if (CSS.supports(\"background-color\", \"color-mix(in srgb, red 30%, white)\")) {\n                popup.style.backgroundColor = `color-mix(in srgb, ${baseColor} 30%, white)`;\n            } else {\n                const BACKGROUND_ENLIGHT = 0.7;\n                popup.style.backgroundColor = Util.makeHexColor(...this.#color.map((c)=>Math.floor(BACKGROUND_ENLIGHT * (255 - c) + c)));\n            }\n        }\n        const header = document.createElement(\"span\");\n        header.className = \"header\";\n        const title = document.createElement(\"h1\");\n        header.append(title);\n        ({ dir: title.dir, str: title.textContent } = this.#titleObj);\n        popup.append(header);\n        if (this.#dateObj) {\n            const modificationDate = document.createElement(\"span\");\n            modificationDate.classList.add(\"popupDate\");\n            modificationDate.setAttribute(\"data-l10n-id\", \"pdfjs-annotation-date-time-string\");\n            modificationDate.setAttribute(\"data-l10n-args\", JSON.stringify({\n                dateObj: this.#dateObj.valueOf()\n            }));\n            header.append(modificationDate);\n        }\n        const html = this.#html;\n        if (html) {\n            XfaLayer.render({\n                xfaHtml: html,\n                intent: \"richText\",\n                div: popup\n            });\n            popup.lastChild.classList.add(\"richText\", \"popupContent\");\n        } else {\n            const contents = this._formatContents(this.#contentsObj);\n            popup.append(contents);\n        }\n        this.#container.append(popup);\n    }\n    get #html() {\n        const richText = this.#richText;\n        const contentsObj = this.#contentsObj;\n        if (richText?.str && (!contentsObj?.str || contentsObj.str === richText.str)) {\n            return this.#richText.html || null;\n        }\n        return null;\n    }\n    get #fontSize() {\n        return this.#html?.attributes?.style?.fontSize || 0;\n    }\n    get #fontColor() {\n        return this.#html?.attributes?.style?.color || null;\n    }\n    #makePopupContent(text) {\n        const popupLines = [];\n        const popupContent = {\n            str: text,\n            html: {\n                name: \"div\",\n                attributes: {\n                    dir: \"auto\"\n                },\n                children: [\n                    {\n                        name: \"p\",\n                        children: popupLines\n                    }\n                ]\n            }\n        };\n        const lineAttributes = {\n            style: {\n                color: this.#fontColor,\n                fontSize: this.#fontSize ? `calc(${this.#fontSize}px * var(--scale-factor))` : \"\"\n            }\n        };\n        for (const line of text.split(\"\\n\")){\n            popupLines.push({\n                name: \"span\",\n                value: line,\n                attributes: lineAttributes\n            });\n        }\n        return popupContent;\n    }\n    _formatContents({ str, dir }) {\n        const p = document.createElement(\"p\");\n        p.classList.add(\"popupContent\");\n        p.dir = dir;\n        const lines = str.split(/(?:\\r\\n?|\\n)/);\n        for(let i = 0, ii = lines.length; i < ii; ++i){\n            const line = lines[i];\n            p.append(document.createTextNode(line));\n            if (i < ii - 1) {\n                p.append(document.createElement(\"br\"));\n            }\n        }\n        return p;\n    }\n    #keyDown(event) {\n        if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {\n            return;\n        }\n        if (event.key === \"Enter\" || event.key === \"Escape\" && this.#pinned) {\n            this.#toggle();\n        }\n    }\n    updateEdited({ rect, popupContent }) {\n        this.#updates ||= {\n            contentsObj: this.#contentsObj,\n            richText: this.#richText\n        };\n        if (rect) {\n            this.#position = null;\n        }\n        if (popupContent) {\n            this.#richText = this.#makePopupContent(popupContent);\n            this.#contentsObj = null;\n        }\n        this.#popup?.remove();\n        this.#popup = null;\n    }\n    resetEdited() {\n        if (!this.#updates) {\n            return;\n        }\n        ({ contentsObj: this.#contentsObj, richText: this.#richText } = this.#updates);\n        this.#updates = null;\n        this.#popup?.remove();\n        this.#popup = null;\n        this.#position = null;\n    }\n    #setPosition() {\n        if (this.#position !== null) {\n            return;\n        }\n        const { page: { view }, viewport: { rawDims: { pageWidth, pageHeight, pageX, pageY } } } = this.#parent;\n        let useParentRect = !!this.#parentRect;\n        let rect = useParentRect ? this.#parentRect : this.#rect;\n        for (const element of this.#elements){\n            if (!rect || Util.intersect(element.data.rect, rect) !== null) {\n                rect = element.data.rect;\n                useParentRect = true;\n                break;\n            }\n        }\n        const normalizedRect = Util.normalizeRect([\n            rect[0],\n            view[3] - rect[1] + view[1],\n            rect[2],\n            view[3] - rect[3] + view[1]\n        ]);\n        const HORIZONTAL_SPACE_AFTER_ANNOTATION = 5;\n        const parentWidth = useParentRect ? rect[2] - rect[0] + HORIZONTAL_SPACE_AFTER_ANNOTATION : 0;\n        const popupLeft = normalizedRect[0] + parentWidth;\n        const popupTop = normalizedRect[1];\n        this.#position = [\n            100 * (popupLeft - pageX) / pageWidth,\n            100 * (popupTop - pageY) / pageHeight\n        ];\n        const { style } = this.#container;\n        style.left = `${this.#position[0]}%`;\n        style.top = `${this.#position[1]}%`;\n    }\n    #toggle() {\n        this.#pinned = !this.#pinned;\n        if (this.#pinned) {\n            this.#show();\n            this.#container.addEventListener(\"click\", this.#boundToggle);\n            this.#container.addEventListener(\"keydown\", this.#boundKeyDown);\n        } else {\n            this.#hide();\n            this.#container.removeEventListener(\"click\", this.#boundToggle);\n            this.#container.removeEventListener(\"keydown\", this.#boundKeyDown);\n        }\n    }\n    #show() {\n        if (!this.#popup) {\n            this.render();\n        }\n        if (!this.isVisible) {\n            this.#setPosition();\n            this.#container.hidden = false;\n            this.#container.style.zIndex = parseInt(this.#container.style.zIndex) + 1000;\n        } else if (this.#pinned) {\n            this.#container.classList.add(\"focused\");\n        }\n    }\n    #hide() {\n        this.#container.classList.remove(\"focused\");\n        if (this.#pinned || !this.isVisible) {\n            return;\n        }\n        this.#container.hidden = true;\n        this.#container.style.zIndex = parseInt(this.#container.style.zIndex) - 1000;\n    }\n    forceHide() {\n        this.#wasVisible = this.isVisible;\n        if (!this.#wasVisible) {\n            return;\n        }\n        this.#container.hidden = true;\n    }\n    maybeShow() {\n        if (!this.#wasVisible) {\n            return;\n        }\n        if (!this.#popup) {\n            this.#show();\n        }\n        this.#wasVisible = false;\n        this.#container.hidden = false;\n    }\n    get isVisible() {\n        return this.#container.hidden === false;\n    }\n}\nclass FreeTextAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.textContent = parameters.data.textContent;\n        this.textPosition = parameters.data.textPosition;\n        this.annotationEditorType = AnnotationEditorType.FREETEXT;\n    }\n    render() {\n        this.container.classList.add(\"freeTextAnnotation\");\n        if (this.textContent) {\n            const content = document.createElement(\"div\");\n            content.classList.add(\"annotationTextContent\");\n            content.setAttribute(\"role\", \"comment\");\n            for (const line of this.textContent){\n                const lineSpan = document.createElement(\"span\");\n                lineSpan.textContent = line;\n                content.append(lineSpan);\n            }\n            this.container.append(content);\n        }\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this._editOnDoubleClick();\n        return this.container;\n    }\n}\nclass LineAnnotationElement extends AnnotationElement {\n    #line;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#line = null;\n    }\n    render() {\n        this.container.classList.add(\"lineAnnotation\");\n        const data = this.data;\n        const { width, height } = getRectDims(data.rect);\n        const svg = this.svgFactory.create(width, height, true);\n        const line = this.#line = this.svgFactory.createElement(\"svg:line\");\n        line.setAttribute(\"x1\", data.rect[2] - data.lineCoordinates[0]);\n        line.setAttribute(\"y1\", data.rect[3] - data.lineCoordinates[1]);\n        line.setAttribute(\"x2\", data.rect[2] - data.lineCoordinates[2]);\n        line.setAttribute(\"y2\", data.rect[3] - data.lineCoordinates[3]);\n        line.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n        line.setAttribute(\"stroke\", \"transparent\");\n        line.setAttribute(\"fill\", \"transparent\");\n        svg.append(line);\n        this.container.append(svg);\n        if (!data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#line;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass SquareAnnotationElement extends AnnotationElement {\n    #square;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#square = null;\n    }\n    render() {\n        this.container.classList.add(\"squareAnnotation\");\n        const data = this.data;\n        const { width, height } = getRectDims(data.rect);\n        const svg = this.svgFactory.create(width, height, true);\n        const borderWidth = data.borderStyle.width;\n        const square = this.#square = this.svgFactory.createElement(\"svg:rect\");\n        square.setAttribute(\"x\", borderWidth / 2);\n        square.setAttribute(\"y\", borderWidth / 2);\n        square.setAttribute(\"width\", width - borderWidth);\n        square.setAttribute(\"height\", height - borderWidth);\n        square.setAttribute(\"stroke-width\", borderWidth || 1);\n        square.setAttribute(\"stroke\", \"transparent\");\n        square.setAttribute(\"fill\", \"transparent\");\n        svg.append(square);\n        this.container.append(svg);\n        if (!data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#square;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass CircleAnnotationElement extends AnnotationElement {\n    #circle;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#circle = null;\n    }\n    render() {\n        this.container.classList.add(\"circleAnnotation\");\n        const data = this.data;\n        const { width, height } = getRectDims(data.rect);\n        const svg = this.svgFactory.create(width, height, true);\n        const borderWidth = data.borderStyle.width;\n        const circle = this.#circle = this.svgFactory.createElement(\"svg:ellipse\");\n        circle.setAttribute(\"cx\", width / 2);\n        circle.setAttribute(\"cy\", height / 2);\n        circle.setAttribute(\"rx\", width / 2 - borderWidth / 2);\n        circle.setAttribute(\"ry\", height / 2 - borderWidth / 2);\n        circle.setAttribute(\"stroke-width\", borderWidth || 1);\n        circle.setAttribute(\"stroke\", \"transparent\");\n        circle.setAttribute(\"fill\", \"transparent\");\n        svg.append(circle);\n        this.container.append(svg);\n        if (!data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#circle;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass PolylineAnnotationElement extends AnnotationElement {\n    #polyline;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#polyline = null;\n        this.containerClassName = \"polylineAnnotation\";\n        this.svgElementName = \"svg:polyline\";\n    }\n    render() {\n        this.container.classList.add(this.containerClassName);\n        const { data: { rect, vertices, borderStyle, popupRef } } = this;\n        if (!vertices) {\n            return this.container;\n        }\n        const { width, height } = getRectDims(rect);\n        const svg = this.svgFactory.create(width, height, true);\n        let points = [];\n        for(let i = 0, ii = vertices.length; i < ii; i += 2){\n            const x = vertices[i] - rect[0];\n            const y = rect[3] - vertices[i + 1];\n            points.push(`${x},${y}`);\n        }\n        points = points.join(\" \");\n        const polyline = this.#polyline = this.svgFactory.createElement(this.svgElementName);\n        polyline.setAttribute(\"points\", points);\n        polyline.setAttribute(\"stroke-width\", borderStyle.width || 1);\n        polyline.setAttribute(\"stroke\", \"transparent\");\n        polyline.setAttribute(\"fill\", \"transparent\");\n        svg.append(polyline);\n        this.container.append(svg);\n        if (!popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#polyline;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass PolygonAnnotationElement extends PolylineAnnotationElement {\n    constructor(parameters){\n        super(parameters);\n        this.containerClassName = \"polygonAnnotation\";\n        this.svgElementName = \"svg:polygon\";\n    }\n}\nclass CaretAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n    }\n    render() {\n        this.container.classList.add(\"caretAnnotation\");\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n}\nclass InkAnnotationElement extends AnnotationElement {\n    #polylinesGroupElement;\n    #polylines;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#polylinesGroupElement = null;\n        this.#polylines = [];\n        this.containerClassName = \"inkAnnotation\";\n        this.svgElementName = \"svg:polyline\";\n        this.annotationEditorType = this.data.it === \"InkHighlight\" ? AnnotationEditorType.HIGHLIGHT : AnnotationEditorType.INK;\n    }\n    #getTransform(rotation, rect) {\n        switch(rotation){\n            case 90:\n                return {\n                    transform: `rotate(90) translate(${-rect[0]},${rect[1]}) scale(1,-1)`,\n                    width: rect[3] - rect[1],\n                    height: rect[2] - rect[0]\n                };\n            case 180:\n                return {\n                    transform: `rotate(180) translate(${-rect[2]},${rect[1]}) scale(1,-1)`,\n                    width: rect[2] - rect[0],\n                    height: rect[3] - rect[1]\n                };\n            case 270:\n                return {\n                    transform: `rotate(270) translate(${-rect[2]},${rect[3]}) scale(1,-1)`,\n                    width: rect[3] - rect[1],\n                    height: rect[2] - rect[0]\n                };\n            default:\n                return {\n                    transform: `translate(${-rect[0]},${rect[3]}) scale(1,-1)`,\n                    width: rect[2] - rect[0],\n                    height: rect[3] - rect[1]\n                };\n        }\n    }\n    render() {\n        this.container.classList.add(this.containerClassName);\n        const { data: { rect, rotation, inkLists, borderStyle, popupRef } } = this;\n        const { transform, width, height } = this.#getTransform(rotation, rect);\n        const svg = this.svgFactory.create(width, height, true);\n        const g = this.#polylinesGroupElement = this.svgFactory.createElement(\"svg:g\");\n        svg.append(g);\n        g.setAttribute(\"stroke-width\", borderStyle.width || 1);\n        g.setAttribute(\"stroke-linecap\", \"round\");\n        g.setAttribute(\"stroke-linejoin\", \"round\");\n        g.setAttribute(\"stroke-miterlimit\", 10);\n        g.setAttribute(\"stroke\", \"transparent\");\n        g.setAttribute(\"fill\", \"transparent\");\n        g.setAttribute(\"transform\", transform);\n        for(let i = 0, ii = inkLists.length; i < ii; i++){\n            const polyline = this.svgFactory.createElement(this.svgElementName);\n            this.#polylines.push(polyline);\n            polyline.setAttribute(\"points\", inkLists[i].join(\",\"));\n            g.append(polyline);\n        }\n        if (!popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.append(svg);\n        this._editOnDoubleClick();\n        return this.container;\n    }\n    updateEdited(params) {\n        super.updateEdited(params);\n        const { thickness, points, rect } = params;\n        const g = this.#polylinesGroupElement;\n        if (thickness >= 0) {\n            g.setAttribute(\"stroke-width\", thickness || 1);\n        }\n        if (points) {\n            for(let i = 0, ii = this.#polylines.length; i < ii; i++){\n                this.#polylines[i].setAttribute(\"points\", points[i].join(\",\"));\n            }\n        }\n        if (rect) {\n            const { transform, width, height } = this.#getTransform(this.data.rotation, rect);\n            const root = g.parentElement;\n            root.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n            g.setAttribute(\"transform\", transform);\n        }\n    }\n    getElementsToTriggerPopup() {\n        return this.#polylines;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass HighlightAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true,\n            createQuadrilaterals: true\n        });\n        this.annotationEditorType = AnnotationEditorType.HIGHLIGHT;\n    }\n    render() {\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.classList.add(\"highlightAnnotation\");\n        this._editOnDoubleClick();\n        return this.container;\n    }\n}\nclass UnderlineAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true,\n            createQuadrilaterals: true\n        });\n    }\n    render() {\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.classList.add(\"underlineAnnotation\");\n        return this.container;\n    }\n}\nclass SquigglyAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true,\n            createQuadrilaterals: true\n        });\n    }\n    render() {\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.classList.add(\"squigglyAnnotation\");\n        return this.container;\n    }\n}\nclass StrikeOutAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true,\n            createQuadrilaterals: true\n        });\n    }\n    render() {\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.classList.add(\"strikeoutAnnotation\");\n        return this.container;\n    }\n}\nclass StampAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.annotationEditorType = AnnotationEditorType.STAMP;\n    }\n    render() {\n        this.container.classList.add(\"stampAnnotation\");\n        this.container.setAttribute(\"role\", \"img\");\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this._editOnDoubleClick();\n        return this.container;\n    }\n}\nclass FileAttachmentAnnotationElement extends AnnotationElement {\n    #trigger;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true\n        });\n        this.#trigger = null;\n        const { file } = this.data;\n        this.filename = file.filename;\n        this.content = file.content;\n        this.linkService.eventBus?.dispatch(\"fileattachmentannotation\", {\n            source: this,\n            ...file\n        });\n    }\n    render() {\n        this.container.classList.add(\"fileAttachmentAnnotation\");\n        const { container, data } = this;\n        let trigger;\n        if (data.hasAppearance || data.fillAlpha === 0) {\n            trigger = document.createElement(\"div\");\n        } else {\n            trigger = document.createElement(\"img\");\n            trigger.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(data.name) ? \"paperclip\" : \"pushpin\"}.svg`;\n            if (data.fillAlpha && data.fillAlpha < 1) {\n                trigger.style = `filter: opacity(${Math.round(data.fillAlpha * 100)}%);`;\n            }\n        }\n        trigger.addEventListener(\"dblclick\", this.#download.bind(this));\n        this.#trigger = trigger;\n        const { isMac } = util_FeatureTest.platform;\n        container.addEventListener(\"keydown\", (evt)=>{\n            if (evt.key === \"Enter\" && (isMac ? evt.metaKey : evt.ctrlKey)) {\n                this.#download();\n            }\n        });\n        if (!data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        } else {\n            trigger.classList.add(\"popupTriggerArea\");\n        }\n        container.append(trigger);\n        return container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#trigger;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n    #download() {\n        this.downloadManager?.openOrDownloadData(this.content, this.filename);\n    }\n}\nclass AnnotationLayer {\n    #accessibilityManager;\n    #annotationCanvasMap;\n    #editableAnnotations;\n    #structTreeLayer;\n    constructor({ div, accessibilityManager, annotationCanvasMap, annotationEditorUIManager, page, viewport, structTreeLayer }){\n        this.#accessibilityManager = null;\n        this.#annotationCanvasMap = null;\n        this.#editableAnnotations = new Map();\n        this.#structTreeLayer = null;\n        this.div = div;\n        this.#accessibilityManager = accessibilityManager;\n        this.#annotationCanvasMap = annotationCanvasMap;\n        this.#structTreeLayer = structTreeLayer || null;\n        this.page = page;\n        this.viewport = viewport;\n        this.zIndex = 0;\n        this._annotationEditorUIManager = annotationEditorUIManager;\n    }\n    hasEditableAnnotations() {\n        return this.#editableAnnotations.size > 0;\n    }\n    async #appendElement(element, id) {\n        const contentElement = element.firstChild || element;\n        const annotationId = contentElement.id = `${AnnotationPrefix}${id}`;\n        const ariaAttributes = await this.#structTreeLayer?.getAriaAttributes(annotationId);\n        if (ariaAttributes) {\n            for (const [key, value] of ariaAttributes){\n                contentElement.setAttribute(key, value);\n            }\n        }\n        this.div.append(element);\n        this.#accessibilityManager?.moveElementInDOM(this.div, element, contentElement, false);\n    }\n    async render(params) {\n        const { annotations } = params;\n        const layer = this.div;\n        setLayerDimensions(layer, this.viewport);\n        const popupToElements = new Map();\n        const elementParams = {\n            data: null,\n            layer,\n            linkService: params.linkService,\n            downloadManager: params.downloadManager,\n            imageResourcesPath: params.imageResourcesPath || \"\",\n            renderForms: params.renderForms !== false,\n            svgFactory: new DOMSVGFactory(),\n            annotationStorage: params.annotationStorage || new AnnotationStorage(),\n            enableScripting: params.enableScripting === true,\n            hasJSActions: params.hasJSActions,\n            fieldObjects: params.fieldObjects,\n            parent: this,\n            elements: null\n        };\n        for (const data of annotations){\n            if (data.noHTML) {\n                continue;\n            }\n            const isPopupAnnotation = data.annotationType === AnnotationType.POPUP;\n            if (!isPopupAnnotation) {\n                const { width, height } = getRectDims(data.rect);\n                if (width <= 0 || height <= 0) {\n                    continue;\n                }\n            } else {\n                const elements = popupToElements.get(data.id);\n                if (!elements) {\n                    continue;\n                }\n                elementParams.elements = elements;\n            }\n            elementParams.data = data;\n            const element = AnnotationElementFactory.create(elementParams);\n            if (!element.isRenderable) {\n                continue;\n            }\n            if (!isPopupAnnotation && data.popupRef) {\n                const elements = popupToElements.get(data.popupRef);\n                if (!elements) {\n                    popupToElements.set(data.popupRef, [\n                        element\n                    ]);\n                } else {\n                    elements.push(element);\n                }\n            }\n            const rendered = element.render();\n            if (data.hidden) {\n                rendered.style.visibility = \"hidden\";\n            }\n            await this.#appendElement(rendered, data.id);\n            if (element._isEditable) {\n                this.#editableAnnotations.set(element.data.id, element);\n                this._annotationEditorUIManager?.renderAnnotationElement(element);\n            }\n        }\n        this.#setAnnotationCanvasMap();\n    }\n    update({ viewport }) {\n        const layer = this.div;\n        this.viewport = viewport;\n        setLayerDimensions(layer, {\n            rotation: viewport.rotation\n        });\n        this.#setAnnotationCanvasMap();\n        layer.hidden = false;\n    }\n    #setAnnotationCanvasMap() {\n        if (!this.#annotationCanvasMap) {\n            return;\n        }\n        const layer = this.div;\n        for (const [id, canvas] of this.#annotationCanvasMap){\n            const element = layer.querySelector(`[data-annotation-id=\"${id}\"]`);\n            if (!element) {\n                continue;\n            }\n            canvas.className = \"annotationContent\";\n            const { firstChild } = element;\n            if (!firstChild) {\n                element.append(canvas);\n            } else if (firstChild.nodeName === \"CANVAS\") {\n                firstChild.replaceWith(canvas);\n            } else if (!firstChild.classList.contains(\"annotationContent\")) {\n                firstChild.before(canvas);\n            } else {\n                firstChild.after(canvas);\n            }\n        }\n        this.#annotationCanvasMap.clear();\n    }\n    getEditableAnnotations() {\n        return Array.from(this.#editableAnnotations.values());\n    }\n    getEditableAnnotation(id) {\n        return this.#editableAnnotations.get(id);\n    }\n}\n; // ./src/display/editor/freetext.js\nconst EOL_PATTERN = /\\r\\n?|\\n/g;\nclass FreeTextEditor extends AnnotationEditor {\n    #color;\n    #content;\n    #editorDivId;\n    #editModeAC;\n    #fontSize;\n    static{\n        this._freeTextDefaultContent = \"\";\n    }\n    static{\n        this._internalPadding = 0;\n    }\n    static{\n        this._defaultColor = null;\n    }\n    static{\n        this._defaultFontSize = 10;\n    }\n    static get _keyboardManager() {\n        const proto = FreeTextEditor.prototype;\n        const arrowChecker = (self)=>self.isEmpty();\n        const small = AnnotationEditorUIManager.TRANSLATE_SMALL;\n        const big = AnnotationEditorUIManager.TRANSLATE_BIG;\n        return shadow(this, \"_keyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"ctrl+s\",\n                    \"mac+meta+s\",\n                    \"ctrl+p\",\n                    \"mac+meta+p\"\n                ],\n                proto.commitOrRemove,\n                {\n                    bubbles: true\n                }\n            ],\n            [\n                [\n                    \"ctrl+Enter\",\n                    \"mac+meta+Enter\",\n                    \"Escape\",\n                    \"mac+Escape\"\n                ],\n                proto.commitOrRemove\n            ],\n            [\n                [\n                    \"ArrowLeft\",\n                    \"mac+ArrowLeft\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        -small,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowLeft\",\n                    \"mac+shift+ArrowLeft\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        -big,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowRight\",\n                    \"mac+ArrowRight\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        small,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowRight\",\n                    \"mac+shift+ArrowRight\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        big,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"mac+ArrowUp\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        0,\n                        -small\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowUp\",\n                    \"mac+shift+ArrowUp\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        0,\n                        -big\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"mac+ArrowDown\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        0,\n                        small\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowDown\",\n                    \"mac+shift+ArrowDown\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        0,\n                        big\n                    ],\n                    checker: arrowChecker\n                }\n            ]\n        ]));\n    }\n    static{\n        this._type = \"freetext\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.FREETEXT;\n    }\n    constructor(params){\n        super({\n            ...params,\n            name: \"freeTextEditor\"\n        });\n        this.#content = \"\";\n        this.#editorDivId = `${this.id}-editor`;\n        this.#editModeAC = null;\n        this.#color = params.color || FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor;\n        this.#fontSize = params.fontSize || FreeTextEditor._defaultFontSize;\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n        const style = getComputedStyle(document.documentElement);\n        this._internalPadding = parseFloat(style.getPropertyValue(\"--freetext-padding\"));\n    }\n    static updateDefaultParams(type, value) {\n        switch(type){\n            case AnnotationEditorParamsType.FREETEXT_SIZE:\n                FreeTextEditor._defaultFontSize = value;\n                break;\n            case AnnotationEditorParamsType.FREETEXT_COLOR:\n                FreeTextEditor._defaultColor = value;\n                break;\n        }\n    }\n    updateParams(type, value) {\n        switch(type){\n            case AnnotationEditorParamsType.FREETEXT_SIZE:\n                this.#updateFontSize(value);\n                break;\n            case AnnotationEditorParamsType.FREETEXT_COLOR:\n                this.#updateColor(value);\n                break;\n        }\n    }\n    static get defaultPropertiesToUpdate() {\n        return [\n            [\n                AnnotationEditorParamsType.FREETEXT_SIZE,\n                FreeTextEditor._defaultFontSize\n            ],\n            [\n                AnnotationEditorParamsType.FREETEXT_COLOR,\n                FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor\n            ]\n        ];\n    }\n    get propertiesToUpdate() {\n        return [\n            [\n                AnnotationEditorParamsType.FREETEXT_SIZE,\n                this.#fontSize\n            ],\n            [\n                AnnotationEditorParamsType.FREETEXT_COLOR,\n                this.#color\n            ]\n        ];\n    }\n    #updateFontSize(fontSize) {\n        const setFontsize = (size)=>{\n            this.editorDiv.style.fontSize = `calc(${size}px * var(--scale-factor))`;\n            this.translate(0, -(size - this.#fontSize) * this.parentScale);\n            this.#fontSize = size;\n            this.#setEditorDimensions();\n        };\n        const savedFontsize = this.#fontSize;\n        this.addCommands({\n            cmd: setFontsize.bind(this, fontSize),\n            undo: setFontsize.bind(this, savedFontsize),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type: AnnotationEditorParamsType.FREETEXT_SIZE,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n    }\n    #updateColor(color) {\n        const setColor = (col)=>{\n            this.#color = this.editorDiv.style.color = col;\n        };\n        const savedColor = this.#color;\n        this.addCommands({\n            cmd: setColor.bind(this, color),\n            undo: setColor.bind(this, savedColor),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type: AnnotationEditorParamsType.FREETEXT_COLOR,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n    }\n    _translateEmpty(x, y) {\n        this._uiManager.translateSelectedEditors(x, y, true);\n    }\n    getInitialTranslation() {\n        const scale = this.parentScale;\n        return [\n            -FreeTextEditor._internalPadding * scale,\n            -(FreeTextEditor._internalPadding + this.#fontSize) * scale\n        ];\n    }\n    rebuild() {\n        if (!this.parent) {\n            return;\n        }\n        super.rebuild();\n        if (this.div === null) {\n            return;\n        }\n        if (!this.isAttachedToDOM) {\n            this.parent.add(this);\n        }\n    }\n    enableEditMode() {\n        if (this.isInEditMode()) {\n            return;\n        }\n        this.parent.setEditingState(false);\n        this.parent.updateToolbar(AnnotationEditorType.FREETEXT);\n        super.enableEditMode();\n        this.overlayDiv.classList.remove(\"enabled\");\n        this.editorDiv.contentEditable = true;\n        this._isDraggable = false;\n        this.div.removeAttribute(\"aria-activedescendant\");\n        this.#editModeAC = new AbortController();\n        const signal = this._uiManager.combinedSignal(this.#editModeAC);\n        this.editorDiv.addEventListener(\"keydown\", this.editorDivKeydown.bind(this), {\n            signal\n        });\n        this.editorDiv.addEventListener(\"focus\", this.editorDivFocus.bind(this), {\n            signal\n        });\n        this.editorDiv.addEventListener(\"blur\", this.editorDivBlur.bind(this), {\n            signal\n        });\n        this.editorDiv.addEventListener(\"input\", this.editorDivInput.bind(this), {\n            signal\n        });\n        this.editorDiv.addEventListener(\"paste\", this.editorDivPaste.bind(this), {\n            signal\n        });\n    }\n    disableEditMode() {\n        if (!this.isInEditMode()) {\n            return;\n        }\n        this.parent.setEditingState(true);\n        super.disableEditMode();\n        this.overlayDiv.classList.add(\"enabled\");\n        this.editorDiv.contentEditable = false;\n        this.div.setAttribute(\"aria-activedescendant\", this.#editorDivId);\n        this._isDraggable = true;\n        this.#editModeAC?.abort();\n        this.#editModeAC = null;\n        this.div.focus({\n            preventScroll: true\n        });\n        this.isEditing = false;\n        this.parent.div.classList.add(\"freetextEditing\");\n    }\n    focusin(event) {\n        if (!this._focusEventsAllowed) {\n            return;\n        }\n        super.focusin(event);\n        if (event.target !== this.editorDiv) {\n            this.editorDiv.focus();\n        }\n    }\n    onceAdded() {\n        if (this.width) {\n            return;\n        }\n        this.enableEditMode();\n        this.editorDiv.focus();\n        if (this._initialOptions?.isCentered) {\n            this.center();\n        }\n        this._initialOptions = null;\n    }\n    isEmpty() {\n        return !this.editorDiv || this.editorDiv.innerText.trim() === \"\";\n    }\n    remove() {\n        this.isEditing = false;\n        if (this.parent) {\n            this.parent.setEditingState(true);\n            this.parent.div.classList.add(\"freetextEditing\");\n        }\n        super.remove();\n    }\n    #extractText() {\n        const buffer = [];\n        this.editorDiv.normalize();\n        let prevChild = null;\n        for (const child of this.editorDiv.childNodes){\n            if (prevChild?.nodeType === Node.TEXT_NODE && child.nodeName === \"BR\") {\n                continue;\n            }\n            buffer.push(FreeTextEditor.#getNodeContent(child));\n            prevChild = child;\n        }\n        return buffer.join(\"\\n\");\n    }\n    #setEditorDimensions() {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        let rect;\n        if (this.isAttachedToDOM) {\n            rect = this.div.getBoundingClientRect();\n        } else {\n            const { currentLayer, div } = this;\n            const savedDisplay = div.style.display;\n            const savedVisibility = div.classList.contains(\"hidden\");\n            div.classList.remove(\"hidden\");\n            div.style.display = \"hidden\";\n            currentLayer.div.append(this.div);\n            rect = div.getBoundingClientRect();\n            div.remove();\n            div.style.display = savedDisplay;\n            div.classList.toggle(\"hidden\", savedVisibility);\n        }\n        if (this.rotation % 180 === this.parentRotation % 180) {\n            this.width = rect.width / parentWidth;\n            this.height = rect.height / parentHeight;\n        } else {\n            this.width = rect.height / parentWidth;\n            this.height = rect.width / parentHeight;\n        }\n        this.fixAndSetPosition();\n    }\n    commit() {\n        if (!this.isInEditMode()) {\n            return;\n        }\n        super.commit();\n        this.disableEditMode();\n        const savedText = this.#content;\n        const newText = this.#content = this.#extractText().trimEnd();\n        if (savedText === newText) {\n            return;\n        }\n        const setText = (text)=>{\n            this.#content = text;\n            if (!text) {\n                this.remove();\n                return;\n            }\n            this.#setContent();\n            this._uiManager.rebuild(this);\n            this.#setEditorDimensions();\n        };\n        this.addCommands({\n            cmd: ()=>{\n                setText(newText);\n            },\n            undo: ()=>{\n                setText(savedText);\n            },\n            mustExec: false\n        });\n        this.#setEditorDimensions();\n    }\n    shouldGetKeyboardEvents() {\n        return this.isInEditMode();\n    }\n    enterInEditMode() {\n        this.enableEditMode();\n        this.editorDiv.focus();\n    }\n    dblclick(event) {\n        this.enterInEditMode();\n    }\n    keydown(event) {\n        if (event.target === this.div && event.key === \"Enter\") {\n            this.enterInEditMode();\n            event.preventDefault();\n        }\n    }\n    editorDivKeydown(event) {\n        FreeTextEditor._keyboardManager.exec(this, event);\n    }\n    editorDivFocus(event) {\n        this.isEditing = true;\n    }\n    editorDivBlur(event) {\n        this.isEditing = false;\n    }\n    editorDivInput(event) {\n        this.parent.div.classList.toggle(\"freetextEditing\", this.isEmpty());\n    }\n    disableEditing() {\n        this.editorDiv.setAttribute(\"role\", \"comment\");\n        this.editorDiv.removeAttribute(\"aria-multiline\");\n    }\n    enableEditing() {\n        this.editorDiv.setAttribute(\"role\", \"textbox\");\n        this.editorDiv.setAttribute(\"aria-multiline\", true);\n    }\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        let baseX, baseY;\n        if (this.width) {\n            baseX = this.x;\n            baseY = this.y;\n        }\n        super.render();\n        this.editorDiv = document.createElement(\"div\");\n        this.editorDiv.className = \"internal\";\n        this.editorDiv.setAttribute(\"id\", this.#editorDivId);\n        this.editorDiv.setAttribute(\"data-l10n-id\", \"pdfjs-free-text2\");\n        this.editorDiv.setAttribute(\"data-l10n-attrs\", \"default-content\");\n        this.enableEditing();\n        this.editorDiv.contentEditable = true;\n        const { style } = this.editorDiv;\n        style.fontSize = `calc(${this.#fontSize}px * var(--scale-factor))`;\n        style.color = this.#color;\n        this.div.append(this.editorDiv);\n        this.overlayDiv = document.createElement(\"div\");\n        this.overlayDiv.classList.add(\"overlay\", \"enabled\");\n        this.div.append(this.overlayDiv);\n        bindEvents(this, this.div, [\n            \"dblclick\",\n            \"keydown\"\n        ]);\n        if (this.width) {\n            const [parentWidth, parentHeight] = this.parentDimensions;\n            if (this.annotationElementId) {\n                const { position } = this._initialData;\n                let [tx, ty] = this.getInitialTranslation();\n                [tx, ty] = this.pageTranslationToScreen(tx, ty);\n                const [pageWidth, pageHeight] = this.pageDimensions;\n                const [pageX, pageY] = this.pageTranslation;\n                let posX, posY;\n                switch(this.rotation){\n                    case 0:\n                        posX = baseX + (position[0] - pageX) / pageWidth;\n                        posY = baseY + this.height - (position[1] - pageY) / pageHeight;\n                        break;\n                    case 90:\n                        posX = baseX + (position[0] - pageX) / pageWidth;\n                        posY = baseY - (position[1] - pageY) / pageHeight;\n                        [tx, ty] = [\n                            ty,\n                            -tx\n                        ];\n                        break;\n                    case 180:\n                        posX = baseX - this.width + (position[0] - pageX) / pageWidth;\n                        posY = baseY - (position[1] - pageY) / pageHeight;\n                        [tx, ty] = [\n                            -tx,\n                            -ty\n                        ];\n                        break;\n                    case 270:\n                        posX = baseX + (position[0] - pageX - this.height * pageHeight) / pageWidth;\n                        posY = baseY + (position[1] - pageY - this.width * pageWidth) / pageHeight;\n                        [tx, ty] = [\n                            -ty,\n                            tx\n                        ];\n                        break;\n                }\n                this.setAt(posX * parentWidth, posY * parentHeight, tx, ty);\n            } else {\n                this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n            }\n            this.#setContent();\n            this._isDraggable = true;\n            this.editorDiv.contentEditable = false;\n        } else {\n            this._isDraggable = false;\n            this.editorDiv.contentEditable = true;\n        }\n        return this.div;\n    }\n    static #getNodeContent(node) {\n        return (node.nodeType === Node.TEXT_NODE ? node.nodeValue : node.innerText).replaceAll(EOL_PATTERN, \"\");\n    }\n    editorDivPaste(event) {\n        const clipboardData = event.clipboardData || window.clipboardData;\n        const { types } = clipboardData;\n        if (types.length === 1 && types[0] === \"text/plain\") {\n            return;\n        }\n        event.preventDefault();\n        const paste = FreeTextEditor.#deserializeContent(clipboardData.getData(\"text\") || \"\").replaceAll(EOL_PATTERN, \"\\n\");\n        if (!paste) {\n            return;\n        }\n        const selection = window.getSelection();\n        if (!selection.rangeCount) {\n            return;\n        }\n        this.editorDiv.normalize();\n        selection.deleteFromDocument();\n        const range = selection.getRangeAt(0);\n        if (!paste.includes(\"\\n\")) {\n            range.insertNode(document.createTextNode(paste));\n            this.editorDiv.normalize();\n            selection.collapseToStart();\n            return;\n        }\n        const { startContainer, startOffset } = range;\n        const bufferBefore = [];\n        const bufferAfter = [];\n        if (startContainer.nodeType === Node.TEXT_NODE) {\n            const parent = startContainer.parentElement;\n            bufferAfter.push(startContainer.nodeValue.slice(startOffset).replaceAll(EOL_PATTERN, \"\"));\n            if (parent !== this.editorDiv) {\n                let buffer = bufferBefore;\n                for (const child of this.editorDiv.childNodes){\n                    if (child === parent) {\n                        buffer = bufferAfter;\n                        continue;\n                    }\n                    buffer.push(FreeTextEditor.#getNodeContent(child));\n                }\n            }\n            bufferBefore.push(startContainer.nodeValue.slice(0, startOffset).replaceAll(EOL_PATTERN, \"\"));\n        } else if (startContainer === this.editorDiv) {\n            let buffer = bufferBefore;\n            let i = 0;\n            for (const child of this.editorDiv.childNodes){\n                if (i++ === startOffset) {\n                    buffer = bufferAfter;\n                }\n                buffer.push(FreeTextEditor.#getNodeContent(child));\n            }\n        }\n        this.#content = `${bufferBefore.join(\"\\n\")}${paste}${bufferAfter.join(\"\\n\")}`;\n        this.#setContent();\n        const newRange = new Range();\n        let beforeLength = bufferBefore.reduce((acc, line)=>acc + line.length, 0);\n        for (const { firstChild } of this.editorDiv.childNodes){\n            if (firstChild.nodeType === Node.TEXT_NODE) {\n                const length = firstChild.nodeValue.length;\n                if (beforeLength <= length) {\n                    newRange.setStart(firstChild, beforeLength);\n                    newRange.setEnd(firstChild, beforeLength);\n                    break;\n                }\n                beforeLength -= length;\n            }\n        }\n        selection.removeAllRanges();\n        selection.addRange(newRange);\n    }\n    #setContent() {\n        this.editorDiv.replaceChildren();\n        if (!this.#content) {\n            return;\n        }\n        for (const line of this.#content.split(\"\\n\")){\n            const div = document.createElement(\"div\");\n            div.append(line ? document.createTextNode(line) : document.createElement(\"br\"));\n            this.editorDiv.append(div);\n        }\n    }\n    #serializeContent() {\n        return this.#content.replaceAll(\"\\xa0\", \" \");\n    }\n    static #deserializeContent(content) {\n        return content.replaceAll(\" \", \"\\xa0\");\n    }\n    get contentDiv() {\n        return this.editorDiv;\n    }\n    static async deserialize(data, parent, uiManager) {\n        let initialData = null;\n        if (data instanceof FreeTextAnnotationElement) {\n            const { data: { defaultAppearanceData: { fontSize, fontColor }, rect, rotation, id, popupRef }, textContent, textPosition, parent: { page: { pageNumber } } } = data;\n            if (!textContent || textContent.length === 0) {\n                return null;\n            }\n            initialData = data = {\n                annotationType: AnnotationEditorType.FREETEXT,\n                color: Array.from(fontColor),\n                fontSize,\n                value: textContent.join(\"\\n\"),\n                position: textPosition,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                id,\n                deleted: false,\n                popupRef\n            };\n        }\n        const editor = await super.deserialize(data, parent, uiManager);\n        editor.#fontSize = data.fontSize;\n        editor.#color = Util.makeHexColor(...data.color);\n        editor.#content = FreeTextEditor.#deserializeContent(data.value);\n        editor.annotationElementId = data.id || null;\n        editor._initialData = initialData;\n        return editor;\n    }\n    serialize(isForCopying = false) {\n        if (this.isEmpty()) {\n            return null;\n        }\n        if (this.deleted) {\n            return this.serializeDeleted();\n        }\n        const padding = FreeTextEditor._internalPadding * this.parentScale;\n        const rect = this.getRect(padding, padding);\n        const color = AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : this.#color);\n        const serialized = {\n            annotationType: AnnotationEditorType.FREETEXT,\n            color,\n            fontSize: this.#fontSize,\n            value: this.#serializeContent(),\n            pageIndex: this.pageIndex,\n            rect,\n            rotation: this.rotation,\n            structTreeParentId: this._structTreeParentId\n        };\n        if (isForCopying) {\n            return serialized;\n        }\n        if (this.annotationElementId && !this.#hasElementChanged(serialized)) {\n            return null;\n        }\n        serialized.id = this.annotationElementId;\n        return serialized;\n    }\n    #hasElementChanged(serialized) {\n        const { value, fontSize, color, pageIndex } = this._initialData;\n        return this._hasBeenMoved || serialized.value !== value || serialized.fontSize !== fontSize || serialized.color.some((c, i)=>c !== color[i]) || serialized.pageIndex !== pageIndex;\n    }\n    renderAnnotationElement(annotation) {\n        const content = super.renderAnnotationElement(annotation);\n        if (this.deleted) {\n            return content;\n        }\n        const { style } = content;\n        style.fontSize = `calc(${this.#fontSize}px * var(--scale-factor))`;\n        style.color = this.#color;\n        content.replaceChildren();\n        for (const line of this.#content.split(\"\\n\")){\n            const div = document.createElement(\"div\");\n            div.append(line ? document.createTextNode(line) : document.createElement(\"br\"));\n            content.append(div);\n        }\n        const padding = FreeTextEditor._internalPadding * this.parentScale;\n        annotation.updateEdited({\n            rect: this.getRect(padding, padding),\n            popupContent: this.#content\n        });\n        return content;\n    }\n    resetAnnotationElement(annotation) {\n        super.resetAnnotationElement(annotation);\n        annotation.resetEdited();\n    }\n}\n; // ./src/display/editor/drawers/outline.js\nclass Outline {\n    static{\n        this.PRECISION = 1e-4;\n    }\n    toSVGPath() {\n        unreachable(\"Abstract method `toSVGPath` must be implemented.\");\n    }\n    get box() {\n        unreachable(\"Abstract getter `box` must be implemented.\");\n    }\n    serialize(_bbox, _rotation) {\n        unreachable(\"Abstract method `serialize` must be implemented.\");\n    }\n    static _rescale(src, tx, ty, sx, sy, dest) {\n        dest ||= new Float32Array(src.length);\n        for(let i = 0, ii = src.length; i < ii; i += 2){\n            dest[i] = tx + src[i] * sx;\n            dest[i + 1] = ty + src[i + 1] * sy;\n        }\n        return dest;\n    }\n    static _rescaleAndSwap(src, tx, ty, sx, sy, dest) {\n        dest ||= new Float32Array(src.length);\n        for(let i = 0, ii = src.length; i < ii; i += 2){\n            dest[i] = tx + src[i + 1] * sx;\n            dest[i + 1] = ty + src[i] * sy;\n        }\n        return dest;\n    }\n    static _translate(src, tx, ty, dest) {\n        dest ||= new Float32Array(src.length);\n        for(let i = 0, ii = src.length; i < ii; i += 2){\n            dest[i] = tx + src[i];\n            dest[i + 1] = ty + src[i + 1];\n        }\n        return dest;\n    }\n    static svgRound(x) {\n        return Math.round(x * 10000);\n    }\n    static _normalizePoint(x, y, parentWidth, parentHeight, rotation) {\n        switch(rotation){\n            case 90:\n                return [\n                    1 - y / parentWidth,\n                    x / parentHeight\n                ];\n            case 180:\n                return [\n                    1 - x / parentWidth,\n                    1 - y / parentHeight\n                ];\n            case 270:\n                return [\n                    y / parentWidth,\n                    1 - x / parentHeight\n                ];\n            default:\n                return [\n                    x / parentWidth,\n                    y / parentHeight\n                ];\n        }\n    }\n    static _normalizePagePoint(x, y, rotation) {\n        switch(rotation){\n            case 90:\n                return [\n                    1 - y,\n                    x\n                ];\n            case 180:\n                return [\n                    1 - x,\n                    1 - y\n                ];\n            case 270:\n                return [\n                    y,\n                    1 - x\n                ];\n            default:\n                return [\n                    x,\n                    y\n                ];\n        }\n    }\n    static createBezierPoints(x1, y1, x2, y2, x3, y3) {\n        return [\n            (x1 + 5 * x2) / 6,\n            (y1 + 5 * y2) / 6,\n            (5 * x2 + x3) / 6,\n            (5 * y2 + y3) / 6,\n            (x2 + x3) / 2,\n            (y2 + y3) / 2\n        ];\n    }\n}\n; // ./src/display/editor/drawers/freedraw.js\nclass FreeDrawOutliner {\n    #box;\n    #bottom;\n    #innerMargin;\n    #isLTR;\n    #top;\n    #last;\n    #lastX;\n    #lastY;\n    #min;\n    #min_dist;\n    #scaleFactor;\n    #thickness;\n    #points;\n    static #MIN_DIST = 8;\n    static #MIN_DIFF = 2;\n    static #MIN = FreeDrawOutliner.#MIN_DIST + FreeDrawOutliner.#MIN_DIFF;\n    constructor({ x, y }, box, scaleFactor, thickness, isLTR, innerMargin = 0){\n        this.#bottom = [];\n        this.#top = [];\n        this.#last = new Float32Array(18);\n        this.#points = [];\n        this.#box = box;\n        this.#thickness = thickness * scaleFactor;\n        this.#isLTR = isLTR;\n        this.#last.set([\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            x,\n            y\n        ], 6);\n        this.#innerMargin = innerMargin;\n        this.#min_dist = FreeDrawOutliner.#MIN_DIST * scaleFactor;\n        this.#min = FreeDrawOutliner.#MIN * scaleFactor;\n        this.#scaleFactor = scaleFactor;\n        this.#points.push(x, y);\n    }\n    isEmpty() {\n        return isNaN(this.#last[8]);\n    }\n    #getLastCoords() {\n        const lastTop = this.#last.subarray(4, 6);\n        const lastBottom = this.#last.subarray(16, 18);\n        const [x, y, width, height] = this.#box;\n        return [\n            (this.#lastX + (lastTop[0] - lastBottom[0]) / 2 - x) / width,\n            (this.#lastY + (lastTop[1] - lastBottom[1]) / 2 - y) / height,\n            (this.#lastX + (lastBottom[0] - lastTop[0]) / 2 - x) / width,\n            (this.#lastY + (lastBottom[1] - lastTop[1]) / 2 - y) / height\n        ];\n    }\n    add({ x, y }) {\n        this.#lastX = x;\n        this.#lastY = y;\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        let [x1, y1, x2, y2] = this.#last.subarray(8, 12);\n        const diffX = x - x2;\n        const diffY = y - y2;\n        const d = Math.hypot(diffX, diffY);\n        if (d < this.#min) {\n            return false;\n        }\n        const diffD = d - this.#min_dist;\n        const K = diffD / d;\n        const shiftX = K * diffX;\n        const shiftY = K * diffY;\n        let x0 = x1;\n        let y0 = y1;\n        x1 = x2;\n        y1 = y2;\n        x2 += shiftX;\n        y2 += shiftY;\n        this.#points?.push(x, y);\n        const nX = -shiftY / diffD;\n        const nY = shiftX / diffD;\n        const thX = nX * this.#thickness;\n        const thY = nY * this.#thickness;\n        this.#last.set(this.#last.subarray(2, 8), 0);\n        this.#last.set([\n            x2 + thX,\n            y2 + thY\n        ], 4);\n        this.#last.set(this.#last.subarray(14, 18), 12);\n        this.#last.set([\n            x2 - thX,\n            y2 - thY\n        ], 16);\n        if (isNaN(this.#last[6])) {\n            if (this.#top.length === 0) {\n                this.#last.set([\n                    x1 + thX,\n                    y1 + thY\n                ], 2);\n                this.#top.push(NaN, NaN, NaN, NaN, (x1 + thX - layerX) / layerWidth, (y1 + thY - layerY) / layerHeight);\n                this.#last.set([\n                    x1 - thX,\n                    y1 - thY\n                ], 14);\n                this.#bottom.push(NaN, NaN, NaN, NaN, (x1 - thX - layerX) / layerWidth, (y1 - thY - layerY) / layerHeight);\n            }\n            this.#last.set([\n                x0,\n                y0,\n                x1,\n                y1,\n                x2,\n                y2\n            ], 6);\n            return !this.isEmpty();\n        }\n        this.#last.set([\n            x0,\n            y0,\n            x1,\n            y1,\n            x2,\n            y2\n        ], 6);\n        const angle = Math.abs(Math.atan2(y0 - y1, x0 - x1) - Math.atan2(shiftY, shiftX));\n        if (angle < Math.PI / 2) {\n            [x1, y1, x2, y2] = this.#last.subarray(2, 6);\n            this.#top.push(NaN, NaN, NaN, NaN, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);\n            [x1, y1, x0, y0] = this.#last.subarray(14, 18);\n            this.#bottom.push(NaN, NaN, NaN, NaN, ((x0 + x1) / 2 - layerX) / layerWidth, ((y0 + y1) / 2 - layerY) / layerHeight);\n            return true;\n        }\n        [x0, y0, x1, y1, x2, y2] = this.#last.subarray(0, 6);\n        this.#top.push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);\n        [x2, y2, x1, y1, x0, y0] = this.#last.subarray(12, 18);\n        this.#bottom.push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);\n        return true;\n    }\n    toSVGPath() {\n        if (this.isEmpty()) {\n            return \"\";\n        }\n        const top = this.#top;\n        const bottom = this.#bottom;\n        if (isNaN(this.#last[6]) && !this.isEmpty()) {\n            return this.#toSVGPathTwoPoints();\n        }\n        const buffer = [];\n        buffer.push(`M${top[4]} ${top[5]}`);\n        for(let i = 6; i < top.length; i += 6){\n            if (isNaN(top[i])) {\n                buffer.push(`L${top[i + 4]} ${top[i + 5]}`);\n            } else {\n                buffer.push(`C${top[i]} ${top[i + 1]} ${top[i + 2]} ${top[i + 3]} ${top[i + 4]} ${top[i + 5]}`);\n            }\n        }\n        this.#toSVGPathEnd(buffer);\n        for(let i = bottom.length - 6; i >= 6; i -= 6){\n            if (isNaN(bottom[i])) {\n                buffer.push(`L${bottom[i + 4]} ${bottom[i + 5]}`);\n            } else {\n                buffer.push(`C${bottom[i]} ${bottom[i + 1]} ${bottom[i + 2]} ${bottom[i + 3]} ${bottom[i + 4]} ${bottom[i + 5]}`);\n            }\n        }\n        this.#toSVGPathStart(buffer);\n        return buffer.join(\" \");\n    }\n    #toSVGPathTwoPoints() {\n        const [x, y, width, height] = this.#box;\n        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n        return `M${(this.#last[2] - x) / width} ${(this.#last[3] - y) / height} L${(this.#last[4] - x) / width} ${(this.#last[5] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(this.#last[16] - x) / width} ${(this.#last[17] - y) / height} L${(this.#last[14] - x) / width} ${(this.#last[15] - y) / height} Z`;\n    }\n    #toSVGPathStart(buffer) {\n        const bottom = this.#bottom;\n        buffer.push(`L${bottom[4]} ${bottom[5]} Z`);\n    }\n    #toSVGPathEnd(buffer) {\n        const [x, y, width, height] = this.#box;\n        const lastTop = this.#last.subarray(4, 6);\n        const lastBottom = this.#last.subarray(16, 18);\n        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n        buffer.push(`L${(lastTop[0] - x) / width} ${(lastTop[1] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(lastBottom[0] - x) / width} ${(lastBottom[1] - y) / height}`);\n    }\n    newFreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR) {\n        return new FreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR);\n    }\n    getOutlines() {\n        const top = this.#top;\n        const bottom = this.#bottom;\n        const last = this.#last;\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        const points = new Float32Array((this.#points?.length ?? 0) + 2);\n        for(let i = 0, ii = points.length - 2; i < ii; i += 2){\n            points[i] = (this.#points[i] - layerX) / layerWidth;\n            points[i + 1] = (this.#points[i + 1] - layerY) / layerHeight;\n        }\n        points[points.length - 2] = (this.#lastX - layerX) / layerWidth;\n        points[points.length - 1] = (this.#lastY - layerY) / layerHeight;\n        if (isNaN(last[6]) && !this.isEmpty()) {\n            return this.#getOutlineTwoPoints(points);\n        }\n        const outline = new Float32Array(this.#top.length + 24 + this.#bottom.length);\n        let N = top.length;\n        for(let i = 0; i < N; i += 2){\n            if (isNaN(top[i])) {\n                outline[i] = outline[i + 1] = NaN;\n                continue;\n            }\n            outline[i] = top[i];\n            outline[i + 1] = top[i + 1];\n        }\n        N = this.#getOutlineEnd(outline, N);\n        for(let i = bottom.length - 6; i >= 6; i -= 6){\n            for(let j = 0; j < 6; j += 2){\n                if (isNaN(bottom[i + j])) {\n                    outline[N] = outline[N + 1] = NaN;\n                    N += 2;\n                    continue;\n                }\n                outline[N] = bottom[i + j];\n                outline[N + 1] = bottom[i + j + 1];\n                N += 2;\n            }\n        }\n        this.#getOutlineStart(outline, N);\n        return this.newFreeDrawOutline(outline, points, this.#box, this.#scaleFactor, this.#innerMargin, this.#isLTR);\n    }\n    #getOutlineTwoPoints(points) {\n        const last = this.#last;\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n        const outline = new Float32Array(36);\n        outline.set([\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (last[2] - layerX) / layerWidth,\n            (last[3] - layerY) / layerHeight,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (last[4] - layerX) / layerWidth,\n            (last[5] - layerY) / layerHeight,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            lastTopX,\n            lastTopY,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            lastBottomX,\n            lastBottomY,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (last[16] - layerX) / layerWidth,\n            (last[17] - layerY) / layerHeight,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (last[14] - layerX) / layerWidth,\n            (last[15] - layerY) / layerHeight\n        ], 0);\n        return this.newFreeDrawOutline(outline, points, this.#box, this.#scaleFactor, this.#innerMargin, this.#isLTR);\n    }\n    #getOutlineStart(outline, pos) {\n        const bottom = this.#bottom;\n        outline.set([\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            bottom[4],\n            bottom[5]\n        ], pos);\n        return pos += 6;\n    }\n    #getOutlineEnd(outline, pos) {\n        const lastTop = this.#last.subarray(4, 6);\n        const lastBottom = this.#last.subarray(16, 18);\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n        outline.set([\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (lastTop[0] - layerX) / layerWidth,\n            (lastTop[1] - layerY) / layerHeight,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            lastTopX,\n            lastTopY,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            lastBottomX,\n            lastBottomY,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (lastBottom[0] - layerX) / layerWidth,\n            (lastBottom[1] - layerY) / layerHeight\n        ], pos);\n        return pos += 24;\n    }\n}\nclass FreeDrawOutline extends Outline {\n    #box;\n    #bbox;\n    #innerMargin;\n    #isLTR;\n    #points;\n    #scaleFactor;\n    #outline;\n    constructor(outline, points, box, scaleFactor, innerMargin, isLTR){\n        super();\n        this.#bbox = new Float32Array(4);\n        this.#outline = outline;\n        this.#points = points;\n        this.#box = box;\n        this.#scaleFactor = scaleFactor;\n        this.#innerMargin = innerMargin;\n        this.#isLTR = isLTR;\n        this.lastPoint = [\n            NaN,\n            NaN\n        ];\n        this.#computeMinMax(isLTR);\n        const [x, y, width, height] = this.#bbox;\n        for(let i = 0, ii = outline.length; i < ii; i += 2){\n            outline[i] = (outline[i] - x) / width;\n            outline[i + 1] = (outline[i + 1] - y) / height;\n        }\n        for(let i = 0, ii = points.length; i < ii; i += 2){\n            points[i] = (points[i] - x) / width;\n            points[i + 1] = (points[i + 1] - y) / height;\n        }\n    }\n    toSVGPath() {\n        const buffer = [\n            `M${this.#outline[4]} ${this.#outline[5]}`\n        ];\n        for(let i = 6, ii = this.#outline.length; i < ii; i += 6){\n            if (isNaN(this.#outline[i])) {\n                buffer.push(`L${this.#outline[i + 4]} ${this.#outline[i + 5]}`);\n                continue;\n            }\n            buffer.push(`C${this.#outline[i]} ${this.#outline[i + 1]} ${this.#outline[i + 2]} ${this.#outline[i + 3]} ${this.#outline[i + 4]} ${this.#outline[i + 5]}`);\n        }\n        buffer.push(\"Z\");\n        return buffer.join(\" \");\n    }\n    serialize([blX, blY, trX, trY], rotation) {\n        const width = trX - blX;\n        const height = trY - blY;\n        let outline;\n        let points;\n        switch(rotation){\n            case 0:\n                outline = Outline._rescale(this.#outline, blX, trY, width, -height);\n                points = Outline._rescale(this.#points, blX, trY, width, -height);\n                break;\n            case 90:\n                outline = Outline._rescaleAndSwap(this.#outline, blX, blY, width, height);\n                points = Outline._rescaleAndSwap(this.#points, blX, blY, width, height);\n                break;\n            case 180:\n                outline = Outline._rescale(this.#outline, trX, blY, -width, height);\n                points = Outline._rescale(this.#points, trX, blY, -width, height);\n                break;\n            case 270:\n                outline = Outline._rescaleAndSwap(this.#outline, trX, trY, -width, -height);\n                points = Outline._rescaleAndSwap(this.#points, trX, trY, -width, -height);\n                break;\n        }\n        return {\n            outline: Array.from(outline),\n            points: [\n                Array.from(points)\n            ]\n        };\n    }\n    #computeMinMax(isLTR) {\n        const outline = this.#outline;\n        let lastX = outline[4];\n        let lastY = outline[5];\n        let minX = lastX;\n        let minY = lastY;\n        let maxX = lastX;\n        let maxY = lastY;\n        let lastPointX = lastX;\n        let lastPointY = lastY;\n        const ltrCallback = isLTR ? Math.max : Math.min;\n        for(let i = 6, ii = outline.length; i < ii; i += 6){\n            if (isNaN(outline[i])) {\n                minX = Math.min(minX, outline[i + 4]);\n                minY = Math.min(minY, outline[i + 5]);\n                maxX = Math.max(maxX, outline[i + 4]);\n                maxY = Math.max(maxY, outline[i + 5]);\n                if (lastPointY < outline[i + 5]) {\n                    lastPointX = outline[i + 4];\n                    lastPointY = outline[i + 5];\n                } else if (lastPointY === outline[i + 5]) {\n                    lastPointX = ltrCallback(lastPointX, outline[i + 4]);\n                }\n            } else {\n                const bbox = Util.bezierBoundingBox(lastX, lastY, ...outline.slice(i, i + 6));\n                minX = Math.min(minX, bbox[0]);\n                minY = Math.min(minY, bbox[1]);\n                maxX = Math.max(maxX, bbox[2]);\n                maxY = Math.max(maxY, bbox[3]);\n                if (lastPointY < bbox[3]) {\n                    lastPointX = bbox[2];\n                    lastPointY = bbox[3];\n                } else if (lastPointY === bbox[3]) {\n                    lastPointX = ltrCallback(lastPointX, bbox[2]);\n                }\n            }\n            lastX = outline[i + 4];\n            lastY = outline[i + 5];\n        }\n        const bbox = this.#bbox;\n        bbox[0] = minX - this.#innerMargin;\n        bbox[1] = minY - this.#innerMargin;\n        bbox[2] = maxX - minX + 2 * this.#innerMargin;\n        bbox[3] = maxY - minY + 2 * this.#innerMargin;\n        this.lastPoint = [\n            lastPointX,\n            lastPointY\n        ];\n    }\n    get box() {\n        return this.#bbox;\n    }\n    newOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin = 0) {\n        return new FreeDrawOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin);\n    }\n    getNewOutline(thickness, innerMargin) {\n        const [x, y, width, height] = this.#bbox;\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        const sx = width * layerWidth;\n        const sy = height * layerHeight;\n        const tx = x * layerWidth + layerX;\n        const ty = y * layerHeight + layerY;\n        const outliner = this.newOutliner({\n            x: this.#points[0] * sx + tx,\n            y: this.#points[1] * sy + ty\n        }, this.#box, this.#scaleFactor, thickness, this.#isLTR, innerMargin ?? this.#innerMargin);\n        for(let i = 2; i < this.#points.length; i += 2){\n            outliner.add({\n                x: this.#points[i] * sx + tx,\n                y: this.#points[i + 1] * sy + ty\n            });\n        }\n        return outliner.getOutlines();\n    }\n}\n; // ./src/display/editor/drawers/highlight.js\nclass HighlightOutliner {\n    #box;\n    #lastPoint;\n    #verticalEdges;\n    #intervals;\n    constructor(boxes, borderWidth = 0, innerMargin = 0, isLTR = true){\n        this.#verticalEdges = [];\n        this.#intervals = [];\n        let minX = Infinity;\n        let maxX = -Infinity;\n        let minY = Infinity;\n        let maxY = -Infinity;\n        const NUMBER_OF_DIGITS = 4;\n        const EPSILON = 10 ** -NUMBER_OF_DIGITS;\n        for (const { x, y, width, height } of boxes){\n            const x1 = Math.floor((x - borderWidth) / EPSILON) * EPSILON;\n            const x2 = Math.ceil((x + width + borderWidth) / EPSILON) * EPSILON;\n            const y1 = Math.floor((y - borderWidth) / EPSILON) * EPSILON;\n            const y2 = Math.ceil((y + height + borderWidth) / EPSILON) * EPSILON;\n            const left = [\n                x1,\n                y1,\n                y2,\n                true\n            ];\n            const right = [\n                x2,\n                y1,\n                y2,\n                false\n            ];\n            this.#verticalEdges.push(left, right);\n            minX = Math.min(minX, x1);\n            maxX = Math.max(maxX, x2);\n            minY = Math.min(minY, y1);\n            maxY = Math.max(maxY, y2);\n        }\n        const bboxWidth = maxX - minX + 2 * innerMargin;\n        const bboxHeight = maxY - minY + 2 * innerMargin;\n        const shiftedMinX = minX - innerMargin;\n        const shiftedMinY = minY - innerMargin;\n        const lastEdge = this.#verticalEdges.at(isLTR ? -1 : -2);\n        const lastPoint = [\n            lastEdge[0],\n            lastEdge[2]\n        ];\n        for (const edge of this.#verticalEdges){\n            const [x, y1, y2] = edge;\n            edge[0] = (x - shiftedMinX) / bboxWidth;\n            edge[1] = (y1 - shiftedMinY) / bboxHeight;\n            edge[2] = (y2 - shiftedMinY) / bboxHeight;\n        }\n        this.#box = new Float32Array([\n            shiftedMinX,\n            shiftedMinY,\n            bboxWidth,\n            bboxHeight\n        ]);\n        this.#lastPoint = lastPoint;\n    }\n    getOutlines() {\n        this.#verticalEdges.sort((a, b)=>a[0] - b[0] || a[1] - b[1] || a[2] - b[2]);\n        const outlineVerticalEdges = [];\n        for (const edge of this.#verticalEdges){\n            if (edge[3]) {\n                outlineVerticalEdges.push(...this.#breakEdge(edge));\n                this.#insert(edge);\n            } else {\n                this.#remove(edge);\n                outlineVerticalEdges.push(...this.#breakEdge(edge));\n            }\n        }\n        return this.#getOutlines(outlineVerticalEdges);\n    }\n    #getOutlines(outlineVerticalEdges) {\n        const edges = [];\n        const allEdges = new Set();\n        for (const edge of outlineVerticalEdges){\n            const [x, y1, y2] = edge;\n            edges.push([\n                x,\n                y1,\n                edge\n            ], [\n                x,\n                y2,\n                edge\n            ]);\n        }\n        edges.sort((a, b)=>a[1] - b[1] || a[0] - b[0]);\n        for(let i = 0, ii = edges.length; i < ii; i += 2){\n            const edge1 = edges[i][2];\n            const edge2 = edges[i + 1][2];\n            edge1.push(edge2);\n            edge2.push(edge1);\n            allEdges.add(edge1);\n            allEdges.add(edge2);\n        }\n        const outlines = [];\n        let outline;\n        while(allEdges.size > 0){\n            const edge = allEdges.values().next().value;\n            let [x, y1, y2, edge1, edge2] = edge;\n            allEdges.delete(edge);\n            let lastPointX = x;\n            let lastPointY = y1;\n            outline = [\n                x,\n                y2\n            ];\n            outlines.push(outline);\n            while(true){\n                let e;\n                if (allEdges.has(edge1)) {\n                    e = edge1;\n                } else if (allEdges.has(edge2)) {\n                    e = edge2;\n                } else {\n                    break;\n                }\n                allEdges.delete(e);\n                [x, y1, y2, edge1, edge2] = e;\n                if (lastPointX !== x) {\n                    outline.push(lastPointX, lastPointY, x, lastPointY === y1 ? y1 : y2);\n                    lastPointX = x;\n                }\n                lastPointY = lastPointY === y1 ? y2 : y1;\n            }\n            outline.push(lastPointX, lastPointY);\n        }\n        return new HighlightOutline(outlines, this.#box, this.#lastPoint);\n    }\n    #binarySearch(y) {\n        const array = this.#intervals;\n        let start = 0;\n        let end = array.length - 1;\n        while(start <= end){\n            const middle = start + end >> 1;\n            const y1 = array[middle][0];\n            if (y1 === y) {\n                return middle;\n            }\n            if (y1 < y) {\n                start = middle + 1;\n            } else {\n                end = middle - 1;\n            }\n        }\n        return end + 1;\n    }\n    #insert([, y1, y2]) {\n        const index = this.#binarySearch(y1);\n        this.#intervals.splice(index, 0, [\n            y1,\n            y2\n        ]);\n    }\n    #remove([, y1, y2]) {\n        const index = this.#binarySearch(y1);\n        for(let i = index; i < this.#intervals.length; i++){\n            const [start, end] = this.#intervals[i];\n            if (start !== y1) {\n                break;\n            }\n            if (start === y1 && end === y2) {\n                this.#intervals.splice(i, 1);\n                return;\n            }\n        }\n        for(let i = index - 1; i >= 0; i--){\n            const [start, end] = this.#intervals[i];\n            if (start !== y1) {\n                break;\n            }\n            if (start === y1 && end === y2) {\n                this.#intervals.splice(i, 1);\n                return;\n            }\n        }\n    }\n    #breakEdge(edge) {\n        const [x, y1, y2] = edge;\n        const results = [\n            [\n                x,\n                y1,\n                y2\n            ]\n        ];\n        const index = this.#binarySearch(y2);\n        for(let i = 0; i < index; i++){\n            const [start, end] = this.#intervals[i];\n            for(let j = 0, jj = results.length; j < jj; j++){\n                const [, y3, y4] = results[j];\n                if (end <= y3 || y4 <= start) {\n                    continue;\n                }\n                if (y3 >= start) {\n                    if (y4 > end) {\n                        results[j][1] = end;\n                    } else {\n                        if (jj === 1) {\n                            return [];\n                        }\n                        results.splice(j, 1);\n                        j--;\n                        jj--;\n                    }\n                    continue;\n                }\n                results[j][2] = start;\n                if (y4 > end) {\n                    results.push([\n                        x,\n                        end,\n                        y4\n                    ]);\n                }\n            }\n        }\n        return results;\n    }\n}\nclass HighlightOutline extends Outline {\n    #box;\n    #outlines;\n    constructor(outlines, box, lastPoint){\n        super();\n        this.#outlines = outlines;\n        this.#box = box;\n        this.lastPoint = lastPoint;\n    }\n    toSVGPath() {\n        const buffer = [];\n        for (const polygon of this.#outlines){\n            let [prevX, prevY] = polygon;\n            buffer.push(`M${prevX} ${prevY}`);\n            for(let i = 2; i < polygon.length; i += 2){\n                const x = polygon[i];\n                const y = polygon[i + 1];\n                if (x === prevX) {\n                    buffer.push(`V${y}`);\n                    prevY = y;\n                } else if (y === prevY) {\n                    buffer.push(`H${x}`);\n                    prevX = x;\n                }\n            }\n            buffer.push(\"Z\");\n        }\n        return buffer.join(\" \");\n    }\n    serialize([blX, blY, trX, trY], _rotation) {\n        const outlines = [];\n        const width = trX - blX;\n        const height = trY - blY;\n        for (const outline of this.#outlines){\n            const points = new Array(outline.length);\n            for(let i = 0; i < outline.length; i += 2){\n                points[i] = blX + outline[i] * width;\n                points[i + 1] = trY - outline[i + 1] * height;\n            }\n            outlines.push(points);\n        }\n        return outlines;\n    }\n    get box() {\n        return this.#box;\n    }\n    get classNamesForOutlining() {\n        return [\n            \"highlightOutline\"\n        ];\n    }\n}\nclass FreeHighlightOutliner extends FreeDrawOutliner {\n    newFreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR) {\n        return new FreeHighlightOutline(outline, points, box, scaleFactor, innerMargin, isLTR);\n    }\n}\nclass FreeHighlightOutline extends FreeDrawOutline {\n    newOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin = 0) {\n        return new FreeHighlightOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin);\n    }\n}\n; // ./src/display/editor/color_picker.js\nclass ColorPicker {\n    #button;\n    #buttonSwatch;\n    #defaultColor;\n    #dropdown;\n    #dropdownWasFromKeyboard;\n    #isMainColorPicker;\n    #editor;\n    #eventBus;\n    #openDropdownAC;\n    #uiManager;\n    #type;\n    static #l10nColor = null;\n    static get _keyboardManager() {\n        return shadow(this, \"_keyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"Escape\",\n                    \"mac+Escape\"\n                ],\n                ColorPicker.prototype._hideDropdownFromKeyboard\n            ],\n            [\n                [\n                    \" \",\n                    \"mac+ \"\n                ],\n                ColorPicker.prototype._colorSelectFromKeyboard\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"ArrowRight\",\n                    \"mac+ArrowDown\",\n                    \"mac+ArrowRight\"\n                ],\n                ColorPicker.prototype._moveToNext\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"ArrowLeft\",\n                    \"mac+ArrowUp\",\n                    \"mac+ArrowLeft\"\n                ],\n                ColorPicker.prototype._moveToPrevious\n            ],\n            [\n                [\n                    \"Home\",\n                    \"mac+Home\"\n                ],\n                ColorPicker.prototype._moveToBeginning\n            ],\n            [\n                [\n                    \"End\",\n                    \"mac+End\"\n                ],\n                ColorPicker.prototype._moveToEnd\n            ]\n        ]));\n    }\n    constructor({ editor = null, uiManager = null }){\n        this.#button = null;\n        this.#buttonSwatch = null;\n        this.#dropdown = null;\n        this.#dropdownWasFromKeyboard = false;\n        this.#isMainColorPicker = false;\n        this.#editor = null;\n        this.#openDropdownAC = null;\n        this.#uiManager = null;\n        if (editor) {\n            this.#isMainColorPicker = false;\n            this.#type = AnnotationEditorParamsType.HIGHLIGHT_COLOR;\n            this.#editor = editor;\n        } else {\n            this.#isMainColorPicker = true;\n            this.#type = AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR;\n        }\n        this.#uiManager = editor?._uiManager || uiManager;\n        this.#eventBus = this.#uiManager._eventBus;\n        this.#defaultColor = editor?.color || this.#uiManager?.highlightColors.values().next().value || \"#FFFF98\";\n        ColorPicker.#l10nColor ||= Object.freeze({\n            blue: \"pdfjs-editor-colorpicker-blue\",\n            green: \"pdfjs-editor-colorpicker-green\",\n            pink: \"pdfjs-editor-colorpicker-pink\",\n            red: \"pdfjs-editor-colorpicker-red\",\n            yellow: \"pdfjs-editor-colorpicker-yellow\"\n        });\n    }\n    renderButton() {\n        const button = this.#button = document.createElement(\"button\");\n        button.className = \"colorPicker\";\n        button.tabIndex = \"0\";\n        button.setAttribute(\"data-l10n-id\", \"pdfjs-editor-colorpicker-button\");\n        button.setAttribute(\"aria-haspopup\", true);\n        const signal = this.#uiManager._signal;\n        button.addEventListener(\"click\", this.#openDropdown.bind(this), {\n            signal\n        });\n        button.addEventListener(\"keydown\", this.#keyDown.bind(this), {\n            signal\n        });\n        const swatch = this.#buttonSwatch = document.createElement(\"span\");\n        swatch.className = \"swatch\";\n        swatch.setAttribute(\"aria-hidden\", true);\n        swatch.style.backgroundColor = this.#defaultColor;\n        button.append(swatch);\n        return button;\n    }\n    renderMainDropdown() {\n        const dropdown = this.#dropdown = this.#getDropdownRoot();\n        dropdown.setAttribute(\"aria-orientation\", \"horizontal\");\n        dropdown.setAttribute(\"aria-labelledby\", \"highlightColorPickerLabel\");\n        return dropdown;\n    }\n    #getDropdownRoot() {\n        const div = document.createElement(\"div\");\n        const signal = this.#uiManager._signal;\n        div.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        div.className = \"dropdown\";\n        div.role = \"listbox\";\n        div.setAttribute(\"aria-multiselectable\", false);\n        div.setAttribute(\"aria-orientation\", \"vertical\");\n        div.setAttribute(\"data-l10n-id\", \"pdfjs-editor-colorpicker-dropdown\");\n        for (const [name, color] of this.#uiManager.highlightColors){\n            const button = document.createElement(\"button\");\n            button.tabIndex = \"0\";\n            button.role = \"option\";\n            button.setAttribute(\"data-color\", color);\n            button.title = name;\n            button.setAttribute(\"data-l10n-id\", ColorPicker.#l10nColor[name]);\n            const swatch = document.createElement(\"span\");\n            button.append(swatch);\n            swatch.className = \"swatch\";\n            swatch.style.backgroundColor = color;\n            button.setAttribute(\"aria-selected\", color === this.#defaultColor);\n            button.addEventListener(\"click\", this.#colorSelect.bind(this, color), {\n                signal\n            });\n            div.append(button);\n        }\n        div.addEventListener(\"keydown\", this.#keyDown.bind(this), {\n            signal\n        });\n        return div;\n    }\n    #colorSelect(color, event) {\n        event.stopPropagation();\n        this.#eventBus.dispatch(\"switchannotationeditorparams\", {\n            source: this,\n            type: this.#type,\n            value: color\n        });\n    }\n    _colorSelectFromKeyboard(event) {\n        if (event.target === this.#button) {\n            this.#openDropdown(event);\n            return;\n        }\n        const color = event.target.getAttribute(\"data-color\");\n        if (!color) {\n            return;\n        }\n        this.#colorSelect(color, event);\n    }\n    _moveToNext(event) {\n        if (!this.#isDropdownVisible) {\n            this.#openDropdown(event);\n            return;\n        }\n        if (event.target === this.#button) {\n            this.#dropdown.firstChild?.focus();\n            return;\n        }\n        event.target.nextSibling?.focus();\n    }\n    _moveToPrevious(event) {\n        if (event.target === this.#dropdown?.firstChild || event.target === this.#button) {\n            if (this.#isDropdownVisible) {\n                this._hideDropdownFromKeyboard();\n            }\n            return;\n        }\n        if (!this.#isDropdownVisible) {\n            this.#openDropdown(event);\n        }\n        event.target.previousSibling?.focus();\n    }\n    _moveToBeginning(event) {\n        if (!this.#isDropdownVisible) {\n            this.#openDropdown(event);\n            return;\n        }\n        this.#dropdown.firstChild?.focus();\n    }\n    _moveToEnd(event) {\n        if (!this.#isDropdownVisible) {\n            this.#openDropdown(event);\n            return;\n        }\n        this.#dropdown.lastChild?.focus();\n    }\n    #keyDown(event) {\n        ColorPicker._keyboardManager.exec(this, event);\n    }\n    #openDropdown(event) {\n        if (this.#isDropdownVisible) {\n            this.hideDropdown();\n            return;\n        }\n        this.#dropdownWasFromKeyboard = event.detail === 0;\n        if (!this.#openDropdownAC) {\n            this.#openDropdownAC = new AbortController();\n            window.addEventListener(\"pointerdown\", this.#pointerDown.bind(this), {\n                signal: this.#uiManager.combinedSignal(this.#openDropdownAC)\n            });\n        }\n        if (this.#dropdown) {\n            this.#dropdown.classList.remove(\"hidden\");\n            return;\n        }\n        const root = this.#dropdown = this.#getDropdownRoot();\n        this.#button.append(root);\n    }\n    #pointerDown(event) {\n        if (this.#dropdown?.contains(event.target)) {\n            return;\n        }\n        this.hideDropdown();\n    }\n    hideDropdown() {\n        this.#dropdown?.classList.add(\"hidden\");\n        this.#openDropdownAC?.abort();\n        this.#openDropdownAC = null;\n    }\n    get #isDropdownVisible() {\n        return this.#dropdown && !this.#dropdown.classList.contains(\"hidden\");\n    }\n    _hideDropdownFromKeyboard() {\n        if (this.#isMainColorPicker) {\n            return;\n        }\n        if (!this.#isDropdownVisible) {\n            this.#editor?.unselect();\n            return;\n        }\n        this.hideDropdown();\n        this.#button.focus({\n            preventScroll: true,\n            focusVisible: this.#dropdownWasFromKeyboard\n        });\n    }\n    updateColor(color) {\n        if (this.#buttonSwatch) {\n            this.#buttonSwatch.style.backgroundColor = color;\n        }\n        if (!this.#dropdown) {\n            return;\n        }\n        const i = this.#uiManager.highlightColors.values();\n        for (const child of this.#dropdown.children){\n            child.setAttribute(\"aria-selected\", i.next().value === color);\n        }\n    }\n    destroy() {\n        this.#button?.remove();\n        this.#button = null;\n        this.#buttonSwatch = null;\n        this.#dropdown?.remove();\n        this.#dropdown = null;\n    }\n}\n; // ./src/display/editor/highlight.js\nclass HighlightEditor extends AnnotationEditor {\n    #anchorNode;\n    #anchorOffset;\n    #boxes;\n    #clipPathId;\n    #colorPicker;\n    #focusOutlines;\n    #focusNode;\n    #focusOffset;\n    #highlightDiv;\n    #highlightOutlines;\n    #id;\n    #isFreeHighlight;\n    #lastPoint;\n    #opacity;\n    #outlineId;\n    #text;\n    #thickness;\n    #methodOfCreation;\n    static{\n        this._defaultColor = null;\n    }\n    static{\n        this._defaultOpacity = 1;\n    }\n    static{\n        this._defaultThickness = 12;\n    }\n    static{\n        this._type = \"highlight\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.HIGHLIGHT;\n    }\n    static{\n        this._freeHighlightId = -1;\n    }\n    static{\n        this._freeHighlight = null;\n    }\n    static{\n        this._freeHighlightClipId = \"\";\n    }\n    static get _keyboardManager() {\n        const proto = HighlightEditor.prototype;\n        return shadow(this, \"_keyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"ArrowLeft\",\n                    \"mac+ArrowLeft\"\n                ],\n                proto._moveCaret,\n                {\n                    args: [\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowRight\",\n                    \"mac+ArrowRight\"\n                ],\n                proto._moveCaret,\n                {\n                    args: [\n                        1\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"mac+ArrowUp\"\n                ],\n                proto._moveCaret,\n                {\n                    args: [\n                        2\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"mac+ArrowDown\"\n                ],\n                proto._moveCaret,\n                {\n                    args: [\n                        3\n                    ]\n                }\n            ]\n        ]));\n    }\n    constructor(params){\n        super({\n            ...params,\n            name: \"highlightEditor\"\n        });\n        this.#anchorNode = null;\n        this.#anchorOffset = 0;\n        this.#clipPathId = null;\n        this.#colorPicker = null;\n        this.#focusOutlines = null;\n        this.#focusNode = null;\n        this.#focusOffset = 0;\n        this.#highlightDiv = null;\n        this.#highlightOutlines = null;\n        this.#id = null;\n        this.#isFreeHighlight = false;\n        this.#lastPoint = null;\n        this.#outlineId = null;\n        this.#text = \"\";\n        this.#methodOfCreation = \"\";\n        this.color = params.color || HighlightEditor._defaultColor;\n        this.#thickness = params.thickness || HighlightEditor._defaultThickness;\n        this.#opacity = params.opacity || HighlightEditor._defaultOpacity;\n        this.#boxes = params.boxes || null;\n        this.#methodOfCreation = params.methodOfCreation || \"\";\n        this.#text = params.text || \"\";\n        this._isDraggable = false;\n        if (params.highlightId > -1) {\n            this.#isFreeHighlight = true;\n            this.#createFreeOutlines(params);\n            this.#addToDrawLayer();\n        } else if (this.#boxes) {\n            this.#anchorNode = params.anchorNode;\n            this.#anchorOffset = params.anchorOffset;\n            this.#focusNode = params.focusNode;\n            this.#focusOffset = params.focusOffset;\n            this.#createOutlines();\n            this.#addToDrawLayer();\n            this.rotate(this.rotation);\n        }\n    }\n    get telemetryInitialData() {\n        return {\n            action: \"added\",\n            type: this.#isFreeHighlight ? \"free_highlight\" : \"highlight\",\n            color: this._uiManager.highlightColorNames.get(this.color),\n            thickness: this.#thickness,\n            methodOfCreation: this.#methodOfCreation\n        };\n    }\n    get telemetryFinalData() {\n        return {\n            type: \"highlight\",\n            color: this._uiManager.highlightColorNames.get(this.color)\n        };\n    }\n    static computeTelemetryFinalData(data) {\n        return {\n            numberOfColors: data.get(\"color\").size\n        };\n    }\n    #createOutlines() {\n        const outliner = new HighlightOutliner(this.#boxes, 0.001);\n        this.#highlightOutlines = outliner.getOutlines();\n        [this.x, this.y, this.width, this.height] = this.#highlightOutlines.box;\n        const outlinerForOutline = new HighlightOutliner(this.#boxes, 0.0025, 0.001, this._uiManager.direction === \"ltr\");\n        this.#focusOutlines = outlinerForOutline.getOutlines();\n        const { lastPoint } = this.#focusOutlines;\n        this.#lastPoint = [\n            (lastPoint[0] - this.x) / this.width,\n            (lastPoint[1] - this.y) / this.height\n        ];\n    }\n    #createFreeOutlines({ highlightOutlines, highlightId, clipPathId }) {\n        this.#highlightOutlines = highlightOutlines;\n        const extraThickness = 1.5;\n        this.#focusOutlines = highlightOutlines.getNewOutline(this.#thickness / 2 + extraThickness, 0.0025);\n        if (highlightId >= 0) {\n            this.#id = highlightId;\n            this.#clipPathId = clipPathId;\n            this.parent.drawLayer.finalizeDraw(highlightId, {\n                bbox: highlightOutlines.box,\n                path: {\n                    d: highlightOutlines.toSVGPath()\n                }\n            });\n            this.#outlineId = this.parent.drawLayer.drawOutline({\n                rootClass: {\n                    highlightOutline: true,\n                    free: true\n                },\n                bbox: this.#focusOutlines.box,\n                path: {\n                    d: this.#focusOutlines.toSVGPath()\n                }\n            }, true);\n        } else if (this.parent) {\n            const angle = this.parent.viewport.rotation;\n            this.parent.drawLayer.updateProperties(this.#id, {\n                bbox: HighlightEditor.#rotateBbox(this.#highlightOutlines.box, (angle - this.rotation + 360) % 360),\n                path: {\n                    d: highlightOutlines.toSVGPath()\n                }\n            });\n            this.parent.drawLayer.updateProperties(this.#outlineId, {\n                bbox: HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle),\n                path: {\n                    d: this.#focusOutlines.toSVGPath()\n                }\n            });\n        }\n        const [x, y, width, height] = highlightOutlines.box;\n        switch(this.rotation){\n            case 0:\n                this.x = x;\n                this.y = y;\n                this.width = width;\n                this.height = height;\n                break;\n            case 90:\n                {\n                    const [pageWidth, pageHeight] = this.parentDimensions;\n                    this.x = y;\n                    this.y = 1 - x;\n                    this.width = width * pageHeight / pageWidth;\n                    this.height = height * pageWidth / pageHeight;\n                    break;\n                }\n            case 180:\n                this.x = 1 - x;\n                this.y = 1 - y;\n                this.width = width;\n                this.height = height;\n                break;\n            case 270:\n                {\n                    const [pageWidth, pageHeight] = this.parentDimensions;\n                    this.x = 1 - y;\n                    this.y = x;\n                    this.width = width * pageHeight / pageWidth;\n                    this.height = height * pageWidth / pageHeight;\n                    break;\n                }\n        }\n        const { lastPoint } = this.#focusOutlines;\n        this.#lastPoint = [\n            (lastPoint[0] - x) / width,\n            (lastPoint[1] - y) / height\n        ];\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n        HighlightEditor._defaultColor ||= uiManager.highlightColors?.values().next().value || \"#fff066\";\n    }\n    static updateDefaultParams(type, value) {\n        switch(type){\n            case AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR:\n                HighlightEditor._defaultColor = value;\n                break;\n            case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:\n                HighlightEditor._defaultThickness = value;\n                break;\n        }\n    }\n    translateInPage(x, y) {}\n    get toolbarPosition() {\n        return this.#lastPoint;\n    }\n    updateParams(type, value) {\n        switch(type){\n            case AnnotationEditorParamsType.HIGHLIGHT_COLOR:\n                this.#updateColor(value);\n                break;\n            case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:\n                this.#updateThickness(value);\n                break;\n        }\n    }\n    static get defaultPropertiesToUpdate() {\n        return [\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR,\n                HighlightEditor._defaultColor\n            ],\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_THICKNESS,\n                HighlightEditor._defaultThickness\n            ]\n        ];\n    }\n    get propertiesToUpdate() {\n        return [\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_COLOR,\n                this.color || HighlightEditor._defaultColor\n            ],\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_THICKNESS,\n                this.#thickness || HighlightEditor._defaultThickness\n            ],\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_FREE,\n                this.#isFreeHighlight\n            ]\n        ];\n    }\n    #updateColor(color) {\n        const setColorAndOpacity = (col, opa)=>{\n            this.color = col;\n            this.#opacity = opa;\n            this.parent?.drawLayer.updateProperties(this.#id, {\n                root: {\n                    fill: col,\n                    \"fill-opacity\": opa\n                }\n            });\n            this.#colorPicker?.updateColor(col);\n        };\n        const savedColor = this.color;\n        const savedOpacity = this.#opacity;\n        this.addCommands({\n            cmd: setColorAndOpacity.bind(this, color, HighlightEditor._defaultOpacity),\n            undo: setColorAndOpacity.bind(this, savedColor, savedOpacity),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type: AnnotationEditorParamsType.HIGHLIGHT_COLOR,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n        this._reportTelemetry({\n            action: \"color_changed\",\n            color: this._uiManager.highlightColorNames.get(color)\n        }, true);\n    }\n    #updateThickness(thickness) {\n        const savedThickness = this.#thickness;\n        const setThickness = (th)=>{\n            this.#thickness = th;\n            this.#changeThickness(th);\n        };\n        this.addCommands({\n            cmd: setThickness.bind(this, thickness),\n            undo: setThickness.bind(this, savedThickness),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type: AnnotationEditorParamsType.INK_THICKNESS,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n        this._reportTelemetry({\n            action: \"thickness_changed\",\n            thickness\n        }, true);\n    }\n    async addEditToolbar() {\n        const toolbar = await super.addEditToolbar();\n        if (!toolbar) {\n            return null;\n        }\n        if (this._uiManager.highlightColors) {\n            this.#colorPicker = new ColorPicker({\n                editor: this\n            });\n            toolbar.addColorPicker(this.#colorPicker);\n        }\n        return toolbar;\n    }\n    disableEditing() {\n        super.disableEditing();\n        this.div.classList.toggle(\"disabled\", true);\n    }\n    enableEditing() {\n        super.enableEditing();\n        this.div.classList.toggle(\"disabled\", false);\n    }\n    fixAndSetPosition() {\n        return super.fixAndSetPosition(this.#getRotation());\n    }\n    getBaseTranslation() {\n        return [\n            0,\n            0\n        ];\n    }\n    getRect(tx, ty) {\n        return super.getRect(tx, ty, this.#getRotation());\n    }\n    onceAdded() {\n        if (!this.annotationElementId) {\n            this.parent.addUndoableEditor(this);\n        }\n        this.div.focus();\n    }\n    remove() {\n        this.#cleanDrawLayer();\n        this._reportTelemetry({\n            action: \"deleted\"\n        });\n        super.remove();\n    }\n    rebuild() {\n        if (!this.parent) {\n            return;\n        }\n        super.rebuild();\n        if (this.div === null) {\n            return;\n        }\n        this.#addToDrawLayer();\n        if (!this.isAttachedToDOM) {\n            this.parent.add(this);\n        }\n    }\n    setParent(parent) {\n        let mustBeSelected = false;\n        if (this.parent && !parent) {\n            this.#cleanDrawLayer();\n        } else if (parent) {\n            this.#addToDrawLayer(parent);\n            mustBeSelected = !this.parent && this.div?.classList.contains(\"selectedEditor\");\n        }\n        super.setParent(parent);\n        this.show(this._isVisible);\n        if (mustBeSelected) {\n            this.select();\n        }\n    }\n    #changeThickness(thickness) {\n        if (!this.#isFreeHighlight) {\n            return;\n        }\n        this.#createFreeOutlines({\n            highlightOutlines: this.#highlightOutlines.getNewOutline(thickness / 2)\n        });\n        this.fixAndSetPosition();\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.setDims(this.width * parentWidth, this.height * parentHeight);\n    }\n    #cleanDrawLayer() {\n        if (this.#id === null || !this.parent) {\n            return;\n        }\n        this.parent.drawLayer.remove(this.#id);\n        this.#id = null;\n        this.parent.drawLayer.remove(this.#outlineId);\n        this.#outlineId = null;\n    }\n    #addToDrawLayer(parent = this.parent) {\n        if (this.#id !== null) {\n            return;\n        }\n        ({ id: this.#id, clipPathId: this.#clipPathId } = parent.drawLayer.draw({\n            bbox: this.#highlightOutlines.box,\n            root: {\n                viewBox: \"0 0 1 1\",\n                fill: this.color,\n                \"fill-opacity\": this.#opacity\n            },\n            rootClass: {\n                highlight: true,\n                free: this.#isFreeHighlight\n            },\n            path: {\n                d: this.#highlightOutlines.toSVGPath()\n            }\n        }, false, true));\n        this.#outlineId = parent.drawLayer.drawOutline({\n            rootClass: {\n                highlightOutline: true,\n                free: this.#isFreeHighlight\n            },\n            bbox: this.#focusOutlines.box,\n            path: {\n                d: this.#focusOutlines.toSVGPath()\n            }\n        }, this.#isFreeHighlight);\n        if (this.#highlightDiv) {\n            this.#highlightDiv.style.clipPath = this.#clipPathId;\n        }\n    }\n    static #rotateBbox([x, y, width, height], angle) {\n        switch(angle){\n            case 90:\n                return [\n                    1 - y - height,\n                    x,\n                    height,\n                    width\n                ];\n            case 180:\n                return [\n                    1 - x - width,\n                    1 - y - height,\n                    width,\n                    height\n                ];\n            case 270:\n                return [\n                    y,\n                    1 - x - width,\n                    height,\n                    width\n                ];\n        }\n        return [\n            x,\n            y,\n            width,\n            height\n        ];\n    }\n    rotate(angle) {\n        const { drawLayer } = this.parent;\n        let box;\n        if (this.#isFreeHighlight) {\n            angle = (angle - this.rotation + 360) % 360;\n            box = HighlightEditor.#rotateBbox(this.#highlightOutlines.box, angle);\n        } else {\n            box = HighlightEditor.#rotateBbox([\n                this.x,\n                this.y,\n                this.width,\n                this.height\n            ], angle);\n        }\n        drawLayer.updateProperties(this.#id, {\n            bbox: box,\n            root: {\n                \"data-main-rotation\": angle\n            }\n        });\n        drawLayer.updateProperties(this.#outlineId, {\n            bbox: HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle),\n            root: {\n                \"data-main-rotation\": angle\n            }\n        });\n    }\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        const div = super.render();\n        if (this.#text) {\n            div.setAttribute(\"aria-label\", this.#text);\n            div.setAttribute(\"role\", \"mark\");\n        }\n        if (this.#isFreeHighlight) {\n            div.classList.add(\"free\");\n        } else {\n            this.div.addEventListener(\"keydown\", this.#keydown.bind(this), {\n                signal: this._uiManager._signal\n            });\n        }\n        const highlightDiv = this.#highlightDiv = document.createElement(\"div\");\n        div.append(highlightDiv);\n        highlightDiv.setAttribute(\"aria-hidden\", \"true\");\n        highlightDiv.className = \"internal\";\n        highlightDiv.style.clipPath = this.#clipPathId;\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.setDims(this.width * parentWidth, this.height * parentHeight);\n        bindEvents(this, this.#highlightDiv, [\n            \"pointerover\",\n            \"pointerleave\"\n        ]);\n        this.enableEditing();\n        return div;\n    }\n    pointerover() {\n        if (!this.isSelected) {\n            this.parent?.drawLayer.updateProperties(this.#outlineId, {\n                rootClass: {\n                    hovered: true\n                }\n            });\n        }\n    }\n    pointerleave() {\n        if (!this.isSelected) {\n            this.parent?.drawLayer.updateProperties(this.#outlineId, {\n                rootClass: {\n                    hovered: false\n                }\n            });\n        }\n    }\n    #keydown(event) {\n        HighlightEditor._keyboardManager.exec(this, event);\n    }\n    _moveCaret(direction) {\n        this.parent.unselect(this);\n        switch(direction){\n            case 0:\n            case 2:\n                this.#setCaret(true);\n                break;\n            case 1:\n            case 3:\n                this.#setCaret(false);\n                break;\n        }\n    }\n    #setCaret(start) {\n        if (!this.#anchorNode) {\n            return;\n        }\n        const selection = window.getSelection();\n        if (start) {\n            selection.setPosition(this.#anchorNode, this.#anchorOffset);\n        } else {\n            selection.setPosition(this.#focusNode, this.#focusOffset);\n        }\n    }\n    select() {\n        super.select();\n        if (!this.#outlineId) {\n            return;\n        }\n        this.parent?.drawLayer.updateProperties(this.#outlineId, {\n            rootClass: {\n                hovered: false,\n                selected: true\n            }\n        });\n    }\n    unselect() {\n        super.unselect();\n        if (!this.#outlineId) {\n            return;\n        }\n        this.parent?.drawLayer.updateProperties(this.#outlineId, {\n            rootClass: {\n                selected: false\n            }\n        });\n        if (!this.#isFreeHighlight) {\n            this.#setCaret(false);\n        }\n    }\n    get _mustFixPosition() {\n        return !this.#isFreeHighlight;\n    }\n    show(visible = this._isVisible) {\n        super.show(visible);\n        if (this.parent) {\n            this.parent.drawLayer.updateProperties(this.#id, {\n                rootClass: {\n                    hidden: !visible\n                }\n            });\n            this.parent.drawLayer.updateProperties(this.#outlineId, {\n                rootClass: {\n                    hidden: !visible\n                }\n            });\n        }\n    }\n    #getRotation() {\n        return this.#isFreeHighlight ? this.rotation : 0;\n    }\n    #serializeBoxes() {\n        if (this.#isFreeHighlight) {\n            return null;\n        }\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        const [pageX, pageY] = this.pageTranslation;\n        const boxes = this.#boxes;\n        const quadPoints = new Float32Array(boxes.length * 8);\n        let i = 0;\n        for (const { x, y, width, height } of boxes){\n            const sx = x * pageWidth + pageX;\n            const sy = (1 - y) * pageHeight + pageY;\n            quadPoints[i] = quadPoints[i + 4] = sx;\n            quadPoints[i + 1] = quadPoints[i + 3] = sy;\n            quadPoints[i + 2] = quadPoints[i + 6] = sx + width * pageWidth;\n            quadPoints[i + 5] = quadPoints[i + 7] = sy - height * pageHeight;\n            i += 8;\n        }\n        return quadPoints;\n    }\n    #serializeOutlines(rect) {\n        return this.#highlightOutlines.serialize(rect, this.#getRotation());\n    }\n    static startHighlighting(parent, isLTR, { target: textLayer, x, y }) {\n        const { x: layerX, y: layerY, width: parentWidth, height: parentHeight } = textLayer.getBoundingClientRect();\n        const ac = new AbortController();\n        const signal = parent.combinedSignal(ac);\n        const pointerUpCallback = (e)=>{\n            ac.abort();\n            this.#endHighlight(parent, e);\n        };\n        window.addEventListener(\"blur\", pointerUpCallback, {\n            signal\n        });\n        window.addEventListener(\"pointerup\", pointerUpCallback, {\n            signal\n        });\n        window.addEventListener(\"pointerdown\", stopEvent, {\n            capture: true,\n            passive: false,\n            signal\n        });\n        window.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        textLayer.addEventListener(\"pointermove\", this.#highlightMove.bind(this, parent), {\n            signal\n        });\n        this._freeHighlight = new FreeHighlightOutliner({\n            x,\n            y\n        }, [\n            layerX,\n            layerY,\n            parentWidth,\n            parentHeight\n        ], parent.scale, this._defaultThickness / 2, isLTR, 0.001);\n        ({ id: this._freeHighlightId, clipPathId: this._freeHighlightClipId } = parent.drawLayer.draw({\n            bbox: [\n                0,\n                0,\n                1,\n                1\n            ],\n            root: {\n                viewBox: \"0 0 1 1\",\n                fill: this._defaultColor,\n                \"fill-opacity\": this._defaultOpacity\n            },\n            rootClass: {\n                highlight: true,\n                free: true\n            },\n            path: {\n                d: this._freeHighlight.toSVGPath()\n            }\n        }, true, true));\n    }\n    static #highlightMove(parent, event) {\n        if (this._freeHighlight.add(event)) {\n            parent.drawLayer.updateProperties(this._freeHighlightId, {\n                path: {\n                    d: this._freeHighlight.toSVGPath()\n                }\n            });\n        }\n    }\n    static #endHighlight(parent, event) {\n        if (!this._freeHighlight.isEmpty()) {\n            parent.createAndAddNewEditor(event, false, {\n                highlightId: this._freeHighlightId,\n                highlightOutlines: this._freeHighlight.getOutlines(),\n                clipPathId: this._freeHighlightClipId,\n                methodOfCreation: \"main_toolbar\"\n            });\n        } else {\n            parent.drawLayer.remove(this._freeHighlightId);\n        }\n        this._freeHighlightId = -1;\n        this._freeHighlight = null;\n        this._freeHighlightClipId = \"\";\n    }\n    static async deserialize(data, parent, uiManager) {\n        let initialData = null;\n        if (data instanceof HighlightAnnotationElement) {\n            const { data: { quadPoints, rect, rotation, id, color, opacity, popupRef }, parent: { page: { pageNumber } } } = data;\n            initialData = data = {\n                annotationType: AnnotationEditorType.HIGHLIGHT,\n                color: Array.from(color),\n                opacity,\n                quadPoints,\n                boxes: null,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                id,\n                deleted: false,\n                popupRef\n            };\n        } else if (data instanceof InkAnnotationElement) {\n            const { data: { inkLists, rect, rotation, id, color, borderStyle: { rawWidth: thickness }, popupRef }, parent: { page: { pageNumber } } } = data;\n            initialData = data = {\n                annotationType: AnnotationEditorType.HIGHLIGHT,\n                color: Array.from(color),\n                thickness,\n                inkLists,\n                boxes: null,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                id,\n                deleted: false,\n                popupRef\n            };\n        }\n        const { color, quadPoints, inkLists, opacity } = data;\n        const editor = await super.deserialize(data, parent, uiManager);\n        editor.color = Util.makeHexColor(...color);\n        editor.#opacity = opacity || 1;\n        if (inkLists) {\n            editor.#thickness = data.thickness;\n        }\n        editor.annotationElementId = data.id || null;\n        editor._initialData = initialData;\n        const [pageWidth, pageHeight] = editor.pageDimensions;\n        const [pageX, pageY] = editor.pageTranslation;\n        if (quadPoints) {\n            const boxes = editor.#boxes = [];\n            for(let i = 0; i < quadPoints.length; i += 8){\n                boxes.push({\n                    x: (quadPoints[i] - pageX) / pageWidth,\n                    y: 1 - (quadPoints[i + 1] - pageY) / pageHeight,\n                    width: (quadPoints[i + 2] - quadPoints[i]) / pageWidth,\n                    height: (quadPoints[i + 1] - quadPoints[i + 5]) / pageHeight\n                });\n            }\n            editor.#createOutlines();\n            editor.#addToDrawLayer();\n            editor.rotate(editor.rotation);\n        } else if (inkLists) {\n            editor.#isFreeHighlight = true;\n            const points = inkLists[0];\n            const point = {\n                x: points[0] - pageX,\n                y: pageHeight - (points[1] - pageY)\n            };\n            const outliner = new FreeHighlightOutliner(point, [\n                0,\n                0,\n                pageWidth,\n                pageHeight\n            ], 1, editor.#thickness / 2, true, 0.001);\n            for(let i = 0, ii = points.length; i < ii; i += 2){\n                point.x = points[i] - pageX;\n                point.y = pageHeight - (points[i + 1] - pageY);\n                outliner.add(point);\n            }\n            const { id, clipPathId } = parent.drawLayer.draw({\n                bbox: [\n                    0,\n                    0,\n                    1,\n                    1\n                ],\n                root: {\n                    viewBox: \"0 0 1 1\",\n                    fill: editor.color,\n                    \"fill-opacity\": editor._defaultOpacity\n                },\n                rootClass: {\n                    highlight: true,\n                    free: true\n                },\n                path: {\n                    d: outliner.toSVGPath()\n                }\n            }, true, true);\n            editor.#createFreeOutlines({\n                highlightOutlines: outliner.getOutlines(),\n                highlightId: id,\n                clipPathId\n            });\n            editor.#addToDrawLayer();\n        }\n        return editor;\n    }\n    serialize(isForCopying = false) {\n        if (this.isEmpty() || isForCopying) {\n            return null;\n        }\n        if (this.deleted) {\n            return this.serializeDeleted();\n        }\n        const rect = this.getRect(0, 0);\n        const color = AnnotationEditor._colorManager.convert(this.color);\n        const serialized = {\n            annotationType: AnnotationEditorType.HIGHLIGHT,\n            color,\n            opacity: this.#opacity,\n            thickness: this.#thickness,\n            quadPoints: this.#serializeBoxes(),\n            outlines: this.#serializeOutlines(rect),\n            pageIndex: this.pageIndex,\n            rect,\n            rotation: this.#getRotation(),\n            structTreeParentId: this._structTreeParentId\n        };\n        if (this.annotationElementId && !this.#hasElementChanged(serialized)) {\n            return null;\n        }\n        serialized.id = this.annotationElementId;\n        return serialized;\n    }\n    #hasElementChanged(serialized) {\n        const { color } = this._initialData;\n        return serialized.color.some((c, i)=>c !== color[i]);\n    }\n    renderAnnotationElement(annotation) {\n        annotation.updateEdited({\n            rect: this.getRect(0, 0)\n        });\n        return null;\n    }\n    static canCreateNewEmptyEditor() {\n        return false;\n    }\n}\n; // ./src/display/editor/draw.js\nclass DrawingOptions {\n    #svgProperties;\n    updateProperty(name, value) {\n        this[name] = value;\n        this.updateSVGProperty(name, value);\n    }\n    updateProperties(properties) {\n        if (!properties) {\n            return;\n        }\n        for (const [name, value] of Object.entries(properties)){\n            this.updateProperty(name, value);\n        }\n    }\n    updateSVGProperty(name, value) {\n        this.#svgProperties[name] = value;\n    }\n    toSVGProperties() {\n        const root = this.#svgProperties;\n        this.#svgProperties = Object.create(null);\n        return {\n            root\n        };\n    }\n    reset() {\n        this.#svgProperties = Object.create(null);\n    }\n    updateAll(options = this) {\n        this.updateProperties(options);\n    }\n    clone() {\n        unreachable(\"Not implemented\");\n    }\n    constructor(){\n        this.#svgProperties = Object.create(null);\n    }\n}\nclass DrawingEditor extends AnnotationEditor {\n    #drawOutlines;\n    #mustBeCommitted;\n    static{\n        this._currentDrawId = -1;\n    }\n    static{\n        this._currentDraw = null;\n    }\n    static{\n        this._currentDrawingOptions = null;\n    }\n    static{\n        this._currentParent = null;\n    }\n    static{\n        this._INNER_MARGIN = 3;\n    }\n    constructor(params){\n        super(params);\n        this.#drawOutlines = null;\n        this._drawId = null;\n        this.#mustBeCommitted = params.mustBeCommitted || false;\n        if (params.drawOutlines) {\n            this.#createDrawOutlines(params);\n            this.#addToDrawLayer();\n        }\n    }\n    #createDrawOutlines({ drawOutlines, drawId, drawingOptions }) {\n        this.#drawOutlines = drawOutlines;\n        this._drawingOptions ||= drawingOptions;\n        if (drawId >= 0) {\n            this._drawId = drawId;\n            this.parent.drawLayer.finalizeDraw(drawId, drawOutlines.defaultProperties);\n        } else {\n            this._drawId = this.#createDrawing(drawOutlines, this.parent);\n        }\n        this.#updateBbox(drawOutlines.box);\n    }\n    #createDrawing(drawOutlines, parent) {\n        const { id } = parent.drawLayer.draw(DrawingEditor._mergeSVGProperties(this._drawingOptions.toSVGProperties(), drawOutlines.defaultSVGProperties), false, false);\n        return id;\n    }\n    static _mergeSVGProperties(p1, p2) {\n        const p1Keys = new Set(Object.keys(p1));\n        for (const [key, value] of Object.entries(p2)){\n            if (p1Keys.has(key)) {\n                Object.assign(p1[key], value);\n            } else {\n                p1[key] = value;\n            }\n        }\n        return p1;\n    }\n    static getDefaultDrawingOptions(_options) {\n        unreachable(\"Not implemented\");\n    }\n    static get typesMap() {\n        unreachable(\"Not implemented\");\n    }\n    static get isDrawer() {\n        return true;\n    }\n    static get supportMultipleDrawings() {\n        return false;\n    }\n    static updateDefaultParams(type, value) {\n        const propertyName = this.typesMap.get(type);\n        if (propertyName) {\n            this._defaultDrawingOptions.updateProperty(propertyName, value);\n        }\n        if (this._currentParent) {\n            this._currentDraw.updateProperty(propertyName, value);\n            this._currentParent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties());\n        }\n    }\n    updateParams(type, value) {\n        const propertyName = this.constructor.typesMap.get(type);\n        if (propertyName) {\n            this._updateProperty(type, propertyName, value);\n        }\n    }\n    static get defaultPropertiesToUpdate() {\n        const properties = [];\n        const options = this._defaultDrawingOptions;\n        for (const [type, name] of this.typesMap){\n            properties.push([\n                type,\n                options[name]\n            ]);\n        }\n        return properties;\n    }\n    get propertiesToUpdate() {\n        const properties = [];\n        const { _drawingOptions } = this;\n        for (const [type, name] of this.constructor.typesMap){\n            properties.push([\n                type,\n                _drawingOptions[name]\n            ]);\n        }\n        return properties;\n    }\n    _updateProperty(type, name, value) {\n        const options = this._drawingOptions;\n        const savedValue = options[name];\n        const setter = (val)=>{\n            options.updateProperty(name, val);\n            const bbox = this.#drawOutlines.updateProperty(name, val);\n            if (bbox) {\n                this.#updateBbox(bbox);\n            }\n            this.parent?.drawLayer.updateProperties(this._drawId, options.toSVGProperties());\n        };\n        this.addCommands({\n            cmd: setter.bind(this, value),\n            undo: setter.bind(this, savedValue),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n    }\n    _onResizing() {\n        this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathResizingSVGProperties(this.#convertToDrawSpace()), {\n            bbox: this.#rotateBox()\n        }));\n    }\n    _onResized() {\n        this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathResizedSVGProperties(this.#convertToDrawSpace()), {\n            bbox: this.#rotateBox()\n        }));\n    }\n    _onTranslating(x, y) {\n        this.parent?.drawLayer.updateProperties(this._drawId, {\n            bbox: this.#rotateBox(x, y)\n        });\n    }\n    _onTranslated() {\n        this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathTranslatedSVGProperties(this.#convertToDrawSpace(), this.parentDimensions), {\n            bbox: this.#rotateBox()\n        }));\n    }\n    _onStartDragging() {\n        this.parent?.drawLayer.updateProperties(this._drawId, {\n            rootClass: {\n                moving: true\n            }\n        });\n    }\n    _onStopDragging() {\n        this.parent?.drawLayer.updateProperties(this._drawId, {\n            rootClass: {\n                moving: false\n            }\n        });\n    }\n    commit() {\n        super.commit();\n        this.disableEditMode();\n        this.disableEditing();\n    }\n    disableEditing() {\n        super.disableEditing();\n        this.div.classList.toggle(\"disabled\", true);\n    }\n    enableEditing() {\n        super.enableEditing();\n        this.div.classList.toggle(\"disabled\", false);\n    }\n    getBaseTranslation() {\n        return [\n            0,\n            0\n        ];\n    }\n    get isResizable() {\n        return true;\n    }\n    onceAdded() {\n        if (!this.annotationElementId) {\n            this.parent.addUndoableEditor(this);\n        }\n        this._isDraggable = true;\n        if (this.#mustBeCommitted) {\n            this.#mustBeCommitted = false;\n            this.commit();\n            this.parent.setSelected(this);\n            if (this.isOnScreen) {\n                this.div.focus();\n            }\n        }\n    }\n    remove() {\n        this.#cleanDrawLayer();\n        super.remove();\n    }\n    rebuild() {\n        if (!this.parent) {\n            return;\n        }\n        super.rebuild();\n        if (this.div === null) {\n            return;\n        }\n        this.#addToDrawLayer();\n        this.#updateBbox(this.#drawOutlines.box);\n        if (!this.isAttachedToDOM) {\n            this.parent.add(this);\n        }\n    }\n    setParent(parent) {\n        let mustBeSelected = false;\n        if (this.parent && !parent) {\n            this._uiManager.removeShouldRescale(this);\n            this.#cleanDrawLayer();\n        } else if (parent) {\n            this._uiManager.addShouldRescale(this);\n            this.#addToDrawLayer(parent);\n            mustBeSelected = !this.parent && this.div?.classList.contains(\"selectedEditor\");\n        }\n        super.setParent(parent);\n        if (mustBeSelected) {\n            this.select();\n        }\n    }\n    #cleanDrawLayer() {\n        if (this._drawId === null || !this.parent) {\n            return;\n        }\n        this.parent.drawLayer.remove(this._drawId);\n        this._drawId = null;\n        this._drawingOptions.reset();\n    }\n    #addToDrawLayer(parent = this.parent) {\n        if (this._drawId !== null && this.parent === parent) {\n            return;\n        }\n        if (this._drawId !== null) {\n            this.parent.drawLayer.updateParent(this._drawId, parent.drawLayer);\n            return;\n        }\n        this._drawingOptions.updateAll();\n        this._drawId = this.#createDrawing(this.#drawOutlines, parent);\n    }\n    #convertToParentSpace([x, y, width, height]) {\n        const { parentDimensions: [pW, pH], rotation } = this;\n        switch(rotation){\n            case 90:\n                return [\n                    y,\n                    1 - x,\n                    width * (pH / pW),\n                    height * (pW / pH)\n                ];\n            case 180:\n                return [\n                    1 - x,\n                    1 - y,\n                    width,\n                    height\n                ];\n            case 270:\n                return [\n                    1 - y,\n                    x,\n                    width * (pH / pW),\n                    height * (pW / pH)\n                ];\n            default:\n                return [\n                    x,\n                    y,\n                    width,\n                    height\n                ];\n        }\n    }\n    #convertToDrawSpace() {\n        const { x, y, width, height, parentDimensions: [pW, pH], rotation } = this;\n        switch(rotation){\n            case 90:\n                return [\n                    1 - y,\n                    x,\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            case 180:\n                return [\n                    1 - x,\n                    1 - y,\n                    width,\n                    height\n                ];\n            case 270:\n                return [\n                    y,\n                    1 - x,\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            default:\n                return [\n                    x,\n                    y,\n                    width,\n                    height\n                ];\n        }\n    }\n    #updateBbox(bbox) {\n        [this.x, this.y, this.width, this.height] = this.#convertToParentSpace(bbox);\n        if (this.div) {\n            this.fixAndSetPosition();\n            const [parentWidth, parentHeight] = this.parentDimensions;\n            this.setDims(this.width * parentWidth, this.height * parentHeight);\n        }\n        this._onResized();\n    }\n    #rotateBox() {\n        const { x, y, width, height, rotation, parentRotation, parentDimensions: [pW, pH] } = this;\n        switch((rotation * 4 + parentRotation) / 90){\n            case 1:\n                return [\n                    1 - y - height,\n                    x,\n                    height,\n                    width\n                ];\n            case 2:\n                return [\n                    1 - x - width,\n                    1 - y - height,\n                    width,\n                    height\n                ];\n            case 3:\n                return [\n                    y,\n                    1 - x - width,\n                    height,\n                    width\n                ];\n            case 4:\n                return [\n                    x,\n                    y - width * (pW / pH),\n                    height * (pH / pW),\n                    width * (pW / pH)\n                ];\n            case 5:\n                return [\n                    1 - y,\n                    x,\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            case 6:\n                return [\n                    1 - x - height * (pH / pW),\n                    1 - y,\n                    height * (pH / pW),\n                    width * (pW / pH)\n                ];\n            case 7:\n                return [\n                    y - width * (pW / pH),\n                    1 - x - height * (pH / pW),\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            case 8:\n                return [\n                    x - width,\n                    y - height,\n                    width,\n                    height\n                ];\n            case 9:\n                return [\n                    1 - y,\n                    x - width,\n                    height,\n                    width\n                ];\n            case 10:\n                return [\n                    1 - x,\n                    1 - y,\n                    width,\n                    height\n                ];\n            case 11:\n                return [\n                    y - height,\n                    1 - x,\n                    height,\n                    width\n                ];\n            case 12:\n                return [\n                    x - height * (pH / pW),\n                    y,\n                    height * (pH / pW),\n                    width * (pW / pH)\n                ];\n            case 13:\n                return [\n                    1 - y - width * (pW / pH),\n                    x - height * (pH / pW),\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            case 14:\n                return [\n                    1 - x,\n                    1 - y - width * (pW / pH),\n                    height * (pH / pW),\n                    width * (pW / pH)\n                ];\n            case 15:\n                return [\n                    y,\n                    1 - x,\n                    width * (pW / pH),\n                    height * (pH / pW)\n                ];\n            default:\n                return [\n                    x,\n                    y,\n                    width,\n                    height\n                ];\n        }\n    }\n    rotate() {\n        if (!this.parent) {\n            return;\n        }\n        this.parent.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties({\n            bbox: this.#rotateBox()\n        }, this.#drawOutlines.updateRotation((this.parentRotation - this.rotation + 360) % 360)));\n    }\n    onScaleChanging() {\n        if (!this.parent) {\n            return;\n        }\n        this.#updateBbox(this.#drawOutlines.updateParentDimensions(this.parentDimensions, this.parent.scale));\n    }\n    static onScaleChangingWhenDrawing() {}\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        const div = super.render();\n        div.classList.add(\"draw\");\n        const drawDiv = document.createElement(\"div\");\n        div.append(drawDiv);\n        drawDiv.setAttribute(\"aria-hidden\", \"true\");\n        drawDiv.className = \"internal\";\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.setDims(this.width * parentWidth, this.height * parentHeight);\n        this._uiManager.addShouldRescale(this);\n        this.disableEditing();\n        return div;\n    }\n    static createDrawerInstance(_x, _y, _parentWidth, _parentHeight, _rotation) {\n        unreachable(\"Not implemented\");\n    }\n    static startDrawing(parent, uiManager, _isLTR, { target, offsetX: x, offsetY: y }) {\n        const { viewport: { rotation } } = parent;\n        const { width: parentWidth, height: parentHeight } = target.getBoundingClientRect();\n        const ac = new AbortController();\n        const signal = parent.combinedSignal(ac);\n        window.addEventListener(\"pointerup\", (e)=>{\n            ac.abort();\n            parent.toggleDrawing(true);\n            this._endDraw(e);\n        }, {\n            signal\n        });\n        window.addEventListener(\"pointerdown\", stopEvent, {\n            capture: true,\n            passive: false,\n            signal\n        });\n        window.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        target.addEventListener(\"pointermove\", this._drawMove.bind(this), {\n            signal\n        });\n        parent.toggleDrawing();\n        uiManager._editorUndoBar?.hide();\n        if (this._currentDraw) {\n            parent.drawLayer.updateProperties(this._currentDrawId, this._currentDraw.startNew(x, y, parentWidth, parentHeight, rotation));\n            return;\n        }\n        uiManager.updateUIForDefaultProperties(this);\n        this._currentDraw = this.createDrawerInstance(x, y, parentWidth, parentHeight, rotation);\n        this._currentDrawingOptions = this.getDefaultDrawingOptions();\n        this._currentParent = parent;\n        ({ id: this._currentDrawId } = parent.drawLayer.draw(this._mergeSVGProperties(this._currentDrawingOptions.toSVGProperties(), this._currentDraw.defaultSVGProperties), true, false));\n    }\n    static _drawMove({ offsetX, offsetY }) {\n        this._currentParent.drawLayer.updateProperties(this._currentDrawId, this._currentDraw.add(offsetX, offsetY));\n    }\n    static _endDraw({ offsetX, offsetY }) {\n        const parent = this._currentParent;\n        parent.drawLayer.updateProperties(this._currentDrawId, this._currentDraw.end(offsetX, offsetY));\n        if (this.supportMultipleDrawings) {\n            const draw = this._currentDraw;\n            const drawId = this._currentDrawId;\n            const lastElement = draw.getLastElement();\n            parent.addCommands({\n                cmd: ()=>{\n                    parent.drawLayer.updateProperties(drawId, draw.setLastElement(lastElement));\n                },\n                undo: ()=>{\n                    parent.drawLayer.updateProperties(drawId, draw.removeLastElement());\n                },\n                mustExec: false,\n                type: AnnotationEditorParamsType.DRAW_STEP\n            });\n            return;\n        }\n        this.endDrawing(false);\n    }\n    static endDrawing(isAborted) {\n        const parent = this._currentParent;\n        if (!parent) {\n            return null;\n        }\n        parent.toggleDrawing(true);\n        parent.cleanUndoStack(AnnotationEditorParamsType.DRAW_STEP);\n        if (!this._currentDraw.isEmpty()) {\n            const { pageDimensions: [pageWidth, pageHeight], scale } = parent;\n            const editor = parent.createAndAddNewEditor({\n                offsetX: 0,\n                offsetY: 0\n            }, false, {\n                drawId: this._currentDrawId,\n                drawOutlines: this._currentDraw.getOutlines(pageWidth * scale, pageHeight * scale, scale, this._INNER_MARGIN),\n                drawingOptions: this._currentDrawingOptions,\n                mustBeCommitted: !isAborted\n            });\n            this._cleanup();\n            return editor;\n        }\n        parent.drawLayer.remove(this._currentDrawId);\n        this._cleanup();\n        return null;\n    }\n    static _cleanup() {\n        this._currentDrawId = -1;\n        this._currentDraw = null;\n        this._currentDrawingOptions = null;\n        this._currentParent = null;\n    }\n    createDrawingOptions(_data) {}\n    static deserializeDraw(_pageX, _pageY, _pageWidth, _pageHeight, _innerWidth, _data) {\n        unreachable(\"Not implemented\");\n    }\n    static async deserialize(data, parent, uiManager) {\n        const { rawDims: { pageWidth, pageHeight, pageX, pageY } } = parent.viewport;\n        const drawOutlines = this.deserializeDraw(pageX, pageY, pageWidth, pageHeight, this._INNER_MARGIN, data);\n        const editor = await super.deserialize(data, parent, uiManager);\n        editor.createDrawingOptions(data);\n        editor.#createDrawOutlines({\n            drawOutlines\n        });\n        editor.#addToDrawLayer();\n        editor.onScaleChanging();\n        editor.rotate();\n        return editor;\n    }\n    serializeDraw(isForCopying) {\n        const [pageX, pageY] = this.pageTranslation;\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        return this.#drawOutlines.serialize([\n            pageX,\n            pageY,\n            pageWidth,\n            pageHeight\n        ], isForCopying);\n    }\n    renderAnnotationElement(annotation) {\n        annotation.updateEdited({\n            rect: this.getRect(0, 0)\n        });\n        return null;\n    }\n    static canCreateNewEmptyEditor() {\n        return false;\n    }\n}\n; // ./src/display/editor/drawers/inkdraw.js\nclass InkDrawOutliner {\n    #last;\n    #line;\n    #lines;\n    #rotation;\n    #thickness;\n    #points;\n    #lastSVGPath;\n    #lastIndex;\n    #outlines;\n    #parentWidth;\n    #parentHeight;\n    constructor(x, y, parentWidth, parentHeight, rotation, thickness){\n        this.#last = new Float64Array(6);\n        this.#lastSVGPath = \"\";\n        this.#lastIndex = 0;\n        this.#outlines = new InkDrawOutline();\n        this.#parentWidth = parentWidth;\n        this.#parentHeight = parentHeight;\n        this.#rotation = rotation;\n        this.#thickness = thickness;\n        [x, y] = this.#normalizePoint(x, y);\n        const line = this.#line = [\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            x,\n            y\n        ];\n        this.#points = [\n            x,\n            y\n        ];\n        this.#lines = [\n            {\n                line,\n                points: this.#points\n            }\n        ];\n        this.#last.set(line, 0);\n    }\n    updateProperty(name, value) {\n        if (name === \"stroke-width\") {\n            this.#thickness = value;\n        }\n    }\n    #normalizePoint(x, y) {\n        return Outline._normalizePoint(x, y, this.#parentWidth, this.#parentHeight, this.#rotation);\n    }\n    isEmpty() {\n        return !this.#lines || this.#lines.length === 0;\n    }\n    add(x, y) {\n        [x, y] = this.#normalizePoint(x, y);\n        const [x1, y1, x2, y2] = this.#last.subarray(2, 6);\n        const diffX = x - x2;\n        const diffY = y - y2;\n        const d = Math.hypot(this.#parentWidth * diffX, this.#parentHeight * diffY);\n        if (d <= 2) {\n            return null;\n        }\n        this.#points.push(x, y);\n        if (isNaN(x1)) {\n            this.#last.set([\n                x2,\n                y2,\n                x,\n                y\n            ], 2);\n            this.#line.push(NaN, NaN, NaN, NaN, x, y);\n            return {\n                path: {\n                    d: this.toSVGPath()\n                }\n            };\n        }\n        if (isNaN(this.#last[0])) {\n            this.#line.splice(6, 6);\n        }\n        this.#last.set([\n            x1,\n            y1,\n            x2,\n            y2,\n            x,\n            y\n        ], 0);\n        this.#line.push(...Outline.createBezierPoints(x1, y1, x2, y2, x, y));\n        return {\n            path: {\n                d: this.toSVGPath()\n            }\n        };\n    }\n    end(x, y) {\n        const change = this.add(x, y);\n        if (change) {\n            return change;\n        }\n        if (this.#points.length === 2) {\n            return {\n                path: {\n                    d: this.toSVGPath()\n                }\n            };\n        }\n        return null;\n    }\n    startNew(x, y, parentWidth, parentHeight, rotation) {\n        this.#parentWidth = parentWidth;\n        this.#parentHeight = parentHeight;\n        this.#rotation = rotation;\n        [x, y] = this.#normalizePoint(x, y);\n        const line = this.#line = [\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            x,\n            y\n        ];\n        this.#points = [\n            x,\n            y\n        ];\n        const last = this.#lines.at(-1);\n        if (last) {\n            last.line = new Float32Array(last.line);\n            last.points = new Float32Array(last.points);\n        }\n        this.#lines.push({\n            line,\n            points: this.#points\n        });\n        this.#last.set(line, 0);\n        this.#lastIndex = 0;\n        this.toSVGPath();\n        return null;\n    }\n    getLastElement() {\n        return this.#lines.at(-1);\n    }\n    setLastElement(element) {\n        if (!this.#lines) {\n            return this.#outlines.setLastElement(element);\n        }\n        this.#lines.push(element);\n        this.#line = element.line;\n        this.#points = element.points;\n        this.#lastIndex = 0;\n        return {\n            path: {\n                d: this.toSVGPath()\n            }\n        };\n    }\n    removeLastElement() {\n        if (!this.#lines) {\n            return this.#outlines.removeLastElement();\n        }\n        this.#lines.pop();\n        this.#lastSVGPath = \"\";\n        for(let i = 0, ii = this.#lines.length; i < ii; i++){\n            const { line, points } = this.#lines[i];\n            this.#line = line;\n            this.#points = points;\n            this.#lastIndex = 0;\n            this.toSVGPath();\n        }\n        return {\n            path: {\n                d: this.#lastSVGPath\n            }\n        };\n    }\n    toSVGPath() {\n        const firstX = Outline.svgRound(this.#line[4]);\n        const firstY = Outline.svgRound(this.#line[5]);\n        if (this.#points.length === 2) {\n            this.#lastSVGPath = `${this.#lastSVGPath} M ${firstX} ${firstY} Z`;\n            return this.#lastSVGPath;\n        }\n        if (this.#points.length <= 6) {\n            const i = this.#lastSVGPath.lastIndexOf(\"M\");\n            this.#lastSVGPath = `${this.#lastSVGPath.slice(0, i)} M ${firstX} ${firstY}`;\n            this.#lastIndex = 6;\n        }\n        if (this.#points.length === 4) {\n            const secondX = Outline.svgRound(this.#line[10]);\n            const secondY = Outline.svgRound(this.#line[11]);\n            this.#lastSVGPath = `${this.#lastSVGPath} L ${secondX} ${secondY}`;\n            this.#lastIndex = 12;\n            return this.#lastSVGPath;\n        }\n        const buffer = [];\n        if (this.#lastIndex === 0) {\n            buffer.push(`M ${firstX} ${firstY}`);\n            this.#lastIndex = 6;\n        }\n        for(let i = this.#lastIndex, ii = this.#line.length; i < ii; i += 6){\n            const [c1x, c1y, c2x, c2y, x, y] = this.#line.slice(i, i + 6).map(Outline.svgRound);\n            buffer.push(`C${c1x} ${c1y} ${c2x} ${c2y} ${x} ${y}`);\n        }\n        this.#lastSVGPath += buffer.join(\" \");\n        this.#lastIndex = this.#line.length;\n        return this.#lastSVGPath;\n    }\n    getOutlines(parentWidth, parentHeight, scale, innerMargin) {\n        const last = this.#lines.at(-1);\n        last.line = new Float32Array(last.line);\n        last.points = new Float32Array(last.points);\n        this.#outlines.build(this.#lines, parentWidth, parentHeight, scale, this.#rotation, this.#thickness, innerMargin);\n        this.#last = null;\n        this.#line = null;\n        this.#lines = null;\n        this.#lastSVGPath = null;\n        return this.#outlines;\n    }\n    get defaultSVGProperties() {\n        return {\n            root: {\n                viewBox: \"0 0 10000 10000\"\n            },\n            rootClass: {\n                draw: true\n            },\n            bbox: [\n                0,\n                0,\n                1,\n                1\n            ]\n        };\n    }\n}\nclass InkDrawOutline extends Outline {\n    #bbox;\n    #currentRotation;\n    #innerMargin;\n    #lines;\n    #parentWidth;\n    #parentHeight;\n    #parentScale;\n    #rotation;\n    #thickness;\n    build(lines, parentWidth, parentHeight, parentScale, rotation, thickness, innerMargin) {\n        this.#parentWidth = parentWidth;\n        this.#parentHeight = parentHeight;\n        this.#parentScale = parentScale;\n        this.#rotation = rotation;\n        this.#thickness = thickness;\n        this.#innerMargin = innerMargin ?? 0;\n        this.#lines = lines;\n        this.#computeBbox();\n    }\n    setLastElement(element) {\n        this.#lines.push(element);\n        return {\n            path: {\n                d: this.toSVGPath()\n            }\n        };\n    }\n    removeLastElement() {\n        this.#lines.pop();\n        return {\n            path: {\n                d: this.toSVGPath()\n            }\n        };\n    }\n    toSVGPath() {\n        const buffer = [];\n        for (const { line } of this.#lines){\n            buffer.push(`M${Outline.svgRound(line[4])} ${Outline.svgRound(line[5])}`);\n            if (line.length === 6) {\n                buffer.push(\"Z\");\n                continue;\n            }\n            if (line.length === 12) {\n                buffer.push(`L${Outline.svgRound(line[10])} ${Outline.svgRound(line[11])}`);\n                continue;\n            }\n            for(let i = 6, ii = line.length; i < ii; i += 6){\n                const [c1x, c1y, c2x, c2y, x, y] = line.subarray(i, i + 6).map(Outline.svgRound);\n                buffer.push(`C${c1x} ${c1y} ${c2x} ${c2y} ${x} ${y}`);\n            }\n        }\n        return buffer.join(\"\");\n    }\n    serialize([pageX, pageY, pageWidth, pageHeight], isForCopying) {\n        const serializedLines = [];\n        const serializedPoints = [];\n        const [x, y, width, height] = this.#getBBoxWithNoMargin();\n        let tx, ty, sx, sy, x1, y1, x2, y2, rescaleFn;\n        switch(this.#rotation){\n            case 0:\n                rescaleFn = Outline._rescale;\n                tx = pageX;\n                ty = pageY + pageHeight;\n                sx = pageWidth;\n                sy = -pageHeight;\n                x1 = pageX + x * pageWidth;\n                y1 = pageY + (1 - y - height) * pageHeight;\n                x2 = pageX + (x + width) * pageWidth;\n                y2 = pageY + (1 - y) * pageHeight;\n                break;\n            case 90:\n                rescaleFn = Outline._rescaleAndSwap;\n                tx = pageX;\n                ty = pageY;\n                sx = pageWidth;\n                sy = pageHeight;\n                x1 = pageX + y * pageWidth;\n                y1 = pageY + x * pageHeight;\n                x2 = pageX + (y + height) * pageWidth;\n                y2 = pageY + (x + width) * pageHeight;\n                break;\n            case 180:\n                rescaleFn = Outline._rescale;\n                tx = pageX + pageWidth;\n                ty = pageY;\n                sx = -pageWidth;\n                sy = pageHeight;\n                x1 = pageX + (1 - x - width) * pageWidth;\n                y1 = pageY + y * pageHeight;\n                x2 = pageX + (1 - x) * pageWidth;\n                y2 = pageY + (y + height) * pageHeight;\n                break;\n            case 270:\n                rescaleFn = Outline._rescaleAndSwap;\n                tx = pageX + pageWidth;\n                ty = pageY + pageHeight;\n                sx = -pageWidth;\n                sy = -pageHeight;\n                x1 = pageX + (1 - y - height) * pageWidth;\n                y1 = pageY + (1 - x - width) * pageHeight;\n                x2 = pageX + (1 - y) * pageWidth;\n                y2 = pageY + (1 - x) * pageHeight;\n                break;\n        }\n        for (const { line, points } of this.#lines){\n            serializedLines.push(rescaleFn(line, tx, ty, sx, sy, isForCopying ? new Array(line.length) : null));\n            serializedPoints.push(rescaleFn(points, tx, ty, sx, sy, isForCopying ? new Array(points.length) : null));\n        }\n        return {\n            lines: serializedLines,\n            points: serializedPoints,\n            rect: [\n                x1,\n                y1,\n                x2,\n                y2\n            ]\n        };\n    }\n    static deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, { paths: { lines, points }, rotation, thickness }) {\n        const newLines = [];\n        let tx, ty, sx, sy, rescaleFn;\n        switch(rotation){\n            case 0:\n                rescaleFn = Outline._rescale;\n                tx = -pageX / pageWidth;\n                ty = pageY / pageHeight + 1;\n                sx = 1 / pageWidth;\n                sy = -1 / pageHeight;\n                break;\n            case 90:\n                rescaleFn = Outline._rescaleAndSwap;\n                tx = -pageY / pageHeight;\n                ty = -pageX / pageWidth;\n                sx = 1 / pageHeight;\n                sy = 1 / pageWidth;\n                break;\n            case 180:\n                rescaleFn = Outline._rescale;\n                tx = pageX / pageWidth + 1;\n                ty = -pageY / pageHeight;\n                sx = -1 / pageWidth;\n                sy = 1 / pageHeight;\n                break;\n            case 270:\n                rescaleFn = Outline._rescaleAndSwap;\n                tx = pageY / pageHeight + 1;\n                ty = pageX / pageWidth + 1;\n                sx = -1 / pageHeight;\n                sy = -1 / pageWidth;\n                break;\n        }\n        if (!lines) {\n            lines = [];\n            for (const point of points){\n                const len = point.length;\n                if (len === 2) {\n                    lines.push(new Float32Array([\n                        NaN,\n                        NaN,\n                        NaN,\n                        NaN,\n                        point[0],\n                        point[1]\n                    ]));\n                    continue;\n                }\n                if (len === 4) {\n                    lines.push(new Float32Array([\n                        NaN,\n                        NaN,\n                        NaN,\n                        NaN,\n                        point[0],\n                        point[1],\n                        NaN,\n                        NaN,\n                        NaN,\n                        NaN,\n                        point[2],\n                        point[3]\n                    ]));\n                    continue;\n                }\n                const line = new Float32Array(3 * (len - 2));\n                lines.push(line);\n                let [x1, y1, x2, y2] = point.subarray(0, 4);\n                line.set([\n                    NaN,\n                    NaN,\n                    NaN,\n                    NaN,\n                    x1,\n                    y1\n                ], 0);\n                for(let i = 4; i < len; i += 2){\n                    const x = point[i];\n                    const y = point[i + 1];\n                    line.set(Outline.createBezierPoints(x1, y1, x2, y2, x, y), (i - 2) * 3);\n                    [x1, y1, x2, y2] = [\n                        x2,\n                        y2,\n                        x,\n                        y\n                    ];\n                }\n            }\n        }\n        for(let i = 0, ii = lines.length; i < ii; i++){\n            newLines.push({\n                line: rescaleFn(lines[i].map((x)=>x ?? NaN), tx, ty, sx, sy),\n                points: rescaleFn(points[i].map((x)=>x ?? NaN), tx, ty, sx, sy)\n            });\n        }\n        const outlines = new InkDrawOutline();\n        outlines.build(newLines, pageWidth, pageHeight, 1, rotation, thickness, innerMargin);\n        return outlines;\n    }\n    #getMarginComponents(thickness = this.#thickness) {\n        const margin = this.#innerMargin + thickness / 2 * this.#parentScale;\n        return this.#rotation % 180 === 0 ? [\n            margin / this.#parentWidth,\n            margin / this.#parentHeight\n        ] : [\n            margin / this.#parentHeight,\n            margin / this.#parentWidth\n        ];\n    }\n    #getBBoxWithNoMargin() {\n        const [x, y, width, height] = this.#bbox;\n        const [marginX, marginY] = this.#getMarginComponents(0);\n        return [\n            x + marginX,\n            y + marginY,\n            width - 2 * marginX,\n            height - 2 * marginY\n        ];\n    }\n    #computeBbox() {\n        const bbox = this.#bbox = new Float32Array([\n            Infinity,\n            Infinity,\n            -Infinity,\n            -Infinity\n        ]);\n        for (const { line } of this.#lines){\n            if (line.length <= 12) {\n                for(let i = 4, ii = line.length; i < ii; i += 6){\n                    const [x, y] = line.subarray(i, i + 2);\n                    bbox[0] = Math.min(bbox[0], x);\n                    bbox[1] = Math.min(bbox[1], y);\n                    bbox[2] = Math.max(bbox[2], x);\n                    bbox[3] = Math.max(bbox[3], y);\n                }\n                continue;\n            }\n            let lastX = line[4], lastY = line[5];\n            for(let i = 6, ii = line.length; i < ii; i += 6){\n                const [c1x, c1y, c2x, c2y, x, y] = line.subarray(i, i + 6);\n                Util.bezierBoundingBox(lastX, lastY, c1x, c1y, c2x, c2y, x, y, bbox);\n                lastX = x;\n                lastY = y;\n            }\n        }\n        const [marginX, marginY] = this.#getMarginComponents();\n        bbox[0] = Math.min(1, Math.max(0, bbox[0] - marginX));\n        bbox[1] = Math.min(1, Math.max(0, bbox[1] - marginY));\n        bbox[2] = Math.min(1, Math.max(0, bbox[2] + marginX));\n        bbox[3] = Math.min(1, Math.max(0, bbox[3] + marginY));\n        bbox[2] -= bbox[0];\n        bbox[3] -= bbox[1];\n    }\n    get box() {\n        return this.#bbox;\n    }\n    updateProperty(name, value) {\n        if (name === \"stroke-width\") {\n            return this.#updateThickness(value);\n        }\n        return null;\n    }\n    #updateThickness(thickness) {\n        const [oldMarginX, oldMarginY] = this.#getMarginComponents();\n        this.#thickness = thickness;\n        const [newMarginX, newMarginY] = this.#getMarginComponents();\n        const [diffMarginX, diffMarginY] = [\n            newMarginX - oldMarginX,\n            newMarginY - oldMarginY\n        ];\n        const bbox = this.#bbox;\n        bbox[0] -= diffMarginX;\n        bbox[1] -= diffMarginY;\n        bbox[2] += 2 * diffMarginX;\n        bbox[3] += 2 * diffMarginY;\n        return bbox;\n    }\n    updateParentDimensions([width, height], scale) {\n        const [oldMarginX, oldMarginY] = this.#getMarginComponents();\n        this.#parentWidth = width;\n        this.#parentHeight = height;\n        this.#parentScale = scale;\n        const [newMarginX, newMarginY] = this.#getMarginComponents();\n        const diffMarginX = newMarginX - oldMarginX;\n        const diffMarginY = newMarginY - oldMarginY;\n        const bbox = this.#bbox;\n        bbox[0] -= diffMarginX;\n        bbox[1] -= diffMarginY;\n        bbox[2] += 2 * diffMarginX;\n        bbox[3] += 2 * diffMarginY;\n        return bbox;\n    }\n    updateRotation(rotation) {\n        this.#currentRotation = rotation;\n        return {\n            path: {\n                transform: this.rotationTransform\n            }\n        };\n    }\n    get viewBox() {\n        return this.#bbox.map(Outline.svgRound).join(\" \");\n    }\n    get defaultProperties() {\n        const [x, y] = this.#bbox;\n        return {\n            root: {\n                viewBox: this.viewBox\n            },\n            path: {\n                \"transform-origin\": `${Outline.svgRound(x)} ${Outline.svgRound(y)}`\n            }\n        };\n    }\n    get rotationTransform() {\n        const [, , width, height] = this.#bbox;\n        let a = 0, b = 0, c = 0, d = 0, e = 0, f = 0;\n        switch(this.#currentRotation){\n            case 90:\n                b = height / width;\n                c = -width / height;\n                e = width;\n                break;\n            case 180:\n                a = -1;\n                d = -1;\n                e = width;\n                f = height;\n                break;\n            case 270:\n                b = -height / width;\n                c = width / height;\n                f = height;\n                break;\n            default:\n                return \"\";\n        }\n        return `matrix(${a} ${b} ${c} ${d} ${Outline.svgRound(e)} ${Outline.svgRound(f)})`;\n    }\n    getPathResizingSVGProperties([newX, newY, newWidth, newHeight]) {\n        const [marginX, marginY] = this.#getMarginComponents();\n        const [x, y, width, height] = this.#bbox;\n        if (Math.abs(width - marginX) <= Outline.PRECISION || Math.abs(height - marginY) <= Outline.PRECISION) {\n            const tx = newX + newWidth / 2 - (x + width / 2);\n            const ty = newY + newHeight / 2 - (y + height / 2);\n            return {\n                path: {\n                    \"transform-origin\": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,\n                    transform: `${this.rotationTransform} translate(${tx} ${ty})`\n                }\n            };\n        }\n        const s1x = (newWidth - 2 * marginX) / (width - 2 * marginX);\n        const s1y = (newHeight - 2 * marginY) / (height - 2 * marginY);\n        const s2x = width / newWidth;\n        const s2y = height / newHeight;\n        return {\n            path: {\n                \"transform-origin\": `${Outline.svgRound(x)} ${Outline.svgRound(y)}`,\n                transform: `${this.rotationTransform} scale(${s2x} ${s2y}) ` + `translate(${Outline.svgRound(marginX)} ${Outline.svgRound(marginY)}) scale(${s1x} ${s1y}) ` + `translate(${Outline.svgRound(-marginX)} ${Outline.svgRound(-marginY)})`\n            }\n        };\n    }\n    getPathResizedSVGProperties([newX, newY, newWidth, newHeight]) {\n        const [marginX, marginY] = this.#getMarginComponents();\n        const bbox = this.#bbox;\n        const [x, y, width, height] = bbox;\n        bbox[0] = newX;\n        bbox[1] = newY;\n        bbox[2] = newWidth;\n        bbox[3] = newHeight;\n        if (Math.abs(width - marginX) <= Outline.PRECISION || Math.abs(height - marginY) <= Outline.PRECISION) {\n            const tx = newX + newWidth / 2 - (x + width / 2);\n            const ty = newY + newHeight / 2 - (y + height / 2);\n            for (const { line, points } of this.#lines){\n                Outline._translate(line, tx, ty, line);\n                Outline._translate(points, tx, ty, points);\n            }\n            return {\n                root: {\n                    viewBox: this.viewBox\n                },\n                path: {\n                    \"transform-origin\": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,\n                    transform: this.rotationTransform || null,\n                    d: this.toSVGPath()\n                }\n            };\n        }\n        const s1x = (newWidth - 2 * marginX) / (width - 2 * marginX);\n        const s1y = (newHeight - 2 * marginY) / (height - 2 * marginY);\n        const tx = -s1x * (x + marginX) + newX + marginX;\n        const ty = -s1y * (y + marginY) + newY + marginY;\n        if (s1x !== 1 || s1y !== 1 || tx !== 0 || ty !== 0) {\n            for (const { line, points } of this.#lines){\n                Outline._rescale(line, tx, ty, s1x, s1y, line);\n                Outline._rescale(points, tx, ty, s1x, s1y, points);\n            }\n        }\n        return {\n            root: {\n                viewBox: this.viewBox\n            },\n            path: {\n                \"transform-origin\": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,\n                transform: this.rotationTransform || null,\n                d: this.toSVGPath()\n            }\n        };\n    }\n    getPathTranslatedSVGProperties([newX, newY], parentDimensions) {\n        const [newParentWidth, newParentHeight] = parentDimensions;\n        const bbox = this.#bbox;\n        const tx = newX - bbox[0];\n        const ty = newY - bbox[1];\n        if (this.#parentWidth === newParentWidth && this.#parentHeight === newParentHeight) {\n            for (const { line, points } of this.#lines){\n                Outline._translate(line, tx, ty, line);\n                Outline._translate(points, tx, ty, points);\n            }\n        } else {\n            const sx = this.#parentWidth / newParentWidth;\n            const sy = this.#parentHeight / newParentHeight;\n            this.#parentWidth = newParentWidth;\n            this.#parentHeight = newParentHeight;\n            for (const { line, points } of this.#lines){\n                Outline._rescale(line, tx, ty, sx, sy, line);\n                Outline._rescale(points, tx, ty, sx, sy, points);\n            }\n            bbox[2] *= sx;\n            bbox[3] *= sy;\n        }\n        bbox[0] = newX;\n        bbox[1] = newY;\n        return {\n            root: {\n                viewBox: this.viewBox\n            },\n            path: {\n                d: this.toSVGPath(),\n                \"transform-origin\": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`\n            }\n        };\n    }\n    get defaultSVGProperties() {\n        const bbox = this.#bbox;\n        return {\n            root: {\n                viewBox: this.viewBox\n            },\n            rootClass: {\n                draw: true\n            },\n            path: {\n                d: this.toSVGPath(),\n                \"transform-origin\": `${Outline.svgRound(bbox[0])} ${Outline.svgRound(bbox[1])}`,\n                transform: this.rotationTransform || null\n            },\n            bbox\n        };\n    }\n    constructor(...args){\n        super(...args);\n        this.#currentRotation = 0;\n    }\n}\n; // ./src/display/editor/ink.js\nclass InkDrawingOptions extends DrawingOptions {\n    #viewParameters;\n    constructor(viewerParameters){\n        super();\n        this.#viewParameters = viewerParameters;\n        super.updateProperties({\n            fill: \"none\",\n            stroke: AnnotationEditor._defaultLineColor,\n            \"stroke-opacity\": 1,\n            \"stroke-width\": 1,\n            \"stroke-linecap\": \"round\",\n            \"stroke-linejoin\": \"round\",\n            \"stroke-miterlimit\": 10\n        });\n    }\n    updateSVGProperty(name, value) {\n        if (name === \"stroke-width\") {\n            value ??= this[\"stroke-width\"];\n            value *= this.#viewParameters.realScale;\n        }\n        super.updateSVGProperty(name, value);\n    }\n    clone() {\n        const clone = new InkDrawingOptions(this.#viewParameters);\n        clone.updateAll(this);\n        return clone;\n    }\n}\nclass InkEditor extends DrawingEditor {\n    static{\n        this._type = \"ink\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.INK;\n    }\n    static{\n        this._defaultDrawingOptions = null;\n    }\n    constructor(params){\n        super({\n            ...params,\n            name: \"inkEditor\"\n        });\n        this._willKeepAspectRatio = true;\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n        this._defaultDrawingOptions = new InkDrawingOptions(uiManager.viewParameters);\n    }\n    static getDefaultDrawingOptions(options) {\n        const clone = this._defaultDrawingOptions.clone();\n        clone.updateProperties(options);\n        return clone;\n    }\n    static get supportMultipleDrawings() {\n        return true;\n    }\n    static get typesMap() {\n        return shadow(this, \"typesMap\", new Map([\n            [\n                AnnotationEditorParamsType.INK_THICKNESS,\n                \"stroke-width\"\n            ],\n            [\n                AnnotationEditorParamsType.INK_COLOR,\n                \"stroke\"\n            ],\n            [\n                AnnotationEditorParamsType.INK_OPACITY,\n                \"stroke-opacity\"\n            ]\n        ]));\n    }\n    static createDrawerInstance(x, y, parentWidth, parentHeight, rotation) {\n        return new InkDrawOutliner(x, y, parentWidth, parentHeight, rotation, this._defaultDrawingOptions[\"stroke-width\"]);\n    }\n    static deserializeDraw(pageX, pageY, pageWidth, pageHeight, innerMargin, data) {\n        return InkDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);\n    }\n    static async deserialize(data, parent, uiManager) {\n        let initialData = null;\n        if (data instanceof InkAnnotationElement) {\n            const { data: { inkLists, rect, rotation, id, color, opacity, borderStyle: { rawWidth: thickness }, popupRef }, parent: { page: { pageNumber } } } = data;\n            initialData = data = {\n                annotationType: AnnotationEditorType.INK,\n                color: Array.from(color),\n                thickness,\n                opacity,\n                paths: {\n                    points: inkLists\n                },\n                boxes: null,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                id,\n                deleted: false,\n                popupRef\n            };\n        }\n        const editor = await super.deserialize(data, parent, uiManager);\n        editor.annotationElementId = data.id || null;\n        editor._initialData = initialData;\n        return editor;\n    }\n    onScaleChanging() {\n        if (!this.parent) {\n            return;\n        }\n        super.onScaleChanging();\n        const { _drawId, _drawingOptions, parent } = this;\n        _drawingOptions.updateSVGProperty(\"stroke-width\");\n        parent.drawLayer.updateProperties(_drawId, _drawingOptions.toSVGProperties());\n    }\n    static onScaleChangingWhenDrawing() {\n        const parent = this._currentParent;\n        if (!parent) {\n            return;\n        }\n        super.onScaleChangingWhenDrawing();\n        this._defaultDrawingOptions.updateSVGProperty(\"stroke-width\");\n        parent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties());\n    }\n    createDrawingOptions({ color, thickness, opacity }) {\n        this._drawingOptions = InkEditor.getDefaultDrawingOptions({\n            stroke: Util.makeHexColor(...color),\n            \"stroke-width\": thickness,\n            \"stroke-opacity\": opacity\n        });\n    }\n    serialize(isForCopying = false) {\n        if (this.isEmpty()) {\n            return null;\n        }\n        if (this.deleted) {\n            return this.serializeDeleted();\n        }\n        const { lines, points, rect } = this.serializeDraw(isForCopying);\n        const { _drawingOptions: { stroke, \"stroke-opacity\": opacity, \"stroke-width\": thickness } } = this;\n        const serialized = {\n            annotationType: AnnotationEditorType.INK,\n            color: AnnotationEditor._colorManager.convert(stroke),\n            opacity,\n            thickness,\n            paths: {\n                lines,\n                points\n            },\n            pageIndex: this.pageIndex,\n            rect,\n            rotation: this.rotation,\n            structTreeParentId: this._structTreeParentId\n        };\n        if (isForCopying) {\n            return serialized;\n        }\n        if (this.annotationElementId && !this.#hasElementChanged(serialized)) {\n            return null;\n        }\n        serialized.id = this.annotationElementId;\n        return serialized;\n    }\n    #hasElementChanged(serialized) {\n        const { color, thickness, opacity, pageIndex } = this._initialData;\n        return this._hasBeenMoved || this._hasBeenResized || serialized.color.some((c, i)=>c !== color[i]) || serialized.thickness !== thickness || serialized.opacity !== opacity || serialized.pageIndex !== pageIndex;\n    }\n    renderAnnotationElement(annotation) {\n        const { points, rect } = this.serializeDraw(false);\n        annotation.updateEdited({\n            rect,\n            thickness: this._drawingOptions[\"stroke-width\"],\n            points\n        });\n        return null;\n    }\n}\n; // ./src/display/editor/stamp.js\nclass StampEditor extends AnnotationEditor {\n    #bitmap;\n    #bitmapId;\n    #bitmapPromise;\n    #bitmapUrl;\n    #bitmapFile;\n    #bitmapFileName;\n    #canvas;\n    #observer;\n    #resizeTimeoutId;\n    #isSvg;\n    #hasBeenAddedInUndoStack;\n    static{\n        this._type = \"stamp\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.STAMP;\n    }\n    constructor(params){\n        super({\n            ...params,\n            name: \"stampEditor\"\n        });\n        this.#bitmap = null;\n        this.#bitmapId = null;\n        this.#bitmapPromise = null;\n        this.#bitmapUrl = null;\n        this.#bitmapFile = null;\n        this.#bitmapFileName = \"\";\n        this.#canvas = null;\n        this.#observer = null;\n        this.#resizeTimeoutId = null;\n        this.#isSvg = false;\n        this.#hasBeenAddedInUndoStack = false;\n        this.#bitmapUrl = params.bitmapUrl;\n        this.#bitmapFile = params.bitmapFile;\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n    }\n    static get supportedTypes() {\n        const types = [\n            \"apng\",\n            \"avif\",\n            \"bmp\",\n            \"gif\",\n            \"jpeg\",\n            \"png\",\n            \"svg+xml\",\n            \"webp\",\n            \"x-icon\"\n        ];\n        return shadow(this, \"supportedTypes\", types.map((type)=>`image/${type}`));\n    }\n    static get supportedTypesStr() {\n        return shadow(this, \"supportedTypesStr\", this.supportedTypes.join(\",\"));\n    }\n    static isHandlingMimeForPasting(mime) {\n        return this.supportedTypes.includes(mime);\n    }\n    static paste(item, parent) {\n        parent.pasteEditor(AnnotationEditorType.STAMP, {\n            bitmapFile: item.getAsFile()\n        });\n    }\n    altTextFinish() {\n        if (this._uiManager.useNewAltTextFlow) {\n            this.div.hidden = false;\n        }\n        super.altTextFinish();\n    }\n    get telemetryFinalData() {\n        return {\n            type: \"stamp\",\n            hasAltText: !!this.altTextData?.altText\n        };\n    }\n    static computeTelemetryFinalData(data) {\n        const hasAltTextStats = data.get(\"hasAltText\");\n        return {\n            hasAltText: hasAltTextStats.get(true) ?? 0,\n            hasNoAltText: hasAltTextStats.get(false) ?? 0\n        };\n    }\n    #getBitmapFetched(data, fromId = false) {\n        if (!data) {\n            this.remove();\n            return;\n        }\n        this.#bitmap = data.bitmap;\n        if (!fromId) {\n            this.#bitmapId = data.id;\n            this.#isSvg = data.isSvg;\n        }\n        if (data.file) {\n            this.#bitmapFileName = data.file.name;\n        }\n        this.#createCanvas();\n    }\n    #getBitmapDone() {\n        this.#bitmapPromise = null;\n        this._uiManager.enableWaiting(false);\n        if (!this.#canvas) {\n            return;\n        }\n        if (this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#bitmap) {\n            this._editToolbar.hide();\n            this._uiManager.editAltText(this, true);\n            return;\n        }\n        if (!this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#bitmap) {\n            this._reportTelemetry({\n                action: \"pdfjs.image.image_added\",\n                data: {\n                    alt_text_modal: false,\n                    alt_text_type: \"empty\"\n                }\n            });\n            try {\n                this.mlGuessAltText();\n            } catch  {}\n        }\n        this.div.focus();\n    }\n    async mlGuessAltText(imageData = null, updateAltTextData = true) {\n        if (this.hasAltTextData()) {\n            return null;\n        }\n        const { mlManager } = this._uiManager;\n        if (!mlManager) {\n            throw new Error(\"No ML.\");\n        }\n        if (!await mlManager.isEnabledFor(\"altText\")) {\n            throw new Error(\"ML isn't enabled for alt text.\");\n        }\n        const { data, width, height } = imageData || this.copyCanvas(null, null, true).imageData;\n        const response = await mlManager.guess({\n            name: \"altText\",\n            request: {\n                data,\n                width,\n                height,\n                channels: data.length / (width * height)\n            }\n        });\n        if (!response) {\n            throw new Error(\"No response from the AI service.\");\n        }\n        if (response.error) {\n            throw new Error(\"Error from the AI service.\");\n        }\n        if (response.cancel) {\n            return null;\n        }\n        if (!response.output) {\n            throw new Error(\"No valid response from the AI service.\");\n        }\n        const altText = response.output;\n        await this.setGuessedAltText(altText);\n        if (updateAltTextData && !this.hasAltTextData()) {\n            this.altTextData = {\n                alt: altText,\n                decorative: false\n            };\n        }\n        return altText;\n    }\n    #getBitmap() {\n        if (this.#bitmapId) {\n            this._uiManager.enableWaiting(true);\n            this._uiManager.imageManager.getFromId(this.#bitmapId).then((data)=>this.#getBitmapFetched(data, true)).finally(()=>this.#getBitmapDone());\n            return;\n        }\n        if (this.#bitmapUrl) {\n            const url = this.#bitmapUrl;\n            this.#bitmapUrl = null;\n            this._uiManager.enableWaiting(true);\n            this.#bitmapPromise = this._uiManager.imageManager.getFromUrl(url).then((data)=>this.#getBitmapFetched(data)).finally(()=>this.#getBitmapDone());\n            return;\n        }\n        if (this.#bitmapFile) {\n            const file = this.#bitmapFile;\n            this.#bitmapFile = null;\n            this._uiManager.enableWaiting(true);\n            this.#bitmapPromise = this._uiManager.imageManager.getFromFile(file).then((data)=>this.#getBitmapFetched(data)).finally(()=>this.#getBitmapDone());\n            return;\n        }\n        const input = document.createElement(\"input\");\n        input.type = \"file\";\n        input.accept = StampEditor.supportedTypesStr;\n        const signal = this._uiManager._signal;\n        this.#bitmapPromise = new Promise((resolve)=>{\n            input.addEventListener(\"change\", async ()=>{\n                if (!input.files || input.files.length === 0) {\n                    this.remove();\n                } else {\n                    this._uiManager.enableWaiting(true);\n                    const data = await this._uiManager.imageManager.getFromFile(input.files[0]);\n                    this._reportTelemetry({\n                        action: \"pdfjs.image.image_selected\",\n                        data: {\n                            alt_text_modal: this._uiManager.useNewAltTextFlow\n                        }\n                    });\n                    this.#getBitmapFetched(data);\n                }\n                resolve();\n            }, {\n                signal\n            });\n            input.addEventListener(\"cancel\", ()=>{\n                this.remove();\n                resolve();\n            }, {\n                signal\n            });\n        }).finally(()=>this.#getBitmapDone());\n        input.click();\n    }\n    remove() {\n        if (this.#bitmapId) {\n            this.#bitmap = null;\n            this._uiManager.imageManager.deleteId(this.#bitmapId);\n            this.#canvas?.remove();\n            this.#canvas = null;\n            this.#observer?.disconnect();\n            this.#observer = null;\n            if (this.#resizeTimeoutId) {\n                clearTimeout(this.#resizeTimeoutId);\n                this.#resizeTimeoutId = null;\n            }\n        }\n        super.remove();\n    }\n    rebuild() {\n        if (!this.parent) {\n            if (this.#bitmapId) {\n                this.#getBitmap();\n            }\n            return;\n        }\n        super.rebuild();\n        if (this.div === null) {\n            return;\n        }\n        if (this.#bitmapId && this.#canvas === null) {\n            this.#getBitmap();\n        }\n        if (!this.isAttachedToDOM) {\n            this.parent.add(this);\n        }\n    }\n    onceAdded() {\n        this._isDraggable = true;\n        this.div.focus();\n    }\n    isEmpty() {\n        return !(this.#bitmapPromise || this.#bitmap || this.#bitmapUrl || this.#bitmapFile || this.#bitmapId);\n    }\n    get isResizable() {\n        return true;\n    }\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        let baseX, baseY;\n        if (this.width) {\n            baseX = this.x;\n            baseY = this.y;\n        }\n        super.render();\n        this.div.hidden = true;\n        this.div.setAttribute(\"role\", \"figure\");\n        this.addAltTextButton();\n        if (this.#bitmap) {\n            this.#createCanvas();\n        } else {\n            this.#getBitmap();\n        }\n        if (this.width && !this.annotationElementId) {\n            const [parentWidth, parentHeight] = this.parentDimensions;\n            this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n        }\n        return this.div;\n    }\n    #createCanvas() {\n        const { div } = this;\n        let { width, height } = this.#bitmap;\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        const MAX_RATIO = 0.75;\n        if (this.width) {\n            width = this.width * pageWidth;\n            height = this.height * pageHeight;\n        } else if (width > MAX_RATIO * pageWidth || height > MAX_RATIO * pageHeight) {\n            const factor = Math.min(MAX_RATIO * pageWidth / width, MAX_RATIO * pageHeight / height);\n            width *= factor;\n            height *= factor;\n        }\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.setDims(width * parentWidth / pageWidth, height * parentHeight / pageHeight);\n        this._uiManager.enableWaiting(false);\n        const canvas = this.#canvas = document.createElement(\"canvas\");\n        canvas.setAttribute(\"role\", \"img\");\n        this.addContainer(canvas);\n        if (!this._uiManager.useNewAltTextWhenAddingImage || !this._uiManager.useNewAltTextFlow || this.annotationElementId) {\n            div.hidden = false;\n        }\n        this.#drawBitmap(width, height);\n        this.#createObserver();\n        if (!this.#hasBeenAddedInUndoStack) {\n            this.parent.addUndoableEditor(this);\n            this.#hasBeenAddedInUndoStack = true;\n        }\n        this._reportTelemetry({\n            action: \"inserted_image\"\n        });\n        if (this.#bitmapFileName) {\n            canvas.setAttribute(\"aria-label\", this.#bitmapFileName);\n        }\n    }\n    copyCanvas(maxDataDimension, maxPreviewDimension, createImageData = false) {\n        if (!maxDataDimension) {\n            maxDataDimension = 224;\n        }\n        const { width: bitmapWidth, height: bitmapHeight } = this.#bitmap;\n        const outputScale = new OutputScale();\n        let bitmap = this.#bitmap;\n        let width = bitmapWidth, height = bitmapHeight;\n        let canvas = null;\n        if (maxPreviewDimension) {\n            if (bitmapWidth > maxPreviewDimension || bitmapHeight > maxPreviewDimension) {\n                const ratio = Math.min(maxPreviewDimension / bitmapWidth, maxPreviewDimension / bitmapHeight);\n                width = Math.floor(bitmapWidth * ratio);\n                height = Math.floor(bitmapHeight * ratio);\n            }\n            canvas = document.createElement(\"canvas\");\n            const scaledWidth = canvas.width = Math.ceil(width * outputScale.sx);\n            const scaledHeight = canvas.height = Math.ceil(height * outputScale.sy);\n            if (!this.#isSvg) {\n                bitmap = this.#scaleBitmap(scaledWidth, scaledHeight);\n            }\n            const ctx = canvas.getContext(\"2d\");\n            ctx.filter = this._uiManager.hcmFilter;\n            let white = \"white\", black = \"#cfcfd8\";\n            if (this._uiManager.hcmFilter !== \"none\") {\n                black = \"black\";\n            } else if (window.matchMedia?.(\"(prefers-color-scheme: dark)\").matches) {\n                white = \"#8f8f9d\";\n                black = \"#42414d\";\n            }\n            const boxDim = 15;\n            const boxDimWidth = boxDim * outputScale.sx;\n            const boxDimHeight = boxDim * outputScale.sy;\n            const pattern = new OffscreenCanvas(boxDimWidth * 2, boxDimHeight * 2);\n            const patternCtx = pattern.getContext(\"2d\");\n            patternCtx.fillStyle = white;\n            patternCtx.fillRect(0, 0, boxDimWidth * 2, boxDimHeight * 2);\n            patternCtx.fillStyle = black;\n            patternCtx.fillRect(0, 0, boxDimWidth, boxDimHeight);\n            patternCtx.fillRect(boxDimWidth, boxDimHeight, boxDimWidth, boxDimHeight);\n            ctx.fillStyle = ctx.createPattern(pattern, \"repeat\");\n            ctx.fillRect(0, 0, scaledWidth, scaledHeight);\n            ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, scaledWidth, scaledHeight);\n        }\n        let imageData = null;\n        if (createImageData) {\n            let dataWidth, dataHeight;\n            if (outputScale.symmetric && bitmap.width < maxDataDimension && bitmap.height < maxDataDimension) {\n                dataWidth = bitmap.width;\n                dataHeight = bitmap.height;\n            } else {\n                bitmap = this.#bitmap;\n                if (bitmapWidth > maxDataDimension || bitmapHeight > maxDataDimension) {\n                    const ratio = Math.min(maxDataDimension / bitmapWidth, maxDataDimension / bitmapHeight);\n                    dataWidth = Math.floor(bitmapWidth * ratio);\n                    dataHeight = Math.floor(bitmapHeight * ratio);\n                    if (!this.#isSvg) {\n                        bitmap = this.#scaleBitmap(dataWidth, dataHeight);\n                    }\n                }\n            }\n            const offscreen = new OffscreenCanvas(dataWidth, dataHeight);\n            const offscreenCtx = offscreen.getContext(\"2d\", {\n                willReadFrequently: true\n            });\n            offscreenCtx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, dataWidth, dataHeight);\n            imageData = {\n                width: dataWidth,\n                height: dataHeight,\n                data: offscreenCtx.getImageData(0, 0, dataWidth, dataHeight).data\n            };\n        }\n        return {\n            canvas,\n            width,\n            height,\n            imageData\n        };\n    }\n    #setDimensions(width, height) {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.width = width / parentWidth;\n        this.height = height / parentHeight;\n        if (this._initialOptions?.isCentered) {\n            this.center();\n        } else {\n            this.fixAndSetPosition();\n        }\n        this._initialOptions = null;\n        if (this.#resizeTimeoutId !== null) {\n            clearTimeout(this.#resizeTimeoutId);\n        }\n        const TIME_TO_WAIT = 200;\n        this.#resizeTimeoutId = setTimeout(()=>{\n            this.#resizeTimeoutId = null;\n            this.#drawBitmap(width, height);\n        }, TIME_TO_WAIT);\n    }\n    #scaleBitmap(width, height) {\n        const { width: bitmapWidth, height: bitmapHeight } = this.#bitmap;\n        let newWidth = bitmapWidth;\n        let newHeight = bitmapHeight;\n        let bitmap = this.#bitmap;\n        while(newWidth > 2 * width || newHeight > 2 * height){\n            const prevWidth = newWidth;\n            const prevHeight = newHeight;\n            if (newWidth > 2 * width) {\n                newWidth = newWidth >= 16384 ? Math.floor(newWidth / 2) - 1 : Math.ceil(newWidth / 2);\n            }\n            if (newHeight > 2 * height) {\n                newHeight = newHeight >= 16384 ? Math.floor(newHeight / 2) - 1 : Math.ceil(newHeight / 2);\n            }\n            const offscreen = new OffscreenCanvas(newWidth, newHeight);\n            const ctx = offscreen.getContext(\"2d\");\n            ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);\n            bitmap = offscreen.transferToImageBitmap();\n        }\n        return bitmap;\n    }\n    #drawBitmap(width, height) {\n        const outputScale = new OutputScale();\n        const scaledWidth = Math.ceil(width * outputScale.sx);\n        const scaledHeight = Math.ceil(height * outputScale.sy);\n        const canvas = this.#canvas;\n        if (!canvas || canvas.width === scaledWidth && canvas.height === scaledHeight) {\n            return;\n        }\n        canvas.width = scaledWidth;\n        canvas.height = scaledHeight;\n        const bitmap = this.#isSvg ? this.#bitmap : this.#scaleBitmap(scaledWidth, scaledHeight);\n        const ctx = canvas.getContext(\"2d\");\n        ctx.filter = this._uiManager.hcmFilter;\n        ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, scaledWidth, scaledHeight);\n    }\n    getImageForAltText() {\n        return this.#canvas;\n    }\n    #serializeBitmap(toUrl) {\n        if (toUrl) {\n            if (this.#isSvg) {\n                const url = this._uiManager.imageManager.getSvgUrl(this.#bitmapId);\n                if (url) {\n                    return url;\n                }\n            }\n            const canvas = document.createElement(\"canvas\");\n            ({ width: canvas.width, height: canvas.height } = this.#bitmap);\n            const ctx = canvas.getContext(\"2d\");\n            ctx.drawImage(this.#bitmap, 0, 0);\n            return canvas.toDataURL();\n        }\n        if (this.#isSvg) {\n            const [pageWidth, pageHeight] = this.pageDimensions;\n            const width = Math.round(this.width * pageWidth * PixelsPerInch.PDF_TO_CSS_UNITS);\n            const height = Math.round(this.height * pageHeight * PixelsPerInch.PDF_TO_CSS_UNITS);\n            const offscreen = new OffscreenCanvas(width, height);\n            const ctx = offscreen.getContext(\"2d\");\n            ctx.drawImage(this.#bitmap, 0, 0, this.#bitmap.width, this.#bitmap.height, 0, 0, width, height);\n            return offscreen.transferToImageBitmap();\n        }\n        return structuredClone(this.#bitmap);\n    }\n    #createObserver() {\n        if (!this._uiManager._signal) {\n            return;\n        }\n        this.#observer = new ResizeObserver((entries)=>{\n            const rect = entries[0].contentRect;\n            if (rect.width && rect.height) {\n                this.#setDimensions(rect.width, rect.height);\n            }\n        });\n        this.#observer.observe(this.div);\n        this._uiManager._signal.addEventListener(\"abort\", ()=>{\n            this.#observer?.disconnect();\n            this.#observer = null;\n        }, {\n            once: true\n        });\n    }\n    static async deserialize(data, parent, uiManager) {\n        let initialData = null;\n        if (data instanceof StampAnnotationElement) {\n            const { data: { rect, rotation, id, structParent, popupRef }, container, parent: { page: { pageNumber } } } = data;\n            const canvas = container.querySelector(\"canvas\");\n            const imageData = uiManager.imageManager.getFromCanvas(container.id, canvas);\n            canvas.remove();\n            const altText = (await parent._structTree.getAriaAttributes(`${AnnotationPrefix}${id}`))?.get(\"aria-label\") || \"\";\n            initialData = data = {\n                annotationType: AnnotationEditorType.STAMP,\n                bitmapId: imageData.id,\n                bitmap: imageData.bitmap,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                id,\n                deleted: false,\n                accessibilityData: {\n                    decorative: false,\n                    altText\n                },\n                isSvg: false,\n                structParent,\n                popupRef\n            };\n        }\n        const editor = await super.deserialize(data, parent, uiManager);\n        const { rect, bitmap, bitmapUrl, bitmapId, isSvg, accessibilityData } = data;\n        if (bitmapId && uiManager.imageManager.isValidId(bitmapId)) {\n            editor.#bitmapId = bitmapId;\n            if (bitmap) {\n                editor.#bitmap = bitmap;\n            }\n        } else {\n            editor.#bitmapUrl = bitmapUrl;\n        }\n        editor.#isSvg = isSvg;\n        const [parentWidth, parentHeight] = editor.pageDimensions;\n        editor.width = (rect[2] - rect[0]) / parentWidth;\n        editor.height = (rect[3] - rect[1]) / parentHeight;\n        editor.annotationElementId = data.id || null;\n        if (accessibilityData) {\n            editor.altTextData = accessibilityData;\n        }\n        editor._initialData = initialData;\n        editor.#hasBeenAddedInUndoStack = !!initialData;\n        return editor;\n    }\n    serialize(isForCopying = false, context = null) {\n        if (this.isEmpty()) {\n            return null;\n        }\n        if (this.deleted) {\n            return this.serializeDeleted();\n        }\n        const serialized = {\n            annotationType: AnnotationEditorType.STAMP,\n            bitmapId: this.#bitmapId,\n            pageIndex: this.pageIndex,\n            rect: this.getRect(0, 0),\n            rotation: this.rotation,\n            isSvg: this.#isSvg,\n            structTreeParentId: this._structTreeParentId\n        };\n        if (isForCopying) {\n            serialized.bitmapUrl = this.#serializeBitmap(true);\n            serialized.accessibilityData = this.serializeAltText(true);\n            return serialized;\n        }\n        const { decorative, altText } = this.serializeAltText(false);\n        if (!decorative && altText) {\n            serialized.accessibilityData = {\n                type: \"Figure\",\n                alt: altText\n            };\n        }\n        if (this.annotationElementId) {\n            const changes = this.#hasElementChanged(serialized);\n            if (changes.isSame) {\n                return null;\n            }\n            if (changes.isSameAltText) {\n                delete serialized.accessibilityData;\n            } else {\n                serialized.accessibilityData.structParent = this._initialData.structParent ?? -1;\n            }\n        }\n        serialized.id = this.annotationElementId;\n        if (context === null) {\n            return serialized;\n        }\n        context.stamps ||= new Map();\n        const area = this.#isSvg ? (serialized.rect[2] - serialized.rect[0]) * (serialized.rect[3] - serialized.rect[1]) : null;\n        if (!context.stamps.has(this.#bitmapId)) {\n            context.stamps.set(this.#bitmapId, {\n                area,\n                serialized\n            });\n            serialized.bitmap = this.#serializeBitmap(false);\n        } else if (this.#isSvg) {\n            const prevData = context.stamps.get(this.#bitmapId);\n            if (area > prevData.area) {\n                prevData.area = area;\n                prevData.serialized.bitmap.close();\n                prevData.serialized.bitmap = this.#serializeBitmap(false);\n            }\n        }\n        return serialized;\n    }\n    #hasElementChanged(serialized) {\n        const { pageIndex, accessibilityData: { altText } } = this._initialData;\n        const isSamePageIndex = serialized.pageIndex === pageIndex;\n        const isSameAltText = (serialized.accessibilityData?.alt || \"\") === altText;\n        return {\n            isSame: !this._hasBeenMoved && !this._hasBeenResized && isSamePageIndex && isSameAltText,\n            isSameAltText\n        };\n    }\n    renderAnnotationElement(annotation) {\n        annotation.updateEdited({\n            rect: this.getRect(0, 0)\n        });\n        return null;\n    }\n}\n; // ./src/display/editor/annotation_editor_layer.js\nclass AnnotationEditorLayer {\n    #accessibilityManager;\n    #allowClick;\n    #annotationLayer;\n    #clickAC;\n    #editorFocusTimeoutId;\n    #editors;\n    #hadPointerDown;\n    #isDisabling;\n    #drawingAC;\n    #textLayer;\n    #textSelectionAC;\n    #uiManager;\n    static{\n        this._initialized = false;\n    }\n    static #editorTypes = new Map([\n        FreeTextEditor,\n        InkEditor,\n        StampEditor,\n        HighlightEditor\n    ].map((type)=>[\n            type._editorType,\n            type\n        ]));\n    constructor({ uiManager, pageIndex, div, structTreeLayer, accessibilityManager, annotationLayer, drawLayer, textLayer, viewport, l10n }){\n        this.#allowClick = false;\n        this.#annotationLayer = null;\n        this.#clickAC = null;\n        this.#editorFocusTimeoutId = null;\n        this.#editors = new Map();\n        this.#hadPointerDown = false;\n        this.#isDisabling = false;\n        this.#drawingAC = null;\n        this.#textLayer = null;\n        this.#textSelectionAC = null;\n        const editorTypes = [\n            ...AnnotationEditorLayer.#editorTypes.values()\n        ];\n        if (!AnnotationEditorLayer._initialized) {\n            AnnotationEditorLayer._initialized = true;\n            for (const editorType of editorTypes){\n                editorType.initialize(l10n, uiManager);\n            }\n        }\n        uiManager.registerEditorTypes(editorTypes);\n        this.#uiManager = uiManager;\n        this.pageIndex = pageIndex;\n        this.div = div;\n        this.#accessibilityManager = accessibilityManager;\n        this.#annotationLayer = annotationLayer;\n        this.viewport = viewport;\n        this.#textLayer = textLayer;\n        this.drawLayer = drawLayer;\n        this._structTree = structTreeLayer;\n        this.#uiManager.addLayer(this);\n    }\n    get isEmpty() {\n        return this.#editors.size === 0;\n    }\n    get isInvisible() {\n        return this.isEmpty && this.#uiManager.getMode() === AnnotationEditorType.NONE;\n    }\n    updateToolbar(mode) {\n        this.#uiManager.updateToolbar(mode);\n    }\n    updateMode(mode = this.#uiManager.getMode()) {\n        this.#cleanup();\n        switch(mode){\n            case AnnotationEditorType.NONE:\n                this.disableTextSelection();\n                this.togglePointerEvents(false);\n                this.toggleAnnotationLayerPointerEvents(true);\n                this.disableClick();\n                return;\n            case AnnotationEditorType.INK:\n                this.disableTextSelection();\n                this.togglePointerEvents(true);\n                this.enableClick();\n                break;\n            case AnnotationEditorType.HIGHLIGHT:\n                this.enableTextSelection();\n                this.togglePointerEvents(false);\n                this.disableClick();\n                break;\n            default:\n                this.disableTextSelection();\n                this.togglePointerEvents(true);\n                this.enableClick();\n        }\n        this.toggleAnnotationLayerPointerEvents(false);\n        const { classList } = this.div;\n        for (const editorType of AnnotationEditorLayer.#editorTypes.values()){\n            classList.toggle(`${editorType._type}Editing`, mode === editorType._editorType);\n        }\n        this.div.hidden = false;\n    }\n    hasTextLayer(textLayer) {\n        return textLayer === this.#textLayer?.div;\n    }\n    setEditingState(isEditing) {\n        this.#uiManager.setEditingState(isEditing);\n    }\n    addCommands(params) {\n        this.#uiManager.addCommands(params);\n    }\n    cleanUndoStack(type) {\n        this.#uiManager.cleanUndoStack(type);\n    }\n    toggleDrawing(enabled = false) {\n        this.div.classList.toggle(\"drawing\", !enabled);\n    }\n    togglePointerEvents(enabled = false) {\n        this.div.classList.toggle(\"disabled\", !enabled);\n    }\n    toggleAnnotationLayerPointerEvents(enabled = false) {\n        this.#annotationLayer?.div.classList.toggle(\"disabled\", !enabled);\n    }\n    async enable() {\n        this.div.tabIndex = 0;\n        this.togglePointerEvents(true);\n        const annotationElementIds = new Set();\n        for (const editor of this.#editors.values()){\n            editor.enableEditing();\n            editor.show(true);\n            if (editor.annotationElementId) {\n                this.#uiManager.removeChangedExistingAnnotation(editor);\n                annotationElementIds.add(editor.annotationElementId);\n            }\n        }\n        if (!this.#annotationLayer) {\n            return;\n        }\n        const editables = this.#annotationLayer.getEditableAnnotations();\n        for (const editable of editables){\n            editable.hide();\n            if (this.#uiManager.isDeletedAnnotationElement(editable.data.id)) {\n                continue;\n            }\n            if (annotationElementIds.has(editable.data.id)) {\n                continue;\n            }\n            const editor = await this.deserialize(editable);\n            if (!editor) {\n                continue;\n            }\n            this.addOrRebuild(editor);\n            editor.enableEditing();\n        }\n    }\n    disable() {\n        this.#isDisabling = true;\n        this.div.tabIndex = -1;\n        this.togglePointerEvents(false);\n        const changedAnnotations = new Map();\n        const resetAnnotations = new Map();\n        for (const editor of this.#editors.values()){\n            editor.disableEditing();\n            if (!editor.annotationElementId) {\n                continue;\n            }\n            if (editor.serialize() !== null) {\n                changedAnnotations.set(editor.annotationElementId, editor);\n                continue;\n            } else {\n                resetAnnotations.set(editor.annotationElementId, editor);\n            }\n            this.getEditableAnnotation(editor.annotationElementId)?.show();\n            editor.remove();\n        }\n        if (this.#annotationLayer) {\n            const editables = this.#annotationLayer.getEditableAnnotations();\n            for (const editable of editables){\n                const { id } = editable.data;\n                if (this.#uiManager.isDeletedAnnotationElement(id)) {\n                    continue;\n                }\n                let editor = resetAnnotations.get(id);\n                if (editor) {\n                    editor.resetAnnotationElement(editable);\n                    editor.show(false);\n                    editable.show();\n                    continue;\n                }\n                editor = changedAnnotations.get(id);\n                if (editor) {\n                    this.#uiManager.addChangedExistingAnnotation(editor);\n                    if (editor.renderAnnotationElement(editable)) {\n                        editor.show(false);\n                    }\n                }\n                editable.show();\n            }\n        }\n        this.#cleanup();\n        if (this.isEmpty) {\n            this.div.hidden = true;\n        }\n        const { classList } = this.div;\n        for (const editorType of AnnotationEditorLayer.#editorTypes.values()){\n            classList.remove(`${editorType._type}Editing`);\n        }\n        this.disableTextSelection();\n        this.toggleAnnotationLayerPointerEvents(true);\n        this.#isDisabling = false;\n    }\n    getEditableAnnotation(id) {\n        return this.#annotationLayer?.getEditableAnnotation(id) || null;\n    }\n    setActiveEditor(editor) {\n        const currentActive = this.#uiManager.getActive();\n        if (currentActive === editor) {\n            return;\n        }\n        this.#uiManager.setActiveEditor(editor);\n    }\n    enableTextSelection() {\n        this.div.tabIndex = -1;\n        if (this.#textLayer?.div && !this.#textSelectionAC) {\n            this.#textSelectionAC = new AbortController();\n            const signal = this.#uiManager.combinedSignal(this.#textSelectionAC);\n            this.#textLayer.div.addEventListener(\"pointerdown\", this.#textLayerPointerDown.bind(this), {\n                signal\n            });\n            this.#textLayer.div.classList.add(\"highlighting\");\n        }\n    }\n    disableTextSelection() {\n        this.div.tabIndex = 0;\n        if (this.#textLayer?.div && this.#textSelectionAC) {\n            this.#textSelectionAC.abort();\n            this.#textSelectionAC = null;\n            this.#textLayer.div.classList.remove(\"highlighting\");\n        }\n    }\n    #textLayerPointerDown(event) {\n        this.#uiManager.unselectAll();\n        const { target } = event;\n        if (target === this.#textLayer.div || (target.getAttribute(\"role\") === \"img\" || target.classList.contains(\"endOfContent\")) && this.#textLayer.div.contains(target)) {\n            const { isMac } = util_FeatureTest.platform;\n            if (event.button !== 0 || event.ctrlKey && isMac) {\n                return;\n            }\n            this.#uiManager.showAllEditors(\"highlight\", true, true);\n            this.#textLayer.div.classList.add(\"free\");\n            this.toggleDrawing();\n            HighlightEditor.startHighlighting(this, this.#uiManager.direction === \"ltr\", {\n                target: this.#textLayer.div,\n                x: event.x,\n                y: event.y\n            });\n            this.#textLayer.div.addEventListener(\"pointerup\", ()=>{\n                this.#textLayer.div.classList.remove(\"free\");\n                this.toggleDrawing(true);\n            }, {\n                once: true,\n                signal: this.#uiManager._signal\n            });\n            event.preventDefault();\n        }\n    }\n    enableClick() {\n        if (this.#clickAC) {\n            return;\n        }\n        this.#clickAC = new AbortController();\n        const signal = this.#uiManager.combinedSignal(this.#clickAC);\n        this.div.addEventListener(\"pointerdown\", this.pointerdown.bind(this), {\n            signal\n        });\n        this.div.addEventListener(\"pointerup\", this.pointerup.bind(this), {\n            signal\n        });\n    }\n    disableClick() {\n        this.#clickAC?.abort();\n        this.#clickAC = null;\n    }\n    attach(editor) {\n        this.#editors.set(editor.id, editor);\n        const { annotationElementId } = editor;\n        if (annotationElementId && this.#uiManager.isDeletedAnnotationElement(annotationElementId)) {\n            this.#uiManager.removeDeletedAnnotationElement(editor);\n        }\n    }\n    detach(editor) {\n        this.#editors.delete(editor.id);\n        this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);\n        if (!this.#isDisabling && editor.annotationElementId) {\n            this.#uiManager.addDeletedAnnotationElement(editor);\n        }\n    }\n    remove(editor) {\n        this.detach(editor);\n        this.#uiManager.removeEditor(editor);\n        editor.div.remove();\n        editor.isAttachedToDOM = false;\n    }\n    changeParent(editor) {\n        if (editor.parent === this) {\n            return;\n        }\n        if (editor.parent && editor.annotationElementId) {\n            this.#uiManager.addDeletedAnnotationElement(editor.annotationElementId);\n            AnnotationEditor.deleteAnnotationElement(editor);\n            editor.annotationElementId = null;\n        }\n        this.attach(editor);\n        editor.parent?.detach(editor);\n        editor.setParent(this);\n        if (editor.div && editor.isAttachedToDOM) {\n            editor.div.remove();\n            this.div.append(editor.div);\n        }\n    }\n    add(editor) {\n        if (editor.parent === this && editor.isAttachedToDOM) {\n            return;\n        }\n        this.changeParent(editor);\n        this.#uiManager.addEditor(editor);\n        this.attach(editor);\n        if (!editor.isAttachedToDOM) {\n            const div = editor.render();\n            this.div.append(div);\n            editor.isAttachedToDOM = true;\n        }\n        editor.fixAndSetPosition();\n        editor.onceAdded();\n        this.#uiManager.addToAnnotationStorage(editor);\n        editor._reportTelemetry(editor.telemetryInitialData);\n    }\n    moveEditorInDOM(editor) {\n        if (!editor.isAttachedToDOM) {\n            return;\n        }\n        const { activeElement } = document;\n        if (editor.div.contains(activeElement) && !this.#editorFocusTimeoutId) {\n            editor._focusEventsAllowed = false;\n            this.#editorFocusTimeoutId = setTimeout(()=>{\n                this.#editorFocusTimeoutId = null;\n                if (!editor.div.contains(document.activeElement)) {\n                    editor.div.addEventListener(\"focusin\", ()=>{\n                        editor._focusEventsAllowed = true;\n                    }, {\n                        once: true,\n                        signal: this.#uiManager._signal\n                    });\n                    activeElement.focus();\n                } else {\n                    editor._focusEventsAllowed = true;\n                }\n            }, 0);\n        }\n        editor._structTreeParentId = this.#accessibilityManager?.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);\n    }\n    addOrRebuild(editor) {\n        if (editor.needsToBeRebuilt()) {\n            editor.parent ||= this;\n            editor.rebuild();\n            editor.show();\n        } else {\n            this.add(editor);\n        }\n    }\n    addUndoableEditor(editor) {\n        const cmd = ()=>editor._uiManager.rebuild(editor);\n        const undo = ()=>{\n            editor.remove();\n        };\n        this.addCommands({\n            cmd,\n            undo,\n            mustExec: false\n        });\n    }\n    getNextId() {\n        return this.#uiManager.getId();\n    }\n    get #currentEditorType() {\n        return AnnotationEditorLayer.#editorTypes.get(this.#uiManager.getMode());\n    }\n    combinedSignal(ac) {\n        return this.#uiManager.combinedSignal(ac);\n    }\n    #createNewEditor(params) {\n        const editorType = this.#currentEditorType;\n        return editorType ? new editorType.prototype.constructor(params) : null;\n    }\n    canCreateNewEmptyEditor() {\n        return this.#currentEditorType?.canCreateNewEmptyEditor();\n    }\n    pasteEditor(mode, params) {\n        this.#uiManager.updateToolbar(mode);\n        this.#uiManager.updateMode(mode);\n        const { offsetX, offsetY } = this.#getCenterPoint();\n        const id = this.getNextId();\n        const editor = this.#createNewEditor({\n            parent: this,\n            id,\n            x: offsetX,\n            y: offsetY,\n            uiManager: this.#uiManager,\n            isCentered: true,\n            ...params\n        });\n        if (editor) {\n            this.add(editor);\n        }\n    }\n    async deserialize(data) {\n        return await AnnotationEditorLayer.#editorTypes.get(data.annotationType ?? data.annotationEditorType)?.deserialize(data, this, this.#uiManager) || null;\n    }\n    createAndAddNewEditor(event, isCentered, data = {}) {\n        const id = this.getNextId();\n        const editor = this.#createNewEditor({\n            parent: this,\n            id,\n            x: event.offsetX,\n            y: event.offsetY,\n            uiManager: this.#uiManager,\n            isCentered,\n            ...data\n        });\n        if (editor) {\n            this.add(editor);\n        }\n        return editor;\n    }\n    #getCenterPoint() {\n        const { x, y, width, height } = this.div.getBoundingClientRect();\n        const tlX = Math.max(0, x);\n        const tlY = Math.max(0, y);\n        const brX = Math.min(window.innerWidth, x + width);\n        const brY = Math.min(window.innerHeight, y + height);\n        const centerX = (tlX + brX) / 2 - x;\n        const centerY = (tlY + brY) / 2 - y;\n        const [offsetX, offsetY] = this.viewport.rotation % 180 === 0 ? [\n            centerX,\n            centerY\n        ] : [\n            centerY,\n            centerX\n        ];\n        return {\n            offsetX,\n            offsetY\n        };\n    }\n    addNewEditor() {\n        this.createAndAddNewEditor(this.#getCenterPoint(), true);\n    }\n    setSelected(editor) {\n        this.#uiManager.setSelected(editor);\n    }\n    toggleSelected(editor) {\n        this.#uiManager.toggleSelected(editor);\n    }\n    unselect(editor) {\n        this.#uiManager.unselect(editor);\n    }\n    pointerup(event) {\n        const { isMac } = util_FeatureTest.platform;\n        if (event.button !== 0 || event.ctrlKey && isMac) {\n            return;\n        }\n        if (event.target !== this.div) {\n            return;\n        }\n        if (!this.#hadPointerDown) {\n            return;\n        }\n        this.#hadPointerDown = false;\n        if (this.#currentEditorType?.isDrawer && this.#currentEditorType.supportMultipleDrawings) {\n            return;\n        }\n        if (!this.#allowClick) {\n            this.#allowClick = true;\n            return;\n        }\n        if (this.#uiManager.getMode() === AnnotationEditorType.STAMP) {\n            this.#uiManager.unselectAll();\n            return;\n        }\n        this.createAndAddNewEditor(event, false);\n    }\n    pointerdown(event) {\n        if (this.#uiManager.getMode() === AnnotationEditorType.HIGHLIGHT) {\n            this.enableTextSelection();\n        }\n        if (this.#hadPointerDown) {\n            this.#hadPointerDown = false;\n            return;\n        }\n        const { isMac } = util_FeatureTest.platform;\n        if (event.button !== 0 || event.ctrlKey && isMac) {\n            return;\n        }\n        if (event.target !== this.div) {\n            return;\n        }\n        this.#hadPointerDown = true;\n        if (this.#currentEditorType?.isDrawer) {\n            this.startDrawingSession(event);\n            return;\n        }\n        const editor = this.#uiManager.getActive();\n        this.#allowClick = !editor || editor.isEmpty();\n    }\n    startDrawingSession(event) {\n        this.div.focus();\n        if (this.#drawingAC) {\n            this.#currentEditorType.startDrawing(this, this.#uiManager, false, event);\n            return;\n        }\n        this.#uiManager.setCurrentDrawingSession(this);\n        this.#drawingAC = new AbortController();\n        const signal = this.#uiManager.combinedSignal(this.#drawingAC);\n        this.div.addEventListener(\"blur\", ({ relatedTarget })=>{\n            if (relatedTarget && !this.div.contains(relatedTarget)) {\n                this.commitOrRemove();\n            }\n        }, {\n            signal\n        });\n        this.#currentEditorType.startDrawing(this, this.#uiManager, false, event);\n    }\n    endDrawingSession(isAborted = false) {\n        if (!this.#drawingAC) {\n            return null;\n        }\n        this.#uiManager.setCurrentDrawingSession(null);\n        this.#drawingAC.abort();\n        this.#drawingAC = null;\n        return this.#currentEditorType.endDrawing(isAborted);\n    }\n    findNewParent(editor, x, y) {\n        const layer = this.#uiManager.findParent(x, y);\n        if (layer === null || layer === this) {\n            return false;\n        }\n        layer.changeParent(editor);\n        return true;\n    }\n    commitOrRemove() {\n        if (this.#drawingAC) {\n            this.endDrawingSession();\n            return true;\n        }\n        return false;\n    }\n    onScaleChanging() {\n        if (!this.#drawingAC) {\n            return;\n        }\n        this.#currentEditorType.onScaleChangingWhenDrawing(this);\n    }\n    destroy() {\n        this.commitOrRemove();\n        if (this.#uiManager.getActive()?.parent === this) {\n            this.#uiManager.commitOrRemove();\n            this.#uiManager.setActiveEditor(null);\n        }\n        if (this.#editorFocusTimeoutId) {\n            clearTimeout(this.#editorFocusTimeoutId);\n            this.#editorFocusTimeoutId = null;\n        }\n        for (const editor of this.#editors.values()){\n            this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);\n            editor.setParent(null);\n            editor.isAttachedToDOM = false;\n            editor.div.remove();\n        }\n        this.div = null;\n        this.#editors.clear();\n        this.#uiManager.removeLayer(this);\n    }\n    #cleanup() {\n        for (const editor of this.#editors.values()){\n            if (editor.isEmpty()) {\n                editor.remove();\n            }\n        }\n    }\n    render({ viewport }) {\n        this.viewport = viewport;\n        setLayerDimensions(this.div, viewport);\n        for (const editor of this.#uiManager.getEditors(this.pageIndex)){\n            this.add(editor);\n            editor.rebuild();\n        }\n        this.updateMode();\n    }\n    update({ viewport }) {\n        this.#uiManager.commitOrRemove();\n        this.#cleanup();\n        const oldRotation = this.viewport.rotation;\n        const rotation = viewport.rotation;\n        this.viewport = viewport;\n        setLayerDimensions(this.div, {\n            rotation\n        });\n        if (oldRotation !== rotation) {\n            for (const editor of this.#editors.values()){\n                editor.rotate(rotation);\n            }\n        }\n    }\n    get pageDimensions() {\n        const { pageWidth, pageHeight } = this.viewport.rawDims;\n        return [\n            pageWidth,\n            pageHeight\n        ];\n    }\n    get scale() {\n        return this.#uiManager.viewParameters.realScale;\n    }\n}\n; // ./src/display/draw_layer.js\nclass DrawLayer {\n    #parent;\n    #id;\n    #mapping;\n    #toUpdate;\n    constructor({ pageIndex }){\n        this.#parent = null;\n        this.#id = 0;\n        this.#mapping = new Map();\n        this.#toUpdate = new Map();\n        this.pageIndex = pageIndex;\n    }\n    setParent(parent) {\n        if (!this.#parent) {\n            this.#parent = parent;\n            return;\n        }\n        if (this.#parent !== parent) {\n            if (this.#mapping.size > 0) {\n                for (const root of this.#mapping.values()){\n                    root.remove();\n                    parent.append(root);\n                }\n            }\n            this.#parent = parent;\n        }\n    }\n    static get _svgFactory() {\n        return shadow(this, \"_svgFactory\", new DOMSVGFactory());\n    }\n    static #setBox(element, [x, y, width, height]) {\n        const { style } = element;\n        style.top = `${100 * y}%`;\n        style.left = `${100 * x}%`;\n        style.width = `${100 * width}%`;\n        style.height = `${100 * height}%`;\n    }\n    #createSVG() {\n        const svg = DrawLayer._svgFactory.create(1, 1, true);\n        this.#parent.append(svg);\n        svg.setAttribute(\"aria-hidden\", true);\n        return svg;\n    }\n    #createClipPath(defs, pathId) {\n        const clipPath = DrawLayer._svgFactory.createElement(\"clipPath\");\n        defs.append(clipPath);\n        const clipPathId = `clip_${pathId}`;\n        clipPath.setAttribute(\"id\", clipPathId);\n        clipPath.setAttribute(\"clipPathUnits\", \"objectBoundingBox\");\n        const clipPathUse = DrawLayer._svgFactory.createElement(\"use\");\n        clipPath.append(clipPathUse);\n        clipPathUse.setAttribute(\"href\", `#${pathId}`);\n        clipPathUse.classList.add(\"clip\");\n        return clipPathId;\n    }\n    #updateProperties(element, properties) {\n        for (const [key, value] of Object.entries(properties)){\n            if (value === null) {\n                element.removeAttribute(key);\n            } else {\n                element.setAttribute(key, value);\n            }\n        }\n    }\n    draw(properties, isPathUpdatable = false, hasClip = false) {\n        const id = this.#id++;\n        const root = this.#createSVG();\n        const defs = DrawLayer._svgFactory.createElement(\"defs\");\n        root.append(defs);\n        const path = DrawLayer._svgFactory.createElement(\"path\");\n        defs.append(path);\n        const pathId = `path_p${this.pageIndex}_${id}`;\n        path.setAttribute(\"id\", pathId);\n        path.setAttribute(\"vector-effect\", \"non-scaling-stroke\");\n        if (isPathUpdatable) {\n            this.#toUpdate.set(id, path);\n        }\n        const clipPathId = hasClip ? this.#createClipPath(defs, pathId) : null;\n        const use = DrawLayer._svgFactory.createElement(\"use\");\n        root.append(use);\n        use.setAttribute(\"href\", `#${pathId}`);\n        this.updateProperties(root, properties);\n        this.#mapping.set(id, root);\n        return {\n            id,\n            clipPathId: `url(#${clipPathId})`\n        };\n    }\n    drawOutline(properties, mustRemoveSelfIntersections) {\n        const id = this.#id++;\n        const root = this.#createSVG();\n        const defs = DrawLayer._svgFactory.createElement(\"defs\");\n        root.append(defs);\n        const path = DrawLayer._svgFactory.createElement(\"path\");\n        defs.append(path);\n        const pathId = `path_p${this.pageIndex}_${id}`;\n        path.setAttribute(\"id\", pathId);\n        path.setAttribute(\"vector-effect\", \"non-scaling-stroke\");\n        let maskId;\n        if (mustRemoveSelfIntersections) {\n            const mask = DrawLayer._svgFactory.createElement(\"mask\");\n            defs.append(mask);\n            maskId = `mask_p${this.pageIndex}_${id}`;\n            mask.setAttribute(\"id\", maskId);\n            mask.setAttribute(\"maskUnits\", \"objectBoundingBox\");\n            const rect = DrawLayer._svgFactory.createElement(\"rect\");\n            mask.append(rect);\n            rect.setAttribute(\"width\", \"1\");\n            rect.setAttribute(\"height\", \"1\");\n            rect.setAttribute(\"fill\", \"white\");\n            const use = DrawLayer._svgFactory.createElement(\"use\");\n            mask.append(use);\n            use.setAttribute(\"href\", `#${pathId}`);\n            use.setAttribute(\"stroke\", \"none\");\n            use.setAttribute(\"fill\", \"black\");\n            use.setAttribute(\"fill-rule\", \"nonzero\");\n            use.classList.add(\"mask\");\n        }\n        const use1 = DrawLayer._svgFactory.createElement(\"use\");\n        root.append(use1);\n        use1.setAttribute(\"href\", `#${pathId}`);\n        if (maskId) {\n            use1.setAttribute(\"mask\", `url(#${maskId})`);\n        }\n        const use2 = use1.cloneNode();\n        root.append(use2);\n        use1.classList.add(\"mainOutline\");\n        use2.classList.add(\"secondaryOutline\");\n        this.updateProperties(root, properties);\n        this.#mapping.set(id, root);\n        return id;\n    }\n    finalizeDraw(id, properties) {\n        this.#toUpdate.delete(id);\n        this.updateProperties(id, properties);\n    }\n    updateProperties(elementOrId, properties) {\n        if (!properties) {\n            return;\n        }\n        const { root, bbox, rootClass, path } = properties;\n        const element = typeof elementOrId === \"number\" ? this.#mapping.get(elementOrId) : elementOrId;\n        if (!element) {\n            return;\n        }\n        if (root) {\n            this.#updateProperties(element, root);\n        }\n        if (bbox) {\n            DrawLayer.#setBox(element, bbox);\n        }\n        if (rootClass) {\n            const { classList } = element;\n            for (const [className, value] of Object.entries(rootClass)){\n                classList.toggle(className, value);\n            }\n        }\n        if (path) {\n            const defs = element.firstChild;\n            const pathElement = defs.firstChild;\n            this.#updateProperties(pathElement, path);\n        }\n    }\n    updateParent(id, layer) {\n        if (layer === this) {\n            return;\n        }\n        const root = this.#mapping.get(id);\n        if (!root) {\n            return;\n        }\n        layer.#parent.append(root);\n        this.#mapping.delete(id);\n        layer.#mapping.set(id, root);\n    }\n    remove(id) {\n        this.#toUpdate.delete(id);\n        if (this.#parent === null) {\n            return;\n        }\n        this.#mapping.get(id).remove();\n        this.#mapping.delete(id);\n    }\n    destroy() {\n        this.#parent = null;\n        for (const root of this.#mapping.values()){\n            root.remove();\n        }\n        this.#mapping.clear();\n        this.#toUpdate.clear();\n    }\n}\n; // ./src/pdf.js\nconst pdfjsVersion = \"4.9.155\";\nconst pdfjsBuild = \"a4eb8407c\";\n{\n    globalThis.pdfjsTestingUtils = {\n        HighlightOutliner: HighlightOutliner\n    };\n}var __webpack_exports__AbortException = __nested_webpack_exports__.AbortException;\nvar __webpack_exports__AnnotationEditorLayer = __nested_webpack_exports__.AnnotationEditorLayer;\nvar __webpack_exports__AnnotationEditorParamsType = __nested_webpack_exports__.AnnotationEditorParamsType;\nvar __webpack_exports__AnnotationEditorType = __nested_webpack_exports__.AnnotationEditorType;\nvar __webpack_exports__AnnotationEditorUIManager = __nested_webpack_exports__.AnnotationEditorUIManager;\nvar __webpack_exports__AnnotationLayer = __nested_webpack_exports__.AnnotationLayer;\nvar __webpack_exports__AnnotationMode = __nested_webpack_exports__.AnnotationMode;\nvar __webpack_exports__ColorPicker = __nested_webpack_exports__.ColorPicker;\nvar __webpack_exports__DOMSVGFactory = __nested_webpack_exports__.DOMSVGFactory;\nvar __webpack_exports__DrawLayer = __nested_webpack_exports__.DrawLayer;\nvar __webpack_exports__FeatureTest = __nested_webpack_exports__.FeatureTest;\nvar __webpack_exports__GlobalWorkerOptions = __nested_webpack_exports__.GlobalWorkerOptions;\nvar __webpack_exports__ImageKind = __nested_webpack_exports__.ImageKind;\nvar __webpack_exports__InvalidPDFException = __nested_webpack_exports__.InvalidPDFException;\nvar __webpack_exports__MissingPDFException = __nested_webpack_exports__.MissingPDFException;\nvar __webpack_exports__OPS = __nested_webpack_exports__.OPS;\nvar __webpack_exports__OutputScale = __nested_webpack_exports__.OutputScale;\nvar __webpack_exports__PDFDataRangeTransport = __nested_webpack_exports__.PDFDataRangeTransport;\nvar __webpack_exports__PDFDateString = __nested_webpack_exports__.PDFDateString;\nvar __webpack_exports__PDFWorker = __nested_webpack_exports__.PDFWorker;\nvar __webpack_exports__PasswordResponses = __nested_webpack_exports__.PasswordResponses;\nvar __webpack_exports__PermissionFlag = __nested_webpack_exports__.PermissionFlag;\nvar __webpack_exports__PixelsPerInch = __nested_webpack_exports__.PixelsPerInch;\nvar __webpack_exports__RenderingCancelledException = __nested_webpack_exports__.RenderingCancelledException;\nvar __webpack_exports__TextLayer = __nested_webpack_exports__.TextLayer;\nvar __webpack_exports__UnexpectedResponseException = __nested_webpack_exports__.UnexpectedResponseException;\nvar __webpack_exports__Util = __nested_webpack_exports__.Util;\nvar __webpack_exports__VerbosityLevel = __nested_webpack_exports__.VerbosityLevel;\nvar __webpack_exports__XfaLayer = __nested_webpack_exports__.XfaLayer;\nvar __webpack_exports__build = __nested_webpack_exports__.build;\nvar __webpack_exports__createValidAbsoluteUrl = __nested_webpack_exports__.createValidAbsoluteUrl;\nvar __webpack_exports__fetchData = __nested_webpack_exports__.fetchData;\nvar __webpack_exports__getDocument = __nested_webpack_exports__.getDocument;\nvar __webpack_exports__getFilenameFromUrl = __nested_webpack_exports__.getFilenameFromUrl;\nvar __webpack_exports__getPdfFilenameFromUrl = __nested_webpack_exports__.getPdfFilenameFromUrl;\nvar __webpack_exports__getXfaPageViewport = __nested_webpack_exports__.getXfaPageViewport;\nvar __webpack_exports__isDataScheme = __nested_webpack_exports__.isDataScheme;\nvar __webpack_exports__isPdfFile = __nested_webpack_exports__.isPdfFile;\nvar __webpack_exports__noContextMenu = __nested_webpack_exports__.noContextMenu;\nvar __webpack_exports__normalizeUnicode = __nested_webpack_exports__.normalizeUnicode;\nvar __webpack_exports__setLayerDimensions = __nested_webpack_exports__.setLayerDimensions;\nvar __webpack_exports__shadow = __nested_webpack_exports__.shadow;\nvar __webpack_exports__stopEvent = __nested_webpack_exports__.stopEvent;\nvar __webpack_exports__version = __nested_webpack_exports__.version;\n //# sourceMappingURL=pdf.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGRmanMtZGlzdC9idWlsZC9wZGYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBb0JDLEdBRUQsTUFBTSxHQUFHLG9CQUFvQjtBQUM3QixNQUFNLEdBQUcsSUFBSUEsOEJBQW1CQSxHQUFHLENBQUM7QUFDcEMsTUFBTSxHQUNOLHdFQUF3RSxHQUN4RSxNQUFNLEdBQUcsMkNBQTJDLEdBQ3BELE1BQU0sR0FBSTtJQUNWLE1BQU0sR0FBSSw4Q0FBOEM7SUFDeEQsTUFBTSxHQUFJQSw4QkFBbUJBLENBQUNDLENBQUMsR0FBRyxDQUFDQyxTQUFTQztRQUM1QyxNQUFNLEdBQUssSUFBSSxJQUFJQyxPQUFPRCxXQUFZO1lBQ3RDLE1BQU0sR0FBTSxJQUFHSCw4QkFBbUJBLENBQUNLLENBQUMsQ0FBQ0YsWUFBWUMsUUFBUSxDQUFDSiw4QkFBbUJBLENBQUNLLENBQUMsQ0FBQ0gsU0FBU0UsTUFBTTtnQkFDL0YsTUFBTSxHQUFPRSxPQUFPQyxjQUFjLENBQUNMLFNBQVNFLEtBQUs7b0JBQUVJLFlBQVk7b0JBQU1DLEtBQUtOLFVBQVUsQ0FBQ0MsSUFBSTtnQkFBQztZQUMxRixNQUFNLEdBQU07UUFDWixNQUFNLEdBQUs7SUFDWCxNQUFNLEdBQUk7QUFDVixNQUFNLEdBQUc7QUFDVCxNQUFNLEdBQ04sTUFBTSxHQUFHLDRDQUE0QyxHQUNyRCxNQUFNLEdBQUk7SUFDVixNQUFNLEdBQUlKLDhCQUFtQkEsQ0FBQ0ssQ0FBQyxHQUFHLENBQUNLLEtBQUtDLE9BQVVMLE9BQU9NLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNKLEtBQUtDO0FBQzVGLE1BQU0sR0FBRztBQUNULE1BQU0sR0FDTix3RUFBd0UsR0FDeEUsSUFBSUksMEJBQW1CQSxHQUFHQyxXQUFXQyxRQUFRLEdBQUcsQ0FBQztBQUVqRCxVQUFVO0FBQ1Zq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QVMsQ0FBQyxFQUFFO0lBQzNCO0lBQ0EsT0FBT0EsVUFBVXlMLEVBQUUsRUFBRUMsRUFBRSxFQUFFO1FBQ3ZCLE9BQU87WUFBQ0QsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUUsR0FBR0QsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUU7WUFBRUQsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUUsR0FBR0QsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUU7WUFBRUQsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUUsR0FBR0QsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUU7WUFBRUQsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUUsR0FBR0QsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUU7WUFBRUQsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUUsR0FBR0QsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUUsR0FBR0QsRUFBRSxDQUFDLEVBQUU7WUFBRUEsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUUsR0FBR0QsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUUsR0FBR0QsRUFBRSxDQUFDLEVBQUU7U0FBQztJQUNuTjtJQUNBLE9BQU9FLGVBQWVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFO1FBQzFCLE1BQU1DLEtBQUtGLENBQUMsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFLEdBQUdELENBQUMsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFLEdBQUdBLENBQUMsQ0FBQyxFQUFFO1FBQzNDLE1BQU1FLEtBQUtILENBQUMsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFLEdBQUdELENBQUMsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFLEdBQUdBLENBQUMsQ0FBQyxFQUFFO1FB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azovL25leHQtcXdlbi1kb2MtcGFyc2UvLi9ub2RlX21vZHVsZXMvcGRmanMtZGlzdC9idWlsZC9wZGYubWpzPzgzZTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljc3RhcnQgVGhlIGZvbGxvd2luZyBpcyB0aGUgZW50aXJlIGxpY2Vuc2Ugbm90aWNlIGZvciB0aGVcbiAqIEphdmFTY3JpcHQgY29kZSBpbiB0aGlzIHBhZ2VcbiAqXG4gKiBDb3B5cmlnaHQgMjAyNCBNb3ppbGxhIEZvdW5kYXRpb25cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQGxpY2VuZCBUaGUgYWJvdmUgaXMgdGhlIGVudGlyZSBsaWNlbnNlIG5vdGljZSBmb3IgdGhlXG4gKiBKYXZhU2NyaXB0IGNvZGUgaW4gdGhpcyBwYWdlXG4gKi9cblxuLyoqKioqKi8gLy8gVGhlIHJlcXVpcmUgc2NvcGVcbi8qKioqKiovIHZhciBfX3dlYnBhY2tfcmVxdWlyZV9fID0ge307XG4vKioqKioqLyBcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAvKiB3ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMgKi9cbi8qKioqKiovICgoKSA9PiB7XG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcbi8qKioqKiovIFx0XHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG4vKioqKioqLyBcdFx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcbi8qKioqKiovIFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqLyB9KSgpO1xuLyoqKioqKi8gXG4vKioqKioqLyAvKiB3ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kICovXG4vKioqKioqLyAoKCkgPT4ge1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpXG4vKioqKioqLyB9KSgpO1xuLyoqKioqKi8gXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xudmFyIF9fd2VicGFja19leHBvcnRzX18gPSBnbG9iYWxUaGlzLnBkZmpzTGliID0ge307XG5cbi8vIEVYUE9SVFNcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4gIEFib3J0RXhjZXB0aW9uOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQWJvcnRFeGNlcHRpb24pLFxuICBBbm5vdGF0aW9uRWRpdG9yTGF5ZXI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBBbm5vdGF0aW9uRWRpdG9yTGF5ZXIpLFxuICBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZTogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlKSxcbiAgQW5ub3RhdGlvbkVkaXRvclR5cGU6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBBbm5vdGF0aW9uRWRpdG9yVHlwZSksXG4gIEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyKSxcbiAgQW5ub3RhdGlvbkxheWVyOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQW5ub3RhdGlvbkxheWVyKSxcbiAgQW5ub3RhdGlvbk1vZGU6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBBbm5vdGF0aW9uTW9kZSksXG4gIENvbG9yUGlja2VyOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ29sb3JQaWNrZXIpLFxuICBET01TVkdGYWN0b3J5OiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRE9NU1ZHRmFjdG9yeSksXG4gIERyYXdMYXllcjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIERyYXdMYXllciksXG4gIEZlYXR1cmVUZXN0OiAoKSA9PiAoLyogcmVleHBvcnQgKi8gdXRpbF9GZWF0dXJlVGVzdCksXG4gIEdsb2JhbFdvcmtlck9wdGlvbnM6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBHbG9iYWxXb3JrZXJPcHRpb25zKSxcbiAgSW1hZ2VLaW5kOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gdXRpbF9JbWFnZUtpbmQpLFxuICBJbnZhbGlkUERGRXhjZXB0aW9uOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gSW52YWxpZFBERkV4Y2VwdGlvbiksXG4gIE1pc3NpbmdQREZFeGNlcHRpb246ICgpID0+ICgvKiByZWV4cG9ydCAqLyBNaXNzaW5nUERGRXhjZXB0aW9uKSxcbiAgT1BTOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gT1BTKSxcbiAgT3V0cHV0U2NhbGU6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBPdXRwdXRTY2FsZSksXG4gIFBERkRhdGFSYW5nZVRyYW5zcG9ydDogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFBERkRhdGFSYW5nZVRyYW5zcG9ydCksXG4gIFBERkRhdGVTdHJpbmc6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQREZEYXRlU3RyaW5nKSxcbiAgUERGV29ya2VyOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUERGV29ya2VyKSxcbiAgUGFzc3dvcmRSZXNwb25zZXM6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQYXNzd29yZFJlc3BvbnNlcyksXG4gIFBlcm1pc3Npb25GbGFnOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUGVybWlzc2lvbkZsYWcpLFxuICBQaXhlbHNQZXJJbmNoOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUGl4ZWxzUGVySW5jaCksXG4gIFJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbiksXG4gIFRleHRMYXllcjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFRleHRMYXllciksXG4gIFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbiksXG4gIFV0aWw6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBVdGlsKSxcbiAgVmVyYm9zaXR5TGV2ZWw6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBWZXJib3NpdHlMZXZlbCksXG4gIFhmYUxheWVyOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gWGZhTGF5ZXIpLFxuICBidWlsZDogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGJ1aWxkKSxcbiAgY3JlYXRlVmFsaWRBYnNvbHV0ZVVybDogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGNyZWF0ZVZhbGlkQWJzb2x1dGVVcmwpLFxuICBmZXRjaERhdGE6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBmZXRjaERhdGEpLFxuICBnZXREb2N1bWVudDogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGdldERvY3VtZW50KSxcbiAgZ2V0RmlsZW5hbWVGcm9tVXJsOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gZ2V0RmlsZW5hbWVGcm9tVXJsKSxcbiAgZ2V0UGRmRmlsZW5hbWVGcm9tVXJsOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gZ2V0UGRmRmlsZW5hbWVGcm9tVXJsKSxcbiAgZ2V0WGZhUGFnZVZpZXdwb3J0OiAoKSA9PiAoLyogcmVleHBvcnQgKi8gZ2V0WGZhUGFnZVZpZXdwb3J0KSxcbiAgaXNEYXRhU2NoZW1lOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gaXNEYXRhU2NoZW1lKSxcbiAgaXNQZGZGaWxlOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gaXNQZGZGaWxlKSxcbiAgbm9Db250ZXh0TWVudTogKCkgPT4gKC8qIHJlZXhwb3J0ICovIG5vQ29udGV4dE1lbnUpLFxuICBub3JtYWxpemVVbmljb2RlOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gbm9ybWFsaXplVW5pY29kZSksXG4gIHNldExheWVyRGltZW5zaW9uczogKCkgPT4gKC8qIHJlZXhwb3J0ICovIHNldExheWVyRGltZW5zaW9ucyksXG4gIHNoYWRvdzogKCkgPT4gKC8qIHJlZXhwb3J0ICovIHNoYWRvdyksXG4gIHN0b3BFdmVudDogKCkgPT4gKC8qIHJlZXhwb3J0ICovIHN0b3BFdmVudCksXG4gIHZlcnNpb246ICgpID0+ICgvKiByZWV4cG9ydCAqLyB2ZXJzaW9uKVxufSk7XG5cbjsvLyAuL3NyYy9zaGFyZWQvdXRpbC5qc1xuY29uc3QgaXNOb2RlSlMgPSB0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzICsgXCJcIiA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIgJiYgIXByb2Nlc3MudmVyc2lvbnMubncgJiYgIShwcm9jZXNzLnZlcnNpb25zLmVsZWN0cm9uICYmIHByb2Nlc3MudHlwZSAmJiBwcm9jZXNzLnR5cGUgIT09IFwiYnJvd3NlclwiKTtcbmNvbnN0IElERU5USVRZX01BVFJJWCA9IFsxLCAwLCAwLCAxLCAwLCAwXTtcbmNvbnN0IEZPTlRfSURFTlRJVFlfTUFUUklYID0gWzAuMDAxLCAwLCAwLCAwLjAwMSwgMCwgMF07XG5jb25zdCBNQVhfSU1BR0VfU0laRV9UT19DQUNIRSA9IDEwZTY7XG5jb25zdCBMSU5FX0ZBQ1RPUiA9IDEuMzU7XG5jb25zdCBMSU5FX0RFU0NFTlRfRkFDVE9SID0gMC4zNTtcbmNvbnN0IEJBU0VMSU5FX0ZBQ1RPUiA9IExJTkVfREVTQ0VOVF9GQUNUT1IgLyBMSU5FX0ZBQ1RPUjtcbmNvbnN0IFJlbmRlcmluZ0ludGVudEZsYWcgPSB7XG4gIEFOWTogMHgwMSxcbiAgRElTUExBWTogMHgwMixcbiAgUFJJTlQ6IDB4MDQsXG4gIFNBVkU6IDB4MDgsXG4gIEFOTk9UQVRJT05TX0ZPUk1TOiAweDEwLFxuICBBTk5PVEFUSU9OU19TVE9SQUdFOiAweDIwLFxuICBBTk5PVEFUSU9OU19ESVNBQkxFOiAweDQwLFxuICBJU19FRElUSU5HOiAweDgwLFxuICBPUExJU1Q6IDB4MTAwXG59O1xuY29uc3QgQW5ub3RhdGlvbk1vZGUgPSB7XG4gIERJU0FCTEU6IDAsXG4gIEVOQUJMRTogMSxcbiAgRU5BQkxFX0ZPUk1TOiAyLFxuICBFTkFCTEVfU1RPUkFHRTogM1xufTtcbmNvbnN0IEFubm90YXRpb25FZGl0b3JQcmVmaXggPSBcInBkZmpzX2ludGVybmFsX2VkaXRvcl9cIjtcbmNvbnN0IEFubm90YXRpb25FZGl0b3JUeXBlID0ge1xuICBESVNBQkxFOiAtMSxcbiAgTk9ORTogMCxcbiAgRlJFRVRFWFQ6IDMsXG4gIEhJR0hMSUdIVDogOSxcbiAgU1RBTVA6IDEzLFxuICBJTks6IDE1XG59O1xuY29uc3QgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUgPSB7XG4gIFJFU0laRTogMSxcbiAgQ1JFQVRFOiAyLFxuICBGUkVFVEVYVF9TSVpFOiAxMSxcbiAgRlJFRVRFWFRfQ09MT1I6IDEyLFxuICBGUkVFVEVYVF9PUEFDSVRZOiAxMyxcbiAgSU5LX0NPTE9SOiAyMSxcbiAgSU5LX1RISUNLTkVTUzogMjIsXG4gIElOS19PUEFDSVRZOiAyMyxcbiAgSElHSExJR0hUX0NPTE9SOiAzMSxcbiAgSElHSExJR0hUX0RFRkFVTFRfQ09MT1I6IDMyLFxuICBISUdITElHSFRfVEhJQ0tORVNTOiAzMyxcbiAgSElHSExJR0hUX0ZSRUU6IDM0LFxuICBISUdITElHSFRfU0hPV19BTEw6IDM1LFxuICBEUkFXX1NURVA6IDQxXG59O1xuY29uc3QgUGVybWlzc2lvbkZsYWcgPSB7XG4gIFBSSU5UOiAweDA0LFxuICBNT0RJRllfQ09OVEVOVFM6IDB4MDgsXG4gIENPUFk6IDB4MTAsXG4gIE1PRElGWV9BTk5PVEFUSU9OUzogMHgyMCxcbiAgRklMTF9JTlRFUkFDVElWRV9GT1JNUzogMHgxMDAsXG4gIENPUFlfRk9SX0FDQ0VTU0lCSUxJVFk6IDB4MjAwLFxuICBBU1NFTUJMRTogMHg0MDAsXG4gIFBSSU5UX0hJR0hfUVVBTElUWTogMHg4MDBcbn07XG5jb25zdCBUZXh0UmVuZGVyaW5nTW9kZSA9IHtcbiAgRklMTDogMCxcbiAgU1RST0tFOiAxLFxuICBGSUxMX1NUUk9LRTogMixcbiAgSU5WSVNJQkxFOiAzLFxuICBGSUxMX0FERF9UT19QQVRIOiA0LFxuICBTVFJPS0VfQUREX1RPX1BBVEg6IDUsXG4gIEZJTExfU1RST0tFX0FERF9UT19QQVRIOiA2LFxuICBBRERfVE9fUEFUSDogNyxcbiAgRklMTF9TVFJPS0VfTUFTSzogMyxcbiAgQUREX1RPX1BBVEhfRkxBRzogNFxufTtcbmNvbnN0IHV0aWxfSW1hZ2VLaW5kID0ge1xuICBHUkFZU0NBTEVfMUJQUDogMSxcbiAgUkdCXzI0QlBQOiAyLFxuICBSR0JBXzMyQlBQOiAzXG59O1xuY29uc3QgQW5ub3RhdGlvblR5cGUgPSB7XG4gIFRFWFQ6IDEsXG4gIExJTks6IDIsXG4gIEZSRUVURVhUOiAzLFxuICBMSU5FOiA0LFxuICBTUVVBUkU6IDUsXG4gIENJUkNMRTogNixcbiAgUE9MWUdPTjogNyxcbiAgUE9MWUxJTkU6IDgsXG4gIEhJR0hMSUdIVDogOSxcbiAgVU5ERVJMSU5FOiAxMCxcbiAgU1FVSUdHTFk6IDExLFxuICBTVFJJS0VPVVQ6IDEyLFxuICBTVEFNUDogMTMsXG4gIENBUkVUOiAxNCxcbiAgSU5LOiAxNSxcbiAgUE9QVVA6IDE2LFxuICBGSUxFQVRUQUNITUVOVDogMTcsXG4gIFNPVU5EOiAxOCxcbiAgTU9WSUU6IDE5LFxuICBXSURHRVQ6IDIwLFxuICBTQ1JFRU46IDIxLFxuICBQUklOVEVSTUFSSzogMjIsXG4gIFRSQVBORVQ6IDIzLFxuICBXQVRFUk1BUks6IDI0LFxuICBUSFJFRUQ6IDI1LFxuICBSRURBQ1Q6IDI2XG59O1xuY29uc3QgQW5ub3RhdGlvblJlcGx5VHlwZSA9IHtcbiAgR1JPVVA6IFwiR3JvdXBcIixcbiAgUkVQTFk6IFwiUlwiXG59O1xuY29uc3QgQW5ub3RhdGlvbkZsYWcgPSB7XG4gIElOVklTSUJMRTogMHgwMSxcbiAgSElEREVOOiAweDAyLFxuICBQUklOVDogMHgwNCxcbiAgTk9aT09NOiAweDA4LFxuICBOT1JPVEFURTogMHgxMCxcbiAgTk9WSUVXOiAweDIwLFxuICBSRUFET05MWTogMHg0MCxcbiAgTE9DS0VEOiAweDgwLFxuICBUT0dHTEVOT1ZJRVc6IDB4MTAwLFxuICBMT0NLRURDT05URU5UUzogMHgyMDBcbn07XG5jb25zdCBBbm5vdGF0aW9uRmllbGRGbGFnID0ge1xuICBSRUFET05MWTogMHgwMDAwMDAxLFxuICBSRVFVSVJFRDogMHgwMDAwMDAyLFxuICBOT0VYUE9SVDogMHgwMDAwMDA0LFxuICBNVUxUSUxJTkU6IDB4MDAwMTAwMCxcbiAgUEFTU1dPUkQ6IDB4MDAwMjAwMCxcbiAgTk9UT0dHTEVUT09GRjogMHgwMDA0MDAwLFxuICBSQURJTzogMHgwMDA4MDAwLFxuICBQVVNIQlVUVE9OOiAweDAwMTAwMDAsXG4gIENPTUJPOiAweDAwMjAwMDAsXG4gIEVESVQ6IDB4MDA0MDAwMCxcbiAgU09SVDogMHgwMDgwMDAwLFxuICBGSUxFU0VMRUNUOiAweDAxMDAwMDAsXG4gIE1VTFRJU0VMRUNUOiAweDAyMDAwMDAsXG4gIERPTk9UU1BFTExDSEVDSzogMHgwNDAwMDAwLFxuICBET05PVFNDUk9MTDogMHgwODAwMDAwLFxuICBDT01COiAweDEwMDAwMDAsXG4gIFJJQ0hURVhUOiAweDIwMDAwMDAsXG4gIFJBRElPU0lOVU5JU09OOiAweDIwMDAwMDAsXG4gIENPTU1JVE9OU0VMQ0hBTkdFOiAweDQwMDAwMDBcbn07XG5jb25zdCBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlID0ge1xuICBTT0xJRDogMSxcbiAgREFTSEVEOiAyLFxuICBCRVZFTEVEOiAzLFxuICBJTlNFVDogNCxcbiAgVU5ERVJMSU5FOiA1XG59O1xuY29uc3QgQW5ub3RhdGlvbkFjdGlvbkV2ZW50VHlwZSA9IHtcbiAgRTogXCJNb3VzZSBFbnRlclwiLFxuICBYOiBcIk1vdXNlIEV4aXRcIixcbiAgRDogXCJNb3VzZSBEb3duXCIsXG4gIFU6IFwiTW91c2UgVXBcIixcbiAgRm86IFwiRm9jdXNcIixcbiAgQmw6IFwiQmx1clwiLFxuICBQTzogXCJQYWdlT3BlblwiLFxuICBQQzogXCJQYWdlQ2xvc2VcIixcbiAgUFY6IFwiUGFnZVZpc2libGVcIixcbiAgUEk6IFwiUGFnZUludmlzaWJsZVwiLFxuICBLOiBcIktleXN0cm9rZVwiLFxuICBGOiBcIkZvcm1hdFwiLFxuICBWOiBcIlZhbGlkYXRlXCIsXG4gIEM6IFwiQ2FsY3VsYXRlXCJcbn07XG5jb25zdCBEb2N1bWVudEFjdGlvbkV2ZW50VHlwZSA9IHtcbiAgV0M6IFwiV2lsbENsb3NlXCIsXG4gIFdTOiBcIldpbGxTYXZlXCIsXG4gIERTOiBcIkRpZFNhdmVcIixcbiAgV1A6IFwiV2lsbFByaW50XCIsXG4gIERQOiBcIkRpZFByaW50XCJcbn07XG5jb25zdCBQYWdlQWN0aW9uRXZlbnRUeXBlID0ge1xuICBPOiBcIlBhZ2VPcGVuXCIsXG4gIEM6IFwiUGFnZUNsb3NlXCJcbn07XG5jb25zdCBWZXJib3NpdHlMZXZlbCA9IHtcbiAgRVJST1JTOiAwLFxuICBXQVJOSU5HUzogMSxcbiAgSU5GT1M6IDVcbn07XG5jb25zdCBPUFMgPSB7XG4gIGRlcGVuZGVuY3k6IDEsXG4gIHNldExpbmVXaWR0aDogMixcbiAgc2V0TGluZUNhcDogMyxcbiAgc2V0TGluZUpvaW46IDQsXG4gIHNldE1pdGVyTGltaXQ6IDUsXG4gIHNldERhc2g6IDYsXG4gIHNldFJlbmRlcmluZ0ludGVudDogNyxcbiAgc2V0RmxhdG5lc3M6IDgsXG4gIHNldEdTdGF0ZTogOSxcbiAgc2F2ZTogMTAsXG4gIHJlc3RvcmU6IDExLFxuICB0cmFuc2Zvcm06IDEyLFxuICBtb3ZlVG86IDEzLFxuICBsaW5lVG86IDE0LFxuICBjdXJ2ZVRvOiAxNSxcbiAgY3VydmVUbzI6IDE2LFxuICBjdXJ2ZVRvMzogMTcsXG4gIGNsb3NlUGF0aDogMTgsXG4gIHJlY3RhbmdsZTogMTksXG4gIHN0cm9rZTogMjAsXG4gIGNsb3NlU3Ryb2tlOiAyMSxcbiAgZmlsbDogMjIsXG4gIGVvRmlsbDogMjMsXG4gIGZpbGxTdHJva2U6IDI0LFxuICBlb0ZpbGxTdHJva2U6IDI1LFxuICBjbG9zZUZpbGxTdHJva2U6IDI2LFxuICBjbG9zZUVPRmlsbFN0cm9rZTogMjcsXG4gIGVuZFBhdGg6IDI4LFxuICBjbGlwOiAyOSxcbiAgZW9DbGlwOiAzMCxcbiAgYmVnaW5UZXh0OiAzMSxcbiAgZW5kVGV4dDogMzIsXG4gIHNldENoYXJTcGFjaW5nOiAzMyxcbiAgc2V0V29yZFNwYWNpbmc6IDM0LFxuICBzZXRIU2NhbGU6IDM1LFxuICBzZXRMZWFkaW5nOiAzNixcbiAgc2V0Rm9udDogMzcsXG4gIHNldFRleHRSZW5kZXJpbmdNb2RlOiAzOCxcbiAgc2V0VGV4dFJpc2U6IDM5LFxuICBtb3ZlVGV4dDogNDAsXG4gIHNldExlYWRpbmdNb3ZlVGV4dDogNDEsXG4gIHNldFRleHRNYXRyaXg6IDQyLFxuICBuZXh0TGluZTogNDMsXG4gIHNob3dUZXh0OiA0NCxcbiAgc2hvd1NwYWNlZFRleHQ6IDQ1LFxuICBuZXh0TGluZVNob3dUZXh0OiA0NixcbiAgbmV4dExpbmVTZXRTcGFjaW5nU2hvd1RleHQ6IDQ3LFxuICBzZXRDaGFyV2lkdGg6IDQ4LFxuICBzZXRDaGFyV2lkdGhBbmRCb3VuZHM6IDQ5LFxuICBzZXRTdHJva2VDb2xvclNwYWNlOiA1MCxcbiAgc2V0RmlsbENvbG9yU3BhY2U6IDUxLFxuICBzZXRTdHJva2VDb2xvcjogNTIsXG4gIHNldFN0cm9rZUNvbG9yTjogNTMsXG4gIHNldEZpbGxDb2xvcjogNTQsXG4gIHNldEZpbGxDb2xvck46IDU1LFxuICBzZXRTdHJva2VHcmF5OiA1NixcbiAgc2V0RmlsbEdyYXk6IDU3LFxuICBzZXRTdHJva2VSR0JDb2xvcjogNTgsXG4gIHNldEZpbGxSR0JDb2xvcjogNTksXG4gIHNldFN0cm9rZUNNWUtDb2xvcjogNjAsXG4gIHNldEZpbGxDTVlLQ29sb3I6IDYxLFxuICBzaGFkaW5nRmlsbDogNjIsXG4gIGJlZ2luSW5saW5lSW1hZ2U6IDYzLFxuICBiZWdpbkltYWdlRGF0YTogNjQsXG4gIGVuZElubGluZUltYWdlOiA2NSxcbiAgcGFpbnRYT2JqZWN0OiA2NixcbiAgbWFya1BvaW50OiA2NyxcbiAgbWFya1BvaW50UHJvcHM6IDY4LFxuICBiZWdpbk1hcmtlZENvbnRlbnQ6IDY5LFxuICBiZWdpbk1hcmtlZENvbnRlbnRQcm9wczogNzAsXG4gIGVuZE1hcmtlZENvbnRlbnQ6IDcxLFxuICBiZWdpbkNvbXBhdDogNzIsXG4gIGVuZENvbXBhdDogNzMsXG4gIHBhaW50Rm9ybVhPYmplY3RCZWdpbjogNzQsXG4gIHBhaW50Rm9ybVhPYmplY3RFbmQ6IDc1LFxuICBiZWdpbkdyb3VwOiA3NixcbiAgZW5kR3JvdXA6IDc3LFxuICBiZWdpbkFubm90YXRpb246IDgwLFxuICBlbmRBbm5vdGF0aW9uOiA4MSxcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0OiA4MyxcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0R3JvdXA6IDg0LFxuICBwYWludEltYWdlWE9iamVjdDogODUsXG4gIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0OiA4NixcbiAgcGFpbnRJbmxpbmVJbWFnZVhPYmplY3RHcm91cDogODcsXG4gIHBhaW50SW1hZ2VYT2JqZWN0UmVwZWF0OiA4OCxcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0UmVwZWF0OiA4OSxcbiAgcGFpbnRTb2xpZENvbG9ySW1hZ2VNYXNrOiA5MCxcbiAgY29uc3RydWN0UGF0aDogOTEsXG4gIHNldFN0cm9rZVRyYW5zcGFyZW50OiA5MixcbiAgc2V0RmlsbFRyYW5zcGFyZW50OiA5M1xufTtcbmNvbnN0IFBhc3N3b3JkUmVzcG9uc2VzID0ge1xuICBORUVEX1BBU1NXT1JEOiAxLFxuICBJTkNPUlJFQ1RfUEFTU1dPUkQ6IDJcbn07XG5sZXQgdmVyYm9zaXR5ID0gVmVyYm9zaXR5TGV2ZWwuV0FSTklOR1M7XG5mdW5jdGlvbiBzZXRWZXJib3NpdHlMZXZlbChsZXZlbCkge1xuICBpZiAoTnVtYmVyLmlzSW50ZWdlcihsZXZlbCkpIHtcbiAgICB2ZXJib3NpdHkgPSBsZXZlbDtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VmVyYm9zaXR5TGV2ZWwoKSB7XG4gIHJldHVybiB2ZXJib3NpdHk7XG59XG5mdW5jdGlvbiBpbmZvKG1zZykge1xuICBpZiAodmVyYm9zaXR5ID49IFZlcmJvc2l0eUxldmVsLklORk9TKSB7XG4gICAgY29uc29sZS5sb2coYEluZm86ICR7bXNnfWApO1xuICB9XG59XG5mdW5jdGlvbiB3YXJuKG1zZykge1xuICBpZiAodmVyYm9zaXR5ID49IFZlcmJvc2l0eUxldmVsLldBUk5JTkdTKSB7XG4gICAgY29uc29sZS5sb2coYFdhcm5pbmc6ICR7bXNnfWApO1xuICB9XG59XG5mdW5jdGlvbiB1bnJlYWNoYWJsZShtc2cpIHtcbiAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG59XG5mdW5jdGlvbiBhc3NlcnQoY29uZCwgbXNnKSB7XG4gIGlmICghY29uZCkge1xuICAgIHVucmVhY2hhYmxlKG1zZyk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9pc1ZhbGlkUHJvdG9jb2wodXJsKSB7XG4gIHN3aXRjaCAodXJsPy5wcm90b2NvbCkge1xuICAgIGNhc2UgXCJodHRwOlwiOlxuICAgIGNhc2UgXCJodHRwczpcIjpcbiAgICBjYXNlIFwiZnRwOlwiOlxuICAgIGNhc2UgXCJtYWlsdG86XCI6XG4gICAgY2FzZSBcInRlbDpcIjpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVZhbGlkQWJzb2x1dGVVcmwodXJsLCBiYXNlVXJsID0gbnVsbCwgb3B0aW9ucyA9IG51bGwpIHtcbiAgaWYgKCF1cmwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cnkge1xuICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiB1cmwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChvcHRpb25zLmFkZERlZmF1bHRQcm90b2NvbCAmJiB1cmwuc3RhcnRzV2l0aChcInd3dy5cIikpIHtcbiAgICAgICAgY29uc3QgZG90cyA9IHVybC5tYXRjaCgvXFwuL2cpO1xuICAgICAgICBpZiAoZG90cz8ubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICB1cmwgPSBgaHR0cDovLyR7dXJsfWA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnRyeUNvbnZlcnRFbmNvZGluZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHVybCA9IHN0cmluZ1RvVVRGOFN0cmluZyh1cmwpO1xuICAgICAgICB9IGNhdGNoIHt9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGFic29sdXRlVXJsID0gYmFzZVVybCA/IG5ldyBVUkwodXJsLCBiYXNlVXJsKSA6IG5ldyBVUkwodXJsKTtcbiAgICBpZiAoX2lzVmFsaWRQcm90b2NvbChhYnNvbHV0ZVVybCkpIHtcbiAgICAgIHJldHVybiBhYnNvbHV0ZVVybDtcbiAgICB9XG4gIH0gY2F0Y2gge31cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBzaGFkb3cob2JqLCBwcm9wLCB2YWx1ZSwgbm9uU2VyaWFsaXphYmxlID0gZmFsc2UpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwge1xuICAgIHZhbHVlLFxuICAgIGVudW1lcmFibGU6ICFub25TZXJpYWxpemFibGUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuY29uc3QgQmFzZUV4Y2VwdGlvbiA9IGZ1bmN0aW9uIEJhc2VFeGNlcHRpb25DbG9zdXJlKCkge1xuICBmdW5jdGlvbiBCYXNlRXhjZXB0aW9uKG1lc3NhZ2UsIG5hbWUpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gIH1cbiAgQmFzZUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgQmFzZUV4Y2VwdGlvbi5jb25zdHJ1Y3RvciA9IEJhc2VFeGNlcHRpb247XG4gIHJldHVybiBCYXNlRXhjZXB0aW9uO1xufSgpO1xuY2xhc3MgUGFzc3dvcmRFeGNlcHRpb24gZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnLCBjb2RlKSB7XG4gICAgc3VwZXIobXNnLCBcIlBhc3N3b3JkRXhjZXB0aW9uXCIpO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gIH1cbn1cbmNsYXNzIFVua25vd25FcnJvckV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2csIGRldGFpbHMpIHtcbiAgICBzdXBlcihtc2csIFwiVW5rbm93bkVycm9yRXhjZXB0aW9uXCIpO1xuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gIH1cbn1cbmNsYXNzIEludmFsaWRQREZFeGNlcHRpb24gZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgc3VwZXIobXNnLCBcIkludmFsaWRQREZFeGNlcHRpb25cIik7XG4gIH1cbn1cbmNsYXNzIE1pc3NpbmdQREZFeGNlcHRpb24gZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgc3VwZXIobXNnLCBcIk1pc3NpbmdQREZFeGNlcHRpb25cIik7XG4gIH1cbn1cbmNsYXNzIFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2csIHN0YXR1cykge1xuICAgIHN1cGVyKG1zZywgXCJVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb25cIik7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gIH1cbn1cbmNsYXNzIEZvcm1hdEVycm9yIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZykge1xuICAgIHN1cGVyKG1zZywgXCJGb3JtYXRFcnJvclwiKTtcbiAgfVxufVxuY2xhc3MgQWJvcnRFeGNlcHRpb24gZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgc3VwZXIobXNnLCBcIkFib3J0RXhjZXB0aW9uXCIpO1xuICB9XG59XG5mdW5jdGlvbiBieXRlc1RvU3RyaW5nKGJ5dGVzKSB7XG4gIGlmICh0eXBlb2YgYnl0ZXMgIT09IFwib2JqZWN0XCIgfHwgYnl0ZXM/Lmxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdW5yZWFjaGFibGUoXCJJbnZhbGlkIGFyZ3VtZW50IGZvciBieXRlc1RvU3RyaW5nXCIpO1xuICB9XG4gIGNvbnN0IGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcbiAgY29uc3QgTUFYX0FSR1VNRU5UX0NPVU5UID0gODE5MjtcbiAgaWYgKGxlbmd0aCA8IE1BWF9BUkdVTUVOVF9DT1VOVCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ5dGVzKTtcbiAgfVxuICBjb25zdCBzdHJCdWYgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gTUFYX0FSR1VNRU5UX0NPVU5UKSB7XG4gICAgY29uc3QgY2h1bmtFbmQgPSBNYXRoLm1pbihpICsgTUFYX0FSR1VNRU5UX0NPVU5ULCBsZW5ndGgpO1xuICAgIGNvbnN0IGNodW5rID0gYnl0ZXMuc3ViYXJyYXkoaSwgY2h1bmtFbmQpO1xuICAgIHN0ckJ1Zi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgY2h1bmspKTtcbiAgfVxuICByZXR1cm4gc3RyQnVmLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBzdHJpbmdUb0J5dGVzKHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gXCJzdHJpbmdcIikge1xuICAgIHVucmVhY2hhYmxlKFwiSW52YWxpZCBhcmd1bWVudCBmb3Igc3RyaW5nVG9CeXRlc1wiKTtcbiAgfVxuICBjb25zdCBsZW5ndGggPSBzdHIubGVuZ3RoO1xuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBieXRlc1tpXSA9IHN0ci5jaGFyQ29kZUF0KGkpICYgMHhmZjtcbiAgfVxuICByZXR1cm4gYnl0ZXM7XG59XG5mdW5jdGlvbiBzdHJpbmczMih2YWx1ZSkge1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh2YWx1ZSA+PiAyNCAmIDB4ZmYsIHZhbHVlID4+IDE2ICYgMHhmZiwgdmFsdWUgPj4gOCAmIDB4ZmYsIHZhbHVlICYgMHhmZik7XG59XG5mdW5jdGlvbiBvYmplY3RTaXplKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGg7XG59XG5mdW5jdGlvbiBvYmplY3RGcm9tTWFwKG1hcCkge1xuICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtYXApIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBpc0xpdHRsZUVuZGlhbigpIHtcbiAgY29uc3QgYnVmZmVyOCA9IG5ldyBVaW50OEFycmF5KDQpO1xuICBidWZmZXI4WzBdID0gMTtcbiAgY29uc3QgdmlldzMyID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmZlcjguYnVmZmVyLCAwLCAxKTtcbiAgcmV0dXJuIHZpZXczMlswXSA9PT0gMTtcbn1cbmZ1bmN0aW9uIGlzRXZhbFN1cHBvcnRlZCgpIHtcbiAgdHJ5IHtcbiAgICBuZXcgRnVuY3Rpb24oXCJcIik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuY2xhc3MgdXRpbF9GZWF0dXJlVGVzdCB7XG4gIHN0YXRpYyBnZXQgaXNMaXR0bGVFbmRpYW4oKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzTGl0dGxlRW5kaWFuXCIsIGlzTGl0dGxlRW5kaWFuKCkpO1xuICB9XG4gIHN0YXRpYyBnZXQgaXNFdmFsU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc0V2YWxTdXBwb3J0ZWRcIiwgaXNFdmFsU3VwcG9ydGVkKCkpO1xuICB9XG4gIHN0YXRpYyBnZXQgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkXCIsIHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09IFwidW5kZWZpbmVkXCIpO1xuICB9XG4gIHN0YXRpYyBnZXQgaXNJbWFnZURlY29kZXJTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzSW1hZ2VEZWNvZGVyU3VwcG9ydGVkXCIsIHR5cGVvZiBJbWFnZURlY29kZXIgIT09IFwidW5kZWZpbmVkXCIpO1xuICB9XG4gIHN0YXRpYyBnZXQgcGxhdGZvcm0oKSB7XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIG5hdmlnYXRvcj8ucGxhdGZvcm0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBzaGFkb3codGhpcywgXCJwbGF0Zm9ybVwiLCB7XG4gICAgICAgIGlzTWFjOiBuYXZpZ2F0b3IucGxhdGZvcm0uaW5jbHVkZXMoXCJNYWNcIiksXG4gICAgICAgIGlzV2luZG93czogbmF2aWdhdG9yLnBsYXRmb3JtLmluY2x1ZGVzKFwiV2luXCIpLFxuICAgICAgICBpc0ZpcmVmb3g6IHR5cGVvZiBuYXZpZ2F0b3I/LnVzZXJBZ2VudCA9PT0gXCJzdHJpbmdcIiAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwiRmlyZWZveFwiKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJwbGF0Zm9ybVwiLCB7XG4gICAgICBpc01hYzogZmFsc2UsXG4gICAgICBpc1dpbmRvd3M6IGZhbHNlLFxuICAgICAgaXNGaXJlZm94OiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXQgaXNDU1NSb3VuZFN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNDU1NSb3VuZFN1cHBvcnRlZFwiLCBnbG9iYWxUaGlzLkNTUz8uc3VwcG9ydHM/LihcIndpZHRoOiByb3VuZCgxLjVweCwgMXB4KVwiKSk7XG4gIH1cbn1cbmNvbnN0IGhleE51bWJlcnMgPSBBcnJheS5mcm9tKEFycmF5KDI1Nikua2V5cygpLCBuID0+IG4udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSk7XG5jbGFzcyBVdGlsIHtcbiAgc3RhdGljIG1ha2VIZXhDb2xvcihyLCBnLCBiKSB7XG4gICAgcmV0dXJuIGAjJHtoZXhOdW1iZXJzW3JdfSR7aGV4TnVtYmVyc1tnXX0ke2hleE51bWJlcnNbYl19YDtcbiAgfVxuICBzdGF0aWMgc2NhbGVNaW5NYXgodHJhbnNmb3JtLCBtaW5NYXgpIHtcbiAgICBsZXQgdGVtcDtcbiAgICBpZiAodHJhbnNmb3JtWzBdKSB7XG4gICAgICBpZiAodHJhbnNmb3JtWzBdIDwgMCkge1xuICAgICAgICB0ZW1wID0gbWluTWF4WzBdO1xuICAgICAgICBtaW5NYXhbMF0gPSBtaW5NYXhbMl07XG4gICAgICAgIG1pbk1heFsyXSA9IHRlbXA7XG4gICAgICB9XG4gICAgICBtaW5NYXhbMF0gKj0gdHJhbnNmb3JtWzBdO1xuICAgICAgbWluTWF4WzJdICo9IHRyYW5zZm9ybVswXTtcbiAgICAgIGlmICh0cmFuc2Zvcm1bM10gPCAwKSB7XG4gICAgICAgIHRlbXAgPSBtaW5NYXhbMV07XG4gICAgICAgIG1pbk1heFsxXSA9IG1pbk1heFszXTtcbiAgICAgICAgbWluTWF4WzNdID0gdGVtcDtcbiAgICAgIH1cbiAgICAgIG1pbk1heFsxXSAqPSB0cmFuc2Zvcm1bM107XG4gICAgICBtaW5NYXhbM10gKj0gdHJhbnNmb3JtWzNdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZW1wID0gbWluTWF4WzBdO1xuICAgICAgbWluTWF4WzBdID0gbWluTWF4WzFdO1xuICAgICAgbWluTWF4WzFdID0gdGVtcDtcbiAgICAgIHRlbXAgPSBtaW5NYXhbMl07XG4gICAgICBtaW5NYXhbMl0gPSBtaW5NYXhbM107XG4gICAgICBtaW5NYXhbM10gPSB0ZW1wO1xuICAgICAgaWYgKHRyYW5zZm9ybVsxXSA8IDApIHtcbiAgICAgICAgdGVtcCA9IG1pbk1heFsxXTtcbiAgICAgICAgbWluTWF4WzFdID0gbWluTWF4WzNdO1xuICAgICAgICBtaW5NYXhbM10gPSB0ZW1wO1xuICAgICAgfVxuICAgICAgbWluTWF4WzFdICo9IHRyYW5zZm9ybVsxXTtcbiAgICAgIG1pbk1heFszXSAqPSB0cmFuc2Zvcm1bMV07XG4gICAgICBpZiAodHJhbnNmb3JtWzJdIDwgMCkge1xuICAgICAgICB0ZW1wID0gbWluTWF4WzBdO1xuICAgICAgICBtaW5NYXhbMF0gPSBtaW5NYXhbMl07XG4gICAgICAgIG1pbk1heFsyXSA9IHRlbXA7XG4gICAgICB9XG4gICAgICBtaW5NYXhbMF0gKj0gdHJhbnNmb3JtWzJdO1xuICAgICAgbWluTWF4WzJdICo9IHRyYW5zZm9ybVsyXTtcbiAgICB9XG4gICAgbWluTWF4WzBdICs9IHRyYW5zZm9ybVs0XTtcbiAgICBtaW5NYXhbMV0gKz0gdHJhbnNmb3JtWzVdO1xuICAgIG1pbk1heFsyXSArPSB0cmFuc2Zvcm1bNF07XG4gICAgbWluTWF4WzNdICs9IHRyYW5zZm9ybVs1XTtcbiAgfVxuICBzdGF0aWMgdHJhbnNmb3JtKG0xLCBtMikge1xuICAgIHJldHVybiBbbTFbMF0gKiBtMlswXSArIG0xWzJdICogbTJbMV0sIG0xWzFdICogbTJbMF0gKyBtMVszXSAqIG0yWzFdLCBtMVswXSAqIG0yWzJdICsgbTFbMl0gKiBtMlszXSwgbTFbMV0gKiBtMlsyXSArIG0xWzNdICogbTJbM10sIG0xWzBdICogbTJbNF0gKyBtMVsyXSAqIG0yWzVdICsgbTFbNF0sIG0xWzFdICogbTJbNF0gKyBtMVszXSAqIG0yWzVdICsgbTFbNV1dO1xuICB9XG4gIHN0YXRpYyBhcHBseVRyYW5zZm9ybShwLCBtKSB7XG4gICAgY29uc3QgeHQgPSBwWzBdICogbVswXSArIHBbMV0gKiBtWzJdICsgbVs0XTtcbiAgICBjb25zdCB5dCA9IHBbMF0gKiBtWzFdICsgcFsxXSAqIG1bM10gKyBtWzVdO1xuICAgIHJldHVybiBbeHQsIHl0XTtcbiAgfVxuICBzdGF0aWMgYXBwbHlJbnZlcnNlVHJhbnNmb3JtKHAsIG0pIHtcbiAgICBjb25zdCBkID0gbVswXSAqIG1bM10gLSBtWzFdICogbVsyXTtcbiAgICBjb25zdCB4dCA9IChwWzBdICogbVszXSAtIHBbMV0gKiBtWzJdICsgbVsyXSAqIG1bNV0gLSBtWzRdICogbVszXSkgLyBkO1xuICAgIGNvbnN0IHl0ID0gKC1wWzBdICogbVsxXSArIHBbMV0gKiBtWzBdICsgbVs0XSAqIG1bMV0gLSBtWzVdICogbVswXSkgLyBkO1xuICAgIHJldHVybiBbeHQsIHl0XTtcbiAgfVxuICBzdGF0aWMgZ2V0QXhpYWxBbGlnbmVkQm91bmRpbmdCb3gociwgbSkge1xuICAgIGNvbnN0IHAxID0gdGhpcy5hcHBseVRyYW5zZm9ybShyLCBtKTtcbiAgICBjb25zdCBwMiA9IHRoaXMuYXBwbHlUcmFuc2Zvcm0oci5zbGljZSgyLCA0KSwgbSk7XG4gICAgY29uc3QgcDMgPSB0aGlzLmFwcGx5VHJhbnNmb3JtKFtyWzBdLCByWzNdXSwgbSk7XG4gICAgY29uc3QgcDQgPSB0aGlzLmFwcGx5VHJhbnNmb3JtKFtyWzJdLCByWzFdXSwgbSk7XG4gICAgcmV0dXJuIFtNYXRoLm1pbihwMVswXSwgcDJbMF0sIHAzWzBdLCBwNFswXSksIE1hdGgubWluKHAxWzFdLCBwMlsxXSwgcDNbMV0sIHA0WzFdKSwgTWF0aC5tYXgocDFbMF0sIHAyWzBdLCBwM1swXSwgcDRbMF0pLCBNYXRoLm1heChwMVsxXSwgcDJbMV0sIHAzWzFdLCBwNFsxXSldO1xuICB9XG4gIHN0YXRpYyBpbnZlcnNlVHJhbnNmb3JtKG0pIHtcbiAgICBjb25zdCBkID0gbVswXSAqIG1bM10gLSBtWzFdICogbVsyXTtcbiAgICByZXR1cm4gW21bM10gLyBkLCAtbVsxXSAvIGQsIC1tWzJdIC8gZCwgbVswXSAvIGQsIChtWzJdICogbVs1XSAtIG1bNF0gKiBtWzNdKSAvIGQsIChtWzRdICogbVsxXSAtIG1bNV0gKiBtWzBdKSAvIGRdO1xuICB9XG4gIHN0YXRpYyBzaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZShtKSB7XG4gICAgY29uc3QgdHJhbnNwb3NlID0gW21bMF0sIG1bMl0sIG1bMV0sIG1bM11dO1xuICAgIGNvbnN0IGEgPSBtWzBdICogdHJhbnNwb3NlWzBdICsgbVsxXSAqIHRyYW5zcG9zZVsyXTtcbiAgICBjb25zdCBiID0gbVswXSAqIHRyYW5zcG9zZVsxXSArIG1bMV0gKiB0cmFuc3Bvc2VbM107XG4gICAgY29uc3QgYyA9IG1bMl0gKiB0cmFuc3Bvc2VbMF0gKyBtWzNdICogdHJhbnNwb3NlWzJdO1xuICAgIGNvbnN0IGQgPSBtWzJdICogdHJhbnNwb3NlWzFdICsgbVszXSAqIHRyYW5zcG9zZVszXTtcbiAgICBjb25zdCBmaXJzdCA9IChhICsgZCkgLyAyO1xuICAgIGNvbnN0IHNlY29uZCA9IE1hdGguc3FydCgoYSArIGQpICoqIDIgLSA0ICogKGEgKiBkIC0gYyAqIGIpKSAvIDI7XG4gICAgY29uc3Qgc3ggPSBmaXJzdCArIHNlY29uZCB8fCAxO1xuICAgIGNvbnN0IHN5ID0gZmlyc3QgLSBzZWNvbmQgfHwgMTtcbiAgICByZXR1cm4gW01hdGguc3FydChzeCksIE1hdGguc3FydChzeSldO1xuICB9XG4gIHN0YXRpYyBub3JtYWxpemVSZWN0KHJlY3QpIHtcbiAgICBjb25zdCByID0gcmVjdC5zbGljZSgwKTtcbiAgICBpZiAocmVjdFswXSA+IHJlY3RbMl0pIHtcbiAgICAgIHJbMF0gPSByZWN0WzJdO1xuICAgICAgclsyXSA9IHJlY3RbMF07XG4gICAgfVxuICAgIGlmIChyZWN0WzFdID4gcmVjdFszXSkge1xuICAgICAgclsxXSA9IHJlY3RbM107XG4gICAgICByWzNdID0gcmVjdFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgc3RhdGljIGludGVyc2VjdChyZWN0MSwgcmVjdDIpIHtcbiAgICBjb25zdCB4TG93ID0gTWF0aC5tYXgoTWF0aC5taW4ocmVjdDFbMF0sIHJlY3QxWzJdKSwgTWF0aC5taW4ocmVjdDJbMF0sIHJlY3QyWzJdKSk7XG4gICAgY29uc3QgeEhpZ2ggPSBNYXRoLm1pbihNYXRoLm1heChyZWN0MVswXSwgcmVjdDFbMl0pLCBNYXRoLm1heChyZWN0MlswXSwgcmVjdDJbMl0pKTtcbiAgICBpZiAoeExvdyA+IHhIaWdoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgeUxvdyA9IE1hdGgubWF4KE1hdGgubWluKHJlY3QxWzFdLCByZWN0MVszXSksIE1hdGgubWluKHJlY3QyWzFdLCByZWN0MlszXSkpO1xuICAgIGNvbnN0IHlIaWdoID0gTWF0aC5taW4oTWF0aC5tYXgocmVjdDFbMV0sIHJlY3QxWzNdKSwgTWF0aC5tYXgocmVjdDJbMV0sIHJlY3QyWzNdKSk7XG4gICAgaWYgKHlMb3cgPiB5SGlnaCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBbeExvdywgeUxvdywgeEhpZ2gsIHlIaWdoXTtcbiAgfVxuICBzdGF0aWMgI2dldEV4dHJlbXVtT25DdXJ2ZSh4MCwgeDEsIHgyLCB4MywgeTAsIHkxLCB5MiwgeTMsIHQsIG1pbk1heCkge1xuICAgIGlmICh0IDw9IDAgfHwgdCA+PSAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG10ID0gMSAtIHQ7XG4gICAgY29uc3QgdHQgPSB0ICogdDtcbiAgICBjb25zdCB0dHQgPSB0dCAqIHQ7XG4gICAgY29uc3QgeCA9IG10ICogKG10ICogKG10ICogeDAgKyAzICogdCAqIHgxKSArIDMgKiB0dCAqIHgyKSArIHR0dCAqIHgzO1xuICAgIGNvbnN0IHkgPSBtdCAqIChtdCAqIChtdCAqIHkwICsgMyAqIHQgKiB5MSkgKyAzICogdHQgKiB5MikgKyB0dHQgKiB5MztcbiAgICBtaW5NYXhbMF0gPSBNYXRoLm1pbihtaW5NYXhbMF0sIHgpO1xuICAgIG1pbk1heFsxXSA9IE1hdGgubWluKG1pbk1heFsxXSwgeSk7XG4gICAgbWluTWF4WzJdID0gTWF0aC5tYXgobWluTWF4WzJdLCB4KTtcbiAgICBtaW5NYXhbM10gPSBNYXRoLm1heChtaW5NYXhbM10sIHkpO1xuICB9XG4gIHN0YXRpYyAjZ2V0RXh0cmVtdW0oeDAsIHgxLCB4MiwgeDMsIHkwLCB5MSwgeTIsIHkzLCBhLCBiLCBjLCBtaW5NYXgpIHtcbiAgICBpZiAoTWF0aC5hYnMoYSkgPCAxZS0xMikge1xuICAgICAgaWYgKE1hdGguYWJzKGIpID49IDFlLTEyKSB7XG4gICAgICAgIHRoaXMuI2dldEV4dHJlbXVtT25DdXJ2ZSh4MCwgeDEsIHgyLCB4MywgeTAsIHkxLCB5MiwgeTMsIC1jIC8gYiwgbWluTWF4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGVsdGEgPSBiICoqIDIgLSA0ICogYyAqIGE7XG4gICAgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzcXJ0RGVsdGEgPSBNYXRoLnNxcnQoZGVsdGEpO1xuICAgIGNvbnN0IGEyID0gMiAqIGE7XG4gICAgdGhpcy4jZ2V0RXh0cmVtdW1PbkN1cnZlKHgwLCB4MSwgeDIsIHgzLCB5MCwgeTEsIHkyLCB5MywgKC1iICsgc3FydERlbHRhKSAvIGEyLCBtaW5NYXgpO1xuICAgIHRoaXMuI2dldEV4dHJlbXVtT25DdXJ2ZSh4MCwgeDEsIHgyLCB4MywgeTAsIHkxLCB5MiwgeTMsICgtYiAtIHNxcnREZWx0YSkgLyBhMiwgbWluTWF4KTtcbiAgfVxuICBzdGF0aWMgYmV6aWVyQm91bmRpbmdCb3goeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCBtaW5NYXgpIHtcbiAgICBpZiAobWluTWF4KSB7XG4gICAgICBtaW5NYXhbMF0gPSBNYXRoLm1pbihtaW5NYXhbMF0sIHgwLCB4Myk7XG4gICAgICBtaW5NYXhbMV0gPSBNYXRoLm1pbihtaW5NYXhbMV0sIHkwLCB5Myk7XG4gICAgICBtaW5NYXhbMl0gPSBNYXRoLm1heChtaW5NYXhbMl0sIHgwLCB4Myk7XG4gICAgICBtaW5NYXhbM10gPSBNYXRoLm1heChtaW5NYXhbM10sIHkwLCB5Myk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pbk1heCA9IFtNYXRoLm1pbih4MCwgeDMpLCBNYXRoLm1pbih5MCwgeTMpLCBNYXRoLm1heCh4MCwgeDMpLCBNYXRoLm1heCh5MCwgeTMpXTtcbiAgICB9XG4gICAgdGhpcy4jZ2V0RXh0cmVtdW0oeDAsIHgxLCB4MiwgeDMsIHkwLCB5MSwgeTIsIHkzLCAzICogKC14MCArIDMgKiAoeDEgLSB4MikgKyB4MyksIDYgKiAoeDAgLSAyICogeDEgKyB4MiksIDMgKiAoeDEgLSB4MCksIG1pbk1heCk7XG4gICAgdGhpcy4jZ2V0RXh0cmVtdW0oeDAsIHgxLCB4MiwgeDMsIHkwLCB5MSwgeTIsIHkzLCAzICogKC15MCArIDMgKiAoeTEgLSB5MikgKyB5MyksIDYgKiAoeTAgLSAyICogeTEgKyB5MiksIDMgKiAoeTEgLSB5MCksIG1pbk1heCk7XG4gICAgcmV0dXJuIG1pbk1heDtcbiAgfVxufVxuY29uc3QgUERGU3RyaW5nVHJhbnNsYXRlVGFibGUgPSAoLyogdW51c2VkIHB1cmUgZXhwcmVzc2lvbiBvciBzdXBlciAqLyBudWxsICYmIChbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMHgyZDgsIDB4MmM3LCAweDJjNiwgMHgyZDksIDB4MmRkLCAweDJkYiwgMHgyZGEsIDB4MmRjLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAweDIwMjIsIDB4MjAyMCwgMHgyMDIxLCAweDIwMjYsIDB4MjAxNCwgMHgyMDEzLCAweDE5MiwgMHgyMDQ0LCAweDIwMzksIDB4MjAzYSwgMHgyMjEyLCAweDIwMzAsIDB4MjAxZSwgMHgyMDFjLCAweDIwMWQsIDB4MjAxOCwgMHgyMDE5LCAweDIwMWEsIDB4MjEyMiwgMHhmYjAxLCAweGZiMDIsIDB4MTQxLCAweDE1MiwgMHgxNjAsIDB4MTc4LCAweDE3ZCwgMHgxMzEsIDB4MTQyLCAweDE1MywgMHgxNjEsIDB4MTdlLCAwLCAweDIwYWNdKSk7XG5mdW5jdGlvbiBzdHJpbmdUb1BERlN0cmluZyhzdHIpIHtcbiAgaWYgKHN0clswXSA+PSBcIlxceEVGXCIpIHtcbiAgICBsZXQgZW5jb2Rpbmc7XG4gICAgaWYgKHN0clswXSA9PT0gXCJcXHhGRVwiICYmIHN0clsxXSA9PT0gXCJcXHhGRlwiKSB7XG4gICAgICBlbmNvZGluZyA9IFwidXRmLTE2YmVcIjtcbiAgICAgIGlmIChzdHIubGVuZ3RoICUgMiA9PT0gMSkge1xuICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3RyWzBdID09PSBcIlxceEZGXCIgJiYgc3RyWzFdID09PSBcIlxceEZFXCIpIHtcbiAgICAgIGVuY29kaW5nID0gXCJ1dGYtMTZsZVwiO1xuICAgICAgaWYgKHN0ci5sZW5ndGggJSAyID09PSAxKSB7XG4gICAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdHJbMF0gPT09IFwiXFx4RUZcIiAmJiBzdHJbMV0gPT09IFwiXFx4QkJcIiAmJiBzdHJbMl0gPT09IFwiXFx4QkZcIikge1xuICAgICAgZW5jb2RpbmcgPSBcInV0Zi04XCI7XG4gICAgfVxuICAgIGlmIChlbmNvZGluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihlbmNvZGluZywge1xuICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBidWZmZXIgPSBzdHJpbmdUb0J5dGVzKHN0cik7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVyLmRlY29kZShidWZmZXIpO1xuICAgICAgICBpZiAoIWRlY29kZWQuaW5jbHVkZXMoXCJcXHgxYlwiKSkge1xuICAgICAgICAgIHJldHVybiBkZWNvZGVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWNvZGVkLnJlcGxhY2VBbGwoL1xceDFiW15cXHgxYl0qKD86XFx4MWJ8JCkvZywgXCJcIik7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICB3YXJuKGBzdHJpbmdUb1BERlN0cmluZzogXCIke2V4fVwiLmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBzdHJCdWYgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gc3RyLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICBjb25zdCBjaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjaGFyQ29kZSA9PT0gMHgxYikge1xuICAgICAgd2hpbGUgKCsraSA8IGlpICYmIHN0ci5jaGFyQ29kZUF0KGkpICE9PSAweDFiKSB7fVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGNvZGUgPSBQREZTdHJpbmdUcmFuc2xhdGVUYWJsZVtjaGFyQ29kZV07XG4gICAgc3RyQnVmLnB1c2goY29kZSA/IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkgOiBzdHIuY2hhckF0KGkpKTtcbiAgfVxuICByZXR1cm4gc3RyQnVmLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBzdHJpbmdUb1VURjhTdHJpbmcoc3RyKSB7XG4gIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKHN0cikpO1xufVxuZnVuY3Rpb24gdXRmOFN0cmluZ1RvU3RyaW5nKHN0cikge1xuICByZXR1cm4gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpO1xufVxuZnVuY3Rpb24gaXNBcnJheUVxdWFsKGFycjEsIGFycjIpIHtcbiAgaWYgKGFycjEubGVuZ3RoICE9PSBhcnIyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMCwgaWkgPSBhcnIxLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICBpZiAoYXJyMVtpXSAhPT0gYXJyMltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldE1vZGlmaWNhdGlvbkRhdGUoZGF0ZSA9IG5ldyBEYXRlKCkpIHtcbiAgY29uc3QgYnVmZmVyID0gW2RhdGUuZ2V0VVRDRnVsbFllYXIoKS50b1N0cmluZygpLCAoZGF0ZS5nZXRVVENNb250aCgpICsgMSkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIiksIGRhdGUuZ2V0VVRDRGF0ZSgpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpLCBkYXRlLmdldFVUQ0hvdXJzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIiksIGRhdGUuZ2V0VVRDTWludXRlcygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpLCBkYXRlLmdldFVUQ1NlY29uZHMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKV07XG4gIHJldHVybiBidWZmZXIuam9pbihcIlwiKTtcbn1cbmxldCBOb3JtYWxpemVSZWdleCA9IG51bGw7XG5sZXQgTm9ybWFsaXphdGlvbk1hcCA9IG51bGw7XG5mdW5jdGlvbiBub3JtYWxpemVVbmljb2RlKHN0cikge1xuICBpZiAoIU5vcm1hbGl6ZVJlZ2V4KSB7XG4gICAgTm9ybWFsaXplUmVnZXggPSAvKFtcXHUwMGEwXFx1MDBiNVxcdTAzN2VcXHUwZWIzXFx1MjAwMC1cXHUyMDBhXFx1MjAyZlxcdTIxMjZcXHVmYjAwLVxcdWZiMDRcXHVmYjA2XFx1ZmIyMC1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDAtXFx1ZmI0MVxcdWZiNDMtXFx1ZmI0NFxcdWZiNDYtXFx1ZmJhMVxcdWZiYTQtXFx1ZmJhOVxcdWZiYWUtXFx1ZmJiMVxcdWZiZDMtXFx1ZmJkY1xcdWZiZGUtXFx1ZmJlN1xcdWZiZWEtXFx1ZmJmOFxcdWZiZmMtXFx1ZmJmZFxcdWZjMDAtXFx1ZmM1ZFxcdWZjNjQtXFx1ZmNmMVxcdWZjZjUtXFx1ZmQzZFxcdWZkODhcXHVmZGY0XFx1ZmRmYS1cXHVmZGZiXFx1ZmU3MVxcdWZlNzdcXHVmZTc5XFx1ZmU3YlxcdWZlN2RdKyl8KFxcdWZiMDUrKS9ndTtcbiAgICBOb3JtYWxpemF0aW9uTWFwID0gbmV3IE1hcChbW1wi76yFXCIsIFwixb90XCJdXSk7XG4gIH1cbiAgcmV0dXJuIHN0ci5yZXBsYWNlQWxsKE5vcm1hbGl6ZVJlZ2V4LCAoXywgcDEsIHAyKSA9PiBwMSA/IHAxLm5vcm1hbGl6ZShcIk5GS0NcIikgOiBOb3JtYWxpemF0aW9uTWFwLmdldChwMikpO1xufVxuZnVuY3Rpb24gZ2V0VXVpZCgpIHtcbiAgaWYgKHR5cGVvZiBjcnlwdG8ucmFuZG9tVVVJRCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIGNyeXB0by5yYW5kb21VVUlEKCk7XG4gIH1cbiAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ1Zik7XG4gIHJldHVybiBieXRlc1RvU3RyaW5nKGJ1Zik7XG59XG5jb25zdCBBbm5vdGF0aW9uUHJlZml4ID0gXCJwZGZqc19pbnRlcm5hbF9pZF9cIjtcbmNvbnN0IEZvbnRSZW5kZXJPcHMgPSB7XG4gIEJFWklFUl9DVVJWRV9UTzogMCxcbiAgTU9WRV9UTzogMSxcbiAgTElORV9UTzogMixcbiAgUVVBRFJBVElDX0NVUlZFX1RPOiAzLFxuICBSRVNUT1JFOiA0LFxuICBTQVZFOiA1LFxuICBTQ0FMRTogNixcbiAgVFJBTlNGT1JNOiA3LFxuICBUUkFOU0xBVEU6IDhcbn07XG5mdW5jdGlvbiB0b0hleFV0aWwoYXJyKSB7XG4gIGlmIChVaW50OEFycmF5LnByb3RvdHlwZS50b0hleCkge1xuICAgIHJldHVybiBhcnIudG9IZXgoKTtcbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbShhcnIsIG51bSA9PiBoZXhOdW1iZXJzW251bV0pLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiB0b0Jhc2U2NFV0aWwoYXJyKSB7XG4gIGlmIChVaW50OEFycmF5LnByb3RvdHlwZS50b0Jhc2U2NCkge1xuICAgIHJldHVybiBhcnIudG9CYXNlNjQoKTtcbiAgfVxuICByZXR1cm4gYnRvYShieXRlc1RvU3RyaW5nKGFycikpO1xufVxuZnVuY3Rpb24gZnJvbUJhc2U2NFV0aWwoc3RyKSB7XG4gIGlmIChVaW50OEFycmF5LmZyb21CYXNlNjQpIHtcbiAgICByZXR1cm4gVWludDhBcnJheS5mcm9tQmFzZTY0KHN0cik7XG4gIH1cbiAgcmV0dXJuIHN0cmluZ1RvQnl0ZXMoYXRvYihzdHIpKTtcbn1cbmlmICh0eXBlb2YgUHJvbWlzZS50cnkgIT09IFwiZnVuY3Rpb25cIikge1xuICBQcm9taXNlLnRyeSA9IGZ1bmN0aW9uIChmbiwgLi4uYXJncykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgIH0pO1xuICB9O1xufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9kaXNwbGF5X3V0aWxzLmpzXG5cbmNvbnN0IFNWR19OUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjtcbmNsYXNzIFBpeGVsc1BlckluY2gge1xuICBzdGF0aWMgQ1NTID0gOTYuMDtcbiAgc3RhdGljIFBERiA9IDcyLjA7XG4gIHN0YXRpYyBQREZfVE9fQ1NTX1VOSVRTID0gdGhpcy5DU1MgLyB0aGlzLlBERjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoRGF0YSh1cmwsIHR5cGUgPSBcInRleHRcIikge1xuICBpZiAoaXNWYWxpZEZldGNoVXJsKHVybCwgZG9jdW1lbnQuYmFzZVVSSSkpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJhcnJheWJ1ZmZlclwiOlxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgIGNhc2UgXCJibG9iXCI6XG4gICAgICAgIHJldHVybiByZXNwb25zZS5ibG9iKCk7XG4gICAgICBjYXNlIFwianNvblwiOlxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHJlcXVlc3Qub3BlbihcIkdFVFwiLCB1cmwsIHRydWUpO1xuICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gdHlwZTtcbiAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIGlmIChyZXF1ZXN0LnJlYWR5U3RhdGUgIT09IFhNTEh0dHBSZXF1ZXN0LkRPTkUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAyMDAgfHwgcmVxdWVzdC5zdGF0dXMgPT09IDApIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBcImFycmF5YnVmZmVyXCI6XG4gICAgICAgICAgY2FzZSBcImJsb2JcIjpcbiAgICAgICAgICBjYXNlIFwianNvblwiOlxuICAgICAgICAgICAgcmVzb2x2ZShyZXF1ZXN0LnJlc3BvbnNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVqZWN0KG5ldyBFcnJvcihyZXF1ZXN0LnN0YXR1c1RleHQpKTtcbiAgICB9O1xuICAgIHJlcXVlc3Quc2VuZChudWxsKTtcbiAgfSk7XG59XG5jbGFzcyBQYWdlVmlld3BvcnQge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdmlld0JveCxcbiAgICBzY2FsZSxcbiAgICByb3RhdGlvbixcbiAgICBvZmZzZXRYID0gMCxcbiAgICBvZmZzZXRZID0gMCxcbiAgICBkb250RmxpcCA9IGZhbHNlXG4gIH0pIHtcbiAgICB0aGlzLnZpZXdCb3ggPSB2aWV3Qm94O1xuICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcbiAgICB0aGlzLnJvdGF0aW9uID0gcm90YXRpb247XG4gICAgdGhpcy5vZmZzZXRYID0gb2Zmc2V0WDtcbiAgICB0aGlzLm9mZnNldFkgPSBvZmZzZXRZO1xuICAgIGNvbnN0IGNlbnRlclggPSAodmlld0JveFsyXSArIHZpZXdCb3hbMF0pIC8gMjtcbiAgICBjb25zdCBjZW50ZXJZID0gKHZpZXdCb3hbM10gKyB2aWV3Qm94WzFdKSAvIDI7XG4gICAgbGV0IHJvdGF0ZUEsIHJvdGF0ZUIsIHJvdGF0ZUMsIHJvdGF0ZUQ7XG4gICAgcm90YXRpb24gJT0gMzYwO1xuICAgIGlmIChyb3RhdGlvbiA8IDApIHtcbiAgICAgIHJvdGF0aW9uICs9IDM2MDtcbiAgICB9XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJvdGF0ZUEgPSAtMTtcbiAgICAgICAgcm90YXRlQiA9IDA7XG4gICAgICAgIHJvdGF0ZUMgPSAwO1xuICAgICAgICByb3RhdGVEID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByb3RhdGVBID0gMDtcbiAgICAgICAgcm90YXRlQiA9IDE7XG4gICAgICAgIHJvdGF0ZUMgPSAxO1xuICAgICAgICByb3RhdGVEID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcm90YXRlQSA9IDA7XG4gICAgICAgIHJvdGF0ZUIgPSAtMTtcbiAgICAgICAgcm90YXRlQyA9IC0xO1xuICAgICAgICByb3RhdGVEID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJvdGF0ZUEgPSAxO1xuICAgICAgICByb3RhdGVCID0gMDtcbiAgICAgICAgcm90YXRlQyA9IDA7XG4gICAgICAgIHJvdGF0ZUQgPSAtMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYWdlVmlld3BvcnQ6IEludmFsaWQgcm90YXRpb24sIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA5MCBkZWdyZWVzLlwiKTtcbiAgICB9XG4gICAgaWYgKGRvbnRGbGlwKSB7XG4gICAgICByb3RhdGVDID0gLXJvdGF0ZUM7XG4gICAgICByb3RhdGVEID0gLXJvdGF0ZUQ7XG4gICAgfVxuICAgIGxldCBvZmZzZXRDYW52YXNYLCBvZmZzZXRDYW52YXNZO1xuICAgIGxldCB3aWR0aCwgaGVpZ2h0O1xuICAgIGlmIChyb3RhdGVBID09PSAwKSB7XG4gICAgICBvZmZzZXRDYW52YXNYID0gTWF0aC5hYnMoY2VudGVyWSAtIHZpZXdCb3hbMV0pICogc2NhbGUgKyBvZmZzZXRYO1xuICAgICAgb2Zmc2V0Q2FudmFzWSA9IE1hdGguYWJzKGNlbnRlclggLSB2aWV3Qm94WzBdKSAqIHNjYWxlICsgb2Zmc2V0WTtcbiAgICAgIHdpZHRoID0gKHZpZXdCb3hbM10gLSB2aWV3Qm94WzFdKSAqIHNjYWxlO1xuICAgICAgaGVpZ2h0ID0gKHZpZXdCb3hbMl0gLSB2aWV3Qm94WzBdKSAqIHNjYWxlO1xuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXRDYW52YXNYID0gTWF0aC5hYnMoY2VudGVyWCAtIHZpZXdCb3hbMF0pICogc2NhbGUgKyBvZmZzZXRYO1xuICAgICAgb2Zmc2V0Q2FudmFzWSA9IE1hdGguYWJzKGNlbnRlclkgLSB2aWV3Qm94WzFdKSAqIHNjYWxlICsgb2Zmc2V0WTtcbiAgICAgIHdpZHRoID0gKHZpZXdCb3hbMl0gLSB2aWV3Qm94WzBdKSAqIHNjYWxlO1xuICAgICAgaGVpZ2h0ID0gKHZpZXdCb3hbM10gLSB2aWV3Qm94WzFdKSAqIHNjYWxlO1xuICAgIH1cbiAgICB0aGlzLnRyYW5zZm9ybSA9IFtyb3RhdGVBICogc2NhbGUsIHJvdGF0ZUIgKiBzY2FsZSwgcm90YXRlQyAqIHNjYWxlLCByb3RhdGVEICogc2NhbGUsIG9mZnNldENhbnZhc1ggLSByb3RhdGVBICogc2NhbGUgKiBjZW50ZXJYIC0gcm90YXRlQyAqIHNjYWxlICogY2VudGVyWSwgb2Zmc2V0Q2FudmFzWSAtIHJvdGF0ZUIgKiBzY2FsZSAqIGNlbnRlclggLSByb3RhdGVEICogc2NhbGUgKiBjZW50ZXJZXTtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cbiAgZ2V0IHJhd0RpbXMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdmlld0JveFxuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJyYXdEaW1zXCIsIHtcbiAgICAgIHBhZ2VXaWR0aDogdmlld0JveFsyXSAtIHZpZXdCb3hbMF0sXG4gICAgICBwYWdlSGVpZ2h0OiB2aWV3Qm94WzNdIC0gdmlld0JveFsxXSxcbiAgICAgIHBhZ2VYOiB2aWV3Qm94WzBdLFxuICAgICAgcGFnZVk6IHZpZXdCb3hbMV1cbiAgICB9KTtcbiAgfVxuICBjbG9uZSh7XG4gICAgc2NhbGUgPSB0aGlzLnNjYWxlLFxuICAgIHJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbixcbiAgICBvZmZzZXRYID0gdGhpcy5vZmZzZXRYLFxuICAgIG9mZnNldFkgPSB0aGlzLm9mZnNldFksXG4gICAgZG9udEZsaXAgPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFBhZ2VWaWV3cG9ydCh7XG4gICAgICB2aWV3Qm94OiB0aGlzLnZpZXdCb3guc2xpY2UoKSxcbiAgICAgIHNjYWxlLFxuICAgICAgcm90YXRpb24sXG4gICAgICBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WSxcbiAgICAgIGRvbnRGbGlwXG4gICAgfSk7XG4gIH1cbiAgY29udmVydFRvVmlld3BvcnRQb2ludCh4LCB5KSB7XG4gICAgcmV0dXJuIFV0aWwuYXBwbHlUcmFuc2Zvcm0oW3gsIHldLCB0aGlzLnRyYW5zZm9ybSk7XG4gIH1cbiAgY29udmVydFRvVmlld3BvcnRSZWN0YW5nbGUocmVjdCkge1xuICAgIGNvbnN0IHRvcExlZnQgPSBVdGlsLmFwcGx5VHJhbnNmb3JtKFtyZWN0WzBdLCByZWN0WzFdXSwgdGhpcy50cmFuc2Zvcm0pO1xuICAgIGNvbnN0IGJvdHRvbVJpZ2h0ID0gVXRpbC5hcHBseVRyYW5zZm9ybShbcmVjdFsyXSwgcmVjdFszXV0sIHRoaXMudHJhbnNmb3JtKTtcbiAgICByZXR1cm4gW3RvcExlZnRbMF0sIHRvcExlZnRbMV0sIGJvdHRvbVJpZ2h0WzBdLCBib3R0b21SaWdodFsxXV07XG4gIH1cbiAgY29udmVydFRvUGRmUG9pbnQoeCwgeSkge1xuICAgIHJldHVybiBVdGlsLmFwcGx5SW52ZXJzZVRyYW5zZm9ybShbeCwgeV0sIHRoaXMudHJhbnNmb3JtKTtcbiAgfVxufVxuY2xhc3MgUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZywgZXh0cmFEZWxheSA9IDApIHtcbiAgICBzdXBlcihtc2csIFwiUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uXCIpO1xuICAgIHRoaXMuZXh0cmFEZWxheSA9IGV4dHJhRGVsYXk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzRGF0YVNjaGVtZSh1cmwpIHtcbiAgY29uc3QgaWkgPSB1cmwubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG4gIHdoaWxlIChpIDwgaWkgJiYgdXJsW2ldLnRyaW0oKSA9PT0gXCJcIikge1xuICAgIGkrKztcbiAgfVxuICByZXR1cm4gdXJsLnN1YnN0cmluZyhpLCBpICsgNSkudG9Mb3dlckNhc2UoKSA9PT0gXCJkYXRhOlwiO1xufVxuZnVuY3Rpb24gaXNQZGZGaWxlKGZpbGVuYW1lKSB7XG4gIHJldHVybiB0eXBlb2YgZmlsZW5hbWUgPT09IFwic3RyaW5nXCIgJiYgL1xcLnBkZiQvaS50ZXN0KGZpbGVuYW1lKTtcbn1cbmZ1bmN0aW9uIGdldEZpbGVuYW1lRnJvbVVybCh1cmwpIHtcbiAgW3VybF0gPSB1cmwuc3BsaXQoL1sjP10vLCAxKTtcbiAgcmV0dXJuIHVybC5zdWJzdHJpbmcodXJsLmxhc3RJbmRleE9mKFwiL1wiKSArIDEpO1xufVxuZnVuY3Rpb24gZ2V0UGRmRmlsZW5hbWVGcm9tVXJsKHVybCwgZGVmYXVsdEZpbGVuYW1lID0gXCJkb2N1bWVudC5wZGZcIikge1xuICBpZiAodHlwZW9mIHVybCAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBkZWZhdWx0RmlsZW5hbWU7XG4gIH1cbiAgaWYgKGlzRGF0YVNjaGVtZSh1cmwpKSB7XG4gICAgd2FybignZ2V0UGRmRmlsZW5hbWVGcm9tVXJsOiBpZ25vcmUgXCJkYXRhOlwiLVVSTCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4nKTtcbiAgICByZXR1cm4gZGVmYXVsdEZpbGVuYW1lO1xuICB9XG4gIGNvbnN0IHJlVVJJID0gL14oPzooPzpbXjpdKzopP1xcL1xcL1teL10rKT8oW14/I10qKShcXD9bXiNdKik/KCMuKik/JC87XG4gIGNvbnN0IHJlRmlsZW5hbWUgPSAvW14vPyM9XStcXC5wZGZcXGIoPyEuKlxcLnBkZlxcYikvaTtcbiAgY29uc3Qgc3BsaXRVUkkgPSByZVVSSS5leGVjKHVybCk7XG4gIGxldCBzdWdnZXN0ZWRGaWxlbmFtZSA9IHJlRmlsZW5hbWUuZXhlYyhzcGxpdFVSSVsxXSkgfHwgcmVGaWxlbmFtZS5leGVjKHNwbGl0VVJJWzJdKSB8fCByZUZpbGVuYW1lLmV4ZWMoc3BsaXRVUklbM10pO1xuICBpZiAoc3VnZ2VzdGVkRmlsZW5hbWUpIHtcbiAgICBzdWdnZXN0ZWRGaWxlbmFtZSA9IHN1Z2dlc3RlZEZpbGVuYW1lWzBdO1xuICAgIGlmIChzdWdnZXN0ZWRGaWxlbmFtZS5pbmNsdWRlcyhcIiVcIikpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN1Z2dlc3RlZEZpbGVuYW1lID0gcmVGaWxlbmFtZS5leGVjKGRlY29kZVVSSUNvbXBvbmVudChzdWdnZXN0ZWRGaWxlbmFtZSkpWzBdO1xuICAgICAgfSBjYXRjaCB7fVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3VnZ2VzdGVkRmlsZW5hbWUgfHwgZGVmYXVsdEZpbGVuYW1lO1xufVxuY2xhc3MgU3RhdFRpbWVyIHtcbiAgc3RhcnRlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRpbWVzID0gW107XG4gIHRpbWUobmFtZSkge1xuICAgIGlmIChuYW1lIGluIHRoaXMuc3RhcnRlZCkge1xuICAgICAgd2FybihgVGltZXIgaXMgYWxyZWFkeSBydW5uaW5nIGZvciAke25hbWV9YCk7XG4gICAgfVxuICAgIHRoaXMuc3RhcnRlZFtuYW1lXSA9IERhdGUubm93KCk7XG4gIH1cbiAgdGltZUVuZChuYW1lKSB7XG4gICAgaWYgKCEobmFtZSBpbiB0aGlzLnN0YXJ0ZWQpKSB7XG4gICAgICB3YXJuKGBUaW1lciBoYXMgbm90IGJlZW4gc3RhcnRlZCBmb3IgJHtuYW1lfWApO1xuICAgIH1cbiAgICB0aGlzLnRpbWVzLnB1c2goe1xuICAgICAgbmFtZSxcbiAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0ZWRbbmFtZV0sXG4gICAgICBlbmQ6IERhdGUubm93KClcbiAgICB9KTtcbiAgICBkZWxldGUgdGhpcy5zdGFydGVkW25hbWVdO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IG91dEJ1ZiA9IFtdO1xuICAgIGxldCBsb25nZXN0ID0gMDtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIG5hbWVcbiAgICB9IG9mIHRoaXMudGltZXMpIHtcbiAgICAgIGxvbmdlc3QgPSBNYXRoLm1heChuYW1lLmxlbmd0aCwgbG9uZ2VzdCk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kXG4gICAgfSBvZiB0aGlzLnRpbWVzKSB7XG4gICAgICBvdXRCdWYucHVzaChgJHtuYW1lLnBhZEVuZChsb25nZXN0KX0gJHtlbmQgLSBzdGFydH1tc1xcbmApO1xuICAgIH1cbiAgICByZXR1cm4gb3V0QnVmLmpvaW4oXCJcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzVmFsaWRGZXRjaFVybCh1cmwsIGJhc2VVcmwpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7XG4gICAgICBwcm90b2NvbFxuICAgIH0gPSBiYXNlVXJsID8gbmV3IFVSTCh1cmwsIGJhc2VVcmwpIDogbmV3IFVSTCh1cmwpO1xuICAgIHJldHVybiBwcm90b2NvbCA9PT0gXCJodHRwOlwiIHx8IHByb3RvY29sID09PSBcImh0dHBzOlwiO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIG5vQ29udGV4dE1lbnUoZSkge1xuICBlLnByZXZlbnREZWZhdWx0KCk7XG59XG5mdW5jdGlvbiBzdG9wRXZlbnQoZSkge1xuICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG59XG5mdW5jdGlvbiBkZXByZWNhdGVkKGRldGFpbHMpIHtcbiAgY29uc29sZS5sb2coXCJEZXByZWNhdGVkIEFQSSB1c2FnZTogXCIgKyBkZXRhaWxzKTtcbn1cbmNsYXNzIFBERkRhdGVTdHJpbmcge1xuICBzdGF0aWMgI3JlZ2V4O1xuICBzdGF0aWMgdG9EYXRlT2JqZWN0KGlucHV0KSB7XG4gICAgaWYgKCFpbnB1dCB8fCB0eXBlb2YgaW5wdXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0aGlzLiNyZWdleCB8fD0gbmV3IFJlZ0V4cChcIl5EOlwiICsgXCIoXFxcXGR7NH0pXCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihbWnwrfC1dKT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiJz9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiJz9cIik7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHRoaXMuI3JlZ2V4LmV4ZWMoaW5wdXQpO1xuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHllYXIgPSBwYXJzZUludChtYXRjaGVzWzFdLCAxMCk7XG4gICAgbGV0IG1vbnRoID0gcGFyc2VJbnQobWF0Y2hlc1syXSwgMTApO1xuICAgIG1vbnRoID0gbW9udGggPj0gMSAmJiBtb250aCA8PSAxMiA/IG1vbnRoIC0gMSA6IDA7XG4gICAgbGV0IGRheSA9IHBhcnNlSW50KG1hdGNoZXNbM10sIDEwKTtcbiAgICBkYXkgPSBkYXkgPj0gMSAmJiBkYXkgPD0gMzEgPyBkYXkgOiAxO1xuICAgIGxldCBob3VyID0gcGFyc2VJbnQobWF0Y2hlc1s0XSwgMTApO1xuICAgIGhvdXIgPSBob3VyID49IDAgJiYgaG91ciA8PSAyMyA/IGhvdXIgOiAwO1xuICAgIGxldCBtaW51dGUgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMCk7XG4gICAgbWludXRlID0gbWludXRlID49IDAgJiYgbWludXRlIDw9IDU5ID8gbWludXRlIDogMDtcbiAgICBsZXQgc2Vjb25kID0gcGFyc2VJbnQobWF0Y2hlc1s2XSwgMTApO1xuICAgIHNlY29uZCA9IHNlY29uZCA+PSAwICYmIHNlY29uZCA8PSA1OSA/IHNlY29uZCA6IDA7XG4gICAgY29uc3QgdW5pdmVyc2FsVGltZVJlbGF0aW9uID0gbWF0Y2hlc1s3XSB8fCBcIlpcIjtcbiAgICBsZXQgb2Zmc2V0SG91ciA9IHBhcnNlSW50KG1hdGNoZXNbOF0sIDEwKTtcbiAgICBvZmZzZXRIb3VyID0gb2Zmc2V0SG91ciA+PSAwICYmIG9mZnNldEhvdXIgPD0gMjMgPyBvZmZzZXRIb3VyIDogMDtcbiAgICBsZXQgb2Zmc2V0TWludXRlID0gcGFyc2VJbnQobWF0Y2hlc1s5XSwgMTApIHx8IDA7XG4gICAgb2Zmc2V0TWludXRlID0gb2Zmc2V0TWludXRlID49IDAgJiYgb2Zmc2V0TWludXRlIDw9IDU5ID8gb2Zmc2V0TWludXRlIDogMDtcbiAgICBpZiAodW5pdmVyc2FsVGltZVJlbGF0aW9uID09PSBcIi1cIikge1xuICAgICAgaG91ciArPSBvZmZzZXRIb3VyO1xuICAgICAgbWludXRlICs9IG9mZnNldE1pbnV0ZTtcbiAgICB9IGVsc2UgaWYgKHVuaXZlcnNhbFRpbWVSZWxhdGlvbiA9PT0gXCIrXCIpIHtcbiAgICAgIGhvdXIgLT0gb2Zmc2V0SG91cjtcbiAgICAgIG1pbnV0ZSAtPSBvZmZzZXRNaW51dGU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCkpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRYZmFQYWdlVmlld3BvcnQoeGZhUGFnZSwge1xuICBzY2FsZSA9IDEsXG4gIHJvdGF0aW9uID0gMFxufSkge1xuICBjb25zdCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH0gPSB4ZmFQYWdlLmF0dHJpYnV0ZXMuc3R5bGU7XG4gIGNvbnN0IHZpZXdCb3ggPSBbMCwgMCwgcGFyc2VJbnQod2lkdGgpLCBwYXJzZUludChoZWlnaHQpXTtcbiAgcmV0dXJuIG5ldyBQYWdlVmlld3BvcnQoe1xuICAgIHZpZXdCb3gsXG4gICAgc2NhbGUsXG4gICAgcm90YXRpb25cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRSR0IoY29sb3IpIHtcbiAgaWYgKGNvbG9yLnN0YXJ0c1dpdGgoXCIjXCIpKSB7XG4gICAgY29uc3QgY29sb3JSR0IgPSBwYXJzZUludChjb2xvci5zbGljZSgxKSwgMTYpO1xuICAgIHJldHVybiBbKGNvbG9yUkdCICYgMHhmZjAwMDApID4+IDE2LCAoY29sb3JSR0IgJiAweDAwZmYwMCkgPj4gOCwgY29sb3JSR0IgJiAweDAwMDBmZl07XG4gIH1cbiAgaWYgKGNvbG9yLnN0YXJ0c1dpdGgoXCJyZ2IoXCIpKSB7XG4gICAgcmV0dXJuIGNvbG9yLnNsaWNlKDQsIC0xKS5zcGxpdChcIixcIikubWFwKHggPT4gcGFyc2VJbnQoeCkpO1xuICB9XG4gIGlmIChjb2xvci5zdGFydHNXaXRoKFwicmdiYShcIikpIHtcbiAgICByZXR1cm4gY29sb3Iuc2xpY2UoNSwgLTEpLnNwbGl0KFwiLFwiKS5tYXAoeCA9PiBwYXJzZUludCh4KSkuc2xpY2UoMCwgMyk7XG4gIH1cbiAgd2FybihgTm90IGEgdmFsaWQgY29sb3IgZm9ybWF0OiBcIiR7Y29sb3J9XCJgKTtcbiAgcmV0dXJuIFswLCAwLCAwXTtcbn1cbmZ1bmN0aW9uIGdldENvbG9yVmFsdWVzKGNvbG9ycykge1xuICBjb25zdCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gIHNwYW4uc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kKHNwYW4pO1xuICBmb3IgKGNvbnN0IG5hbWUgb2YgY29sb3JzLmtleXMoKSkge1xuICAgIHNwYW4uc3R5bGUuY29sb3IgPSBuYW1lO1xuICAgIGNvbnN0IGNvbXB1dGVkQ29sb3IgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzcGFuKS5jb2xvcjtcbiAgICBjb2xvcnMuc2V0KG5hbWUsIGdldFJHQihjb21wdXRlZENvbG9yKSk7XG4gIH1cbiAgc3Bhbi5yZW1vdmUoKTtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KSB7XG4gIGNvbnN0IHtcbiAgICBhLFxuICAgIGIsXG4gICAgYyxcbiAgICBkLFxuICAgIGUsXG4gICAgZlxuICB9ID0gY3R4LmdldFRyYW5zZm9ybSgpO1xuICByZXR1cm4gW2EsIGIsIGMsIGQsIGUsIGZdO1xufVxuZnVuY3Rpb24gZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoY3R4KSB7XG4gIGNvbnN0IHtcbiAgICBhLFxuICAgIGIsXG4gICAgYyxcbiAgICBkLFxuICAgIGUsXG4gICAgZlxuICB9ID0gY3R4LmdldFRyYW5zZm9ybSgpLmludmVydFNlbGYoKTtcbiAgcmV0dXJuIFthLCBiLCBjLCBkLCBlLCBmXTtcbn1cbmZ1bmN0aW9uIHNldExheWVyRGltZW5zaW9ucyhkaXYsIHZpZXdwb3J0LCBtdXN0RmxpcCA9IGZhbHNlLCBtdXN0Um90YXRlID0gdHJ1ZSkge1xuICBpZiAodmlld3BvcnQgaW5zdGFuY2VvZiBQYWdlVmlld3BvcnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0XG4gICAgfSA9IHZpZXdwb3J0LnJhd0RpbXM7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gZGl2O1xuICAgIGNvbnN0IHVzZVJvdW5kID0gdXRpbF9GZWF0dXJlVGVzdC5pc0NTU1JvdW5kU3VwcG9ydGVkO1xuICAgIGNvbnN0IHcgPSBgdmFyKC0tc2NhbGUtZmFjdG9yKSAqICR7cGFnZVdpZHRofXB4YCxcbiAgICAgIGggPSBgdmFyKC0tc2NhbGUtZmFjdG9yKSAqICR7cGFnZUhlaWdodH1weGA7XG4gICAgY29uc3Qgd2lkdGhTdHIgPSB1c2VSb3VuZCA/IGByb3VuZChkb3duLCAke3d9LCB2YXIoLS1zY2FsZS1yb3VuZC14LCAxcHgpKWAgOiBgY2FsYygke3d9KWAsXG4gICAgICBoZWlnaHRTdHIgPSB1c2VSb3VuZCA/IGByb3VuZChkb3duLCAke2h9LCB2YXIoLS1zY2FsZS1yb3VuZC15LCAxcHgpKWAgOiBgY2FsYygke2h9KWA7XG4gICAgaWYgKCFtdXN0RmxpcCB8fCB2aWV3cG9ydC5yb3RhdGlvbiAlIDE4MCA9PT0gMCkge1xuICAgICAgc3R5bGUud2lkdGggPSB3aWR0aFN0cjtcbiAgICAgIHN0eWxlLmhlaWdodCA9IGhlaWdodFN0cjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUud2lkdGggPSBoZWlnaHRTdHI7XG4gICAgICBzdHlsZS5oZWlnaHQgPSB3aWR0aFN0cjtcbiAgICB9XG4gIH1cbiAgaWYgKG11c3RSb3RhdGUpIHtcbiAgICBkaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1tYWluLXJvdGF0aW9uXCIsIHZpZXdwb3J0LnJvdGF0aW9uKTtcbiAgfVxufVxuY2xhc3MgT3V0cHV0U2NhbGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zdCBwaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICB0aGlzLnN4ID0gcGl4ZWxSYXRpbztcbiAgICB0aGlzLnN5ID0gcGl4ZWxSYXRpbztcbiAgfVxuICBnZXQgc2NhbGVkKCkge1xuICAgIHJldHVybiB0aGlzLnN4ICE9PSAxIHx8IHRoaXMuc3kgIT09IDE7XG4gIH1cbiAgZ2V0IHN5bW1ldHJpYygpIHtcbiAgICByZXR1cm4gdGhpcy5zeCA9PT0gdGhpcy5zeTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvdG9vbGJhci5qc1xuXG5jbGFzcyBFZGl0b3JUb29sYmFyIHtcbiAgI3Rvb2xiYXIgPSBudWxsO1xuICAjY29sb3JQaWNrZXIgPSBudWxsO1xuICAjZWRpdG9yO1xuICAjYnV0dG9ucyA9IG51bGw7XG4gICNhbHRUZXh0ID0gbnVsbDtcbiAgc3RhdGljICNsMTBuUmVtb3ZlID0gbnVsbDtcbiAgY29uc3RydWN0b3IoZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9yID0gZWRpdG9yO1xuICAgIEVkaXRvclRvb2xiYXIuI2wxMG5SZW1vdmUgfHw9IE9iamVjdC5mcmVlemUoe1xuICAgICAgZnJlZXRleHQ6IFwicGRmanMtZWRpdG9yLXJlbW92ZS1mcmVldGV4dC1idXR0b25cIixcbiAgICAgIGhpZ2hsaWdodDogXCJwZGZqcy1lZGl0b3ItcmVtb3ZlLWhpZ2hsaWdodC1idXR0b25cIixcbiAgICAgIGluazogXCJwZGZqcy1lZGl0b3ItcmVtb3ZlLWluay1idXR0b25cIixcbiAgICAgIHN0YW1wOiBcInBkZmpzLWVkaXRvci1yZW1vdmUtc3RhbXAtYnV0dG9uXCJcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgZWRpdFRvb2xiYXIgPSB0aGlzLiN0b29sYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBlZGl0VG9vbGJhci5jbGFzc0xpc3QuYWRkKFwiZWRpdFRvb2xiYXJcIiwgXCJoaWRkZW5cIik7XG4gICAgZWRpdFRvb2xiYXIuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInRvb2xiYXJcIik7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jZWRpdG9yLl91aU1hbmFnZXIuX3NpZ25hbDtcbiAgICBlZGl0VG9vbGJhci5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZWRpdFRvb2xiYXIuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIEVkaXRvclRvb2xiYXIuI3BvaW50ZXJEb3duLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBjb25zdCBidXR0b25zID0gdGhpcy4jYnV0dG9ucyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgYnV0dG9ucy5jbGFzc05hbWUgPSBcImJ1dHRvbnNcIjtcbiAgICBlZGl0VG9vbGJhci5hcHBlbmQoYnV0dG9ucyk7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLiNlZGl0b3IudG9vbGJhclBvc2l0aW9uO1xuICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzdHlsZVxuICAgICAgfSA9IGVkaXRUb29sYmFyO1xuICAgICAgY29uc3QgeCA9IHRoaXMuI2VkaXRvci5fdWlNYW5hZ2VyLmRpcmVjdGlvbiA9PT0gXCJsdHJcIiA/IDEgLSBwb3NpdGlvblswXSA6IHBvc2l0aW9uWzBdO1xuICAgICAgc3R5bGUuaW5zZXRJbmxpbmVFbmQgPSBgJHsxMDAgKiB4fSVgO1xuICAgICAgc3R5bGUudG9wID0gYGNhbGMoJHsxMDAgKiBwb3NpdGlvblsxXX0lICsgdmFyKC0tZWRpdG9yLXRvb2xiYXItdmVydC1vZmZzZXQpKWA7XG4gICAgfVxuICAgIHRoaXMuI2FkZERlbGV0ZUJ1dHRvbigpO1xuICAgIHJldHVybiBlZGl0VG9vbGJhcjtcbiAgfVxuICBnZXQgZGl2KCkge1xuICAgIHJldHVybiB0aGlzLiN0b29sYmFyO1xuICB9XG4gIHN0YXRpYyAjcG9pbnRlckRvd24oZSkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cbiAgI2ZvY3VzSW4oZSkge1xuICAgIHRoaXMuI2VkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gZmFsc2U7XG4gICAgc3RvcEV2ZW50KGUpO1xuICB9XG4gICNmb2N1c091dChlKSB7XG4gICAgdGhpcy4jZWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSB0cnVlO1xuICAgIHN0b3BFdmVudChlKTtcbiAgfVxuICAjYWRkTGlzdGVuZXJzVG9FbGVtZW50KGVsZW1lbnQpIHtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLiNlZGl0b3IuX3VpTWFuYWdlci5fc2lnbmFsO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgdGhpcy4jZm9jdXNJbi5iaW5kKHRoaXMpLCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgdGhpcy4jZm9jdXNPdXQuYmluZCh0aGlzKSwge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG5vQ29udGV4dE1lbnUsIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgdGhpcy4jdG9vbGJhci5jbGFzc0xpc3QuYWRkKFwiaGlkZGVuXCIpO1xuICAgIHRoaXMuI2NvbG9yUGlja2VyPy5oaWRlRHJvcGRvd24oKTtcbiAgfVxuICBzaG93KCkge1xuICAgIHRoaXMuI3Rvb2xiYXIuY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKTtcbiAgICB0aGlzLiNhbHRUZXh0Py5zaG93bigpO1xuICB9XG4gICNhZGREZWxldGVCdXR0b24oKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWRpdG9yVHlwZSxcbiAgICAgIF91aU1hbmFnZXJcbiAgICB9ID0gdGhpcy4jZWRpdG9yO1xuICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgYnV0dG9uLmNsYXNzTmFtZSA9IFwiZGVsZXRlXCI7XG4gICAgYnV0dG9uLnRhYkluZGV4ID0gMDtcbiAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIEVkaXRvclRvb2xiYXIuI2wxMG5SZW1vdmVbZWRpdG9yVHlwZV0pO1xuICAgIHRoaXMuI2FkZExpc3RlbmVyc1RvRWxlbWVudChidXR0b24pO1xuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZSA9PiB7XG4gICAgICBfdWlNYW5hZ2VyLmRlbGV0ZSgpO1xuICAgIH0sIHtcbiAgICAgIHNpZ25hbDogX3VpTWFuYWdlci5fc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy4jYnV0dG9ucy5hcHBlbmQoYnV0dG9uKTtcbiAgfVxuICBnZXQgI2RpdmlkZXIoKSB7XG4gICAgY29uc3QgZGl2aWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZGl2aWRlci5jbGFzc05hbWUgPSBcImRpdmlkZXJcIjtcbiAgICByZXR1cm4gZGl2aWRlcjtcbiAgfVxuICBhc3luYyBhZGRBbHRUZXh0KGFsdFRleHQpIHtcbiAgICBjb25zdCBidXR0b24gPSBhd2FpdCBhbHRUZXh0LnJlbmRlcigpO1xuICAgIHRoaXMuI2FkZExpc3RlbmVyc1RvRWxlbWVudChidXR0b24pO1xuICAgIHRoaXMuI2J1dHRvbnMucHJlcGVuZChidXR0b24sIHRoaXMuI2RpdmlkZXIpO1xuICAgIHRoaXMuI2FsdFRleHQgPSBhbHRUZXh0O1xuICB9XG4gIGFkZENvbG9yUGlja2VyKGNvbG9yUGlja2VyKSB7XG4gICAgdGhpcy4jY29sb3JQaWNrZXIgPSBjb2xvclBpY2tlcjtcbiAgICBjb25zdCBidXR0b24gPSBjb2xvclBpY2tlci5yZW5kZXJCdXR0b24oKTtcbiAgICB0aGlzLiNhZGRMaXN0ZW5lcnNUb0VsZW1lbnQoYnV0dG9uKTtcbiAgICB0aGlzLiNidXR0b25zLnByZXBlbmQoYnV0dG9uLCB0aGlzLiNkaXZpZGVyKTtcbiAgfVxuICByZW1vdmUoKSB7XG4gICAgdGhpcy4jdG9vbGJhci5yZW1vdmUoKTtcbiAgICB0aGlzLiNjb2xvclBpY2tlcj8uZGVzdHJveSgpO1xuICAgIHRoaXMuI2NvbG9yUGlja2VyID0gbnVsbDtcbiAgfVxufVxuY2xhc3MgSGlnaGxpZ2h0VG9vbGJhciB7XG4gICNidXR0b25zID0gbnVsbDtcbiAgI3Rvb2xiYXIgPSBudWxsO1xuICAjdWlNYW5hZ2VyO1xuICBjb25zdHJ1Y3Rvcih1aU1hbmFnZXIpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIgPSB1aU1hbmFnZXI7XG4gIH1cbiAgI3JlbmRlcigpIHtcbiAgICBjb25zdCBlZGl0VG9vbGJhciA9IHRoaXMuI3Rvb2xiYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGVkaXRUb29sYmFyLmNsYXNzTmFtZSA9IFwiZWRpdFRvb2xiYXJcIjtcbiAgICBlZGl0VG9vbGJhci5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwidG9vbGJhclwiKTtcbiAgICBlZGl0VG9vbGJhci5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgc2lnbmFsOiB0aGlzLiN1aU1hbmFnZXIuX3NpZ25hbFxuICAgIH0pO1xuICAgIGNvbnN0IGJ1dHRvbnMgPSB0aGlzLiNidXR0b25zID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBidXR0b25zLmNsYXNzTmFtZSA9IFwiYnV0dG9uc1wiO1xuICAgIGVkaXRUb29sYmFyLmFwcGVuZChidXR0b25zKTtcbiAgICB0aGlzLiNhZGRIaWdobGlnaHRCdXR0b24oKTtcbiAgICByZXR1cm4gZWRpdFRvb2xiYXI7XG4gIH1cbiAgI2dldExhc3RQb2ludChib3hlcywgaXNMVFIpIHtcbiAgICBsZXQgbGFzdFkgPSAwO1xuICAgIGxldCBsYXN0WCA9IDA7XG4gICAgZm9yIChjb25zdCBib3ggb2YgYm94ZXMpIHtcbiAgICAgIGNvbnN0IHkgPSBib3gueSArIGJveC5oZWlnaHQ7XG4gICAgICBpZiAoeSA8IGxhc3RZKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgeCA9IGJveC54ICsgKGlzTFRSID8gYm94LndpZHRoIDogMCk7XG4gICAgICBpZiAoeSA+IGxhc3RZKSB7XG4gICAgICAgIGxhc3RYID0geDtcbiAgICAgICAgbGFzdFkgPSB5O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0xUUikge1xuICAgICAgICBpZiAoeCA+IGxhc3RYKSB7XG4gICAgICAgICAgbGFzdFggPSB4O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHggPCBsYXN0WCkge1xuICAgICAgICBsYXN0WCA9IHg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbaXNMVFIgPyAxIC0gbGFzdFggOiBsYXN0WCwgbGFzdFldO1xuICB9XG4gIHNob3cocGFyZW50LCBib3hlcywgaXNMVFIpIHtcbiAgICBjb25zdCBbeCwgeV0gPSB0aGlzLiNnZXRMYXN0UG9pbnQoYm94ZXMsIGlzTFRSKTtcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSB0aGlzLiN0b29sYmFyIHx8PSB0aGlzLiNyZW5kZXIoKTtcbiAgICBwYXJlbnQuYXBwZW5kKHRoaXMuI3Rvb2xiYXIpO1xuICAgIHN0eWxlLmluc2V0SW5saW5lRW5kID0gYCR7MTAwICogeH0lYDtcbiAgICBzdHlsZS50b3AgPSBgY2FsYygkezEwMCAqIHl9JSArIHZhcigtLWVkaXRvci10b29sYmFyLXZlcnQtb2Zmc2V0KSlgO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgdGhpcy4jdG9vbGJhci5yZW1vdmUoKTtcbiAgfVxuICAjYWRkSGlnaGxpZ2h0QnV0dG9uKCkge1xuICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgYnV0dG9uLmNsYXNzTmFtZSA9IFwiaGlnaGxpZ2h0QnV0dG9uXCI7XG4gICAgYnV0dG9uLnRhYkluZGV4ID0gMDtcbiAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIGBwZGZqcy1oaWdobGlnaHQtZmxvYXRpbmctYnV0dG9uMWApO1xuICAgIGNvbnN0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBidXR0b24uYXBwZW5kKHNwYW4pO1xuICAgIHNwYW4uY2xhc3NOYW1lID0gXCJ2aXN1YWxseUhpZGRlblwiO1xuICAgIHNwYW4uc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtaGlnaGxpZ2h0LWZsb2F0aW5nLWJ1dHRvbi1sYWJlbFwiKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLiN1aU1hbmFnZXIuX3NpZ25hbDtcbiAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG5vQ29udGV4dE1lbnUsIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLmhpZ2hsaWdodFNlbGVjdGlvbihcImZsb2F0aW5nX2J1dHRvblwiKTtcbiAgICB9LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLiNidXR0b25zLmFwcGVuZChidXR0b24pO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci90b29scy5qc1xuXG5cblxuZnVuY3Rpb24gYmluZEV2ZW50cyhvYmosIGVsZW1lbnQsIG5hbWVzKSB7XG4gIGZvciAoY29uc3QgbmFtZSBvZiBuYW1lcykge1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBvYmpbbmFtZV0uYmluZChvYmopKTtcbiAgfVxufVxuZnVuY3Rpb24gb3BhY2l0eVRvSGV4KG9wYWNpdHkpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5taW4oMjU1LCBNYXRoLm1heCgxLCAyNTUgKiBvcGFjaXR5KSkpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIik7XG59XG5jbGFzcyBJZE1hbmFnZXIge1xuICAjaWQgPSAwO1xuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIGAke0Fubm90YXRpb25FZGl0b3JQcmVmaXh9JHt0aGlzLiNpZCsrfWA7XG4gIH1cbn1cbmNsYXNzIEltYWdlTWFuYWdlciB7XG4gICNiYXNlSWQgPSBnZXRVdWlkKCk7XG4gICNpZCA9IDA7XG4gICNjYWNoZSA9IG51bGw7XG4gIHN0YXRpYyBnZXQgX2lzU1ZHRml0dGluZ0NhbnZhcygpIHtcbiAgICBjb25zdCBzdmcgPSBgZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9VVRGLTgsPHN2ZyB2aWV3Qm94PVwiMCAwIDEgMVwiIHdpZHRoPVwiMVwiIGhlaWdodD1cIjFcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PHJlY3Qgd2lkdGg9XCIxXCIgaGVpZ2h0PVwiMVwiIHN0eWxlPVwiZmlsbDpyZWQ7XCIvPjwvc3ZnPmA7XG4gICAgY29uc3QgY2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcygxLCAzKTtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZVxuICAgIH0pO1xuICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgaW1hZ2Uuc3JjID0gc3ZnO1xuICAgIGNvbnN0IHByb21pc2UgPSBpbWFnZS5kZWNvZGUoKS50aGVuKCgpID0+IHtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIDEsIDEsIDAsIDAsIDEsIDMpO1xuICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpLmRhdGEuYnVmZmVyKVswXSA9PT0gMDtcbiAgICB9KTtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2lzU1ZHRml0dGluZ0NhbnZhc1wiLCBwcm9taXNlKTtcbiAgfVxuICBhc3luYyAjZ2V0KGtleSwgcmF3RGF0YSkge1xuICAgIHRoaXMuI2NhY2hlIHx8PSBuZXcgTWFwKCk7XG4gICAgbGV0IGRhdGEgPSB0aGlzLiNjYWNoZS5nZXQoa2V5KTtcbiAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChkYXRhPy5iaXRtYXApIHtcbiAgICAgIGRhdGEucmVmQ291bnRlciArPSAxO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBkYXRhIHx8PSB7XG4gICAgICAgIGJpdG1hcDogbnVsbCxcbiAgICAgICAgaWQ6IGBpbWFnZV8ke3RoaXMuI2Jhc2VJZH1fJHt0aGlzLiNpZCsrfWAsXG4gICAgICAgIHJlZkNvdW50ZXI6IDAsXG4gICAgICAgIGlzU3ZnOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGxldCBpbWFnZTtcbiAgICAgIGlmICh0eXBlb2YgcmF3RGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBkYXRhLnVybCA9IHJhd0RhdGE7XG4gICAgICAgIGltYWdlID0gYXdhaXQgZmV0Y2hEYXRhKHJhd0RhdGEsIFwiYmxvYlwiKTtcbiAgICAgIH0gZWxzZSBpZiAocmF3RGF0YSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgaW1hZ2UgPSBkYXRhLmZpbGUgPSByYXdEYXRhO1xuICAgICAgfSBlbHNlIGlmIChyYXdEYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICBpbWFnZSA9IHJhd0RhdGE7XG4gICAgICB9XG4gICAgICBpZiAoaW1hZ2UudHlwZSA9PT0gXCJpbWFnZS9zdmcreG1sXCIpIHtcbiAgICAgICAgY29uc3QgbXVzdFJlbW92ZUFzcGVjdFJhdGlvUHJvbWlzZSA9IEltYWdlTWFuYWdlci5faXNTVkdGaXR0aW5nQ2FudmFzO1xuICAgICAgICBjb25zdCBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgY29uc3QgaW1hZ2VFbGVtZW50ID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGNvbnN0IGltYWdlUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBpbWFnZUVsZW1lbnQub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgZGF0YS5iaXRtYXAgPSBpbWFnZUVsZW1lbnQ7XG4gICAgICAgICAgICBkYXRhLmlzU3ZnID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gZGF0YS5zdmdVcmwgPSBmaWxlUmVhZGVyLnJlc3VsdDtcbiAgICAgICAgICAgIGltYWdlRWxlbWVudC5zcmMgPSAoYXdhaXQgbXVzdFJlbW92ZUFzcGVjdFJhdGlvUHJvbWlzZSkgPyBgJHt1cmx9I3N2Z1ZpZXcocHJlc2VydmVBc3BlY3RSYXRpbyhub25lKSlgIDogdXJsO1xuICAgICAgICAgIH07XG4gICAgICAgICAgaW1hZ2VFbGVtZW50Lm9uZXJyb3IgPSBmaWxlUmVhZGVyLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICBmaWxlUmVhZGVyLnJlYWRBc0RhdGFVUkwoaW1hZ2UpO1xuICAgICAgICBhd2FpdCBpbWFnZVByb21pc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhLmJpdG1hcCA9IGF3YWl0IGNyZWF0ZUltYWdlQml0bWFwKGltYWdlKTtcbiAgICAgIH1cbiAgICAgIGRhdGEucmVmQ291bnRlciA9IDE7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgd2FybihlKTtcbiAgICAgIGRhdGEgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLiNjYWNoZS5zZXQoa2V5LCBkYXRhKTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgdGhpcy4jY2FjaGUuc2V0KGRhdGEuaWQsIGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBhc3luYyBnZXRGcm9tRmlsZShmaWxlKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGFzdE1vZGlmaWVkLFxuICAgICAgbmFtZSxcbiAgICAgIHNpemUsXG4gICAgICB0eXBlXG4gICAgfSA9IGZpbGU7XG4gICAgcmV0dXJuIHRoaXMuI2dldChgJHtsYXN0TW9kaWZpZWR9XyR7bmFtZX1fJHtzaXplfV8ke3R5cGV9YCwgZmlsZSk7XG4gIH1cbiAgYXN5bmMgZ2V0RnJvbVVybCh1cmwpIHtcbiAgICByZXR1cm4gdGhpcy4jZ2V0KHVybCwgdXJsKTtcbiAgfVxuICBhc3luYyBnZXRGcm9tQmxvYihpZCwgYmxvYlByb21pc2UpIHtcbiAgICBjb25zdCBibG9iID0gYXdhaXQgYmxvYlByb21pc2U7XG4gICAgcmV0dXJuIHRoaXMuI2dldChpZCwgYmxvYik7XG4gIH1cbiAgYXN5bmMgZ2V0RnJvbUlkKGlkKSB7XG4gICAgdGhpcy4jY2FjaGUgfHw9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy4jY2FjaGUuZ2V0KGlkKTtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZGF0YS5iaXRtYXApIHtcbiAgICAgIGRhdGEucmVmQ291bnRlciArPSAxO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmIChkYXRhLmZpbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEZyb21GaWxlKGRhdGEuZmlsZSk7XG4gICAgfVxuICAgIGlmIChkYXRhLmJsb2JQcm9taXNlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGJsb2JQcm9taXNlXG4gICAgICB9ID0gZGF0YTtcbiAgICAgIGRlbGV0ZSBkYXRhLmJsb2JQcm9taXNlO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RnJvbUJsb2IoZGF0YS5pZCwgYmxvYlByb21pc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRGcm9tVXJsKGRhdGEudXJsKTtcbiAgfVxuICBnZXRGcm9tQ2FudmFzKGlkLCBjYW52YXMpIHtcbiAgICB0aGlzLiNjYWNoZSB8fD0gbmV3IE1hcCgpO1xuICAgIGxldCBkYXRhID0gdGhpcy4jY2FjaGUuZ2V0KGlkKTtcbiAgICBpZiAoZGF0YT8uYml0bWFwKSB7XG4gICAgICBkYXRhLnJlZkNvdW50ZXIgKz0gMTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBjb25zdCBvZmZzY3JlZW4gPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgY29uc3QgY3R4ID0gb2Zmc2NyZWVuLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBjdHguZHJhd0ltYWdlKGNhbnZhcywgMCwgMCk7XG4gICAgZGF0YSA9IHtcbiAgICAgIGJpdG1hcDogb2Zmc2NyZWVuLnRyYW5zZmVyVG9JbWFnZUJpdG1hcCgpLFxuICAgICAgaWQ6IGBpbWFnZV8ke3RoaXMuI2Jhc2VJZH1fJHt0aGlzLiNpZCsrfWAsXG4gICAgICByZWZDb3VudGVyOiAxLFxuICAgICAgaXNTdmc6IGZhbHNlXG4gICAgfTtcbiAgICB0aGlzLiNjYWNoZS5zZXQoaWQsIGRhdGEpO1xuICAgIHRoaXMuI2NhY2hlLnNldChkYXRhLmlkLCBkYXRhKTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBnZXRTdmdVcmwoaWQpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy4jY2FjaGUuZ2V0KGlkKTtcbiAgICBpZiAoIWRhdGE/LmlzU3ZnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGEuc3ZnVXJsO1xuICB9XG4gIGRlbGV0ZUlkKGlkKSB7XG4gICAgdGhpcy4jY2FjaGUgfHw9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy4jY2FjaGUuZ2V0KGlkKTtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGF0YS5yZWZDb3VudGVyIC09IDE7XG4gICAgaWYgKGRhdGEucmVmQ291bnRlciAhPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBiaXRtYXBcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoIWRhdGEudXJsICYmICFkYXRhLmZpbGUpIHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoYml0bWFwLndpZHRoLCBiaXRtYXAuaGVpZ2h0KTtcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiYml0bWFwcmVuZGVyZXJcIik7XG4gICAgICBjdHgudHJhbnNmZXJGcm9tSW1hZ2VCaXRtYXAoYml0bWFwKTtcbiAgICAgIGRhdGEuYmxvYlByb21pc2UgPSBjYW52YXMuY29udmVydFRvQmxvYigpO1xuICAgIH1cbiAgICBiaXRtYXAuY2xvc2U/LigpO1xuICAgIGRhdGEuYml0bWFwID0gbnVsbDtcbiAgfVxuICBpc1ZhbGlkSWQoaWQpIHtcbiAgICByZXR1cm4gaWQuc3RhcnRzV2l0aChgaW1hZ2VfJHt0aGlzLiNiYXNlSWR9X2ApO1xuICB9XG59XG5jbGFzcyBDb21tYW5kTWFuYWdlciB7XG4gICNjb21tYW5kcyA9IFtdO1xuICAjbG9ja2VkID0gZmFsc2U7XG4gICNtYXhTaXplO1xuICAjcG9zaXRpb24gPSAtMTtcbiAgY29uc3RydWN0b3IobWF4U2l6ZSA9IDEyOCkge1xuICAgIHRoaXMuI21heFNpemUgPSBtYXhTaXplO1xuICB9XG4gIGFkZCh7XG4gICAgY21kLFxuICAgIHVuZG8sXG4gICAgcG9zdCxcbiAgICBtdXN0RXhlYyxcbiAgICB0eXBlID0gTmFOLFxuICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGUgPSBmYWxzZSxcbiAgICBrZWVwVW5kbyA9IGZhbHNlXG4gIH0pIHtcbiAgICBpZiAobXVzdEV4ZWMpIHtcbiAgICAgIGNtZCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy4jbG9ja2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNhdmUgPSB7XG4gICAgICBjbWQsXG4gICAgICB1bmRvLFxuICAgICAgcG9zdCxcbiAgICAgIHR5cGVcbiAgICB9O1xuICAgIGlmICh0aGlzLiNwb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgIGlmICh0aGlzLiNjb21tYW5kcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuI2NvbW1hbmRzLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLiNwb3NpdGlvbiA9IDA7XG4gICAgICB0aGlzLiNjb21tYW5kcy5wdXNoKHNhdmUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob3ZlcndyaXRlSWZTYW1lVHlwZSAmJiB0aGlzLiNjb21tYW5kc1t0aGlzLiNwb3NpdGlvbl0udHlwZSA9PT0gdHlwZSkge1xuICAgICAgaWYgKGtlZXBVbmRvKSB7XG4gICAgICAgIHNhdmUudW5kbyA9IHRoaXMuI2NvbW1hbmRzW3RoaXMuI3Bvc2l0aW9uXS51bmRvO1xuICAgICAgfVxuICAgICAgdGhpcy4jY29tbWFuZHNbdGhpcy4jcG9zaXRpb25dID0gc2F2ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuI3Bvc2l0aW9uICsgMTtcbiAgICBpZiAobmV4dCA9PT0gdGhpcy4jbWF4U2l6ZSkge1xuICAgICAgdGhpcy4jY29tbWFuZHMuc3BsaWNlKDAsIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNwb3NpdGlvbiA9IG5leHQ7XG4gICAgICBpZiAobmV4dCA8IHRoaXMuI2NvbW1hbmRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLiNjb21tYW5kcy5zcGxpY2UobmV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2NvbW1hbmRzLnB1c2goc2F2ZSk7XG4gIH1cbiAgdW5kbygpIHtcbiAgICBpZiAodGhpcy4jcG9zaXRpb24gPT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2xvY2tlZCA9IHRydWU7XG4gICAgY29uc3Qge1xuICAgICAgdW5kbyxcbiAgICAgIHBvc3RcbiAgICB9ID0gdGhpcy4jY29tbWFuZHNbdGhpcy4jcG9zaXRpb25dO1xuICAgIHVuZG8oKTtcbiAgICBwb3N0Py4oKTtcbiAgICB0aGlzLiNsb2NrZWQgPSBmYWxzZTtcbiAgICB0aGlzLiNwb3NpdGlvbiAtPSAxO1xuICB9XG4gIHJlZG8oKSB7XG4gICAgaWYgKHRoaXMuI3Bvc2l0aW9uIDwgdGhpcy4jY29tbWFuZHMubGVuZ3RoIC0gMSkge1xuICAgICAgdGhpcy4jcG9zaXRpb24gKz0gMTtcbiAgICAgIHRoaXMuI2xvY2tlZCA9IHRydWU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNtZCxcbiAgICAgICAgcG9zdFxuICAgICAgfSA9IHRoaXMuI2NvbW1hbmRzW3RoaXMuI3Bvc2l0aW9uXTtcbiAgICAgIGNtZCgpO1xuICAgICAgcG9zdD8uKCk7XG4gICAgICB0aGlzLiNsb2NrZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaGFzU29tZXRoaW5nVG9VbmRvKCkge1xuICAgIHJldHVybiB0aGlzLiNwb3NpdGlvbiAhPT0gLTE7XG4gIH1cbiAgaGFzU29tZXRoaW5nVG9SZWRvKCkge1xuICAgIHJldHVybiB0aGlzLiNwb3NpdGlvbiA8IHRoaXMuI2NvbW1hbmRzLmxlbmd0aCAtIDE7XG4gIH1cbiAgY2xlYW5UeXBlKHR5cGUpIHtcbiAgICBpZiAodGhpcy4jcG9zaXRpb24gPT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSB0aGlzLiNwb3NpdGlvbjsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmICh0aGlzLiNjb21tYW5kc1tpXS50eXBlICE9PSB0eXBlKSB7XG4gICAgICAgIHRoaXMuI2NvbW1hbmRzLnNwbGljZShpICsgMSwgdGhpcy4jcG9zaXRpb24gLSBpKTtcbiAgICAgICAgdGhpcy4jcG9zaXRpb24gPSBpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2NvbW1hbmRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy4jcG9zaXRpb24gPSAtMTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI2NvbW1hbmRzID0gbnVsbDtcbiAgfVxufVxuY2xhc3MgS2V5Ym9hcmRNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoY2FsbGJhY2tzKSB7XG4gICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmFsbEtleXMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBmb3IgKGNvbnN0IFtrZXlzLCBjYWxsYmFjaywgb3B0aW9ucyA9IHt9XSBvZiBjYWxsYmFja3MpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgY29uc3QgaXNNYWNLZXkgPSBrZXkuc3RhcnRzV2l0aChcIm1hYytcIik7XG4gICAgICAgIGlmIChpc01hYyAmJiBpc01hY0tleSkge1xuICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLnNldChrZXkuc2xpY2UoNCksIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuYWxsS2V5cy5hZGQoa2V5LnNwbGl0KFwiK1wiKS5hdCgtMSkpO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc01hYyAmJiAhaXNNYWNLZXkpIHtcbiAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5zZXQoa2V5LCB7XG4gICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmFsbEtleXMuYWRkKGtleS5zcGxpdChcIitcIikuYXQoLTEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAjc2VyaWFsaXplKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmFsdEtleSkge1xuICAgICAgdGhpcy5idWZmZXIucHVzaChcImFsdFwiKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LmN0cmxLZXkpIHtcbiAgICAgIHRoaXMuYnVmZmVyLnB1c2goXCJjdHJsXCIpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQubWV0YUtleSkge1xuICAgICAgdGhpcy5idWZmZXIucHVzaChcIm1ldGFcIik7XG4gICAgfVxuICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgdGhpcy5idWZmZXIucHVzaChcInNoaWZ0XCIpO1xuICAgIH1cbiAgICB0aGlzLmJ1ZmZlci5wdXNoKGV2ZW50LmtleSk7XG4gICAgY29uc3Qgc3RyID0gdGhpcy5idWZmZXIuam9pbihcIitcIik7XG4gICAgdGhpcy5idWZmZXIubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIGV4ZWMoc2VsZiwgZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuYWxsS2V5cy5oYXMoZXZlbnQua2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbmZvID0gdGhpcy5jYWxsYmFja3MuZ2V0KHRoaXMuI3NlcmlhbGl6ZShldmVudCkpO1xuICAgIGlmICghaW5mbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjYWxsYmFjayxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgYnViYmxlcyA9IGZhbHNlLFxuICAgICAgICBhcmdzID0gW10sXG4gICAgICAgIGNoZWNrZXIgPSBudWxsXG4gICAgICB9XG4gICAgfSA9IGluZm87XG4gICAgaWYgKGNoZWNrZXIgJiYgIWNoZWNrZXIoc2VsZiwgZXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrLmJpbmQoc2VsZiwgLi4uYXJncywgZXZlbnQpKCk7XG4gICAgaWYgKCFidWJibGVzKSB7XG4gICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgQ29sb3JNYW5hZ2VyIHtcbiAgc3RhdGljIF9jb2xvcnNNYXBwaW5nID0gbmV3IE1hcChbW1wiQ2FudmFzVGV4dFwiLCBbMCwgMCwgMF1dLCBbXCJDYW52YXNcIiwgWzI1NSwgMjU1LCAyNTVdXV0pO1xuICBnZXQgX2NvbG9ycygpIHtcbiAgICBjb25zdCBjb2xvcnMgPSBuZXcgTWFwKFtbXCJDYW52YXNUZXh0XCIsIG51bGxdLCBbXCJDYW52YXNcIiwgbnVsbF1dKTtcbiAgICBnZXRDb2xvclZhbHVlcyhjb2xvcnMpO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfY29sb3JzXCIsIGNvbG9ycyk7XG4gIH1cbiAgY29udmVydChjb2xvcikge1xuICAgIGNvbnN0IHJnYiA9IGdldFJHQihjb2xvcik7XG4gICAgaWYgKCF3aW5kb3cubWF0Y2hNZWRpYShcIihmb3JjZWQtY29sb3JzOiBhY3RpdmUpXCIpLm1hdGNoZXMpIHtcbiAgICAgIHJldHVybiByZ2I7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW25hbWUsIFJHQl0gb2YgdGhpcy5fY29sb3JzKSB7XG4gICAgICBpZiAoUkdCLmV2ZXJ5KCh4LCBpKSA9PiB4ID09PSByZ2JbaV0pKSB7XG4gICAgICAgIHJldHVybiBDb2xvck1hbmFnZXIuX2NvbG9yc01hcHBpbmcuZ2V0KG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmdiO1xuICB9XG4gIGdldEhleENvZGUobmFtZSkge1xuICAgIGNvbnN0IHJnYiA9IHRoaXMuX2NvbG9ycy5nZXQobmFtZSk7XG4gICAgaWYgKCFyZ2IpIHtcbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICByZXR1cm4gVXRpbC5tYWtlSGV4Q29sb3IoLi4ucmdiKTtcbiAgfVxufVxuY2xhc3MgQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlciB7XG4gICNhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICNhY3RpdmVFZGl0b3IgPSBudWxsO1xuICAjYWxsRWRpdG9ycyA9IG5ldyBNYXAoKTtcbiAgI2FsbExheWVycyA9IG5ldyBNYXAoKTtcbiAgI2FsdFRleHRNYW5hZ2VyID0gbnVsbDtcbiAgI2Fubm90YXRpb25TdG9yYWdlID0gbnVsbDtcbiAgI2NoYW5nZWRFeGlzdGluZ0Fubm90YXRpb25zID0gbnVsbDtcbiAgI2NvbW1hbmRNYW5hZ2VyID0gbmV3IENvbW1hbmRNYW5hZ2VyKCk7XG4gICNjb3B5UGFzdGVBQyA9IG51bGw7XG4gICNjdXJyZW50RHJhd2luZ1Nlc3Npb24gPSBudWxsO1xuICAjY3VycmVudFBhZ2VJbmRleCA9IDA7XG4gICNkZWxldGVkQW5ub3RhdGlvbnNFbGVtZW50SWRzID0gbmV3IFNldCgpO1xuICAjZHJhZ2dpbmdFZGl0b3JzID0gbnVsbDtcbiAgI2VkaXRvclR5cGVzID0gbnVsbDtcbiAgI2VkaXRvcnNUb1Jlc2NhbGUgPSBuZXcgU2V0KCk7XG4gIF9lZGl0b3JVbmRvQmFyID0gbnVsbDtcbiAgI2VuYWJsZUhpZ2hsaWdodEZsb2F0aW5nQnV0dG9uID0gZmFsc2U7XG4gICNlbmFibGVVcGRhdGVkQWRkSW1hZ2UgPSBmYWxzZTtcbiAgI2VuYWJsZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2UgPSBmYWxzZTtcbiAgI2ZpbHRlckZhY3RvcnkgPSBudWxsO1xuICAjZm9jdXNNYWluQ29udGFpbmVyVGltZW91dElkID0gbnVsbDtcbiAgI2ZvY3VzTWFuYWdlckFDID0gbnVsbDtcbiAgI2hpZ2hsaWdodENvbG9ycyA9IG51bGw7XG4gICNoaWdobGlnaHRXaGVuU2hpZnRVcCA9IGZhbHNlO1xuICAjaGlnaGxpZ2h0VG9vbGJhciA9IG51bGw7XG4gICNpZE1hbmFnZXIgPSBuZXcgSWRNYW5hZ2VyKCk7XG4gICNpc0VuYWJsZWQgPSBmYWxzZTtcbiAgI2lzV2FpdGluZyA9IGZhbHNlO1xuICAja2V5Ym9hcmRNYW5hZ2VyQUMgPSBudWxsO1xuICAjbGFzdEFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICAjbWFpbkhpZ2hsaWdodENvbG9yUGlja2VyID0gbnVsbDtcbiAgI21sTWFuYWdlciA9IG51bGw7XG4gICNtb2RlID0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORTtcbiAgI3NlbGVjdGVkRWRpdG9ycyA9IG5ldyBTZXQoKTtcbiAgI3NlbGVjdGVkVGV4dE5vZGUgPSBudWxsO1xuICAjcGFnZUNvbG9ycyA9IG51bGw7XG4gICNzaG93QWxsU3RhdGVzID0gbnVsbDtcbiAgI3ByZXZpb3VzU3RhdGVzID0ge1xuICAgIGlzRWRpdGluZzogZmFsc2UsXG4gICAgaXNFbXB0eTogdHJ1ZSxcbiAgICBoYXNTb21ldGhpbmdUb1VuZG86IGZhbHNlLFxuICAgIGhhc1NvbWV0aGluZ1RvUmVkbzogZmFsc2UsXG4gICAgaGFzU2VsZWN0ZWRFZGl0b3I6IGZhbHNlLFxuICAgIGhhc1NlbGVjdGVkVGV4dDogZmFsc2VcbiAgfTtcbiAgI3RyYW5zbGF0aW9uID0gWzAsIDBdO1xuICAjdHJhbnNsYXRpb25UaW1lb3V0SWQgPSBudWxsO1xuICAjY29udGFpbmVyID0gbnVsbDtcbiAgI3ZpZXdlciA9IG51bGw7XG4gICN1cGRhdGVNb2RlQ2FwYWJpbGl0eSA9IG51bGw7XG4gIHN0YXRpYyBUUkFOU0xBVEVfU01BTEwgPSAxO1xuICBzdGF0aWMgVFJBTlNMQVRFX0JJRyA9IDEwO1xuICBzdGF0aWMgZ2V0IF9rZXlib2FyZE1hbmFnZXIoKSB7XG4gICAgY29uc3QgcHJvdG8gPSBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLnByb3RvdHlwZTtcbiAgICBjb25zdCBhcnJvd0NoZWNrZXIgPSBzZWxmID0+IHNlbGYuI2NvbnRhaW5lci5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50LnRhZ05hbWUgIT09IFwiQlVUVE9OXCIgJiYgc2VsZi5oYXNTb21ldGhpbmdUb0NvbnRyb2woKTtcbiAgICBjb25zdCB0ZXh0SW5wdXRDaGVja2VyID0gKF9zZWxmLCB7XG4gICAgICB0YXJnZXQ6IGVsXG4gICAgfSkgPT4ge1xuICAgICAgaWYgKGVsIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgdHlwZVxuICAgICAgICB9ID0gZWw7XG4gICAgICAgIHJldHVybiB0eXBlICE9PSBcInRleHRcIiAmJiB0eXBlICE9PSBcIm51bWJlclwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBjb25zdCBzbWFsbCA9IHRoaXMuVFJBTlNMQVRFX1NNQUxMO1xuICAgIGNvbnN0IGJpZyA9IHRoaXMuVFJBTlNMQVRFX0JJRztcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2tleWJvYXJkTWFuYWdlclwiLCBuZXcgS2V5Ym9hcmRNYW5hZ2VyKFtbW1wiY3RybCthXCIsIFwibWFjK21ldGErYVwiXSwgcHJvdG8uc2VsZWN0QWxsLCB7XG4gICAgICBjaGVja2VyOiB0ZXh0SW5wdXRDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK3pcIiwgXCJtYWMrbWV0YSt6XCJdLCBwcm90by51bmRvLCB7XG4gICAgICBjaGVja2VyOiB0ZXh0SW5wdXRDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK3lcIiwgXCJjdHJsK3NoaWZ0K3pcIiwgXCJtYWMrbWV0YStzaGlmdCt6XCIsIFwiY3RybCtzaGlmdCtaXCIsIFwibWFjK21ldGErc2hpZnQrWlwiXSwgcHJvdG8ucmVkbywge1xuICAgICAgY2hlY2tlcjogdGV4dElucHV0Q2hlY2tlclxuICAgIH1dLCBbW1wiQmFja3NwYWNlXCIsIFwiYWx0K0JhY2tzcGFjZVwiLCBcImN0cmwrQmFja3NwYWNlXCIsIFwic2hpZnQrQmFja3NwYWNlXCIsIFwibWFjK0JhY2tzcGFjZVwiLCBcIm1hYythbHQrQmFja3NwYWNlXCIsIFwibWFjK2N0cmwrQmFja3NwYWNlXCIsIFwiRGVsZXRlXCIsIFwiY3RybCtEZWxldGVcIiwgXCJzaGlmdCtEZWxldGVcIiwgXCJtYWMrRGVsZXRlXCJdLCBwcm90by5kZWxldGUsIHtcbiAgICAgIGNoZWNrZXI6IHRleHRJbnB1dENoZWNrZXJcbiAgICB9XSwgW1tcIkVudGVyXCIsIFwibWFjK0VudGVyXCJdLCBwcm90by5hZGROZXdFZGl0b3JGcm9tS2V5Ym9hcmQsIHtcbiAgICAgIGNoZWNrZXI6IChzZWxmLCB7XG4gICAgICAgIHRhcmdldDogZWxcbiAgICAgIH0pID0+ICEoZWwgaW5zdGFuY2VvZiBIVE1MQnV0dG9uRWxlbWVudCkgJiYgc2VsZi4jY29udGFpbmVyLmNvbnRhaW5zKGVsKSAmJiAhc2VsZi5pc0VudGVySGFuZGxlZFxuICAgIH1dLCBbW1wiIFwiLCBcIm1hYysgXCJdLCBwcm90by5hZGROZXdFZGl0b3JGcm9tS2V5Ym9hcmQsIHtcbiAgICAgIGNoZWNrZXI6IChzZWxmLCB7XG4gICAgICAgIHRhcmdldDogZWxcbiAgICAgIH0pID0+ICEoZWwgaW5zdGFuY2VvZiBIVE1MQnV0dG9uRWxlbWVudCkgJiYgc2VsZi4jY29udGFpbmVyLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpXG4gICAgfV0sIFtbXCJFc2NhcGVcIiwgXCJtYWMrRXNjYXBlXCJdLCBwcm90by51bnNlbGVjdEFsbF0sIFtbXCJBcnJvd0xlZnRcIiwgXCJtYWMrQXJyb3dMZWZ0XCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFstc21hbGwsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93TGVmdFwiLCBcIm1hYytzaGlmdCtBcnJvd0xlZnRcIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogWy1iaWcsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJBcnJvd1JpZ2h0XCIsIFwibWFjK0Fycm93UmlnaHRcIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogW3NtYWxsLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd1JpZ2h0XCIsIFwibWFjK3NoaWZ0K0Fycm93UmlnaHRcIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogW2JpZywgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93VXBcIiwgXCJtYWMrQXJyb3dVcFwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbMCwgLXNtYWxsXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd1VwXCIsIFwibWFjK3NoaWZ0K0Fycm93VXBcIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogWzAsIC1iaWddLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJBcnJvd0Rvd25cIiwgXCJtYWMrQXJyb3dEb3duXCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFswLCBzbWFsbF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dEb3duXCIsIFwibWFjK3NoaWZ0K0Fycm93RG93blwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbMCwgYmlnXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dXSkpO1xuICB9XG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lciwgdmlld2VyLCBhbHRUZXh0TWFuYWdlciwgZXZlbnRCdXMsIHBkZkRvY3VtZW50LCBwYWdlQ29sb3JzLCBoaWdobGlnaHRDb2xvcnMsIGVuYWJsZUhpZ2hsaWdodEZsb2F0aW5nQnV0dG9uLCBlbmFibGVVcGRhdGVkQWRkSW1hZ2UsIGVuYWJsZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2UsIG1sTWFuYWdlciwgZWRpdG9yVW5kb0Jhcikge1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3NpZ25hbCA9IHRoaXMuI2Fib3J0Q29udHJvbGxlci5zaWduYWw7XG4gICAgdGhpcy4jY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuI3ZpZXdlciA9IHZpZXdlcjtcbiAgICB0aGlzLiNhbHRUZXh0TWFuYWdlciA9IGFsdFRleHRNYW5hZ2VyO1xuICAgIHRoaXMuX2V2ZW50QnVzID0gZXZlbnRCdXM7XG4gICAgZXZlbnRCdXMuX29uKFwiZWRpdGluZ2FjdGlvblwiLCB0aGlzLm9uRWRpdGluZ0FjdGlvbi5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBldmVudEJ1cy5fb24oXCJwYWdlY2hhbmdpbmdcIiwgdGhpcy5vblBhZ2VDaGFuZ2luZy5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBldmVudEJ1cy5fb24oXCJzY2FsZWNoYW5naW5nXCIsIHRoaXMub25TY2FsZUNoYW5naW5nLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGV2ZW50QnVzLl9vbihcInJvdGF0aW9uY2hhbmdpbmdcIiwgdGhpcy5vblJvdGF0aW9uQ2hhbmdpbmcuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZXZlbnRCdXMuX29uKFwic2V0cHJlZmVyZW5jZVwiLCB0aGlzLm9uU2V0UHJlZmVyZW5jZS5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBldmVudEJ1cy5fb24oXCJzd2l0Y2hhbm5vdGF0aW9uZWRpdG9ycGFyYW1zXCIsIGV2dCA9PiB0aGlzLnVwZGF0ZVBhcmFtcyhldnQudHlwZSwgZXZ0LnZhbHVlKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy4jYWRkU2VsZWN0aW9uTGlzdGVuZXIoKTtcbiAgICB0aGlzLiNhZGREcmFnQW5kRHJvcExpc3RlbmVycygpO1xuICAgIHRoaXMuI2FkZEtleWJvYXJkTWFuYWdlcigpO1xuICAgIHRoaXMuI2Fubm90YXRpb25TdG9yYWdlID0gcGRmRG9jdW1lbnQuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgdGhpcy4jZmlsdGVyRmFjdG9yeSA9IHBkZkRvY3VtZW50LmZpbHRlckZhY3Rvcnk7XG4gICAgdGhpcy4jcGFnZUNvbG9ycyA9IHBhZ2VDb2xvcnM7XG4gICAgdGhpcy4jaGlnaGxpZ2h0Q29sb3JzID0gaGlnaGxpZ2h0Q29sb3JzIHx8IG51bGw7XG4gICAgdGhpcy4jZW5hYmxlSGlnaGxpZ2h0RmxvYXRpbmdCdXR0b24gPSBlbmFibGVIaWdobGlnaHRGbG9hdGluZ0J1dHRvbjtcbiAgICB0aGlzLiNlbmFibGVVcGRhdGVkQWRkSW1hZ2UgPSBlbmFibGVVcGRhdGVkQWRkSW1hZ2U7XG4gICAgdGhpcy4jZW5hYmxlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSA9IGVuYWJsZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2U7XG4gICAgdGhpcy4jbWxNYW5hZ2VyID0gbWxNYW5hZ2VyIHx8IG51bGw7XG4gICAgdGhpcy52aWV3UGFyYW1ldGVycyA9IHtcbiAgICAgIHJlYWxTY2FsZTogUGl4ZWxzUGVySW5jaC5QREZfVE9fQ1NTX1VOSVRTLFxuICAgICAgcm90YXRpb246IDBcbiAgICB9O1xuICAgIHRoaXMuaXNTaGlmdEtleURvd24gPSBmYWxzZTtcbiAgICB0aGlzLl9lZGl0b3JVbmRvQmFyID0gZWRpdG9yVW5kb0JhciB8fCBudWxsO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4jdXBkYXRlTW9kZUNhcGFiaWxpdHk/LnJlc29sdmUoKTtcbiAgICB0aGlzLiN1cGRhdGVNb2RlQ2FwYWJpbGl0eSA9IG51bGw7XG4gICAgdGhpcy4jYWJvcnRDb250cm9sbGVyPy5hYm9ydCgpO1xuICAgIHRoaXMuI2Fib3J0Q29udHJvbGxlciA9IG51bGw7XG4gICAgdGhpcy5fc2lnbmFsID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgbGF5ZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLiNhbGxMYXllcnMuY2xlYXIoKTtcbiAgICB0aGlzLiNhbGxFZGl0b3JzLmNsZWFyKCk7XG4gICAgdGhpcy4jZWRpdG9yc1RvUmVzY2FsZS5jbGVhcigpO1xuICAgIHRoaXMuI2FjdGl2ZUVkaXRvciA9IG51bGw7XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmNsZWFyKCk7XG4gICAgdGhpcy4jY29tbWFuZE1hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuI2FsdFRleHRNYW5hZ2VyPy5kZXN0cm95KCk7XG4gICAgdGhpcy4jaGlnaGxpZ2h0VG9vbGJhcj8uaGlkZSgpO1xuICAgIHRoaXMuI2hpZ2hsaWdodFRvb2xiYXIgPSBudWxsO1xuICAgIGlmICh0aGlzLiNmb2N1c01haW5Db250YWluZXJUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNmb2N1c01haW5Db250YWluZXJUaW1lb3V0SWQpO1xuICAgICAgdGhpcy4jZm9jdXNNYWluQ29udGFpbmVyVGltZW91dElkID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3RyYW5zbGF0aW9uVGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jdHJhbnNsYXRpb25UaW1lb3V0SWQpO1xuICAgICAgdGhpcy4jdHJhbnNsYXRpb25UaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLl9lZGl0b3JVbmRvQmFyPy5kZXN0cm95KCk7XG4gIH1cbiAgY29tYmluZWRTaWduYWwoYWMpIHtcbiAgICByZXR1cm4gQWJvcnRTaWduYWwuYW55KFt0aGlzLl9zaWduYWwsIGFjLnNpZ25hbF0pO1xuICB9XG4gIGdldCBtbE1hbmFnZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuI21sTWFuYWdlcjtcbiAgfVxuICBnZXQgdXNlTmV3QWx0VGV4dEZsb3coKSB7XG4gICAgcmV0dXJuIHRoaXMuI2VuYWJsZVVwZGF0ZWRBZGRJbWFnZTtcbiAgfVxuICBnZXQgdXNlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jZW5hYmxlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZTtcbiAgfVxuICBnZXQgaGNtRmlsdGVyKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJoY21GaWx0ZXJcIiwgdGhpcy4jcGFnZUNvbG9ycyA/IHRoaXMuI2ZpbHRlckZhY3RvcnkuYWRkSENNRmlsdGVyKHRoaXMuI3BhZ2VDb2xvcnMuZm9yZWdyb3VuZCwgdGhpcy4jcGFnZUNvbG9ycy5iYWNrZ3JvdW5kKSA6IFwibm9uZVwiKTtcbiAgfVxuICBnZXQgZGlyZWN0aW9uKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJkaXJlY3Rpb25cIiwgZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiNjb250YWluZXIpLmRpcmVjdGlvbik7XG4gIH1cbiAgZ2V0IGhpZ2hsaWdodENvbG9ycygpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaGlnaGxpZ2h0Q29sb3JzXCIsIHRoaXMuI2hpZ2hsaWdodENvbG9ycyA/IG5ldyBNYXAodGhpcy4jaGlnaGxpZ2h0Q29sb3JzLnNwbGl0KFwiLFwiKS5tYXAocGFpciA9PiBwYWlyLnNwbGl0KFwiPVwiKS5tYXAoeCA9PiB4LnRyaW0oKSkpKSA6IG51bGwpO1xuICB9XG4gIGdldCBoaWdobGlnaHRDb2xvck5hbWVzKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJoaWdobGlnaHRDb2xvck5hbWVzXCIsIHRoaXMuaGlnaGxpZ2h0Q29sb3JzID8gbmV3IE1hcChBcnJheS5mcm9tKHRoaXMuaGlnaGxpZ2h0Q29sb3JzLCBlID0+IGUucmV2ZXJzZSgpKSkgOiBudWxsKTtcbiAgfVxuICBzZXRDdXJyZW50RHJhd2luZ1Nlc3Npb24obGF5ZXIpIHtcbiAgICBpZiAobGF5ZXIpIHtcbiAgICAgIHRoaXMudW5zZWxlY3RBbGwoKTtcbiAgICAgIHRoaXMuZGlzYWJsZVVzZXJTZWxlY3QodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGlzYWJsZVVzZXJTZWxlY3QoZmFsc2UpO1xuICAgIH1cbiAgICB0aGlzLiNjdXJyZW50RHJhd2luZ1Nlc3Npb24gPSBsYXllcjtcbiAgfVxuICBzZXRNYWluSGlnaGxpZ2h0Q29sb3JQaWNrZXIoY29sb3JQaWNrZXIpIHtcbiAgICB0aGlzLiNtYWluSGlnaGxpZ2h0Q29sb3JQaWNrZXIgPSBjb2xvclBpY2tlcjtcbiAgfVxuICBlZGl0QWx0VGV4dChlZGl0b3IsIGZpcnN0VGltZSA9IGZhbHNlKSB7XG4gICAgdGhpcy4jYWx0VGV4dE1hbmFnZXI/LmVkaXRBbHRUZXh0KHRoaXMsIGVkaXRvciwgZmlyc3RUaW1lKTtcbiAgfVxuICBzd2l0Y2hUb01vZGUobW9kZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl9ldmVudEJ1cy5vbihcImFubm90YXRpb25lZGl0b3Jtb2RlY2hhbmdlZFwiLCBjYWxsYmFjaywge1xuICAgICAgb25jZTogdHJ1ZSxcbiAgICAgIHNpZ25hbDogdGhpcy5fc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy5fZXZlbnRCdXMuZGlzcGF0Y2goXCJzaG93YW5ub3RhdGlvbmVkaXRvcnVpXCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIG1vZGVcbiAgICB9KTtcbiAgfVxuICBzZXRQcmVmZXJlbmNlKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5fZXZlbnRCdXMuZGlzcGF0Y2goXCJzZXRwcmVmZXJlbmNlXCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIG5hbWUsXG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICB9XG4gIG9uU2V0UHJlZmVyZW5jZSh7XG4gICAgbmFtZSxcbiAgICB2YWx1ZVxuICB9KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlIFwiZW5hYmxlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZVwiOlxuICAgICAgICB0aGlzLiNlbmFibGVOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBvblBhZ2VDaGFuZ2luZyh7XG4gICAgcGFnZU51bWJlclxuICB9KSB7XG4gICAgdGhpcy4jY3VycmVudFBhZ2VJbmRleCA9IHBhZ2VOdW1iZXIgLSAxO1xuICB9XG4gIGZvY3VzTWFpbkNvbnRhaW5lcigpIHtcbiAgICB0aGlzLiNjb250YWluZXIuZm9jdXMoKTtcbiAgfVxuICBmaW5kUGFyZW50KHgsIHkpIHtcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB4OiBsYXllclgsXG4gICAgICAgIHk6IGxheWVyWSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSA9IGxheWVyLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGlmICh4ID49IGxheWVyWCAmJiB4IDw9IGxheWVyWCArIHdpZHRoICYmIHkgPj0gbGF5ZXJZICYmIHkgPD0gbGF5ZXJZICsgaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBsYXllcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZGlzYWJsZVVzZXJTZWxlY3QodmFsdWUgPSBmYWxzZSkge1xuICAgIHRoaXMuI3ZpZXdlci5jbGFzc0xpc3QudG9nZ2xlKFwibm9Vc2VyU2VsZWN0XCIsIHZhbHVlKTtcbiAgfVxuICBhZGRTaG91bGRSZXNjYWxlKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvcnNUb1Jlc2NhbGUuYWRkKGVkaXRvcik7XG4gIH1cbiAgcmVtb3ZlU2hvdWxkUmVzY2FsZShlZGl0b3IpIHtcbiAgICB0aGlzLiNlZGl0b3JzVG9SZXNjYWxlLmRlbGV0ZShlZGl0b3IpO1xuICB9XG4gIG9uU2NhbGVDaGFuZ2luZyh7XG4gICAgc2NhbGVcbiAgfSkge1xuICAgIHRoaXMuY29tbWl0T3JSZW1vdmUoKTtcbiAgICB0aGlzLnZpZXdQYXJhbWV0ZXJzLnJlYWxTY2FsZSA9IHNjYWxlICogUGl4ZWxzUGVySW5jaC5QREZfVE9fQ1NTX1VOSVRTO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnNUb1Jlc2NhbGUpIHtcbiAgICAgIGVkaXRvci5vblNjYWxlQ2hhbmdpbmcoKTtcbiAgICB9XG4gICAgdGhpcy4jY3VycmVudERyYXdpbmdTZXNzaW9uPy5vblNjYWxlQ2hhbmdpbmcoKTtcbiAgfVxuICBvblJvdGF0aW9uQ2hhbmdpbmcoe1xuICAgIHBhZ2VzUm90YXRpb25cbiAgfSkge1xuICAgIHRoaXMuY29tbWl0T3JSZW1vdmUoKTtcbiAgICB0aGlzLnZpZXdQYXJhbWV0ZXJzLnJvdGF0aW9uID0gcGFnZXNSb3RhdGlvbjtcbiAgfVxuICAjZ2V0QW5jaG9yRWxlbWVudEZvclNlbGVjdGlvbih7XG4gICAgYW5jaG9yTm9kZVxuICB9KSB7XG4gICAgcmV0dXJuIGFuY2hvck5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFID8gYW5jaG9yTm9kZS5wYXJlbnRFbGVtZW50IDogYW5jaG9yTm9kZTtcbiAgfVxuICAjZ2V0TGF5ZXJGb3JUZXh0TGF5ZXIodGV4dExheWVyKSB7XG4gICAgY29uc3Qge1xuICAgICAgY3VycmVudExheWVyXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGN1cnJlbnRMYXllci5oYXNUZXh0TGF5ZXIodGV4dExheWVyKSkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRMYXllcjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChsYXllci5oYXNUZXh0TGF5ZXIodGV4dExheWVyKSkge1xuICAgICAgICByZXR1cm4gbGF5ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGhpZ2hsaWdodFNlbGVjdGlvbihtZXRob2RPZkNyZWF0aW9uID0gXCJcIikge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuICAgIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5pc0NvbGxhcHNlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXRcbiAgICB9ID0gc2VsZWN0aW9uO1xuICAgIGNvbnN0IHRleHQgPSBzZWxlY3Rpb24udG9TdHJpbmcoKTtcbiAgICBjb25zdCBhbmNob3JFbGVtZW50ID0gdGhpcy4jZ2V0QW5jaG9yRWxlbWVudEZvclNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIGNvbnN0IHRleHRMYXllciA9IGFuY2hvckVsZW1lbnQuY2xvc2VzdChcIi50ZXh0TGF5ZXJcIik7XG4gICAgY29uc3QgYm94ZXMgPSB0aGlzLmdldFNlbGVjdGlvbkJveGVzKHRleHRMYXllcik7XG4gICAgaWYgKCFib3hlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxlY3Rpb24uZW1wdHkoKTtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuI2dldExheWVyRm9yVGV4dExheWVyKHRleHRMYXllcik7XG4gICAgY29uc3QgaXNOb25lTW9kZSA9IHRoaXMuI21vZGUgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLk5PTkU7XG4gICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICBsYXllcj8uY3JlYXRlQW5kQWRkTmV3RWRpdG9yKHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfSwgZmFsc2UsIHtcbiAgICAgICAgbWV0aG9kT2ZDcmVhdGlvbixcbiAgICAgICAgYm94ZXMsXG4gICAgICAgIGFuY2hvck5vZGUsXG4gICAgICAgIGFuY2hvck9mZnNldCxcbiAgICAgICAgZm9jdXNOb2RlLFxuICAgICAgICBmb2N1c09mZnNldCxcbiAgICAgICAgdGV4dFxuICAgICAgfSk7XG4gICAgICBpZiAoaXNOb25lTW9kZSkge1xuICAgICAgICB0aGlzLnNob3dBbGxFZGl0b3JzKFwiaGlnaGxpZ2h0XCIsIHRydWUsIHRydWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzTm9uZU1vZGUpIHtcbiAgICAgIHRoaXMuc3dpdGNoVG9Nb2RlKEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCwgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFjaygpO1xuICB9XG4gICNkaXNwbGF5SGlnaGxpZ2h0VG9vbGJhcigpIHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24uaXNDb2xsYXBzZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYW5jaG9yRWxlbWVudCA9IHRoaXMuI2dldEFuY2hvckVsZW1lbnRGb3JTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICBjb25zdCB0ZXh0TGF5ZXIgPSBhbmNob3JFbGVtZW50LmNsb3Nlc3QoXCIudGV4dExheWVyXCIpO1xuICAgIGNvbnN0IGJveGVzID0gdGhpcy5nZXRTZWxlY3Rpb25Cb3hlcyh0ZXh0TGF5ZXIpO1xuICAgIGlmICghYm94ZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jaGlnaGxpZ2h0VG9vbGJhciB8fD0gbmV3IEhpZ2hsaWdodFRvb2xiYXIodGhpcyk7XG4gICAgdGhpcy4jaGlnaGxpZ2h0VG9vbGJhci5zaG93KHRleHRMYXllciwgYm94ZXMsIHRoaXMuZGlyZWN0aW9uID09PSBcImx0clwiKTtcbiAgfVxuICBhZGRUb0Fubm90YXRpb25TdG9yYWdlKGVkaXRvcikge1xuICAgIGlmICghZWRpdG9yLmlzRW1wdHkoKSAmJiB0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZSAmJiAhdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2UuaGFzKGVkaXRvci5pZCkpIHtcbiAgICAgIHRoaXMuI2Fubm90YXRpb25TdG9yYWdlLnNldFZhbHVlKGVkaXRvci5pZCwgZWRpdG9yKTtcbiAgICB9XG4gIH1cbiAgI3NlbGVjdGlvbkNoYW5nZSgpIHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24uaXNDb2xsYXBzZWQpIHtcbiAgICAgIGlmICh0aGlzLiNzZWxlY3RlZFRleHROb2RlKSB7XG4gICAgICAgIHRoaXMuI2hpZ2hsaWdodFRvb2xiYXI/LmhpZGUoKTtcbiAgICAgICAgdGhpcy4jc2VsZWN0ZWRUZXh0Tm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgICAgICBoYXNTZWxlY3RlZFRleHQ6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhbmNob3JOb2RlXG4gICAgfSA9IHNlbGVjdGlvbjtcbiAgICBpZiAoYW5jaG9yTm9kZSA9PT0gdGhpcy4jc2VsZWN0ZWRUZXh0Tm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhbmNob3JFbGVtZW50ID0gdGhpcy4jZ2V0QW5jaG9yRWxlbWVudEZvclNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIGNvbnN0IHRleHRMYXllciA9IGFuY2hvckVsZW1lbnQuY2xvc2VzdChcIi50ZXh0TGF5ZXJcIik7XG4gICAgaWYgKCF0ZXh0TGF5ZXIpIHtcbiAgICAgIGlmICh0aGlzLiNzZWxlY3RlZFRleHROb2RlKSB7XG4gICAgICAgIHRoaXMuI2hpZ2hsaWdodFRvb2xiYXI/LmhpZGUoKTtcbiAgICAgICAgdGhpcy4jc2VsZWN0ZWRUZXh0Tm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgICAgICBoYXNTZWxlY3RlZFRleHQ6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNoaWdobGlnaHRUb29sYmFyPy5oaWRlKCk7XG4gICAgdGhpcy4jc2VsZWN0ZWRUZXh0Tm9kZSA9IGFuY2hvck5vZGU7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRUZXh0OiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKHRoaXMuI21vZGUgIT09IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCAmJiB0aGlzLiNtb2RlICE9PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNtb2RlID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQpIHtcbiAgICAgIHRoaXMuc2hvd0FsbEVkaXRvcnMoXCJoaWdobGlnaHRcIiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMuI2hpZ2hsaWdodFdoZW5TaGlmdFVwID0gdGhpcy5pc1NoaWZ0S2V5RG93bjtcbiAgICBpZiAoIXRoaXMuaXNTaGlmdEtleURvd24pIHtcbiAgICAgIGNvbnN0IGFjdGl2ZUxheWVyID0gdGhpcy4jbW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUID8gdGhpcy4jZ2V0TGF5ZXJGb3JUZXh0TGF5ZXIodGV4dExheWVyKSA6IG51bGw7XG4gICAgICBhY3RpdmVMYXllcj8udG9nZ2xlRHJhd2luZygpO1xuICAgICAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICBjb25zdCBzaWduYWwgPSB0aGlzLmNvbWJpbmVkU2lnbmFsKGFjKTtcbiAgICAgIGNvbnN0IHBvaW50ZXJ1cCA9IGUgPT4ge1xuICAgICAgICBpZiAoZS50eXBlID09PSBcInBvaW50ZXJ1cFwiICYmIGUuYnV0dG9uICE9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGFjLmFib3J0KCk7XG4gICAgICAgIGFjdGl2ZUxheWVyPy50b2dnbGVEcmF3aW5nKHRydWUpO1xuICAgICAgICBpZiAoZS50eXBlID09PSBcInBvaW50ZXJ1cFwiKSB7XG4gICAgICAgICAgdGhpcy4jb25TZWxlY3RFbmQoXCJtYWluX3Rvb2xiYXJcIik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBwb2ludGVydXAsIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBwb2ludGVydXAsIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgI29uU2VsZWN0RW5kKG1ldGhvZE9mQ3JlYXRpb24gPSBcIlwiKSB7XG4gICAgaWYgKHRoaXMuI21vZGUgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCkge1xuICAgICAgdGhpcy5oaWdobGlnaHRTZWxlY3Rpb24obWV0aG9kT2ZDcmVhdGlvbik7XG4gICAgfSBlbHNlIGlmICh0aGlzLiNlbmFibGVIaWdobGlnaHRGbG9hdGluZ0J1dHRvbikge1xuICAgICAgdGhpcy4jZGlzcGxheUhpZ2hsaWdodFRvb2xiYXIoKTtcbiAgICB9XG4gIH1cbiAgI2FkZFNlbGVjdGlvbkxpc3RlbmVyKCkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdGhpcy4jc2VsZWN0aW9uQ2hhbmdlLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbDogdGhpcy5fc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgI2FkZEZvY3VzTWFuYWdlcigpIHtcbiAgICBpZiAodGhpcy4jZm9jdXNNYW5hZ2VyQUMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jZm9jdXNNYW5hZ2VyQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5jb21iaW5lZFNpZ25hbCh0aGlzLiNmb2N1c01hbmFnZXJBQyk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLmZvY3VzLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLmJsdXIuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgI3JlbW92ZUZvY3VzTWFuYWdlcigpIHtcbiAgICB0aGlzLiNmb2N1c01hbmFnZXJBQz8uYWJvcnQoKTtcbiAgICB0aGlzLiNmb2N1c01hbmFnZXJBQyA9IG51bGw7XG4gIH1cbiAgYmx1cigpIHtcbiAgICB0aGlzLmlzU2hpZnRLZXlEb3duID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuI2hpZ2hsaWdodFdoZW5TaGlmdFVwKSB7XG4gICAgICB0aGlzLiNoaWdobGlnaHRXaGVuU2hpZnRVcCA9IGZhbHNlO1xuICAgICAgdGhpcy4jb25TZWxlY3RFbmQoXCJtYWluX3Rvb2xiYXJcIik7XG4gICAgfVxuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYWN0aXZlRWxlbWVudFxuICAgIH0gPSBkb2N1bWVudDtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGlmIChlZGl0b3IuZGl2LmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgIHRoaXMuI2xhc3RBY3RpdmVFbGVtZW50ID0gW2VkaXRvciwgYWN0aXZlRWxlbWVudF07XG4gICAgICAgIGVkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb2N1cygpIHtcbiAgICBpZiAoIXRoaXMuI2xhc3RBY3RpdmVFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IFtsYXN0RWRpdG9yLCBsYXN0QWN0aXZlRWxlbWVudF0gPSB0aGlzLiNsYXN0QWN0aXZlRWxlbWVudDtcbiAgICB0aGlzLiNsYXN0QWN0aXZlRWxlbWVudCA9IG51bGw7XG4gICAgbGFzdEFjdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgKCkgPT4ge1xuICAgICAgbGFzdEVkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gdHJ1ZTtcbiAgICB9LCB7XG4gICAgICBvbmNlOiB0cnVlLFxuICAgICAgc2lnbmFsOiB0aGlzLl9zaWduYWxcbiAgICB9KTtcbiAgICBsYXN0QWN0aXZlRWxlbWVudC5mb2N1cygpO1xuICB9XG4gICNhZGRLZXlib2FyZE1hbmFnZXIoKSB7XG4gICAgaWYgKHRoaXMuI2tleWJvYXJkTWFuYWdlckFDKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2tleWJvYXJkTWFuYWdlckFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuY29tYmluZWRTaWduYWwodGhpcy4ja2V5Ym9hcmRNYW5hZ2VyQUMpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLmtleWRvd24uYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCB0aGlzLmtleXVwLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gICNyZW1vdmVLZXlib2FyZE1hbmFnZXIoKSB7XG4gICAgdGhpcy4ja2V5Ym9hcmRNYW5hZ2VyQUM/LmFib3J0KCk7XG4gICAgdGhpcy4ja2V5Ym9hcmRNYW5hZ2VyQUMgPSBudWxsO1xuICB9XG4gICNhZGRDb3B5UGFzdGVMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKHRoaXMuI2NvcHlQYXN0ZUFDKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvcHlQYXN0ZUFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuY29tYmluZWRTaWduYWwodGhpcy4jY29weVBhc3RlQUMpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjb3B5XCIsIHRoaXMuY29weS5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiY3V0XCIsIHRoaXMuY3V0LmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwYXN0ZVwiLCB0aGlzLnBhc3RlLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gICNyZW1vdmVDb3B5UGFzdGVMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy4jY29weVBhc3RlQUM/LmFib3J0KCk7XG4gICAgdGhpcy4jY29weVBhc3RlQUMgPSBudWxsO1xuICB9XG4gICNhZGREcmFnQW5kRHJvcExpc3RlbmVycygpIHtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLl9zaWduYWw7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdvdmVyXCIsIHRoaXMuZHJhZ092ZXIuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImRyb3BcIiwgdGhpcy5kcm9wLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gIGFkZEVkaXRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy4jYWRkS2V5Ym9hcmRNYW5hZ2VyKCk7XG4gICAgdGhpcy4jYWRkQ29weVBhc3RlTGlzdGVuZXJzKCk7XG4gIH1cbiAgcmVtb3ZlRWRpdExpc3RlbmVycygpIHtcbiAgICB0aGlzLiNyZW1vdmVLZXlib2FyZE1hbmFnZXIoKTtcbiAgICB0aGlzLiNyZW1vdmVDb3B5UGFzdGVMaXN0ZW5lcnMoKTtcbiAgfVxuICBkcmFnT3ZlcihldmVudCkge1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gb2YgZXZlbnQuZGF0YVRyYW5zZmVyLml0ZW1zKSB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgdGhpcy4jZWRpdG9yVHlwZXMpIHtcbiAgICAgICAgaWYgKGVkaXRvclR5cGUuaXNIYW5kbGluZ01pbWVGb3JQYXN0aW5nKHR5cGUpKSB7XG4gICAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSBcImNvcHlcIjtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBkcm9wKGV2ZW50KSB7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGV2ZW50LmRhdGFUcmFuc2Zlci5pdGVtcykge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIHRoaXMuI2VkaXRvclR5cGVzKSB7XG4gICAgICAgIGlmIChlZGl0b3JUeXBlLmlzSGFuZGxpbmdNaW1lRm9yUGFzdGluZyhpdGVtLnR5cGUpKSB7XG4gICAgICAgICAgZWRpdG9yVHlwZS5wYXN0ZShpdGVtLCB0aGlzLmN1cnJlbnRMYXllcik7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29weShldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy4jYWN0aXZlRWRpdG9yPy5jb21taXRPclJlbW92ZSgpO1xuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZWRpdG9ycyA9IFtdO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IGVkaXRvci5zZXJpYWxpemUodHJ1ZSk7XG4gICAgICBpZiAoc2VyaWFsaXplZCkge1xuICAgICAgICBlZGl0b3JzLnB1c2goc2VyaWFsaXplZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlZGl0b3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBldmVudC5jbGlwYm9hcmREYXRhLnNldERhdGEoXCJhcHBsaWNhdGlvbi9wZGZqc1wiLCBKU09OLnN0cmluZ2lmeShlZGl0b3JzKSk7XG4gIH1cbiAgY3V0KGV2ZW50KSB7XG4gICAgdGhpcy5jb3B5KGV2ZW50KTtcbiAgICB0aGlzLmRlbGV0ZSgpO1xuICB9XG4gIGFzeW5jIHBhc3RlKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCB7XG4gICAgICBjbGlwYm9hcmREYXRhXG4gICAgfSA9IGV2ZW50O1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBjbGlwYm9hcmREYXRhLml0ZW1zKSB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgdGhpcy4jZWRpdG9yVHlwZXMpIHtcbiAgICAgICAgaWYgKGVkaXRvclR5cGUuaXNIYW5kbGluZ01pbWVGb3JQYXN0aW5nKGl0ZW0udHlwZSkpIHtcbiAgICAgICAgICBlZGl0b3JUeXBlLnBhc3RlKGl0ZW0sIHRoaXMuY3VycmVudExheWVyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGRhdGEgPSBjbGlwYm9hcmREYXRhLmdldERhdGEoXCJhcHBsaWNhdGlvbi9wZGZqc1wiKTtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICB3YXJuKGBwYXN0ZTogXCIke2V4Lm1lc3NhZ2V9XCIuYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnVuc2VsZWN0QWxsKCk7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmN1cnJlbnRMYXllcjtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbmV3RWRpdG9ycyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZGF0YSkge1xuICAgICAgICBjb25zdCBkZXNlcmlhbGl6ZWRFZGl0b3IgPSBhd2FpdCBsYXllci5kZXNlcmlhbGl6ZShlZGl0b3IpO1xuICAgICAgICBpZiAoIWRlc2VyaWFsaXplZEVkaXRvcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBuZXdFZGl0b3JzLnB1c2goZGVzZXJpYWxpemVkRWRpdG9yKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNtZCA9ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgbmV3RWRpdG9ycykge1xuICAgICAgICAgIHRoaXMuI2FkZEVkaXRvclRvTGF5ZXIoZWRpdG9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNzZWxlY3RFZGl0b3JzKG5ld0VkaXRvcnMpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHVuZG8gPSAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIG5ld0VkaXRvcnMpIHtcbiAgICAgICAgICBlZGl0b3IucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgICAgY21kLFxuICAgICAgICB1bmRvLFxuICAgICAgICBtdXN0RXhlYzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHdhcm4oYHBhc3RlOiBcIiR7ZXgubWVzc2FnZX1cIi5gKTtcbiAgICB9XG4gIH1cbiAga2V5ZG93bihldmVudCkge1xuICAgIGlmICghdGhpcy5pc1NoaWZ0S2V5RG93biAmJiBldmVudC5rZXkgPT09IFwiU2hpZnRcIikge1xuICAgICAgdGhpcy5pc1NoaWZ0S2V5RG93biA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLiNtb2RlICE9PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FICYmICF0aGlzLmlzRWRpdG9ySGFuZGxpbmdLZXlib2FyZCkge1xuICAgICAgQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5fa2V5Ym9hcmRNYW5hZ2VyLmV4ZWModGhpcywgZXZlbnQpO1xuICAgIH1cbiAgfVxuICBrZXl1cChldmVudCkge1xuICAgIGlmICh0aGlzLmlzU2hpZnRLZXlEb3duICYmIGV2ZW50LmtleSA9PT0gXCJTaGlmdFwiKSB7XG4gICAgICB0aGlzLmlzU2hpZnRLZXlEb3duID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy4jaGlnaGxpZ2h0V2hlblNoaWZ0VXApIHtcbiAgICAgICAgdGhpcy4jaGlnaGxpZ2h0V2hlblNoaWZ0VXAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jb25TZWxlY3RFbmQoXCJtYWluX3Rvb2xiYXJcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG9uRWRpdGluZ0FjdGlvbih7XG4gICAgbmFtZVxuICB9KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlIFwidW5kb1wiOlxuICAgICAgY2FzZSBcInJlZG9cIjpcbiAgICAgIGNhc2UgXCJkZWxldGVcIjpcbiAgICAgIGNhc2UgXCJzZWxlY3RBbGxcIjpcbiAgICAgICAgdGhpc1tuYW1lXSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJoaWdobGlnaHRTZWxlY3Rpb25cIjpcbiAgICAgICAgdGhpcy5oaWdobGlnaHRTZWxlY3Rpb24oXCJjb250ZXh0X21lbnVcIik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAjZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoZGV0YWlscykge1xuICAgIGNvbnN0IGhhc0NoYW5nZWQgPSBPYmplY3QuZW50cmllcyhkZXRhaWxzKS5zb21lKChba2V5LCB2YWx1ZV0pID0+IHRoaXMuI3ByZXZpb3VzU3RhdGVzW2tleV0gIT09IHZhbHVlKTtcbiAgICBpZiAoaGFzQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fZXZlbnRCdXMuZGlzcGF0Y2goXCJhbm5vdGF0aW9uZWRpdG9yc3RhdGVzY2hhbmdlZFwiLCB7XG4gICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgZGV0YWlsczogT2JqZWN0LmFzc2lnbih0aGlzLiNwcmV2aW91c1N0YXRlcywgZGV0YWlscylcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMuI21vZGUgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCAmJiBkZXRhaWxzLmhhc1NlbGVjdGVkRWRpdG9yID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVVJKFtbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX0ZSRUUsIHRydWVdXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gICNkaXNwYXRjaFVwZGF0ZVVJKGRldGFpbHMpIHtcbiAgICB0aGlzLl9ldmVudEJ1cy5kaXNwYXRjaChcImFubm90YXRpb25lZGl0b3JwYXJhbXNjaGFuZ2VkXCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIGRldGFpbHNcbiAgICB9KTtcbiAgfVxuICBzZXRFZGl0aW5nU3RhdGUoaXNFZGl0aW5nKSB7XG4gICAgaWYgKGlzRWRpdGluZykge1xuICAgICAgdGhpcy4jYWRkRm9jdXNNYW5hZ2VyKCk7XG4gICAgICB0aGlzLiNhZGRDb3B5UGFzdGVMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgICAgaXNFZGl0aW5nOiB0aGlzLiNtb2RlICE9PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FLFxuICAgICAgICBpc0VtcHR5OiB0aGlzLiNpc0VtcHR5KCksXG4gICAgICAgIGhhc1NvbWV0aGluZ1RvVW5kbzogdGhpcy4jY29tbWFuZE1hbmFnZXIuaGFzU29tZXRoaW5nVG9VbmRvKCksXG4gICAgICAgIGhhc1NvbWV0aGluZ1RvUmVkbzogdGhpcy4jY29tbWFuZE1hbmFnZXIuaGFzU29tZXRoaW5nVG9SZWRvKCksXG4gICAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI3JlbW92ZUZvY3VzTWFuYWdlcigpO1xuICAgICAgdGhpcy4jcmVtb3ZlQ29weVBhc3RlTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICAgIGlzRWRpdGluZzogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgdGhpcy5kaXNhYmxlVXNlclNlbGVjdChmYWxzZSk7XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyRWRpdG9yVHlwZXModHlwZXMpIHtcbiAgICBpZiAodGhpcy4jZWRpdG9yVHlwZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jZWRpdG9yVHlwZXMgPSB0eXBlcztcbiAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgdGhpcy4jZWRpdG9yVHlwZXMpIHtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoZWRpdG9yVHlwZS5kZWZhdWx0UHJvcGVydGllc1RvVXBkYXRlKTtcbiAgICB9XG4gIH1cbiAgZ2V0SWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2lkTWFuYWdlci5pZDtcbiAgfVxuICBnZXQgY3VycmVudExheWVyKCkge1xuICAgIHJldHVybiB0aGlzLiNhbGxMYXllcnMuZ2V0KHRoaXMuI2N1cnJlbnRQYWdlSW5kZXgpO1xuICB9XG4gIGdldExheWVyKHBhZ2VJbmRleCkge1xuICAgIHJldHVybiB0aGlzLiNhbGxMYXllcnMuZ2V0KHBhZ2VJbmRleCk7XG4gIH1cbiAgZ2V0IGN1cnJlbnRQYWdlSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2N1cnJlbnRQYWdlSW5kZXg7XG4gIH1cbiAgYWRkTGF5ZXIobGF5ZXIpIHtcbiAgICB0aGlzLiNhbGxMYXllcnMuc2V0KGxheWVyLnBhZ2VJbmRleCwgbGF5ZXIpO1xuICAgIGlmICh0aGlzLiNpc0VuYWJsZWQpIHtcbiAgICAgIGxheWVyLmVuYWJsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXllci5kaXNhYmxlKCk7XG4gICAgfVxuICB9XG4gIHJlbW92ZUxheWVyKGxheWVyKSB7XG4gICAgdGhpcy4jYWxsTGF5ZXJzLmRlbGV0ZShsYXllci5wYWdlSW5kZXgpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZU1vZGUobW9kZSwgZWRpdElkID0gbnVsbCwgaXNGcm9tS2V5Ym9hcmQgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLiNtb2RlID09PSBtb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiN1cGRhdGVNb2RlQ2FwYWJpbGl0eSkge1xuICAgICAgYXdhaXQgdGhpcy4jdXBkYXRlTW9kZUNhcGFiaWxpdHkucHJvbWlzZTtcbiAgICAgIGlmICghdGhpcy4jdXBkYXRlTW9kZUNhcGFiaWxpdHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiN1cGRhdGVNb2RlQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuI21vZGUgPSBtb2RlO1xuICAgIGlmIChtb2RlID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FKSB7XG4gICAgICB0aGlzLnNldEVkaXRpbmdTdGF0ZShmYWxzZSk7XG4gICAgICB0aGlzLiNkaXNhYmxlQWxsKCk7XG4gICAgICB0aGlzLl9lZGl0b3JVbmRvQmFyPy5oaWRlKCk7XG4gICAgICB0aGlzLiN1cGRhdGVNb2RlQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2V0RWRpdGluZ1N0YXRlKHRydWUpO1xuICAgIGF3YWl0IHRoaXMuI2VuYWJsZUFsbCgpO1xuICAgIHRoaXMudW5zZWxlY3RBbGwoKTtcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgbGF5ZXIudXBkYXRlTW9kZShtb2RlKTtcbiAgICB9XG4gICAgaWYgKCFlZGl0SWQpIHtcbiAgICAgIGlmIChpc0Zyb21LZXlib2FyZCkge1xuICAgICAgICB0aGlzLmFkZE5ld0VkaXRvckZyb21LZXlib2FyZCgpO1xuICAgICAgfVxuICAgICAgdGhpcy4jdXBkYXRlTW9kZUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQgPT09IGVkaXRJZCkge1xuICAgICAgICB0aGlzLnNldFNlbGVjdGVkKGVkaXRvcik7XG4gICAgICAgIGVkaXRvci5lbnRlckluRWRpdE1vZGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkaXRvci51bnNlbGVjdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiN1cGRhdGVNb2RlQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gIH1cbiAgYWRkTmV3RWRpdG9yRnJvbUtleWJvYXJkKCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRMYXllci5jYW5DcmVhdGVOZXdFbXB0eUVkaXRvcigpKSB7XG4gICAgICB0aGlzLmN1cnJlbnRMYXllci5hZGROZXdFZGl0b3IoKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlVG9vbGJhcihtb2RlKSB7XG4gICAgaWYgKG1vZGUgPT09IHRoaXMuI21vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZXZlbnRCdXMuZGlzcGF0Y2goXCJzd2l0Y2hhbm5vdGF0aW9uZWRpdG9ybW9kZVwiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICBtb2RlXG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlUGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuQ1JFQVRFOlxuICAgICAgICB0aGlzLmN1cnJlbnRMYXllci5hZGROZXdFZGl0b3IoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfREVGQVVMVF9DT0xPUjpcbiAgICAgICAgdGhpcy4jbWFpbkhpZ2hsaWdodENvbG9yUGlja2VyPy51cGRhdGVDb2xvcih2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfU0hPV19BTEw6XG4gICAgICAgIHRoaXMuX2V2ZW50QnVzLmRpc3BhdGNoKFwicmVwb3J0dGVsZW1ldHJ5XCIsIHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgdHlwZTogXCJlZGl0aW5nXCIsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiaGlnaGxpZ2h0XCIsXG4gICAgICAgICAgICAgIGFjdGlvbjogXCJ0b2dnbGVfdmlzaWJpbGl0eVwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgKHRoaXMuI3Nob3dBbGxTdGF0ZXMgfHw9IG5ldyBNYXAoKSkuc2V0KHR5cGUsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5zaG93QWxsRWRpdG9ycyhcImhpZ2hsaWdodFwiLCB2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGVkaXRvci51cGRhdGVQYXJhbXModHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgdGhpcy4jZWRpdG9yVHlwZXMpIHtcbiAgICAgIGVkaXRvclR5cGUudXBkYXRlRGVmYXVsdFBhcmFtcyh0eXBlLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHNob3dBbGxFZGl0b3JzKHR5cGUsIHZpc2libGUsIHVwZGF0ZUJ1dHRvbiA9IGZhbHNlKSB7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jYWxsRWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGVkaXRvci5lZGl0b3JUeXBlID09PSB0eXBlKSB7XG4gICAgICAgIGVkaXRvci5zaG93KHZpc2libGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuI3Nob3dBbGxTdGF0ZXM/LmdldChBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfU0hPV19BTEwpID8/IHRydWU7XG4gICAgaWYgKHN0YXRlICE9PSB2aXNpYmxlKSB7XG4gICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVVJKFtbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX1NIT1dfQUxMLCB2aXNpYmxlXV0pO1xuICAgIH1cbiAgfVxuICBlbmFibGVXYWl0aW5nKG11c3RXYWl0ID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy4jaXNXYWl0aW5nID09PSBtdXN0V2FpdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNpc1dhaXRpbmcgPSBtdXN0V2FpdDtcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgaWYgKG11c3RXYWl0KSB7XG4gICAgICAgIGxheWVyLmRpc2FibGVDbGljaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGF5ZXIuZW5hYmxlQ2xpY2soKTtcbiAgICAgIH1cbiAgICAgIGxheWVyLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwid2FpdGluZ1wiLCBtdXN0V2FpdCk7XG4gICAgfVxuICB9XG4gIGFzeW5jICNlbmFibGVBbGwoKSB7XG4gICAgaWYgKCF0aGlzLiNpc0VuYWJsZWQpIHtcbiAgICAgIHRoaXMuI2lzRW5hYmxlZCA9IHRydWU7XG4gICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgICAgcHJvbWlzZXMucHVzaChsYXllci5lbmFibGUoKSk7XG4gICAgICB9XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICAgIGVkaXRvci5lbmFibGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgI2Rpc2FibGVBbGwoKSB7XG4gICAgdGhpcy51bnNlbGVjdEFsbCgpO1xuICAgIGlmICh0aGlzLiNpc0VuYWJsZWQpIHtcbiAgICAgIHRoaXMuI2lzRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgICAgbGF5ZXIuZGlzYWJsZSgpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jYWxsRWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgICBlZGl0b3IuZGlzYWJsZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXRFZGl0b3JzKHBhZ2VJbmRleCkge1xuICAgIGNvbnN0IGVkaXRvcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoZWRpdG9yLnBhZ2VJbmRleCA9PT0gcGFnZUluZGV4KSB7XG4gICAgICAgIGVkaXRvcnMucHVzaChlZGl0b3IpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWRpdG9ycztcbiAgfVxuICBnZXRFZGl0b3IoaWQpIHtcbiAgICByZXR1cm4gdGhpcy4jYWxsRWRpdG9ycy5nZXQoaWQpO1xuICB9XG4gIGFkZEVkaXRvcihlZGl0b3IpIHtcbiAgICB0aGlzLiNhbGxFZGl0b3JzLnNldChlZGl0b3IuaWQsIGVkaXRvcik7XG4gIH1cbiAgcmVtb3ZlRWRpdG9yKGVkaXRvcikge1xuICAgIGlmIChlZGl0b3IuZGl2LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICBpZiAodGhpcy4jZm9jdXNNYWluQ29udGFpbmVyVGltZW91dElkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNmb2N1c01haW5Db250YWluZXJUaW1lb3V0SWQpO1xuICAgICAgfVxuICAgICAgdGhpcy4jZm9jdXNNYWluQ29udGFpbmVyVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuZm9jdXNNYWluQ29udGFpbmVyKCk7XG4gICAgICAgIHRoaXMuI2ZvY3VzTWFpbkNvbnRhaW5lclRpbWVvdXRJZCA9IG51bGw7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gICAgdGhpcy4jYWxsRWRpdG9ycy5kZWxldGUoZWRpdG9yLmlkKTtcbiAgICB0aGlzLnVuc2VsZWN0KGVkaXRvcik7XG4gICAgaWYgKCFlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCB8fCAhdGhpcy4jZGVsZXRlZEFubm90YXRpb25zRWxlbWVudElkcy5oYXMoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpKSB7XG4gICAgICB0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZT8ucmVtb3ZlKGVkaXRvci5pZCk7XG4gICAgfVxuICB9XG4gIGFkZERlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpIHtcbiAgICB0aGlzLiNkZWxldGVkQW5ub3RhdGlvbnNFbGVtZW50SWRzLmFkZChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gICAgdGhpcy5hZGRDaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9uKGVkaXRvcik7XG4gICAgZWRpdG9yLmRlbGV0ZWQgPSB0cnVlO1xuICB9XG4gIGlzRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICByZXR1cm4gdGhpcy4jZGVsZXRlZEFubm90YXRpb25zRWxlbWVudElkcy5oYXMoYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gIH1cbiAgcmVtb3ZlRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGVkaXRvcikge1xuICAgIHRoaXMuI2RlbGV0ZWRBbm5vdGF0aW9uc0VsZW1lbnRJZHMuZGVsZXRlKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgICB0aGlzLnJlbW92ZUNoYW5nZWRFeGlzdGluZ0Fubm90YXRpb24oZWRpdG9yKTtcbiAgICBlZGl0b3IuZGVsZXRlZCA9IGZhbHNlO1xuICB9XG4gICNhZGRFZGl0b3JUb0xheWVyKGVkaXRvcikge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy4jYWxsTGF5ZXJzLmdldChlZGl0b3IucGFnZUluZGV4KTtcbiAgICBpZiAobGF5ZXIpIHtcbiAgICAgIGxheWVyLmFkZE9yUmVidWlsZChlZGl0b3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZEVkaXRvcihlZGl0b3IpO1xuICAgICAgdGhpcy5hZGRUb0Fubm90YXRpb25TdG9yYWdlKGVkaXRvcik7XG4gICAgfVxuICB9XG4gIHNldEFjdGl2ZUVkaXRvcihlZGl0b3IpIHtcbiAgICBpZiAodGhpcy4jYWN0aXZlRWRpdG9yID09PSBlZGl0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYWN0aXZlRWRpdG9yID0gZWRpdG9yO1xuICAgIGlmIChlZGl0b3IpIHtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoZWRpdG9yLnByb3BlcnRpZXNUb1VwZGF0ZSk7XG4gICAgfVxuICB9XG4gIGdldCAjbGFzdFNlbGVjdGVkRWRpdG9yKCkge1xuICAgIGxldCBlZCA9IG51bGw7XG4gICAgZm9yIChlZCBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHt9XG4gICAgcmV0dXJuIGVkO1xuICB9XG4gIHVwZGF0ZVVJKGVkaXRvcikge1xuICAgIGlmICh0aGlzLiNsYXN0U2VsZWN0ZWRFZGl0b3IgPT09IGVkaXRvcikge1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShlZGl0b3IucHJvcGVydGllc1RvVXBkYXRlKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlVUlGb3JEZWZhdWx0UHJvcGVydGllcyhlZGl0b3JUeXBlKSB7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShlZGl0b3JUeXBlLmRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUpO1xuICB9XG4gIHRvZ2dsZVNlbGVjdGVkKGVkaXRvcikge1xuICAgIGlmICh0aGlzLiNzZWxlY3RlZEVkaXRvcnMuaGFzKGVkaXRvcikpIHtcbiAgICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5kZWxldGUoZWRpdG9yKTtcbiAgICAgIGVkaXRvci51bnNlbGVjdCgpO1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgICBoYXNTZWxlY3RlZEVkaXRvcjogdGhpcy5oYXNTZWxlY3Rpb25cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuYWRkKGVkaXRvcik7XG4gICAgZWRpdG9yLnNlbGVjdCgpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoZWRpdG9yLnByb3BlcnRpZXNUb1VwZGF0ZSk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IHRydWVcbiAgICB9KTtcbiAgfVxuICBzZXRTZWxlY3RlZChlZGl0b3IpIHtcbiAgICB0aGlzLiNjdXJyZW50RHJhd2luZ1Nlc3Npb24/LmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgZm9yIChjb25zdCBlZCBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGlmIChlZCAhPT0gZWRpdG9yKSB7XG4gICAgICAgIGVkLnVuc2VsZWN0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5jbGVhcigpO1xuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5hZGQoZWRpdG9yKTtcbiAgICBlZGl0b3Iuc2VsZWN0KCk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShlZGl0b3IucHJvcGVydGllc1RvVXBkYXRlKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTZWxlY3RlZEVkaXRvcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGlzU2VsZWN0ZWQoZWRpdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5oYXMoZWRpdG9yKTtcbiAgfVxuICBnZXQgZmlyc3RTZWxlY3RlZEVkaXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcbiAgfVxuICB1bnNlbGVjdChlZGl0b3IpIHtcbiAgICBlZGl0b3IudW5zZWxlY3QoKTtcbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuZGVsZXRlKGVkaXRvcik7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IHRoaXMuaGFzU2VsZWN0aW9uXG4gICAgfSk7XG4gIH1cbiAgZ2V0IGhhc1NlbGVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLnNpemUgIT09IDA7XG4gIH1cbiAgZ2V0IGlzRW50ZXJIYW5kbGVkKCkge1xuICAgIHJldHVybiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuc2l6ZSA9PT0gMSAmJiB0aGlzLmZpcnN0U2VsZWN0ZWRFZGl0b3IuaXNFbnRlckhhbmRsZWQ7XG4gIH1cbiAgdW5kbygpIHtcbiAgICB0aGlzLiNjb21tYW5kTWFuYWdlci51bmRvKCk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU29tZXRoaW5nVG9VbmRvOiB0aGlzLiNjb21tYW5kTWFuYWdlci5oYXNTb21ldGhpbmdUb1VuZG8oKSxcbiAgICAgIGhhc1NvbWV0aGluZ1RvUmVkbzogdHJ1ZSxcbiAgICAgIGlzRW1wdHk6IHRoaXMuI2lzRW1wdHkoKVxuICAgIH0pO1xuICAgIHRoaXMuX2VkaXRvclVuZG9CYXI/LmhpZGUoKTtcbiAgfVxuICByZWRvKCkge1xuICAgIHRoaXMuI2NvbW1hbmRNYW5hZ2VyLnJlZG8oKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTb21ldGhpbmdUb1VuZG86IHRydWUsXG4gICAgICBoYXNTb21ldGhpbmdUb1JlZG86IHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmhhc1NvbWV0aGluZ1RvUmVkbygpLFxuICAgICAgaXNFbXB0eTogdGhpcy4jaXNFbXB0eSgpXG4gICAgfSk7XG4gIH1cbiAgYWRkQ29tbWFuZHMocGFyYW1zKSB7XG4gICAgdGhpcy4jY29tbWFuZE1hbmFnZXIuYWRkKHBhcmFtcyk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU29tZXRoaW5nVG9VbmRvOiB0cnVlLFxuICAgICAgaGFzU29tZXRoaW5nVG9SZWRvOiBmYWxzZSxcbiAgICAgIGlzRW1wdHk6IHRoaXMuI2lzRW1wdHkoKVxuICAgIH0pO1xuICB9XG4gIGNsZWFuVW5kb1N0YWNrKHR5cGUpIHtcbiAgICB0aGlzLiNjb21tYW5kTWFuYWdlci5jbGVhblR5cGUodHlwZSk7XG4gIH1cbiAgI2lzRW1wdHkoKSB7XG4gICAgaWYgKHRoaXMuI2FsbEVkaXRvcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLiNhbGxFZGl0b3JzLnNpemUgPT09IDEpIHtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgICAgcmV0dXJuIGVkaXRvci5pc0VtcHR5KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBkZWxldGUoKSB7XG4gICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgIGNvbnN0IGRyYXdpbmdFZGl0b3IgPSB0aGlzLmN1cnJlbnRMYXllcj8uZW5kRHJhd2luZ1Nlc3Npb24odHJ1ZSk7XG4gICAgaWYgKCF0aGlzLmhhc1NlbGVjdGlvbiAmJiAhZHJhd2luZ0VkaXRvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3JzID0gZHJhd2luZ0VkaXRvciA/IFtkcmF3aW5nRWRpdG9yXSA6IFsuLi50aGlzLiNzZWxlY3RlZEVkaXRvcnNdO1xuICAgIGNvbnN0IGNtZCA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2VkaXRvclVuZG9CYXI/LnNob3codW5kbywgZWRpdG9ycy5sZW5ndGggPT09IDEgPyBlZGl0b3JzWzBdLmVkaXRvclR5cGUgOiBlZGl0b3JzLmxlbmd0aCk7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHVuZG8gPSAoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICAgIHRoaXMuI2FkZEVkaXRvclRvTGF5ZXIoZWRpdG9yKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kLFxuICAgICAgdW5kbyxcbiAgICAgIG11c3RFeGVjOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgY29tbWl0T3JSZW1vdmUoKSB7XG4gICAgdGhpcy4jYWN0aXZlRWRpdG9yPy5jb21taXRPclJlbW92ZSgpO1xuICB9XG4gIGhhc1NvbWV0aGluZ1RvQ29udHJvbCgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWN0aXZlRWRpdG9yIHx8IHRoaXMuaGFzU2VsZWN0aW9uO1xuICB9XG4gICNzZWxlY3RFZGl0b3JzKGVkaXRvcnMpIHtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGVkaXRvci51bnNlbGVjdCgpO1xuICAgIH1cbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuY2xlYXIoKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICBpZiAoZWRpdG9yLmlzRW1wdHkoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5hZGQoZWRpdG9yKTtcbiAgICAgIGVkaXRvci5zZWxlY3QoKTtcbiAgICB9XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IHRoaXMuaGFzU2VsZWN0aW9uXG4gICAgfSk7XG4gIH1cbiAgc2VsZWN0QWxsKCkge1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgZWRpdG9yLmNvbW1pdCgpO1xuICAgIH1cbiAgICB0aGlzLiNzZWxlY3RFZGl0b3JzKHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpO1xuICB9XG4gIHVuc2VsZWN0QWxsKCkge1xuICAgIGlmICh0aGlzLiNhY3RpdmVFZGl0b3IpIHtcbiAgICAgIHRoaXMuI2FjdGl2ZUVkaXRvci5jb21taXRPclJlbW92ZSgpO1xuICAgICAgaWYgKHRoaXMuI21vZGUgIT09IEFubm90YXRpb25FZGl0b3JUeXBlLk5PTkUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy4jY3VycmVudERyYXdpbmdTZXNzaW9uPy5jb21taXRPclJlbW92ZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICBlZGl0b3IudW5zZWxlY3QoKTtcbiAgICB9XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmNsZWFyKCk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgdHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzKHgsIHksIG5vQ29tbWl0ID0gZmFsc2UpIHtcbiAgICBpZiAoIW5vQ29tbWl0KSB7XG4gICAgICB0aGlzLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jdHJhbnNsYXRpb25bMF0gKz0geDtcbiAgICB0aGlzLiN0cmFuc2xhdGlvblsxXSArPSB5O1xuICAgIGNvbnN0IFt0b3RhbFgsIHRvdGFsWV0gPSB0aGlzLiN0cmFuc2xhdGlvbjtcbiAgICBjb25zdCBlZGl0b3JzID0gWy4uLnRoaXMuI3NlbGVjdGVkRWRpdG9yc107XG4gICAgY29uc3QgVElNRV9UT19XQUlUID0gMTAwMDtcbiAgICBpZiAodGhpcy4jdHJhbnNsYXRpb25UaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiN0cmFuc2xhdGlvblRpbWVvdXRJZCk7XG4gICAgfVxuICAgIHRoaXMuI3RyYW5zbGF0aW9uVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLiN0cmFuc2xhdGlvblRpbWVvdXRJZCA9IG51bGw7XG4gICAgICB0aGlzLiN0cmFuc2xhdGlvblswXSA9IHRoaXMuI3RyYW5zbGF0aW9uWzFdID0gMDtcbiAgICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgICBjbWQ6ICgpID0+IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jYWxsRWRpdG9ycy5oYXMoZWRpdG9yLmlkKSkge1xuICAgICAgICAgICAgICBlZGl0b3IudHJhbnNsYXRlSW5QYWdlKHRvdGFsWCwgdG90YWxZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jYWxsRWRpdG9ycy5oYXMoZWRpdG9yLmlkKSkge1xuICAgICAgICAgICAgICBlZGl0b3IudHJhbnNsYXRlSW5QYWdlKC10b3RhbFgsIC10b3RhbFkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbXVzdEV4ZWM6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9LCBUSU1FX1RPX1dBSVQpO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIGVkaXRvcnMpIHtcbiAgICAgIGVkaXRvci50cmFuc2xhdGVJblBhZ2UoeCwgeSk7XG4gICAgfVxuICB9XG4gIHNldFVwRHJhZ1Nlc3Npb24oKSB7XG4gICAgaWYgKCF0aGlzLmhhc1NlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRpc2FibGVVc2VyU2VsZWN0KHRydWUpO1xuICAgIHRoaXMuI2RyYWdnaW5nRWRpdG9ycyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIHRoaXMuI2RyYWdnaW5nRWRpdG9ycy5zZXQoZWRpdG9yLCB7XG4gICAgICAgIHNhdmVkWDogZWRpdG9yLngsXG4gICAgICAgIHNhdmVkWTogZWRpdG9yLnksXG4gICAgICAgIHNhdmVkUGFnZUluZGV4OiBlZGl0b3IucGFnZUluZGV4LFxuICAgICAgICBuZXdYOiAwLFxuICAgICAgICBuZXdZOiAwLFxuICAgICAgICBuZXdQYWdlSW5kZXg6IC0xXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZW5kRHJhZ1Nlc3Npb24oKSB7XG4gICAgaWYgKCF0aGlzLiNkcmFnZ2luZ0VkaXRvcnMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5kaXNhYmxlVXNlclNlbGVjdChmYWxzZSk7XG4gICAgY29uc3QgbWFwID0gdGhpcy4jZHJhZ2dpbmdFZGl0b3JzO1xuICAgIHRoaXMuI2RyYWdnaW5nRWRpdG9ycyA9IG51bGw7XG4gICAgbGV0IG11c3RCZUFkZGVkSW5VbmRvU3RhY2sgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IFt7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHBhZ2VJbmRleFxuICAgIH0sIHZhbHVlXSBvZiBtYXApIHtcbiAgICAgIHZhbHVlLm5ld1ggPSB4O1xuICAgICAgdmFsdWUubmV3WSA9IHk7XG4gICAgICB2YWx1ZS5uZXdQYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgICBtdXN0QmVBZGRlZEluVW5kb1N0YWNrIHx8PSB4ICE9PSB2YWx1ZS5zYXZlZFggfHwgeSAhPT0gdmFsdWUuc2F2ZWRZIHx8IHBhZ2VJbmRleCAhPT0gdmFsdWUuc2F2ZWRQYWdlSW5kZXg7XG4gICAgfVxuICAgIGlmICghbXVzdEJlQWRkZWRJblVuZG9TdGFjaykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBtb3ZlID0gKGVkaXRvciwgeCwgeSwgcGFnZUluZGV4KSA9PiB7XG4gICAgICBpZiAodGhpcy4jYWxsRWRpdG9ycy5oYXMoZWRpdG9yLmlkKSkge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLiNhbGxMYXllcnMuZ2V0KHBhZ2VJbmRleCk7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICBlZGl0b3IuX3NldFBhcmVudEFuZFBvc2l0aW9uKHBhcmVudCwgeCwgeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWRpdG9yLnBhZ2VJbmRleCA9IHBhZ2VJbmRleDtcbiAgICAgICAgICBlZGl0b3IueCA9IHg7XG4gICAgICAgICAgZWRpdG9yLnkgPSB5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IFtlZGl0b3IsIHtcbiAgICAgICAgICBuZXdYLFxuICAgICAgICAgIG5ld1ksXG4gICAgICAgICAgbmV3UGFnZUluZGV4XG4gICAgICAgIH1dIG9mIG1hcCkge1xuICAgICAgICAgIG1vdmUoZWRpdG9yLCBuZXdYLCBuZXdZLCBuZXdQYWdlSW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IFtlZGl0b3IsIHtcbiAgICAgICAgICBzYXZlZFgsXG4gICAgICAgICAgc2F2ZWRZLFxuICAgICAgICAgIHNhdmVkUGFnZUluZGV4XG4gICAgICAgIH1dIG9mIG1hcCkge1xuICAgICAgICAgIG1vdmUoZWRpdG9yLCBzYXZlZFgsIHNhdmVkWSwgc2F2ZWRQYWdlSW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbXVzdEV4ZWM6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBkcmFnU2VsZWN0ZWRFZGl0b3JzKHR4LCB0eSkge1xuICAgIGlmICghdGhpcy4jZHJhZ2dpbmdFZGl0b3JzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2RyYWdnaW5nRWRpdG9ycy5rZXlzKCkpIHtcbiAgICAgIGVkaXRvci5kcmFnKHR4LCB0eSk7XG4gICAgfVxuICB9XG4gIHJlYnVpbGQoZWRpdG9yKSB7XG4gICAgaWYgKGVkaXRvci5wYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0TGF5ZXIoZWRpdG9yLnBhZ2VJbmRleCk7XG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHBhcmVudC5jaGFuZ2VQYXJlbnQoZWRpdG9yKTtcbiAgICAgICAgcGFyZW50LmFkZE9yUmVidWlsZChlZGl0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hZGRFZGl0b3IoZWRpdG9yKTtcbiAgICAgICAgdGhpcy5hZGRUb0Fubm90YXRpb25TdG9yYWdlKGVkaXRvcik7XG4gICAgICAgIGVkaXRvci5yZWJ1aWxkKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVkaXRvci5wYXJlbnQuYWRkT3JSZWJ1aWxkKGVkaXRvcik7XG4gICAgfVxuICB9XG4gIGdldCBpc0VkaXRvckhhbmRsaW5nS2V5Ym9hcmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QWN0aXZlKCk/LnNob3VsZEdldEtleWJvYXJkRXZlbnRzKCkgfHwgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLnNpemUgPT09IDEgJiYgdGhpcy5maXJzdFNlbGVjdGVkRWRpdG9yLnNob3VsZEdldEtleWJvYXJkRXZlbnRzKCk7XG4gIH1cbiAgaXNBY3RpdmUoZWRpdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FjdGl2ZUVkaXRvciA9PT0gZWRpdG9yO1xuICB9XG4gIGdldEFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWN0aXZlRWRpdG9yO1xuICB9XG4gIGdldE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI21vZGU7XG4gIH1cbiAgZ2V0IGltYWdlTWFuYWdlcigpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaW1hZ2VNYW5hZ2VyXCIsIG5ldyBJbWFnZU1hbmFnZXIoKSk7XG4gIH1cbiAgZ2V0U2VsZWN0aW9uQm94ZXModGV4dExheWVyKSB7XG4gICAgaWYgKCF0ZXh0TGF5ZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBzZWxlY3Rpb24ucmFuZ2VDb3VudDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGlmICghdGV4dExheWVyLmNvbnRhaW5zKHNlbGVjdGlvbi5nZXRSYW5nZUF0KGkpLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgeDogbGF5ZXJYLFxuICAgICAgeTogbGF5ZXJZLFxuICAgICAgd2lkdGg6IHBhcmVudFdpZHRoLFxuICAgICAgaGVpZ2h0OiBwYXJlbnRIZWlnaHRcbiAgICB9ID0gdGV4dExheWVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCByb3RhdG9yO1xuICAgIHN3aXRjaCAodGV4dExheWVyLmdldEF0dHJpYnV0ZShcImRhdGEtbWFpbi1yb3RhdGlvblwiKSkge1xuICAgICAgY2FzZSBcIjkwXCI6XG4gICAgICAgIHJvdGF0b3IgPSAoeCwgeSwgdywgaCkgPT4gKHtcbiAgICAgICAgICB4OiAoeSAtIGxheWVyWSkgLyBwYXJlbnRIZWlnaHQsXG4gICAgICAgICAgeTogMSAtICh4ICsgdyAtIGxheWVyWCkgLyBwYXJlbnRXaWR0aCxcbiAgICAgICAgICB3aWR0aDogaCAvIHBhcmVudEhlaWdodCxcbiAgICAgICAgICBoZWlnaHQ6IHcgLyBwYXJlbnRXaWR0aFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiMTgwXCI6XG4gICAgICAgIHJvdGF0b3IgPSAoeCwgeSwgdywgaCkgPT4gKHtcbiAgICAgICAgICB4OiAxIC0gKHggKyB3IC0gbGF5ZXJYKSAvIHBhcmVudFdpZHRoLFxuICAgICAgICAgIHk6IDEgLSAoeSArIGggLSBsYXllclkpIC8gcGFyZW50SGVpZ2h0LFxuICAgICAgICAgIHdpZHRoOiB3IC8gcGFyZW50V2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoIC8gcGFyZW50SGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCIyNzBcIjpcbiAgICAgICAgcm90YXRvciA9ICh4LCB5LCB3LCBoKSA9PiAoe1xuICAgICAgICAgIHg6IDEgLSAoeSArIGggLSBsYXllclkpIC8gcGFyZW50SGVpZ2h0LFxuICAgICAgICAgIHk6ICh4IC0gbGF5ZXJYKSAvIHBhcmVudFdpZHRoLFxuICAgICAgICAgIHdpZHRoOiBoIC8gcGFyZW50SGVpZ2h0LFxuICAgICAgICAgIGhlaWdodDogdyAvIHBhcmVudFdpZHRoXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJvdGF0b3IgPSAoeCwgeSwgdywgaCkgPT4gKHtcbiAgICAgICAgICB4OiAoeCAtIGxheWVyWCkgLyBwYXJlbnRXaWR0aCxcbiAgICAgICAgICB5OiAoeSAtIGxheWVyWSkgLyBwYXJlbnRIZWlnaHQsXG4gICAgICAgICAgd2lkdGg6IHcgLyBwYXJlbnRXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGggLyBwYXJlbnRIZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBib3hlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHNlbGVjdGlvbi5yYW5nZUNvdW50OyBpIDwgaWk7IGkrKykge1xuICAgICAgY29uc3QgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdChpKTtcbiAgICAgIGlmIChyYW5nZS5jb2xsYXBzZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSBvZiByYW5nZS5nZXRDbGllbnRSZWN0cygpKSB7XG4gICAgICAgIGlmICh3aWR0aCA9PT0gMCB8fCBoZWlnaHQgPT09IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBib3hlcy5wdXNoKHJvdGF0b3IoeCwgeSwgd2lkdGgsIGhlaWdodCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYm94ZXMubGVuZ3RoID09PSAwID8gbnVsbCA6IGJveGVzO1xuICB9XG4gIGFkZENoYW5nZWRFeGlzdGluZ0Fubm90YXRpb24oe1xuICAgIGFubm90YXRpb25FbGVtZW50SWQsXG4gICAgaWRcbiAgfSkge1xuICAgICh0aGlzLiNjaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9ucyB8fD0gbmV3IE1hcCgpKS5zZXQoYW5ub3RhdGlvbkVsZW1lbnRJZCwgaWQpO1xuICB9XG4gIHJlbW92ZUNoYW5nZWRFeGlzdGluZ0Fubm90YXRpb24oe1xuICAgIGFubm90YXRpb25FbGVtZW50SWRcbiAgfSkge1xuICAgIHRoaXMuI2NoYW5nZWRFeGlzdGluZ0Fubm90YXRpb25zPy5kZWxldGUoYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gIH1cbiAgcmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIGNvbnN0IGVkaXRvcklkID0gdGhpcy4jY2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbnM/LmdldChhbm5vdGF0aW9uLmRhdGEuaWQpO1xuICAgIGlmICghZWRpdG9ySWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2UuZ2V0UmF3VmFsdWUoZWRpdG9ySWQpO1xuICAgIGlmICghZWRpdG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNtb2RlID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FICYmICFlZGl0b3IuaGFzQmVlbk1vZGlmaWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVkaXRvci5yZW5kZXJBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvYWx0X3RleHQuanNcblxuY2xhc3MgQWx0VGV4dCB7XG4gICNhbHRUZXh0ID0gbnVsbDtcbiAgI2FsdFRleHREZWNvcmF0aXZlID0gZmFsc2U7XG4gICNhbHRUZXh0QnV0dG9uID0gbnVsbDtcbiAgI2FsdFRleHRCdXR0b25MYWJlbCA9IG51bGw7XG4gICNhbHRUZXh0VG9vbHRpcCA9IG51bGw7XG4gICNhbHRUZXh0VG9vbHRpcFRpbWVvdXQgPSBudWxsO1xuICAjYWx0VGV4dFdhc0Zyb21LZXlCb2FyZCA9IGZhbHNlO1xuICAjYmFkZ2UgPSBudWxsO1xuICAjZWRpdG9yID0gbnVsbDtcbiAgI2d1ZXNzZWRUZXh0ID0gbnVsbDtcbiAgI3RleHRXaXRoRGlzY2xhaW1lciA9IG51bGw7XG4gICN1c2VOZXdBbHRUZXh0RmxvdyA9IGZhbHNlO1xuICBzdGF0aWMgI2wxMG5OZXdCdXR0b24gPSBudWxsO1xuICBzdGF0aWMgX2wxMG4gPSBudWxsO1xuICBjb25zdHJ1Y3RvcihlZGl0b3IpIHtcbiAgICB0aGlzLiNlZGl0b3IgPSBlZGl0b3I7XG4gICAgdGhpcy4jdXNlTmV3QWx0VGV4dEZsb3cgPSBlZGl0b3IuX3VpTWFuYWdlci51c2VOZXdBbHRUZXh0RmxvdztcbiAgICBBbHRUZXh0LiNsMTBuTmV3QnV0dG9uIHx8PSBPYmplY3QuZnJlZXplKHtcbiAgICAgIGFkZGVkOiBcInBkZmpzLWVkaXRvci1uZXctYWx0LXRleHQtYWRkZWQtYnV0dG9uXCIsXG4gICAgICBcImFkZGVkLWxhYmVsXCI6IFwicGRmanMtZWRpdG9yLW5ldy1hbHQtdGV4dC1hZGRlZC1idXR0b24tbGFiZWxcIixcbiAgICAgIG1pc3Npbmc6IFwicGRmanMtZWRpdG9yLW5ldy1hbHQtdGV4dC1taXNzaW5nLWJ1dHRvblwiLFxuICAgICAgXCJtaXNzaW5nLWxhYmVsXCI6IFwicGRmanMtZWRpdG9yLW5ldy1hbHQtdGV4dC1taXNzaW5nLWJ1dHRvbi1sYWJlbFwiLFxuICAgICAgcmV2aWV3OiBcInBkZmpzLWVkaXRvci1uZXctYWx0LXRleHQtdG8tcmV2aWV3LWJ1dHRvblwiLFxuICAgICAgXCJyZXZpZXctbGFiZWxcIjogXCJwZGZqcy1lZGl0b3ItbmV3LWFsdC10ZXh0LXRvLXJldmlldy1idXR0b24tbGFiZWxcIlxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBpbml0aWFsaXplKGwxMG4pIHtcbiAgICBBbHRUZXh0Ll9sMTBuID8/PSBsMTBuO1xuICB9XG4gIGFzeW5jIHJlbmRlcigpIHtcbiAgICBjb25zdCBhbHRUZXh0ID0gdGhpcy4jYWx0VGV4dEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgYWx0VGV4dC5jbGFzc05hbWUgPSBcImFsdFRleHRcIjtcbiAgICBhbHRUZXh0LnRhYkluZGV4ID0gXCIwXCI7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLiNhbHRUZXh0QnV0dG9uTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBhbHRUZXh0LmFwcGVuZChsYWJlbCk7XG4gICAgaWYgKHRoaXMuI3VzZU5ld0FsdFRleHRGbG93KSB7XG4gICAgICBhbHRUZXh0LmNsYXNzTGlzdC5hZGQoXCJuZXdcIik7XG4gICAgICBhbHRUZXh0LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBBbHRUZXh0LiNsMTBuTmV3QnV0dG9uLm1pc3NpbmcpO1xuICAgICAgbGFiZWwuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIEFsdFRleHQuI2wxMG5OZXdCdXR0b25bXCJtaXNzaW5nLWxhYmVsXCJdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWx0VGV4dC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1lZGl0b3ItYWx0LXRleHQtYnV0dG9uXCIpO1xuICAgICAgbGFiZWwuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtZWRpdG9yLWFsdC10ZXh0LWJ1dHRvbi1sYWJlbFwiKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jZWRpdG9yLl91aU1hbmFnZXIuX3NpZ25hbDtcbiAgICBhbHRUZXh0LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBhbHRUZXh0LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBldmVudCA9PiBldmVudC5zdG9wUHJvcGFnYXRpb24oKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgY29uc3Qgb25DbGljayA9IGV2ZW50ID0+IHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLiNlZGl0b3IuX3VpTWFuYWdlci5lZGl0QWx0VGV4dCh0aGlzLiNlZGl0b3IpO1xuICAgICAgaWYgKHRoaXMuI3VzZU5ld0FsdFRleHRGbG93KSB7XG4gICAgICAgIHRoaXMuI2VkaXRvci5fcmVwb3J0VGVsZW1ldHJ5KHtcbiAgICAgICAgICBhY3Rpb246IFwicGRmanMuaW1hZ2UuYWx0X3RleHQuaW1hZ2Vfc3RhdHVzX2xhYmVsX2NsaWNrZWRcIixcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBsYWJlbDogdGhpcy4jbGFiZWxcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgYWx0VGV4dC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgb25DbGljaywge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGFsdFRleHQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZXZlbnQgPT4ge1xuICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gYWx0VGV4dCAmJiBldmVudC5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgICB0aGlzLiNhbHRUZXh0V2FzRnJvbUtleUJvYXJkID0gdHJ1ZTtcbiAgICAgICAgb25DbGljayhldmVudCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgYXdhaXQgdGhpcy4jc2V0U3RhdGUoKTtcbiAgICByZXR1cm4gYWx0VGV4dDtcbiAgfVxuICBnZXQgI2xhYmVsKCkge1xuICAgIHJldHVybiB0aGlzLiNhbHRUZXh0ICYmIFwiYWRkZWRcIiB8fCB0aGlzLiNhbHRUZXh0ID09PSBudWxsICYmIHRoaXMuZ3Vlc3NlZFRleHQgJiYgXCJyZXZpZXdcIiB8fCBcIm1pc3NpbmdcIjtcbiAgfVxuICBmaW5pc2goKSB7XG4gICAgaWYgKCF0aGlzLiNhbHRUZXh0QnV0dG9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2FsdFRleHRCdXR0b24uZm9jdXMoe1xuICAgICAgZm9jdXNWaXNpYmxlOiB0aGlzLiNhbHRUZXh0V2FzRnJvbUtleUJvYXJkXG4gICAgfSk7XG4gICAgdGhpcy4jYWx0VGV4dFdhc0Zyb21LZXlCb2FyZCA9IGZhbHNlO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgaWYgKHRoaXMuI3VzZU5ld0FsdFRleHRGbG93KSB7XG4gICAgICByZXR1cm4gdGhpcy4jYWx0VGV4dCA9PT0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuICF0aGlzLiNhbHRUZXh0ICYmICF0aGlzLiNhbHRUZXh0RGVjb3JhdGl2ZTtcbiAgfVxuICBoYXNEYXRhKCkge1xuICAgIGlmICh0aGlzLiN1c2VOZXdBbHRUZXh0Rmxvdykge1xuICAgICAgcmV0dXJuIHRoaXMuI2FsdFRleHQgIT09IG51bGwgfHwgISF0aGlzLiNndWVzc2VkVGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaXNFbXB0eSgpO1xuICB9XG4gIGdldCBndWVzc2VkVGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy4jZ3Vlc3NlZFRleHQ7XG4gIH1cbiAgYXN5bmMgc2V0R3Vlc3NlZFRleHQoZ3Vlc3NlZFRleHQpIHtcbiAgICBpZiAodGhpcy4jYWx0VGV4dCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNndWVzc2VkVGV4dCA9IGd1ZXNzZWRUZXh0O1xuICAgIHRoaXMuI3RleHRXaXRoRGlzY2xhaW1lciA9IGF3YWl0IEFsdFRleHQuX2wxMG4uZ2V0KFwicGRmanMtZWRpdG9yLW5ldy1hbHQtdGV4dC1nZW5lcmF0ZWQtYWx0LXRleHQtd2l0aC1kaXNjbGFpbWVyXCIsIHtcbiAgICAgIGdlbmVyYXRlZEFsdFRleHQ6IGd1ZXNzZWRUZXh0XG4gICAgfSk7XG4gICAgdGhpcy4jc2V0U3RhdGUoKTtcbiAgfVxuICB0b2dnbGVBbHRUZXh0QmFkZ2UodmlzaWJpbGl0eSA9IGZhbHNlKSB7XG4gICAgaWYgKCF0aGlzLiN1c2VOZXdBbHRUZXh0RmxvdyB8fCB0aGlzLiNhbHRUZXh0KSB7XG4gICAgICB0aGlzLiNiYWRnZT8ucmVtb3ZlKCk7XG4gICAgICB0aGlzLiNiYWRnZSA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jYmFkZ2UpIHtcbiAgICAgIGNvbnN0IGJhZGdlID0gdGhpcy4jYmFkZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgYmFkZ2UuY2xhc3NOYW1lID0gXCJub0FsdFRleHRCYWRnZVwiO1xuICAgICAgdGhpcy4jZWRpdG9yLmRpdi5hcHBlbmQoYmFkZ2UpO1xuICAgIH1cbiAgICB0aGlzLiNiYWRnZS5jbGFzc0xpc3QudG9nZ2xlKFwiaGlkZGVuXCIsICF2aXNpYmlsaXR5KTtcbiAgfVxuICBzZXJpYWxpemUoaXNGb3JDb3B5aW5nKSB7XG4gICAgbGV0IGFsdFRleHQgPSB0aGlzLiNhbHRUZXh0O1xuICAgIGlmICghaXNGb3JDb3B5aW5nICYmIHRoaXMuI2d1ZXNzZWRUZXh0ID09PSBhbHRUZXh0KSB7XG4gICAgICBhbHRUZXh0ID0gdGhpcy4jdGV4dFdpdGhEaXNjbGFpbWVyO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgYWx0VGV4dCxcbiAgICAgIGRlY29yYXRpdmU6IHRoaXMuI2FsdFRleHREZWNvcmF0aXZlLFxuICAgICAgZ3Vlc3NlZFRleHQ6IHRoaXMuI2d1ZXNzZWRUZXh0LFxuICAgICAgdGV4dFdpdGhEaXNjbGFpbWVyOiB0aGlzLiN0ZXh0V2l0aERpc2NsYWltZXJcbiAgICB9O1xuICB9XG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhbHRUZXh0OiB0aGlzLiNhbHRUZXh0LFxuICAgICAgZGVjb3JhdGl2ZTogdGhpcy4jYWx0VGV4dERlY29yYXRpdmVcbiAgICB9O1xuICB9XG4gIHNldCBkYXRhKHtcbiAgICBhbHRUZXh0LFxuICAgIGRlY29yYXRpdmUsXG4gICAgZ3Vlc3NlZFRleHQsXG4gICAgdGV4dFdpdGhEaXNjbGFpbWVyLFxuICAgIGNhbmNlbCA9IGZhbHNlXG4gIH0pIHtcbiAgICBpZiAoZ3Vlc3NlZFRleHQpIHtcbiAgICAgIHRoaXMuI2d1ZXNzZWRUZXh0ID0gZ3Vlc3NlZFRleHQ7XG4gICAgICB0aGlzLiN0ZXh0V2l0aERpc2NsYWltZXIgPSB0ZXh0V2l0aERpc2NsYWltZXI7XG4gICAgfVxuICAgIGlmICh0aGlzLiNhbHRUZXh0ID09PSBhbHRUZXh0ICYmIHRoaXMuI2FsdFRleHREZWNvcmF0aXZlID09PSBkZWNvcmF0aXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY2FuY2VsKSB7XG4gICAgICB0aGlzLiNhbHRUZXh0ID0gYWx0VGV4dDtcbiAgICAgIHRoaXMuI2FsdFRleHREZWNvcmF0aXZlID0gZGVjb3JhdGl2ZTtcbiAgICB9XG4gICAgdGhpcy4jc2V0U3RhdGUoKTtcbiAgfVxuICB0b2dnbGUoZW5hYmxlZCA9IGZhbHNlKSB7XG4gICAgaWYgKCF0aGlzLiNhbHRUZXh0QnV0dG9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghZW5hYmxlZCAmJiB0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQpO1xuICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy4jYWx0VGV4dEJ1dHRvbi5kaXNhYmxlZCA9ICFlbmFibGVkO1xuICB9XG4gIHNob3duKCkge1xuICAgIHRoaXMuI2VkaXRvci5fcmVwb3J0VGVsZW1ldHJ5KHtcbiAgICAgIGFjdGlvbjogXCJwZGZqcy5pbWFnZS5hbHRfdGV4dC5pbWFnZV9zdGF0dXNfbGFiZWxfZGlzcGxheWVkXCIsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGxhYmVsOiB0aGlzLiNsYWJlbFxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4jYWx0VGV4dEJ1dHRvbj8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jYWx0VGV4dEJ1dHRvbiA9IG51bGw7XG4gICAgdGhpcy4jYWx0VGV4dEJ1dHRvbkxhYmVsID0gbnVsbDtcbiAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcCA9IG51bGw7XG4gICAgdGhpcy4jYmFkZ2U/LnJlbW92ZSgpO1xuICAgIHRoaXMuI2JhZGdlID0gbnVsbDtcbiAgfVxuICBhc3luYyAjc2V0U3RhdGUoKSB7XG4gICAgY29uc3QgYnV0dG9uID0gdGhpcy4jYWx0VGV4dEJ1dHRvbjtcbiAgICBpZiAoIWJ1dHRvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jdXNlTmV3QWx0VGV4dEZsb3cpIHtcbiAgICAgIGJ1dHRvbi5jbGFzc0xpc3QudG9nZ2xlKFwiZG9uZVwiLCAhIXRoaXMuI2FsdFRleHQpO1xuICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBBbHRUZXh0LiNsMTBuTmV3QnV0dG9uW3RoaXMuI2xhYmVsXSk7XG4gICAgICB0aGlzLiNhbHRUZXh0QnV0dG9uTGFiZWw/LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBBbHRUZXh0LiNsMTBuTmV3QnV0dG9uW2Ake3RoaXMuI2xhYmVsfS1sYWJlbGBdKTtcbiAgICAgIGlmICghdGhpcy4jYWx0VGV4dCkge1xuICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcD8ucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLiNhbHRUZXh0ICYmICF0aGlzLiNhbHRUZXh0RGVjb3JhdGl2ZSkge1xuICAgICAgICBidXR0b24uY2xhc3NMaXN0LnJlbW92ZShcImRvbmVcIik7XG4gICAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwPy5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJkb25lXCIpO1xuICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLWVkaXRvci1hbHQtdGV4dC1lZGl0LWJ1dHRvblwiKTtcbiAgICB9XG4gICAgbGV0IHRvb2x0aXAgPSB0aGlzLiNhbHRUZXh0VG9vbHRpcDtcbiAgICBpZiAoIXRvb2x0aXApIHtcbiAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwID0gdG9vbHRpcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgdG9vbHRpcC5jbGFzc05hbWUgPSBcInRvb2x0aXBcIjtcbiAgICAgIHRvb2x0aXAuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInRvb2x0aXBcIik7XG4gICAgICB0b29sdGlwLmlkID0gYGFsdC10ZXh0LXRvb2x0aXAtJHt0aGlzLiNlZGl0b3IuaWR9YDtcbiAgICAgIGNvbnN0IERFTEFZX1RPX1NIT1dfVE9PTFRJUCA9IDEwMDtcbiAgICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI2VkaXRvci5fdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCk7XG4gICAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCA9IG51bGw7XG4gICAgICB9LCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcC5jbGFzc0xpc3QuYWRkKFwic2hvd1wiKTtcbiAgICAgICAgICB0aGlzLiNlZGl0b3IuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICAgICAgICBhY3Rpb246IFwiYWx0X3RleHRfdG9vbHRpcFwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIERFTEFZX1RPX1NIT1dfVE9PTFRJUCk7XG4gICAgICB9LCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCk7XG4gICAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcD8uY2xhc3NMaXN0LnJlbW92ZShcInNob3dcIik7XG4gICAgICB9LCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNhbHRUZXh0RGVjb3JhdGl2ZSkge1xuICAgICAgdG9vbHRpcC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1lZGl0b3ItYWx0LXRleHQtZGVjb3JhdGl2ZS10b29sdGlwXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b29sdGlwLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiKTtcbiAgICAgIHRvb2x0aXAudGV4dENvbnRlbnQgPSB0aGlzLiNhbHRUZXh0O1xuICAgIH1cbiAgICBpZiAoIXRvb2x0aXAucGFyZW50Tm9kZSkge1xuICAgICAgYnV0dG9uLmFwcGVuZCh0b29sdGlwKTtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuI2VkaXRvci5nZXRJbWFnZUZvckFsdFRleHQoKTtcbiAgICBlbGVtZW50Py5zZXRBdHRyaWJ1dGUoXCJhcmlhLWRlc2NyaWJlZGJ5XCIsIHRvb2x0aXAuaWQpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9lZGl0b3IuanNcblxuXG5cblxuXG5jbGFzcyBBbm5vdGF0aW9uRWRpdG9yIHtcbiAgI2FjY2Vzc2liaWxpdHlEYXRhID0gbnVsbDtcbiAgI2FsbFJlc2l6ZXJEaXZzID0gbnVsbDtcbiAgI2FsdFRleHQgPSBudWxsO1xuICAjZGlzYWJsZWQgPSBmYWxzZTtcbiAgI2RyYWdQb2ludGVySWQgPSBudWxsO1xuICAjZHJhZ1BvaW50ZXJUeXBlID0gXCJcIjtcbiAgI2tlZXBBc3BlY3RSYXRpbyA9IGZhbHNlO1xuICAjcmVzaXplcnNEaXYgPSBudWxsO1xuICAjbGFzdFBvaW50ZXJDb29yZHMgPSBudWxsO1xuICAjc2F2ZWREaW1lbnNpb25zID0gbnVsbDtcbiAgI2ZvY3VzQUMgPSBudWxsO1xuICAjZm9jdXNlZFJlc2l6ZXJOYW1lID0gXCJcIjtcbiAgI2hhc0JlZW5DbGlja2VkID0gZmFsc2U7XG4gICNpbml0aWFsUmVjdCA9IG51bGw7XG4gICNpc0VkaXRpbmcgPSBmYWxzZTtcbiAgI2lzSW5FZGl0TW9kZSA9IGZhbHNlO1xuICAjaXNSZXNpemVyRW5hYmxlZEZvcktleWJvYXJkID0gZmFsc2U7XG4gICNtb3ZlSW5ET01UaW1lb3V0ID0gbnVsbDtcbiAgI3ByZXZEcmFnWCA9IDA7XG4gICNwcmV2RHJhZ1kgPSAwO1xuICAjdGVsZW1ldHJ5VGltZW91dHMgPSBudWxsO1xuICBfZWRpdFRvb2xiYXIgPSBudWxsO1xuICBfaW5pdGlhbE9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBfaW5pdGlhbERhdGEgPSBudWxsO1xuICBfaXNWaXNpYmxlID0gdHJ1ZTtcbiAgX3VpTWFuYWdlciA9IG51bGw7XG4gIF9mb2N1c0V2ZW50c0FsbG93ZWQgPSB0cnVlO1xuICBzdGF0aWMgX2wxMG4gPSBudWxsO1xuICBzdGF0aWMgX2wxMG5SZXNpemVyID0gbnVsbDtcbiAgI2lzRHJhZ2dhYmxlID0gZmFsc2U7XG4gICN6SW5kZXggPSBBbm5vdGF0aW9uRWRpdG9yLl96SW5kZXgrKztcbiAgc3RhdGljIF9ib3JkZXJMaW5lV2lkdGggPSAtMTtcbiAgc3RhdGljIF9jb2xvck1hbmFnZXIgPSBuZXcgQ29sb3JNYW5hZ2VyKCk7XG4gIHN0YXRpYyBfekluZGV4ID0gMTtcbiAgc3RhdGljIF90ZWxlbWV0cnlUaW1lb3V0ID0gMTAwMDtcbiAgc3RhdGljIGdldCBfcmVzaXplcktleWJvYXJkTWFuYWdlcigpIHtcbiAgICBjb25zdCByZXNpemUgPSBBbm5vdGF0aW9uRWRpdG9yLnByb3RvdHlwZS5fcmVzaXplV2l0aEtleWJvYXJkO1xuICAgIGNvbnN0IHNtYWxsID0gQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5UUkFOU0xBVEVfU01BTEw7XG4gICAgY29uc3QgYmlnID0gQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5UUkFOU0xBVEVfQklHO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfcmVzaXplcktleWJvYXJkTWFuYWdlclwiLCBuZXcgS2V5Ym9hcmRNYW5hZ2VyKFtbW1wiQXJyb3dMZWZ0XCIsIFwibWFjK0Fycm93TGVmdFwiXSwgcmVzaXplLCB7XG4gICAgICBhcmdzOiBbLXNtYWxsLCAwXVxuICAgIH1dLCBbW1wiY3RybCtBcnJvd0xlZnRcIiwgXCJtYWMrc2hpZnQrQXJyb3dMZWZ0XCJdLCByZXNpemUsIHtcbiAgICAgIGFyZ3M6IFstYmlnLCAwXVxuICAgIH1dLCBbW1wiQXJyb3dSaWdodFwiLCBcIm1hYytBcnJvd1JpZ2h0XCJdLCByZXNpemUsIHtcbiAgICAgIGFyZ3M6IFtzbWFsbCwgMF1cbiAgICB9XSwgW1tcImN0cmwrQXJyb3dSaWdodFwiLCBcIm1hYytzaGlmdCtBcnJvd1JpZ2h0XCJdLCByZXNpemUsIHtcbiAgICAgIGFyZ3M6IFtiaWcsIDBdXG4gICAgfV0sIFtbXCJBcnJvd1VwXCIsIFwibWFjK0Fycm93VXBcIl0sIHJlc2l6ZSwge1xuICAgICAgYXJnczogWzAsIC1zbWFsbF1cbiAgICB9XSwgW1tcImN0cmwrQXJyb3dVcFwiLCBcIm1hYytzaGlmdCtBcnJvd1VwXCJdLCByZXNpemUsIHtcbiAgICAgIGFyZ3M6IFswLCAtYmlnXVxuICAgIH1dLCBbW1wiQXJyb3dEb3duXCIsIFwibWFjK0Fycm93RG93blwiXSwgcmVzaXplLCB7XG4gICAgICBhcmdzOiBbMCwgc21hbGxdXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93RG93blwiLCBcIm1hYytzaGlmdCtBcnJvd0Rvd25cIl0sIHJlc2l6ZSwge1xuICAgICAgYXJnczogWzAsIGJpZ11cbiAgICB9XSwgW1tcIkVzY2FwZVwiLCBcIm1hYytFc2NhcGVcIl0sIEFubm90YXRpb25FZGl0b3IucHJvdG90eXBlLl9zdG9wUmVzaXppbmdXaXRoS2V5Ym9hcmRdXSkpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmFtZXRlcnMucGFyZW50O1xuICAgIHRoaXMuaWQgPSBwYXJhbWV0ZXJzLmlkO1xuICAgIHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IG51bGw7XG4gICAgdGhpcy5wYWdlSW5kZXggPSBwYXJhbWV0ZXJzLnBhcmVudC5wYWdlSW5kZXg7XG4gICAgdGhpcy5uYW1lID0gcGFyYW1ldGVycy5uYW1lO1xuICAgIHRoaXMuZGl2ID0gbnVsbDtcbiAgICB0aGlzLl91aU1hbmFnZXIgPSBwYXJhbWV0ZXJzLnVpTWFuYWdlcjtcbiAgICB0aGlzLmFubm90YXRpb25FbGVtZW50SWQgPSBudWxsO1xuICAgIHRoaXMuX3dpbGxLZWVwQXNwZWN0UmF0aW8gPSBmYWxzZTtcbiAgICB0aGlzLl9pbml0aWFsT3B0aW9ucy5pc0NlbnRlcmVkID0gcGFyYW1ldGVycy5pc0NlbnRlcmVkO1xuICAgIHRoaXMuX3N0cnVjdFRyZWVQYXJlbnRJZCA9IG51bGw7XG4gICAgY29uc3Qge1xuICAgICAgcm90YXRpb24sXG4gICAgICByYXdEaW1zOiB7XG4gICAgICAgIHBhZ2VXaWR0aCxcbiAgICAgICAgcGFnZUhlaWdodCxcbiAgICAgICAgcGFnZVgsXG4gICAgICAgIHBhZ2VZXG4gICAgICB9XG4gICAgfSA9IHRoaXMucGFyZW50LnZpZXdwb3J0O1xuICAgIHRoaXMucm90YXRpb24gPSByb3RhdGlvbjtcbiAgICB0aGlzLnBhZ2VSb3RhdGlvbiA9ICgzNjAgKyByb3RhdGlvbiAtIHRoaXMuX3VpTWFuYWdlci52aWV3UGFyYW1ldGVycy5yb3RhdGlvbikgJSAzNjA7XG4gICAgdGhpcy5wYWdlRGltZW5zaW9ucyA9IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdO1xuICAgIHRoaXMucGFnZVRyYW5zbGF0aW9uID0gW3BhZ2VYLCBwYWdlWV07XG4gICAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMueCA9IHBhcmFtZXRlcnMueCAvIHdpZHRoO1xuICAgIHRoaXMueSA9IHBhcmFtZXRlcnMueSAvIGhlaWdodDtcbiAgICB0aGlzLmlzQXR0YWNoZWRUb0RPTSA9IGZhbHNlO1xuICAgIHRoaXMuZGVsZXRlZCA9IGZhbHNlO1xuICB9XG4gIGdldCBlZGl0b3JUeXBlKCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IuX3R5cGU7XG4gIH1cbiAgc3RhdGljIGdldCBpc0RyYXdlcigpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhdGljIGdldCBfZGVmYXVsdExpbmVDb2xvcigpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2RlZmF1bHRMaW5lQ29sb3JcIiwgdGhpcy5fY29sb3JNYW5hZ2VyLmdldEhleENvZGUoXCJDYW52YXNUZXh0XCIpKTtcbiAgfVxuICBzdGF0aWMgZGVsZXRlQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yKSB7XG4gICAgY29uc3QgZmFrZUVkaXRvciA9IG5ldyBGYWtlRWRpdG9yKHtcbiAgICAgIGlkOiBlZGl0b3IucGFyZW50LmdldE5leHRJZCgpLFxuICAgICAgcGFyZW50OiBlZGl0b3IucGFyZW50LFxuICAgICAgdWlNYW5hZ2VyOiBlZGl0b3IuX3VpTWFuYWdlclxuICAgIH0pO1xuICAgIGZha2VFZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCA9IGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkO1xuICAgIGZha2VFZGl0b3IuZGVsZXRlZCA9IHRydWU7XG4gICAgZmFrZUVkaXRvci5fdWlNYW5hZ2VyLmFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoZmFrZUVkaXRvcik7XG4gIH1cbiAgc3RhdGljIGluaXRpYWxpemUobDEwbiwgX3VpTWFuYWdlcikge1xuICAgIEFubm90YXRpb25FZGl0b3IuX2wxMG4gPz89IGwxMG47XG4gICAgQW5ub3RhdGlvbkVkaXRvci5fbDEwblJlc2l6ZXIgfHw9IE9iamVjdC5mcmVlemUoe1xuICAgICAgdG9wTGVmdDogXCJwZGZqcy1lZGl0b3ItcmVzaXplci10b3AtbGVmdFwiLFxuICAgICAgdG9wTWlkZGxlOiBcInBkZmpzLWVkaXRvci1yZXNpemVyLXRvcC1taWRkbGVcIixcbiAgICAgIHRvcFJpZ2h0OiBcInBkZmpzLWVkaXRvci1yZXNpemVyLXRvcC1yaWdodFwiLFxuICAgICAgbWlkZGxlUmlnaHQ6IFwicGRmanMtZWRpdG9yLXJlc2l6ZXItbWlkZGxlLXJpZ2h0XCIsXG4gICAgICBib3R0b21SaWdodDogXCJwZGZqcy1lZGl0b3ItcmVzaXplci1ib3R0b20tcmlnaHRcIixcbiAgICAgIGJvdHRvbU1pZGRsZTogXCJwZGZqcy1lZGl0b3ItcmVzaXplci1ib3R0b20tbWlkZGxlXCIsXG4gICAgICBib3R0b21MZWZ0OiBcInBkZmpzLWVkaXRvci1yZXNpemVyLWJvdHRvbS1sZWZ0XCIsXG4gICAgICBtaWRkbGVMZWZ0OiBcInBkZmpzLWVkaXRvci1yZXNpemVyLW1pZGRsZS1sZWZ0XCJcbiAgICB9KTtcbiAgICBpZiAoQW5ub3RhdGlvbkVkaXRvci5fYm9yZGVyTGluZVdpZHRoICE9PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLl9ib3JkZXJMaW5lV2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCItLW91dGxpbmUtd2lkdGhcIikpIHx8IDA7XG4gIH1cbiAgc3RhdGljIHVwZGF0ZURlZmF1bHRQYXJhbXMoX3R5cGUsIF92YWx1ZSkge31cbiAgc3RhdGljIGdldCBkZWZhdWx0UHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBzdGF0aWMgaXNIYW5kbGluZ01pbWVGb3JQYXN0aW5nKG1pbWUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhdGljIHBhc3RlKGl0ZW0sIHBhcmVudCkge1xuICAgIHVucmVhY2hhYmxlKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIGdldCBwcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGdldCBfaXNEcmFnZ2FibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2lzRHJhZ2dhYmxlO1xuICB9XG4gIHNldCBfaXNEcmFnZ2FibGUodmFsdWUpIHtcbiAgICB0aGlzLiNpc0RyYWdnYWJsZSA9IHZhbHVlO1xuICAgIHRoaXMuZGl2Py5jbGFzc0xpc3QudG9nZ2xlKFwiZHJhZ2dhYmxlXCIsIHZhbHVlKTtcbiAgfVxuICBnZXQgaXNFbnRlckhhbmRsZWQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY2VudGVyKCkge1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICBzd2l0Y2ggKHRoaXMucGFyZW50Um90YXRpb24pIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHRoaXMueCAtPSB0aGlzLmhlaWdodCAqIHBhZ2VIZWlnaHQgLyAocGFnZVdpZHRoICogMik7XG4gICAgICAgIHRoaXMueSArPSB0aGlzLndpZHRoICogcGFnZVdpZHRoIC8gKHBhZ2VIZWlnaHQgKiAyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgdGhpcy54ICs9IHRoaXMud2lkdGggLyAyO1xuICAgICAgICB0aGlzLnkgKz0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICB0aGlzLnggKz0gdGhpcy5oZWlnaHQgKiBwYWdlSGVpZ2h0IC8gKHBhZ2VXaWR0aCAqIDIpO1xuICAgICAgICB0aGlzLnkgLT0gdGhpcy53aWR0aCAqIHBhZ2VXaWR0aCAvIChwYWdlSGVpZ2h0ICogMik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy54IC09IHRoaXMud2lkdGggLyAyO1xuICAgICAgICB0aGlzLnkgLT0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICB9XG4gIGFkZENvbW1hbmRzKHBhcmFtcykge1xuICAgIHRoaXMuX3VpTWFuYWdlci5hZGRDb21tYW5kcyhwYXJhbXMpO1xuICB9XG4gIGdldCBjdXJyZW50TGF5ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VpTWFuYWdlci5jdXJyZW50TGF5ZXI7XG4gIH1cbiAgc2V0SW5CYWNrZ3JvdW5kKCkge1xuICAgIHRoaXMuZGl2LnN0eWxlLnpJbmRleCA9IDA7XG4gIH1cbiAgc2V0SW5Gb3JlZ3JvdW5kKCkge1xuICAgIHRoaXMuZGl2LnN0eWxlLnpJbmRleCA9IHRoaXMuI3pJbmRleDtcbiAgfVxuICBzZXRQYXJlbnQocGFyZW50KSB7XG4gICAgaWYgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5wYWdlSW5kZXggPSBwYXJlbnQucGFnZUluZGV4O1xuICAgICAgdGhpcy5wYWdlRGltZW5zaW9ucyA9IHBhcmVudC5wYWdlRGltZW5zaW9ucztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jc3RvcFJlc2l6aW5nKCk7XG4gICAgfVxuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB9XG4gIGZvY3VzaW4oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX2ZvY3VzRXZlbnRzQWxsb3dlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2hhc0JlZW5DbGlja2VkKSB7XG4gICAgICB0aGlzLnBhcmVudC5zZXRTZWxlY3RlZCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jaGFzQmVlbkNsaWNrZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9jdXNvdXQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX2ZvY3VzRXZlbnRzQWxsb3dlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gICAgaWYgKHRhcmdldD8uY2xvc2VzdChgIyR7dGhpcy5pZH1gKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICghdGhpcy5wYXJlbnQ/LmlzTXVsdGlwbGVTZWxlY3Rpb24pIHtcbiAgICAgIHRoaXMuY29tbWl0T3JSZW1vdmUoKTtcbiAgICB9XG4gIH1cbiAgY29tbWl0T3JSZW1vdmUoKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICB0aGlzLnJlbW92ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbW1pdCgpO1xuICAgIH1cbiAgfVxuICBjb21taXQoKSB7XG4gICAgdGhpcy5hZGRUb0Fubm90YXRpb25TdG9yYWdlKCk7XG4gIH1cbiAgYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZSgpIHtcbiAgICB0aGlzLl91aU1hbmFnZXIuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZSh0aGlzKTtcbiAgfVxuICBzZXRBdCh4LCB5LCB0eCwgdHkpIHtcbiAgICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgW3R4LCB0eV0gPSB0aGlzLnNjcmVlblRvUGFnZVRyYW5zbGF0aW9uKHR4LCB0eSk7XG4gICAgdGhpcy54ID0gKHggKyB0eCkgLyB3aWR0aDtcbiAgICB0aGlzLnkgPSAoeSArIHR5KSAvIGhlaWdodDtcbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gIH1cbiAgI3RyYW5zbGF0ZShbd2lkdGgsIGhlaWdodF0sIHgsIHkpIHtcbiAgICBbeCwgeV0gPSB0aGlzLnNjcmVlblRvUGFnZVRyYW5zbGF0aW9uKHgsIHkpO1xuICAgIHRoaXMueCArPSB4IC8gd2lkdGg7XG4gICAgdGhpcy55ICs9IHkgLyBoZWlnaHQ7XG4gICAgdGhpcy5fb25UcmFuc2xhdGluZyh0aGlzLngsIHRoaXMueSk7XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICB9XG4gIHRyYW5zbGF0ZSh4LCB5KSB7XG4gICAgdGhpcy4jdHJhbnNsYXRlKHRoaXMucGFyZW50RGltZW5zaW9ucywgeCwgeSk7XG4gIH1cbiAgdHJhbnNsYXRlSW5QYWdlKHgsIHkpIHtcbiAgICB0aGlzLiNpbml0aWFsUmVjdCB8fD0gW3RoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodF07XG4gICAgdGhpcy4jdHJhbnNsYXRlKHRoaXMucGFnZURpbWVuc2lvbnMsIHgsIHkpO1xuICAgIHRoaXMuZGl2LnNjcm9sbEludG9WaWV3KHtcbiAgICAgIGJsb2NrOiBcIm5lYXJlc3RcIlxuICAgIH0pO1xuICB9XG4gIGRyYWcodHgsIHR5KSB7XG4gICAgdGhpcy4jaW5pdGlhbFJlY3QgfHw9IFt0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHRdO1xuICAgIGNvbnN0IHtcbiAgICAgIGRpdixcbiAgICAgIHBhcmVudERpbWVuc2lvbnM6IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XVxuICAgIH0gPSB0aGlzO1xuICAgIHRoaXMueCArPSB0eCAvIHBhcmVudFdpZHRoO1xuICAgIHRoaXMueSArPSB0eSAvIHBhcmVudEhlaWdodDtcbiAgICBpZiAodGhpcy5wYXJlbnQgJiYgKHRoaXMueCA8IDAgfHwgdGhpcy54ID4gMSB8fCB0aGlzLnkgPCAwIHx8IHRoaXMueSA+IDEpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSB0aGlzLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGlmICh0aGlzLnBhcmVudC5maW5kTmV3UGFyZW50KHRoaXMsIHgsIHkpKSB7XG4gICAgICAgIHRoaXMueCAtPSBNYXRoLmZsb29yKHRoaXMueCk7XG4gICAgICAgIHRoaXMueSAtPSBNYXRoLmZsb29yKHRoaXMueSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IFtieCwgYnldID0gdGhpcy5nZXRCYXNlVHJhbnNsYXRpb24oKTtcbiAgICB4ICs9IGJ4O1xuICAgIHkgKz0gYnk7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gZGl2O1xuICAgIHN0eWxlLmxlZnQgPSBgJHsoMTAwICogeCkudG9GaXhlZCgyKX0lYDtcbiAgICBzdHlsZS50b3AgPSBgJHsoMTAwICogeSkudG9GaXhlZCgyKX0lYDtcbiAgICB0aGlzLl9vblRyYW5zbGF0aW5nKHgsIHkpO1xuICAgIGRpdi5zY3JvbGxJbnRvVmlldyh7XG4gICAgICBibG9jazogXCJuZWFyZXN0XCJcbiAgICB9KTtcbiAgfVxuICBfb25UcmFuc2xhdGluZyh4LCB5KSB7fVxuICBfb25UcmFuc2xhdGVkKHgsIHkpIHt9XG4gIGdldCBfaGFzQmVlbk1vdmVkKCkge1xuICAgIHJldHVybiAhIXRoaXMuI2luaXRpYWxSZWN0ICYmICh0aGlzLiNpbml0aWFsUmVjdFswXSAhPT0gdGhpcy54IHx8IHRoaXMuI2luaXRpYWxSZWN0WzFdICE9PSB0aGlzLnkpO1xuICB9XG4gIGdldCBfaGFzQmVlblJlc2l6ZWQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy4jaW5pdGlhbFJlY3QgJiYgKHRoaXMuI2luaXRpYWxSZWN0WzJdICE9PSB0aGlzLndpZHRoIHx8IHRoaXMuI2luaXRpYWxSZWN0WzNdICE9PSB0aGlzLmhlaWdodCk7XG4gIH1cbiAgZ2V0QmFzZVRyYW5zbGF0aW9uKCkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBjb25zdCB7XG4gICAgICBfYm9yZGVyTGluZVdpZHRoXG4gICAgfSA9IEFubm90YXRpb25FZGl0b3I7XG4gICAgY29uc3QgeCA9IF9ib3JkZXJMaW5lV2lkdGggLyBwYXJlbnRXaWR0aDtcbiAgICBjb25zdCB5ID0gX2JvcmRlckxpbmVXaWR0aCAvIHBhcmVudEhlaWdodDtcbiAgICBzd2l0Y2ggKHRoaXMucm90YXRpb24pIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbLXgsIHldO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbeCwgeV07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmV0dXJuIFt4LCAteV07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gWy14LCAteV07XG4gICAgfVxuICB9XG4gIGdldCBfbXVzdEZpeFBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZpeEFuZFNldFBvc2l0aW9uKHJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIGRpdjoge1xuICAgICAgICBzdHlsZVxuICAgICAgfSxcbiAgICAgIHBhZ2VEaW1lbnNpb25zOiBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XVxuICAgIH0gPSB0aGlzO1xuICAgIGxldCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXM7XG4gICAgd2lkdGggKj0gcGFnZVdpZHRoO1xuICAgIGhlaWdodCAqPSBwYWdlSGVpZ2h0O1xuICAgIHggKj0gcGFnZVdpZHRoO1xuICAgIHkgKj0gcGFnZUhlaWdodDtcbiAgICBpZiAodGhpcy5fbXVzdEZpeFBvc2l0aW9uKSB7XG4gICAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICB4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocGFnZVdpZHRoIC0gd2lkdGgsIHgpKTtcbiAgICAgICAgICB5ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocGFnZUhlaWdodCAtIGhlaWdodCwgeSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDkwOlxuICAgICAgICAgIHggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihwYWdlV2lkdGggLSBoZWlnaHQsIHgpKTtcbiAgICAgICAgICB5ID0gTWF0aC5taW4ocGFnZUhlaWdodCwgTWF0aC5tYXgod2lkdGgsIHkpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxODA6XG4gICAgICAgICAgeCA9IE1hdGgubWluKHBhZ2VXaWR0aCwgTWF0aC5tYXgod2lkdGgsIHgpKTtcbiAgICAgICAgICB5ID0gTWF0aC5taW4ocGFnZUhlaWdodCwgTWF0aC5tYXgoaGVpZ2h0LCB5KSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjcwOlxuICAgICAgICAgIHggPSBNYXRoLm1pbihwYWdlV2lkdGgsIE1hdGgubWF4KGhlaWdodCwgeCkpO1xuICAgICAgICAgIHkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihwYWdlSGVpZ2h0IC0gd2lkdGgsIHkpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy54ID0geCAvPSBwYWdlV2lkdGg7XG4gICAgdGhpcy55ID0geSAvPSBwYWdlSGVpZ2h0O1xuICAgIGNvbnN0IFtieCwgYnldID0gdGhpcy5nZXRCYXNlVHJhbnNsYXRpb24oKTtcbiAgICB4ICs9IGJ4O1xuICAgIHkgKz0gYnk7XG4gICAgc3R5bGUubGVmdCA9IGAkeygxMDAgKiB4KS50b0ZpeGVkKDIpfSVgO1xuICAgIHN0eWxlLnRvcCA9IGAkeygxMDAgKiB5KS50b0ZpeGVkKDIpfSVgO1xuICAgIHRoaXMubW92ZUluRE9NKCk7XG4gIH1cbiAgc3RhdGljICNyb3RhdGVQb2ludCh4LCB5LCBhbmdsZSkge1xuICAgIHN3aXRjaCAoYW5nbGUpIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbeSwgLXhdO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbLXgsIC15XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gWy15LCB4XTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfVxuICB9XG4gIHNjcmVlblRvUGFnZVRyYW5zbGF0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4gQW5ub3RhdGlvbkVkaXRvci4jcm90YXRlUG9pbnQoeCwgeSwgdGhpcy5wYXJlbnRSb3RhdGlvbik7XG4gIH1cbiAgcGFnZVRyYW5zbGF0aW9uVG9TY3JlZW4oeCwgeSkge1xuICAgIHJldHVybiBBbm5vdGF0aW9uRWRpdG9yLiNyb3RhdGVQb2ludCh4LCB5LCAzNjAgLSB0aGlzLnBhcmVudFJvdGF0aW9uKTtcbiAgfVxuICAjZ2V0Um90YXRpb25NYXRyaXgocm90YXRpb24pIHtcbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgICAgICAgIHJldHVybiBbMCwgLXBhZ2VXaWR0aCAvIHBhZ2VIZWlnaHQsIHBhZ2VIZWlnaHQgLyBwYWdlV2lkdGgsIDBdO1xuICAgICAgICB9XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFstMSwgMCwgMCwgLTFdO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgICAgICAgcmV0dXJuIFswLCBwYWdlV2lkdGggLyBwYWdlSGVpZ2h0LCAtcGFnZUhlaWdodCAvIHBhZ2VXaWR0aCwgMF07XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbMSwgMCwgMCwgMV07XG4gICAgfVxuICB9XG4gIGdldCBwYXJlbnRTY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdWlNYW5hZ2VyLnZpZXdQYXJhbWV0ZXJzLnJlYWxTY2FsZTtcbiAgfVxuICBnZXQgcGFyZW50Um90YXRpb24oKSB7XG4gICAgcmV0dXJuICh0aGlzLl91aU1hbmFnZXIudmlld1BhcmFtZXRlcnMucm90YXRpb24gKyB0aGlzLnBhZ2VSb3RhdGlvbikgJSAzNjA7XG4gIH1cbiAgZ2V0IHBhcmVudERpbWVuc2lvbnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgcGFyZW50U2NhbGUsXG4gICAgICBwYWdlRGltZW5zaW9uczogW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF1cbiAgICB9ID0gdGhpcztcbiAgICByZXR1cm4gW3BhZ2VXaWR0aCAqIHBhcmVudFNjYWxlLCBwYWdlSGVpZ2h0ICogcGFyZW50U2NhbGVdO1xuICB9XG4gIHNldERpbXMod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSB0aGlzLmRpdjtcbiAgICBzdHlsZS53aWR0aCA9IGAkeygxMDAgKiB3aWR0aCAvIHBhcmVudFdpZHRoKS50b0ZpeGVkKDIpfSVgO1xuICAgIGlmICghdGhpcy4ja2VlcEFzcGVjdFJhdGlvKSB7XG4gICAgICBzdHlsZS5oZWlnaHQgPSBgJHsoMTAwICogaGVpZ2h0IC8gcGFyZW50SGVpZ2h0KS50b0ZpeGVkKDIpfSVgO1xuICAgIH1cbiAgfVxuICBmaXhEaW1zKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IHRoaXMuZGl2O1xuICAgIGNvbnN0IHtcbiAgICAgIGhlaWdodCxcbiAgICAgIHdpZHRoXG4gICAgfSA9IHN0eWxlO1xuICAgIGNvbnN0IHdpZHRoUGVyY2VudCA9IHdpZHRoLmVuZHNXaXRoKFwiJVwiKTtcbiAgICBjb25zdCBoZWlnaHRQZXJjZW50ID0gIXRoaXMuI2tlZXBBc3BlY3RSYXRpbyAmJiBoZWlnaHQuZW5kc1dpdGgoXCIlXCIpO1xuICAgIGlmICh3aWR0aFBlcmNlbnQgJiYgaGVpZ2h0UGVyY2VudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgaWYgKCF3aWR0aFBlcmNlbnQpIHtcbiAgICAgIHN0eWxlLndpZHRoID0gYCR7KDEwMCAqIHBhcnNlRmxvYXQod2lkdGgpIC8gcGFyZW50V2lkdGgpLnRvRml4ZWQoMil9JWA7XG4gICAgfVxuICAgIGlmICghdGhpcy4ja2VlcEFzcGVjdFJhdGlvICYmICFoZWlnaHRQZXJjZW50KSB7XG4gICAgICBzdHlsZS5oZWlnaHQgPSBgJHsoMTAwICogcGFyc2VGbG9hdChoZWlnaHQpIC8gcGFyZW50SGVpZ2h0KS50b0ZpeGVkKDIpfSVgO1xuICAgIH1cbiAgfVxuICBnZXRJbml0aWFsVHJhbnNsYXRpb24oKSB7XG4gICAgcmV0dXJuIFswLCAwXTtcbiAgfVxuICAjY3JlYXRlUmVzaXplcnMoKSB7XG4gICAgaWYgKHRoaXMuI3Jlc2l6ZXJzRGl2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3Jlc2l6ZXJzRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLiNyZXNpemVyc0Rpdi5jbGFzc0xpc3QuYWRkKFwicmVzaXplcnNcIik7XG4gICAgY29uc3QgY2xhc3NlcyA9IHRoaXMuX3dpbGxLZWVwQXNwZWN0UmF0aW8gPyBbXCJ0b3BMZWZ0XCIsIFwidG9wUmlnaHRcIiwgXCJib3R0b21SaWdodFwiLCBcImJvdHRvbUxlZnRcIl0gOiBbXCJ0b3BMZWZ0XCIsIFwidG9wTWlkZGxlXCIsIFwidG9wUmlnaHRcIiwgXCJtaWRkbGVSaWdodFwiLCBcImJvdHRvbVJpZ2h0XCIsIFwiYm90dG9tTWlkZGxlXCIsIFwiYm90dG9tTGVmdFwiLCBcIm1pZGRsZUxlZnRcIl07XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5fdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIGNsYXNzZXMpIHtcbiAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLiNyZXNpemVyc0Rpdi5hcHBlbmQoZGl2KTtcbiAgICAgIGRpdi5jbGFzc0xpc3QuYWRkKFwicmVzaXplclwiLCBuYW1lKTtcbiAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLXJlc2l6ZXItbmFtZVwiLCBuYW1lKTtcbiAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcy4jcmVzaXplclBvaW50ZXJkb3duLmJpbmQodGhpcywgbmFtZSksIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgZGl2LnRhYkluZGV4ID0gLTE7XG4gICAgfVxuICAgIHRoaXMuZGl2LnByZXBlbmQodGhpcy4jcmVzaXplcnNEaXYpO1xuICB9XG4gICNyZXNpemVyUG9pbnRlcmRvd24obmFtZSwgZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCBldmVudC5jdHJsS2V5ICYmIGlzTWFjKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2FsdFRleHQ/LnRvZ2dsZShmYWxzZSk7XG4gICAgY29uc3Qgc2F2ZWREcmFnZ2FibGUgPSB0aGlzLl9pc0RyYWdnYWJsZTtcbiAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuI2xhc3RQb2ludGVyQ29vcmRzID0gW2V2ZW50LnNjcmVlblgsIGV2ZW50LnNjcmVlblldO1xuICAgIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbChhYyk7XG4gICAgdGhpcy5wYXJlbnQudG9nZ2xlUG9pbnRlckV2ZW50cyhmYWxzZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCB0aGlzLiNyZXNpemVyUG9pbnRlcm1vdmUuYmluZCh0aGlzLCBuYW1lKSwge1xuICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBzdG9wRXZlbnQsIHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLiNzYXZlZERpbWVuc2lvbnMgPSB7XG4gICAgICBzYXZlZFg6IHRoaXMueCxcbiAgICAgIHNhdmVkWTogdGhpcy55LFxuICAgICAgc2F2ZWRXaWR0aDogdGhpcy53aWR0aCxcbiAgICAgIHNhdmVkSGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgIH07XG4gICAgY29uc3Qgc2F2ZWRQYXJlbnRDdXJzb3IgPSB0aGlzLnBhcmVudC5kaXYuc3R5bGUuY3Vyc29yO1xuICAgIGNvbnN0IHNhdmVkQ3Vyc29yID0gdGhpcy5kaXYuc3R5bGUuY3Vyc29yO1xuICAgIHRoaXMuZGl2LnN0eWxlLmN1cnNvciA9IHRoaXMucGFyZW50LmRpdi5zdHlsZS5jdXJzb3IgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShldmVudC50YXJnZXQpLmN1cnNvcjtcbiAgICBjb25zdCBwb2ludGVyVXBDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIGFjLmFib3J0KCk7XG4gICAgICB0aGlzLnBhcmVudC50b2dnbGVQb2ludGVyRXZlbnRzKHRydWUpO1xuICAgICAgdGhpcy4jYWx0VGV4dD8udG9nZ2xlKHRydWUpO1xuICAgICAgdGhpcy5faXNEcmFnZ2FibGUgPSBzYXZlZERyYWdnYWJsZTtcbiAgICAgIHRoaXMucGFyZW50LmRpdi5zdHlsZS5jdXJzb3IgPSBzYXZlZFBhcmVudEN1cnNvcjtcbiAgICAgIHRoaXMuZGl2LnN0eWxlLmN1cnNvciA9IHNhdmVkQ3Vyc29yO1xuICAgICAgdGhpcy4jYWRkUmVzaXplVG9VbmRvU3RhY2soKTtcbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHBvaW50ZXJVcENhbGxiYWNrLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgcG9pbnRlclVwQ2FsbGJhY2ssIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gICNyZXNpemUoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMuc2V0RGltcyhwYXJlbnRXaWR0aCAqIHdpZHRoLCBwYXJlbnRIZWlnaHQgKiBoZWlnaHQpO1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICB0aGlzLl9vblJlc2l6ZWQoKTtcbiAgfVxuICBfb25SZXNpemVkKCkge31cbiAgI2FkZFJlc2l6ZVRvVW5kb1N0YWNrKCkge1xuICAgIGlmICghdGhpcy4jc2F2ZWREaW1lbnNpb25zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHNhdmVkWCxcbiAgICAgIHNhdmVkWSxcbiAgICAgIHNhdmVkV2lkdGgsXG4gICAgICBzYXZlZEhlaWdodFxuICAgIH0gPSB0aGlzLiNzYXZlZERpbWVuc2lvbnM7XG4gICAgdGhpcy4jc2F2ZWREaW1lbnNpb25zID0gbnVsbDtcbiAgICBjb25zdCBuZXdYID0gdGhpcy54O1xuICAgIGNvbnN0IG5ld1kgPSB0aGlzLnk7XG4gICAgY29uc3QgbmV3V2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGNvbnN0IG5ld0hlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgIGlmIChuZXdYID09PSBzYXZlZFggJiYgbmV3WSA9PT0gc2F2ZWRZICYmIG5ld1dpZHRoID09PSBzYXZlZFdpZHRoICYmIG5ld0hlaWdodCA9PT0gc2F2ZWRIZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6IHRoaXMuI3Jlc2l6ZS5iaW5kKHRoaXMsIG5ld1gsIG5ld1ksIG5ld1dpZHRoLCBuZXdIZWlnaHQpLFxuICAgICAgdW5kbzogdGhpcy4jcmVzaXplLmJpbmQodGhpcywgc2F2ZWRYLCBzYXZlZFksIHNhdmVkV2lkdGgsIHNhdmVkSGVpZ2h0KSxcbiAgICAgIG11c3RFeGVjOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgI3Jlc2l6ZXJQb2ludGVybW92ZShuYW1lLCBldmVudCkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBjb25zdCBzYXZlZFggPSB0aGlzLng7XG4gICAgY29uc3Qgc2F2ZWRZID0gdGhpcy55O1xuICAgIGNvbnN0IHNhdmVkV2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGNvbnN0IHNhdmVkSGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgY29uc3QgbWluV2lkdGggPSBBbm5vdGF0aW9uRWRpdG9yLk1JTl9TSVpFIC8gcGFyZW50V2lkdGg7XG4gICAgY29uc3QgbWluSGVpZ2h0ID0gQW5ub3RhdGlvbkVkaXRvci5NSU5fU0laRSAvIHBhcmVudEhlaWdodDtcbiAgICBjb25zdCByb3VuZCA9IHggPT4gTWF0aC5yb3VuZCh4ICogMTAwMDApIC8gMTAwMDA7XG4gICAgY29uc3Qgcm90YXRpb25NYXRyaXggPSB0aGlzLiNnZXRSb3RhdGlvbk1hdHJpeCh0aGlzLnJvdGF0aW9uKTtcbiAgICBjb25zdCB0cmFuc2YgPSAoeCwgeSkgPT4gW3JvdGF0aW9uTWF0cml4WzBdICogeCArIHJvdGF0aW9uTWF0cml4WzJdICogeSwgcm90YXRpb25NYXRyaXhbMV0gKiB4ICsgcm90YXRpb25NYXRyaXhbM10gKiB5XTtcbiAgICBjb25zdCBpbnZSb3RhdGlvbk1hdHJpeCA9IHRoaXMuI2dldFJvdGF0aW9uTWF0cml4KDM2MCAtIHRoaXMucm90YXRpb24pO1xuICAgIGNvbnN0IGludlRyYW5zZiA9ICh4LCB5KSA9PiBbaW52Um90YXRpb25NYXRyaXhbMF0gKiB4ICsgaW52Um90YXRpb25NYXRyaXhbMl0gKiB5LCBpbnZSb3RhdGlvbk1hdHJpeFsxXSAqIHggKyBpbnZSb3RhdGlvbk1hdHJpeFszXSAqIHldO1xuICAgIGxldCBnZXRQb2ludDtcbiAgICBsZXQgZ2V0T3Bwb3NpdGU7XG4gICAgbGV0IGlzRGlhZ29uYWwgPSBmYWxzZTtcbiAgICBsZXQgaXNIb3Jpem9udGFsID0gZmFsc2U7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlIFwidG9wTGVmdFwiOlxuICAgICAgICBpc0RpYWdvbmFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gWzAsIDBdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbdywgaF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInRvcE1pZGRsZVwiOlxuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbdyAvIDIsIDBdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbdyAvIDIsIGhdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ0b3BSaWdodFwiOlxuICAgICAgICBpc0RpYWdvbmFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gW3csIDBdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbMCwgaF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1pZGRsZVJpZ2h0XCI6XG4gICAgICAgIGlzSG9yaXpvbnRhbCA9IHRydWU7XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFt3LCBoIC8gMl07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFswLCBoIC8gMl07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJvdHRvbVJpZ2h0XCI6XG4gICAgICAgIGlzRGlhZ29uYWwgPSB0cnVlO1xuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbdywgaF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFswLCAwXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYm90dG9tTWlkZGxlXCI6XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFt3IC8gMiwgaF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFt3IC8gMiwgMF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJvdHRvbUxlZnRcIjpcbiAgICAgICAgaXNEaWFnb25hbCA9IHRydWU7XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFswLCBoXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gW3csIDBdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtaWRkbGVMZWZ0XCI6XG4gICAgICAgIGlzSG9yaXpvbnRhbCA9IHRydWU7XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFswLCBoIC8gMl07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFt3LCBoIC8gMl07XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBwb2ludCA9IGdldFBvaW50KHNhdmVkV2lkdGgsIHNhdmVkSGVpZ2h0KTtcbiAgICBjb25zdCBvcHBvc2l0ZVBvaW50ID0gZ2V0T3Bwb3NpdGUoc2F2ZWRXaWR0aCwgc2F2ZWRIZWlnaHQpO1xuICAgIGxldCB0cmFuc2ZPcHBvc2l0ZVBvaW50ID0gdHJhbnNmKC4uLm9wcG9zaXRlUG9pbnQpO1xuICAgIGNvbnN0IG9wcG9zaXRlWCA9IHJvdW5kKHNhdmVkWCArIHRyYW5zZk9wcG9zaXRlUG9pbnRbMF0pO1xuICAgIGNvbnN0IG9wcG9zaXRlWSA9IHJvdW5kKHNhdmVkWSArIHRyYW5zZk9wcG9zaXRlUG9pbnRbMV0pO1xuICAgIGxldCByYXRpb1ggPSAxO1xuICAgIGxldCByYXRpb1kgPSAxO1xuICAgIGxldCBkZWx0YVgsIGRlbHRhWTtcbiAgICBpZiAoIWV2ZW50LmZyb21LZXlib2FyZCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzY3JlZW5YLFxuICAgICAgICBzY3JlZW5ZXG4gICAgICB9ID0gZXZlbnQ7XG4gICAgICBjb25zdCBbbGFzdFNjcmVlblgsIGxhc3RTY3JlZW5ZXSA9IHRoaXMuI2xhc3RQb2ludGVyQ29vcmRzO1xuICAgICAgW2RlbHRhWCwgZGVsdGFZXSA9IHRoaXMuc2NyZWVuVG9QYWdlVHJhbnNsYXRpb24oc2NyZWVuWCAtIGxhc3RTY3JlZW5YLCBzY3JlZW5ZIC0gbGFzdFNjcmVlblkpO1xuICAgICAgdGhpcy4jbGFzdFBvaW50ZXJDb29yZHNbMF0gPSBzY3JlZW5YO1xuICAgICAgdGhpcy4jbGFzdFBvaW50ZXJDb29yZHNbMV0gPSBzY3JlZW5ZO1xuICAgIH0gZWxzZSB7XG4gICAgICAoe1xuICAgICAgICBkZWx0YVgsXG4gICAgICAgIGRlbHRhWVxuICAgICAgfSA9IGV2ZW50KTtcbiAgICB9XG4gICAgW2RlbHRhWCwgZGVsdGFZXSA9IGludlRyYW5zZihkZWx0YVggLyBwYXJlbnRXaWR0aCwgZGVsdGFZIC8gcGFyZW50SGVpZ2h0KTtcbiAgICBpZiAoaXNEaWFnb25hbCkge1xuICAgICAgY29uc3Qgb2xkRGlhZyA9IE1hdGguaHlwb3Qoc2F2ZWRXaWR0aCwgc2F2ZWRIZWlnaHQpO1xuICAgICAgcmF0aW9YID0gcmF0aW9ZID0gTWF0aC5tYXgoTWF0aC5taW4oTWF0aC5oeXBvdChvcHBvc2l0ZVBvaW50WzBdIC0gcG9pbnRbMF0gLSBkZWx0YVgsIG9wcG9zaXRlUG9pbnRbMV0gLSBwb2ludFsxXSAtIGRlbHRhWSkgLyBvbGREaWFnLCAxIC8gc2F2ZWRXaWR0aCwgMSAvIHNhdmVkSGVpZ2h0KSwgbWluV2lkdGggLyBzYXZlZFdpZHRoLCBtaW5IZWlnaHQgLyBzYXZlZEhlaWdodCk7XG4gICAgfSBlbHNlIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgIHJhdGlvWCA9IE1hdGgubWF4KG1pbldpZHRoLCBNYXRoLm1pbigxLCBNYXRoLmFicyhvcHBvc2l0ZVBvaW50WzBdIC0gcG9pbnRbMF0gLSBkZWx0YVgpKSkgLyBzYXZlZFdpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICByYXRpb1kgPSBNYXRoLm1heChtaW5IZWlnaHQsIE1hdGgubWluKDEsIE1hdGguYWJzKG9wcG9zaXRlUG9pbnRbMV0gLSBwb2ludFsxXSAtIGRlbHRhWSkpKSAvIHNhdmVkSGVpZ2h0O1xuICAgIH1cbiAgICBjb25zdCBuZXdXaWR0aCA9IHJvdW5kKHNhdmVkV2lkdGggKiByYXRpb1gpO1xuICAgIGNvbnN0IG5ld0hlaWdodCA9IHJvdW5kKHNhdmVkSGVpZ2h0ICogcmF0aW9ZKTtcbiAgICB0cmFuc2ZPcHBvc2l0ZVBvaW50ID0gdHJhbnNmKC4uLmdldE9wcG9zaXRlKG5ld1dpZHRoLCBuZXdIZWlnaHQpKTtcbiAgICBjb25zdCBuZXdYID0gb3Bwb3NpdGVYIC0gdHJhbnNmT3Bwb3NpdGVQb2ludFswXTtcbiAgICBjb25zdCBuZXdZID0gb3Bwb3NpdGVZIC0gdHJhbnNmT3Bwb3NpdGVQb2ludFsxXTtcbiAgICB0aGlzLiNpbml0aWFsUmVjdCB8fD0gW3RoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodF07XG4gICAgdGhpcy53aWR0aCA9IG5ld1dpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgIHRoaXMueCA9IG5ld1g7XG4gICAgdGhpcy55ID0gbmV3WTtcbiAgICB0aGlzLnNldERpbXMocGFyZW50V2lkdGggKiBuZXdXaWR0aCwgcGFyZW50SGVpZ2h0ICogbmV3SGVpZ2h0KTtcbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gICAgdGhpcy5fb25SZXNpemluZygpO1xuICB9XG4gIF9vblJlc2l6aW5nKCkge31cbiAgYWx0VGV4dEZpbmlzaCgpIHtcbiAgICB0aGlzLiNhbHRUZXh0Py5maW5pc2goKTtcbiAgfVxuICBhc3luYyBhZGRFZGl0VG9vbGJhcigpIHtcbiAgICBpZiAodGhpcy5fZWRpdFRvb2xiYXIgfHwgdGhpcy4jaXNJbkVkaXRNb2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWRpdFRvb2xiYXI7XG4gICAgfVxuICAgIHRoaXMuX2VkaXRUb29sYmFyID0gbmV3IEVkaXRvclRvb2xiYXIodGhpcyk7XG4gICAgdGhpcy5kaXYuYXBwZW5kKHRoaXMuX2VkaXRUb29sYmFyLnJlbmRlcigpKTtcbiAgICBpZiAodGhpcy4jYWx0VGV4dCkge1xuICAgICAgYXdhaXQgdGhpcy5fZWRpdFRvb2xiYXIuYWRkQWx0VGV4dCh0aGlzLiNhbHRUZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2VkaXRUb29sYmFyO1xuICB9XG4gIHJlbW92ZUVkaXRUb29sYmFyKCkge1xuICAgIGlmICghdGhpcy5fZWRpdFRvb2xiYXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZWRpdFRvb2xiYXIucmVtb3ZlKCk7XG4gICAgdGhpcy5fZWRpdFRvb2xiYXIgPSBudWxsO1xuICAgIHRoaXMuI2FsdFRleHQ/LmRlc3Ryb3koKTtcbiAgfVxuICBhZGRDb250YWluZXIoY29udGFpbmVyKSB7XG4gICAgY29uc3QgZWRpdFRvb2xiYXJEaXYgPSB0aGlzLl9lZGl0VG9vbGJhcj8uZGl2O1xuICAgIGlmIChlZGl0VG9vbGJhckRpdikge1xuICAgICAgZWRpdFRvb2xiYXJEaXYuYmVmb3JlKGNvbnRhaW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGl2LmFwcGVuZChjb250YWluZXIpO1xuICAgIH1cbiAgfVxuICBnZXRDbGllbnREaW1lbnNpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfVxuICBhc3luYyBhZGRBbHRUZXh0QnV0dG9uKCkge1xuICAgIGlmICh0aGlzLiNhbHRUZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIEFsdFRleHQuaW5pdGlhbGl6ZShBbm5vdGF0aW9uRWRpdG9yLl9sMTBuKTtcbiAgICB0aGlzLiNhbHRUZXh0ID0gbmV3IEFsdFRleHQodGhpcyk7XG4gICAgaWYgKHRoaXMuI2FjY2Vzc2liaWxpdHlEYXRhKSB7XG4gICAgICB0aGlzLiNhbHRUZXh0LmRhdGEgPSB0aGlzLiNhY2Nlc3NpYmlsaXR5RGF0YTtcbiAgICAgIHRoaXMuI2FjY2Vzc2liaWxpdHlEYXRhID0gbnVsbDtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5hZGRFZGl0VG9vbGJhcigpO1xuICB9XG4gIGdldCBhbHRUZXh0RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWx0VGV4dD8uZGF0YTtcbiAgfVxuICBzZXQgYWx0VGV4dERhdGEoZGF0YSkge1xuICAgIGlmICghdGhpcy4jYWx0VGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhbHRUZXh0LmRhdGEgPSBkYXRhO1xuICB9XG4gIGdldCBndWVzc2VkQWx0VGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWx0VGV4dD8uZ3Vlc3NlZFRleHQ7XG4gIH1cbiAgYXN5bmMgc2V0R3Vlc3NlZEFsdFRleHQodGV4dCkge1xuICAgIGF3YWl0IHRoaXMuI2FsdFRleHQ/LnNldEd1ZXNzZWRUZXh0KHRleHQpO1xuICB9XG4gIHNlcmlhbGl6ZUFsdFRleHQoaXNGb3JDb3B5aW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsdFRleHQ/LnNlcmlhbGl6ZShpc0ZvckNvcHlpbmcpO1xuICB9XG4gIGhhc0FsdFRleHQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy4jYWx0VGV4dCAmJiAhdGhpcy4jYWx0VGV4dC5pc0VtcHR5KCk7XG4gIH1cbiAgaGFzQWx0VGV4dERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsdFRleHQ/Lmhhc0RhdGEoKSA/PyBmYWxzZTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5kaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMuZGl2LnNldEF0dHJpYnV0ZShcImRhdGEtZWRpdG9yLXJvdGF0aW9uXCIsICgzNjAgLSB0aGlzLnJvdGF0aW9uKSAlIDM2MCk7XG4gICAgdGhpcy5kaXYuY2xhc3NOYW1lID0gdGhpcy5uYW1lO1xuICAgIHRoaXMuZGl2LnNldEF0dHJpYnV0ZShcImlkXCIsIHRoaXMuaWQpO1xuICAgIHRoaXMuZGl2LnRhYkluZGV4ID0gdGhpcy4jZGlzYWJsZWQgPyAtMSA6IDA7XG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUpIHtcbiAgICAgIHRoaXMuZGl2LmNsYXNzTGlzdC5hZGQoXCJoaWRkZW5cIik7XG4gICAgfVxuICAgIHRoaXMuc2V0SW5Gb3JlZ3JvdW5kKCk7XG4gICAgdGhpcy4jYWRkRm9jdXNMaXN0ZW5lcnMoKTtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgaWYgKHRoaXMucGFyZW50Um90YXRpb24gJSAxODAgIT09IDApIHtcbiAgICAgIHRoaXMuZGl2LnN0eWxlLm1heFdpZHRoID0gYCR7KDEwMCAqIHBhcmVudEhlaWdodCAvIHBhcmVudFdpZHRoKS50b0ZpeGVkKDIpfSVgO1xuICAgICAgdGhpcy5kaXYuc3R5bGUubWF4SGVpZ2h0ID0gYCR7KDEwMCAqIHBhcmVudFdpZHRoIC8gcGFyZW50SGVpZ2h0KS50b0ZpeGVkKDIpfSVgO1xuICAgIH1cbiAgICBjb25zdCBbdHgsIHR5XSA9IHRoaXMuZ2V0SW5pdGlhbFRyYW5zbGF0aW9uKCk7XG4gICAgdGhpcy50cmFuc2xhdGUodHgsIHR5KTtcbiAgICBiaW5kRXZlbnRzKHRoaXMsIHRoaXMuZGl2LCBbXCJwb2ludGVyZG93blwiXSk7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLl9lZGl0b3JVbmRvQmFyPy5oaWRlKCk7XG4gICAgcmV0dXJuIHRoaXMuZGl2O1xuICB9XG4gIHBvaW50ZXJkb3duKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8IGV2ZW50LmN0cmxLZXkgJiYgaXNNYWMpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2hhc0JlZW5DbGlja2VkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5faXNEcmFnZ2FibGUpIHtcbiAgICAgIHRoaXMuI3NldFVwRHJhZ1Nlc3Npb24oZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNzZWxlY3RPblBvaW50ZXJFdmVudChldmVudCk7XG4gIH1cbiAgZ2V0IGlzU2VsZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VpTWFuYWdlci5pc1NlbGVjdGVkKHRoaXMpO1xuICB9XG4gICNzZWxlY3RPblBvaW50ZXJFdmVudChldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgaWYgKGV2ZW50LmN0cmxLZXkgJiYgIWlzTWFjIHx8IGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50Lm1ldGFLZXkgJiYgaXNNYWMpIHtcbiAgICAgIHRoaXMucGFyZW50LnRvZ2dsZVNlbGVjdGVkKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhcmVudC5zZXRTZWxlY3RlZCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgI3NldFVwRHJhZ1Nlc3Npb24oZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBpc1NlbGVjdGVkXG4gICAgfSA9IHRoaXM7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLnNldFVwRHJhZ1Nlc3Npb24oKTtcbiAgICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLl91aU1hbmFnZXIuY29tYmluZWRTaWduYWwoYWMpO1xuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICBzaWduYWxcbiAgICB9O1xuICAgIGNvbnN0IGNhbmNlbERyYWcgPSBlID0+IHtcbiAgICAgIGFjLmFib3J0KCk7XG4gICAgICB0aGlzLiNkcmFnUG9pbnRlcklkID0gbnVsbDtcbiAgICAgIHRoaXMuI2hhc0JlZW5DbGlja2VkID0gZmFsc2U7XG4gICAgICBpZiAoIXRoaXMuX3VpTWFuYWdlci5lbmREcmFnU2Vzc2lvbigpKSB7XG4gICAgICAgIHRoaXMuI3NlbGVjdE9uUG9pbnRlckV2ZW50KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuI3ByZXZEcmFnWCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICB0aGlzLiNwcmV2RHJhZ1kgPSBldmVudC5jbGllbnRZO1xuICAgICAgdGhpcy4jZHJhZ1BvaW50ZXJJZCA9IGV2ZW50LnBvaW50ZXJJZDtcbiAgICAgIHRoaXMuI2RyYWdQb2ludGVyVHlwZSA9IGV2ZW50LnBvaW50ZXJUeXBlO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBlID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGNsaWVudFg6IHgsXG4gICAgICAgICAgY2xpZW50WTogeSxcbiAgICAgICAgICBwb2ludGVySWRcbiAgICAgICAgfSA9IGU7XG4gICAgICAgIGlmIChwb2ludGVySWQgIT09IHRoaXMuI2RyYWdQb2ludGVySWQpIHtcbiAgICAgICAgICBzdG9wRXZlbnQoZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFt0eCwgdHldID0gdGhpcy5zY3JlZW5Ub1BhZ2VUcmFuc2xhdGlvbih4IC0gdGhpcy4jcHJldkRyYWdYLCB5IC0gdGhpcy4jcHJldkRyYWdZKTtcbiAgICAgICAgdGhpcy4jcHJldkRyYWdYID0geDtcbiAgICAgICAgdGhpcy4jcHJldkRyYWdZID0geTtcbiAgICAgICAgdGhpcy5fdWlNYW5hZ2VyLmRyYWdTZWxlY3RlZEVkaXRvcnModHgsIHR5KTtcbiAgICAgIH0sIG9wdHMpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgc3RvcEV2ZW50LCBvcHRzKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgZSA9PiB7XG4gICAgICAgIGlmIChlLmlzUHJpbWFyeSAmJiBlLnBvaW50ZXJUeXBlID09PSB0aGlzLiNkcmFnUG9pbnRlclR5cGUpIHtcbiAgICAgICAgICBjYW5jZWxEcmFnKGUpO1xuICAgICAgICB9XG4gICAgICAgIHN0b3BFdmVudChlKTtcbiAgICAgIH0sIG9wdHMpO1xuICAgIH1cbiAgICB0aGlzLl9vblN0YXJ0RHJhZ2dpbmcoKTtcbiAgICBjb25zdCBwb2ludGVyVXBDYWxsYmFjayA9IGUgPT4ge1xuICAgICAgaWYgKCF0aGlzLiNkcmFnUG9pbnRlcklkIHx8IHRoaXMuI2RyYWdQb2ludGVySWQgPT09IGUucG9pbnRlcklkKSB7XG4gICAgICAgIGNhbmNlbERyYWcoZSk7XG4gICAgICAgIHRoaXMuX29uU3RvcERyYWdnaW5nKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN0b3BFdmVudChlKTtcbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHBvaW50ZXJVcENhbGxiYWNrLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgcG9pbnRlclVwQ2FsbGJhY2ssIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gIF9vblN0YXJ0RHJhZ2dpbmcoKSB7fVxuICBfb25TdG9wRHJhZ2dpbmcoKSB7fVxuICBtb3ZlSW5ET00oKSB7XG4gICAgaWYgKHRoaXMuI21vdmVJbkRPTVRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNtb3ZlSW5ET01UaW1lb3V0KTtcbiAgICB9XG4gICAgdGhpcy4jbW92ZUluRE9NVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy4jbW92ZUluRE9NVGltZW91dCA9IG51bGw7XG4gICAgICB0aGlzLnBhcmVudD8ubW92ZUVkaXRvckluRE9NKHRoaXMpO1xuICAgIH0sIDApO1xuICB9XG4gIF9zZXRQYXJlbnRBbmRQb3NpdGlvbihwYXJlbnQsIHgsIHkpIHtcbiAgICBwYXJlbnQuY2hhbmdlUGFyZW50KHRoaXMpO1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gICAgdGhpcy5fb25UcmFuc2xhdGVkKCk7XG4gIH1cbiAgZ2V0UmVjdCh0eCwgdHksIHJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbikge1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5wYXJlbnRTY2FsZTtcbiAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgY29uc3QgW3BhZ2VYLCBwYWdlWV0gPSB0aGlzLnBhZ2VUcmFuc2xhdGlvbjtcbiAgICBjb25zdCBzaGlmdFggPSB0eCAvIHNjYWxlO1xuICAgIGNvbnN0IHNoaWZ0WSA9IHR5IC8gc2NhbGU7XG4gICAgY29uc3QgeCA9IHRoaXMueCAqIHBhZ2VXaWR0aDtcbiAgICBjb25zdCB5ID0gdGhpcy55ICogcGFnZUhlaWdodDtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMud2lkdGggKiBwYWdlV2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKiBwYWdlSGVpZ2h0O1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIFt4ICsgc2hpZnRYICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5IC0gc2hpZnRZIC0gaGVpZ2h0ICsgcGFnZVksIHggKyBzaGlmdFggKyB3aWR0aCArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSAtIHNoaWZ0WSArIHBhZ2VZXTtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbeCArIHNoaWZ0WSArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSArIHNoaWZ0WCArIHBhZ2VZLCB4ICsgc2hpZnRZICsgaGVpZ2h0ICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5ICsgc2hpZnRYICsgd2lkdGggKyBwYWdlWV07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFt4IC0gc2hpZnRYIC0gd2lkdGggKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgKyBzaGlmdFkgKyBwYWdlWSwgeCAtIHNoaWZ0WCArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSArIHNoaWZ0WSArIGhlaWdodCArIHBhZ2VZXTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3ggLSBzaGlmdFkgLSBoZWlnaHQgKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgLSBzaGlmdFggLSB3aWR0aCArIHBhZ2VZLCB4IC0gc2hpZnRZICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5IC0gc2hpZnRYICsgcGFnZVldO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByb3RhdGlvblwiKTtcbiAgICB9XG4gIH1cbiAgZ2V0UmVjdEluQ3VycmVudENvb3JkcyhyZWN0LCBwYWdlSGVpZ2h0KSB7XG4gICAgY29uc3QgW3gxLCB5MSwgeDIsIHkyXSA9IHJlY3Q7XG4gICAgY29uc3Qgd2lkdGggPSB4MiAtIHgxO1xuICAgIGNvbnN0IGhlaWdodCA9IHkyIC0geTE7XG4gICAgc3dpdGNoICh0aGlzLnJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBbeDEsIHBhZ2VIZWlnaHQgLSB5Miwgd2lkdGgsIGhlaWdodF07XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gW3gxLCBwYWdlSGVpZ2h0IC0geTEsIGhlaWdodCwgd2lkdGhdO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbeDIsIHBhZ2VIZWlnaHQgLSB5MSwgd2lkdGgsIGhlaWdodF07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmV0dXJuIFt4MiwgcGFnZUhlaWdodCAtIHkyLCBoZWlnaHQsIHdpZHRoXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcm90YXRpb25cIik7XG4gICAgfVxuICB9XG4gIG9uY2VBZGRlZCgpIHt9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGVuYWJsZUVkaXRNb2RlKCkge1xuICAgIHRoaXMuI2lzSW5FZGl0TW9kZSA9IHRydWU7XG4gIH1cbiAgZGlzYWJsZUVkaXRNb2RlKCkge1xuICAgIHRoaXMuI2lzSW5FZGl0TW9kZSA9IGZhbHNlO1xuICB9XG4gIGlzSW5FZGl0TW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaXNJbkVkaXRNb2RlO1xuICB9XG4gIHNob3VsZEdldEtleWJvYXJkRXZlbnRzKCkge1xuICAgIHJldHVybiB0aGlzLiNpc1Jlc2l6ZXJFbmFibGVkRm9yS2V5Ym9hcmQ7XG4gIH1cbiAgbmVlZHNUb0JlUmVidWlsdCgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXYgJiYgIXRoaXMuaXNBdHRhY2hlZFRvRE9NO1xuICB9XG4gIGdldCBpc09uU2NyZWVuKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRvcCxcbiAgICAgIGxlZnQsXG4gICAgICBib3R0b20sXG4gICAgICByaWdodFxuICAgIH0gPSB0aGlzLmdldENsaWVudERpbWVuc2lvbnMoKTtcbiAgICBjb25zdCB7XG4gICAgICBpbm5lckhlaWdodCxcbiAgICAgIGlubmVyV2lkdGhcbiAgICB9ID0gd2luZG93O1xuICAgIHJldHVybiBsZWZ0IDwgaW5uZXJXaWR0aCAmJiByaWdodCA+IDAgJiYgdG9wIDwgaW5uZXJIZWlnaHQgJiYgYm90dG9tID4gMDtcbiAgfVxuICAjYWRkRm9jdXNMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKHRoaXMuI2ZvY3VzQUMgfHwgIXRoaXMuZGl2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2ZvY3VzQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5fdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKHRoaXMuI2ZvY3VzQUMpO1xuICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIHRoaXMuZm9jdXNpbi5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgdGhpcy5mb2N1c291dC5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICByZWJ1aWxkKCkge1xuICAgIHRoaXMuI2FkZEZvY3VzTGlzdGVuZXJzKCk7XG4gIH1cbiAgcm90YXRlKF9hbmdsZSkge31cbiAgcmVzaXplKCkge31cbiAgc2VyaWFsaXplRGVsZXRlZCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCxcbiAgICAgIGRlbGV0ZWQ6IHRydWUsXG4gICAgICBwYWdlSW5kZXg6IHRoaXMucGFnZUluZGV4LFxuICAgICAgcG9wdXBSZWY6IHRoaXMuX2luaXRpYWxEYXRhPy5wb3B1cFJlZiB8fCBcIlwiXG4gICAgfTtcbiAgfVxuICBzZXJpYWxpemUoaXNGb3JDb3B5aW5nID0gZmFsc2UsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBbiBlZGl0b3IgbXVzdCBiZSBzZXJpYWxpemFibGVcIik7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKSB7XG4gICAgY29uc3QgZWRpdG9yID0gbmV3IHRoaXMucHJvdG90eXBlLmNvbnN0cnVjdG9yKHtcbiAgICAgIHBhcmVudCxcbiAgICAgIGlkOiBwYXJlbnQuZ2V0TmV4dElkKCksXG4gICAgICB1aU1hbmFnZXJcbiAgICB9KTtcbiAgICBlZGl0b3Iucm90YXRpb24gPSBkYXRhLnJvdGF0aW9uO1xuICAgIGVkaXRvci4jYWNjZXNzaWJpbGl0eURhdGEgPSBkYXRhLmFjY2Vzc2liaWxpdHlEYXRhO1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gZWRpdG9yLnBhZ2VEaW1lbnNpb25zO1xuICAgIGNvbnN0IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSA9IGVkaXRvci5nZXRSZWN0SW5DdXJyZW50Q29vcmRzKGRhdGEucmVjdCwgcGFnZUhlaWdodCk7XG4gICAgZWRpdG9yLnggPSB4IC8gcGFnZVdpZHRoO1xuICAgIGVkaXRvci55ID0geSAvIHBhZ2VIZWlnaHQ7XG4gICAgZWRpdG9yLndpZHRoID0gd2lkdGggLyBwYWdlV2lkdGg7XG4gICAgZWRpdG9yLmhlaWdodCA9IGhlaWdodCAvIHBhZ2VIZWlnaHQ7XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICBnZXQgaGFzQmVlbk1vZGlmaWVkKCkge1xuICAgIHJldHVybiAhIXRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCAmJiAodGhpcy5kZWxldGVkIHx8IHRoaXMuc2VyaWFsaXplKCkgIT09IG51bGwpO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLiNmb2N1c0FDPy5hYm9ydCgpO1xuICAgIHRoaXMuI2ZvY3VzQUMgPSBudWxsO1xuICAgIGlmICghdGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHRoaXMuY29tbWl0KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIucmVtb3ZlRWRpdG9yKHRoaXMpO1xuICAgIH1cbiAgICBpZiAodGhpcy4jbW92ZUluRE9NVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI21vdmVJbkRPTVRpbWVvdXQpO1xuICAgICAgdGhpcy4jbW92ZUluRE9NVGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuI3N0b3BSZXNpemluZygpO1xuICAgIHRoaXMucmVtb3ZlRWRpdFRvb2xiYXIoKTtcbiAgICBpZiAodGhpcy4jdGVsZW1ldHJ5VGltZW91dHMpIHtcbiAgICAgIGZvciAoY29uc3QgdGltZW91dCBvZiB0aGlzLiN0ZWxlbWV0cnlUaW1lb3V0cy52YWx1ZXMoKSkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB9XG4gICAgICB0aGlzLiN0ZWxlbWV0cnlUaW1lb3V0cyA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgfVxuICBnZXQgaXNSZXNpemFibGUoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIG1ha2VSZXNpemFibGUoKSB7XG4gICAgaWYgKHRoaXMuaXNSZXNpemFibGUpIHtcbiAgICAgIHRoaXMuI2NyZWF0ZVJlc2l6ZXJzKCk7XG4gICAgICB0aGlzLiNyZXNpemVyc0Rpdi5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZGVuXCIpO1xuICAgICAgYmluZEV2ZW50cyh0aGlzLCB0aGlzLmRpdiwgW1wia2V5ZG93blwiXSk7XG4gICAgfVxuICB9XG4gIGdldCB0b29sYmFyUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAga2V5ZG93bihldmVudCkge1xuICAgIGlmICghdGhpcy5pc1Jlc2l6YWJsZSB8fCBldmVudC50YXJnZXQgIT09IHRoaXMuZGl2IHx8IGV2ZW50LmtleSAhPT0gXCJFbnRlclwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3VpTWFuYWdlci5zZXRTZWxlY3RlZCh0aGlzKTtcbiAgICB0aGlzLiNzYXZlZERpbWVuc2lvbnMgPSB7XG4gICAgICBzYXZlZFg6IHRoaXMueCxcbiAgICAgIHNhdmVkWTogdGhpcy55LFxuICAgICAgc2F2ZWRXaWR0aDogdGhpcy53aWR0aCxcbiAgICAgIHNhdmVkSGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgIH07XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLiNyZXNpemVyc0Rpdi5jaGlsZHJlbjtcbiAgICBpZiAoIXRoaXMuI2FsbFJlc2l6ZXJEaXZzKSB7XG4gICAgICB0aGlzLiNhbGxSZXNpemVyRGl2cyA9IEFycmF5LmZyb20oY2hpbGRyZW4pO1xuICAgICAgY29uc3QgYm91bmRSZXNpemVyS2V5ZG93biA9IHRoaXMuI3Jlc2l6ZXJLZXlkb3duLmJpbmQodGhpcyk7XG4gICAgICBjb25zdCBib3VuZFJlc2l6ZXJCbHVyID0gdGhpcy4jcmVzaXplckJsdXIuYmluZCh0aGlzKTtcbiAgICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3VpTWFuYWdlci5fc2lnbmFsO1xuICAgICAgZm9yIChjb25zdCBkaXYgb2YgdGhpcy4jYWxsUmVzaXplckRpdnMpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGRpdi5nZXRBdHRyaWJ1dGUoXCJkYXRhLXJlc2l6ZXItbmFtZVwiKTtcbiAgICAgICAgZGl2LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJzcGluYnV0dG9uXCIpO1xuICAgICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgYm91bmRSZXNpemVyS2V5ZG93biwge1xuICAgICAgICAgIHNpZ25hbFxuICAgICAgICB9KTtcbiAgICAgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGJvdW5kUmVzaXplckJsdXIsIHtcbiAgICAgICAgICBzaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy4jcmVzaXplckZvY3VzLmJpbmQodGhpcywgbmFtZSksIHtcbiAgICAgICAgICBzaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgQW5ub3RhdGlvbkVkaXRvci5fbDEwblJlc2l6ZXJbbmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmaXJzdCA9IHRoaXMuI2FsbFJlc2l6ZXJEaXZzWzBdO1xuICAgIGxldCBmaXJzdFBvc2l0aW9uID0gMDtcbiAgICBmb3IgKGNvbnN0IGRpdiBvZiBjaGlsZHJlbikge1xuICAgICAgaWYgKGRpdiA9PT0gZmlyc3QpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBmaXJzdFBvc2l0aW9uKys7XG4gICAgfVxuICAgIGNvbnN0IG5leHRGaXJzdFBvc2l0aW9uID0gKDM2MCAtIHRoaXMucm90YXRpb24gKyB0aGlzLnBhcmVudFJvdGF0aW9uKSAlIDM2MCAvIDkwICogKHRoaXMuI2FsbFJlc2l6ZXJEaXZzLmxlbmd0aCAvIDQpO1xuICAgIGlmIChuZXh0Rmlyc3RQb3NpdGlvbiAhPT0gZmlyc3RQb3NpdGlvbikge1xuICAgICAgaWYgKG5leHRGaXJzdFBvc2l0aW9uIDwgZmlyc3RQb3NpdGlvbikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpcnN0UG9zaXRpb24gLSBuZXh0Rmlyc3RQb3NpdGlvbjsgaSsrKSB7XG4gICAgICAgICAgdGhpcy4jcmVzaXplcnNEaXYuYXBwZW5kKHRoaXMuI3Jlc2l6ZXJzRGl2LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5leHRGaXJzdFBvc2l0aW9uID4gZmlyc3RQb3NpdGlvbikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHRGaXJzdFBvc2l0aW9uIC0gZmlyc3RQb3NpdGlvbjsgaSsrKSB7XG4gICAgICAgICAgdGhpcy4jcmVzaXplcnNEaXYuZmlyc3RDaGlsZC5iZWZvcmUodGhpcy4jcmVzaXplcnNEaXYubGFzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgICBjb25zdCBkaXYgPSB0aGlzLiNhbGxSZXNpemVyRGl2c1tpKytdO1xuICAgICAgICBjb25zdCBuYW1lID0gZGl2LmdldEF0dHJpYnV0ZShcImRhdGEtcmVzaXplci1uYW1lXCIpO1xuICAgICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgQW5ub3RhdGlvbkVkaXRvci5fbDEwblJlc2l6ZXJbbmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNzZXRSZXNpemVyVGFiSW5kZXgoMCk7XG4gICAgdGhpcy4jaXNSZXNpemVyRW5hYmxlZEZvcktleWJvYXJkID0gdHJ1ZTtcbiAgICB0aGlzLiNyZXNpemVyc0Rpdi5maXJzdENoaWxkLmZvY3VzKHtcbiAgICAgIGZvY3VzVmlzaWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gIH1cbiAgI3Jlc2l6ZXJLZXlkb3duKGV2ZW50KSB7XG4gICAgQW5ub3RhdGlvbkVkaXRvci5fcmVzaXplcktleWJvYXJkTWFuYWdlci5leGVjKHRoaXMsIGV2ZW50KTtcbiAgfVxuICAjcmVzaXplckJsdXIoZXZlbnQpIHtcbiAgICBpZiAodGhpcy4jaXNSZXNpemVyRW5hYmxlZEZvcktleWJvYXJkICYmIGV2ZW50LnJlbGF0ZWRUYXJnZXQ/LnBhcmVudE5vZGUgIT09IHRoaXMuI3Jlc2l6ZXJzRGl2KSB7XG4gICAgICB0aGlzLiNzdG9wUmVzaXppbmcoKTtcbiAgICB9XG4gIH1cbiAgI3Jlc2l6ZXJGb2N1cyhuYW1lKSB7XG4gICAgdGhpcy4jZm9jdXNlZFJlc2l6ZXJOYW1lID0gdGhpcy4jaXNSZXNpemVyRW5hYmxlZEZvcktleWJvYXJkID8gbmFtZSA6IFwiXCI7XG4gIH1cbiAgI3NldFJlc2l6ZXJUYWJJbmRleCh2YWx1ZSkge1xuICAgIGlmICghdGhpcy4jYWxsUmVzaXplckRpdnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBkaXYgb2YgdGhpcy4jYWxsUmVzaXplckRpdnMpIHtcbiAgICAgIGRpdi50YWJJbmRleCA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICBfcmVzaXplV2l0aEtleWJvYXJkKHgsIHkpIHtcbiAgICBpZiAoIXRoaXMuI2lzUmVzaXplckVuYWJsZWRGb3JLZXlib2FyZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNyZXNpemVyUG9pbnRlcm1vdmUodGhpcy4jZm9jdXNlZFJlc2l6ZXJOYW1lLCB7XG4gICAgICBkZWx0YVg6IHgsXG4gICAgICBkZWx0YVk6IHksXG4gICAgICBmcm9tS2V5Ym9hcmQ6IHRydWVcbiAgICB9KTtcbiAgfVxuICAjc3RvcFJlc2l6aW5nKCkge1xuICAgIHRoaXMuI2lzUmVzaXplckVuYWJsZWRGb3JLZXlib2FyZCA9IGZhbHNlO1xuICAgIHRoaXMuI3NldFJlc2l6ZXJUYWJJbmRleCgtMSk7XG4gICAgdGhpcy4jYWRkUmVzaXplVG9VbmRvU3RhY2soKTtcbiAgfVxuICBfc3RvcFJlc2l6aW5nV2l0aEtleWJvYXJkKCkge1xuICAgIHRoaXMuI3N0b3BSZXNpemluZygpO1xuICAgIHRoaXMuZGl2LmZvY3VzKCk7XG4gIH1cbiAgc2VsZWN0KCkge1xuICAgIHRoaXMubWFrZVJlc2l6YWJsZSgpO1xuICAgIHRoaXMuZGl2Py5jbGFzc0xpc3QuYWRkKFwic2VsZWN0ZWRFZGl0b3JcIik7XG4gICAgaWYgKCF0aGlzLl9lZGl0VG9vbGJhcikge1xuICAgICAgdGhpcy5hZGRFZGl0VG9vbGJhcigpLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5kaXY/LmNsYXNzTGlzdC5jb250YWlucyhcInNlbGVjdGVkRWRpdG9yXCIpKSB7XG4gICAgICAgICAgdGhpcy5fZWRpdFRvb2xiYXI/LnNob3coKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2VkaXRUb29sYmFyPy5zaG93KCk7XG4gICAgdGhpcy4jYWx0VGV4dD8udG9nZ2xlQWx0VGV4dEJhZGdlKGZhbHNlKTtcbiAgfVxuICB1bnNlbGVjdCgpIHtcbiAgICB0aGlzLiNyZXNpemVyc0Rpdj8uY2xhc3NMaXN0LmFkZChcImhpZGRlblwiKTtcbiAgICB0aGlzLmRpdj8uY2xhc3NMaXN0LnJlbW92ZShcInNlbGVjdGVkRWRpdG9yXCIpO1xuICAgIGlmICh0aGlzLmRpdj8uY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5jdXJyZW50TGF5ZXIuZGl2LmZvY3VzKHtcbiAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX2VkaXRUb29sYmFyPy5oaWRlKCk7XG4gICAgdGhpcy4jYWx0VGV4dD8udG9nZ2xlQWx0VGV4dEJhZGdlKHRydWUpO1xuICB9XG4gIHVwZGF0ZVBhcmFtcyh0eXBlLCB2YWx1ZSkge31cbiAgZGlzYWJsZUVkaXRpbmcoKSB7fVxuICBlbmFibGVFZGl0aW5nKCkge31cbiAgZW50ZXJJbkVkaXRNb2RlKCkge31cbiAgZ2V0SW1hZ2VGb3JBbHRUZXh0KCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldCBjb250ZW50RGl2KCkge1xuICAgIHJldHVybiB0aGlzLmRpdjtcbiAgfVxuICBnZXQgaXNFZGl0aW5nKCkge1xuICAgIHJldHVybiB0aGlzLiNpc0VkaXRpbmc7XG4gIH1cbiAgc2V0IGlzRWRpdGluZyh2YWx1ZSkge1xuICAgIHRoaXMuI2lzRWRpdGluZyA9IHZhbHVlO1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLnBhcmVudC5zZXRTZWxlY3RlZCh0aGlzKTtcbiAgICAgIHRoaXMucGFyZW50LnNldEFjdGl2ZUVkaXRvcih0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXJlbnQuc2V0QWN0aXZlRWRpdG9yKG51bGwpO1xuICAgIH1cbiAgfVxuICBzZXRBc3BlY3RSYXRpbyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy4ja2VlcEFzcGVjdFJhdGlvID0gdHJ1ZTtcbiAgICBjb25zdCBhc3BlY3RSYXRpbyA9IHdpZHRoIC8gaGVpZ2h0O1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IHRoaXMuZGl2O1xuICAgIHN0eWxlLmFzcGVjdFJhdGlvID0gYXNwZWN0UmF0aW87XG4gICAgc3R5bGUuaGVpZ2h0ID0gXCJhdXRvXCI7XG4gIH1cbiAgc3RhdGljIGdldCBNSU5fU0laRSgpIHtcbiAgICByZXR1cm4gMTY7XG4gIH1cbiAgc3RhdGljIGNhbkNyZWF0ZU5ld0VtcHR5RWRpdG9yKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldCB0ZWxlbWV0cnlJbml0aWFsRGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWN0aW9uOiBcImFkZGVkXCJcbiAgICB9O1xuICB9XG4gIGdldCB0ZWxlbWV0cnlGaW5hbERhdGEoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgX3JlcG9ydFRlbGVtZXRyeShkYXRhLCBtdXN0V2FpdCA9IGZhbHNlKSB7XG4gICAgaWYgKG11c3RXYWl0KSB7XG4gICAgICB0aGlzLiN0ZWxlbWV0cnlUaW1lb3V0cyB8fD0gbmV3IE1hcCgpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBhY3Rpb25cbiAgICAgIH0gPSBkYXRhO1xuICAgICAgbGV0IHRpbWVvdXQgPSB0aGlzLiN0ZWxlbWV0cnlUaW1lb3V0cy5nZXQoYWN0aW9uKTtcbiAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5fcmVwb3J0VGVsZW1ldHJ5KGRhdGEpO1xuICAgICAgICB0aGlzLiN0ZWxlbWV0cnlUaW1lb3V0cy5kZWxldGUoYWN0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMuI3RlbGVtZXRyeVRpbWVvdXRzLnNpemUgPT09IDApIHtcbiAgICAgICAgICB0aGlzLiN0ZWxlbWV0cnlUaW1lb3V0cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sIEFubm90YXRpb25FZGl0b3IuX3RlbGVtZXRyeVRpbWVvdXQpO1xuICAgICAgdGhpcy4jdGVsZW1ldHJ5VGltZW91dHMuc2V0KGFjdGlvbiwgdGltZW91dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRhdGEudHlwZSB8fD0gdGhpcy5lZGl0b3JUeXBlO1xuICAgIHRoaXMuX3VpTWFuYWdlci5fZXZlbnRCdXMuZGlzcGF0Y2goXCJyZXBvcnR0ZWxlbWV0cnlcIiwge1xuICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgZGV0YWlsczoge1xuICAgICAgICB0eXBlOiBcImVkaXRpbmdcIixcbiAgICAgICAgZGF0YVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNob3codmlzaWJsZSA9IHRoaXMuX2lzVmlzaWJsZSkge1xuICAgIHRoaXMuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJoaWRkZW5cIiwgIXZpc2libGUpO1xuICAgIHRoaXMuX2lzVmlzaWJsZSA9IHZpc2libGU7XG4gIH1cbiAgZW5hYmxlKCkge1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgdGhpcy5kaXYudGFiSW5kZXggPSAwO1xuICAgIH1cbiAgICB0aGlzLiNkaXNhYmxlZCA9IGZhbHNlO1xuICB9XG4gIGRpc2FibGUoKSB7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICB0aGlzLmRpdi50YWJJbmRleCA9IC0xO1xuICAgIH1cbiAgICB0aGlzLiNkaXNhYmxlZCA9IHRydWU7XG4gIH1cbiAgcmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIGxldCBjb250ZW50ID0gYW5ub3RhdGlvbi5jb250YWluZXIucXVlcnlTZWxlY3RvcihcIi5hbm5vdGF0aW9uQ29udGVudFwiKTtcbiAgICBpZiAoIWNvbnRlbnQpIHtcbiAgICAgIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgY29udGVudC5jbGFzc0xpc3QuYWRkKFwiYW5ub3RhdGlvbkNvbnRlbnRcIiwgdGhpcy5lZGl0b3JUeXBlKTtcbiAgICAgIGFubm90YXRpb24uY29udGFpbmVyLnByZXBlbmQoY29udGVudCk7XG4gICAgfSBlbHNlIGlmIChjb250ZW50Lm5vZGVOYW1lID09PSBcIkNBTlZBU1wiKSB7XG4gICAgICBjb25zdCBjYW52YXMgPSBjb250ZW50O1xuICAgICAgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoXCJhbm5vdGF0aW9uQ29udGVudFwiLCB0aGlzLmVkaXRvclR5cGUpO1xuICAgICAgY2FudmFzLmJlZm9yZShjb250ZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cbiAgcmVzZXRBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgZmlyc3RDaGlsZFxuICAgIH0gPSBhbm5vdGF0aW9uLmNvbnRhaW5lcjtcbiAgICBpZiAoZmlyc3RDaGlsZD8ubm9kZU5hbWUgPT09IFwiRElWXCIgJiYgZmlyc3RDaGlsZC5jbGFzc0xpc3QuY29udGFpbnMoXCJhbm5vdGF0aW9uQ29udGVudFwiKSkge1xuICAgICAgZmlyc3RDaGlsZC5yZW1vdmUoKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEZha2VFZGl0b3IgZXh0ZW5kcyBBbm5vdGF0aW9uRWRpdG9yIHtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIocGFyYW1zKTtcbiAgICB0aGlzLmFubm90YXRpb25FbGVtZW50SWQgPSBwYXJhbXMuYW5ub3RhdGlvbkVsZW1lbnRJZDtcbiAgICB0aGlzLmRlbGV0ZWQgPSB0cnVlO1xuICB9XG4gIHNlcmlhbGl6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVEZWxldGVkKCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL3NoYXJlZC9tdXJtdXJoYXNoMy5qc1xuY29uc3QgU0VFRCA9IDB4YzNkMmUxZjA7XG5jb25zdCBNQVNLX0hJR0ggPSAweGZmZmYwMDAwO1xuY29uc3QgTUFTS19MT1cgPSAweGZmZmY7XG5jbGFzcyBNdXJtdXJIYXNoM182NCB7XG4gIGNvbnN0cnVjdG9yKHNlZWQpIHtcbiAgICB0aGlzLmgxID0gc2VlZCA/IHNlZWQgJiAweGZmZmZmZmZmIDogU0VFRDtcbiAgICB0aGlzLmgyID0gc2VlZCA/IHNlZWQgJiAweGZmZmZmZmZmIDogU0VFRDtcbiAgfVxuICB1cGRhdGUoaW5wdXQpIHtcbiAgICBsZXQgZGF0YSwgbGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShpbnB1dC5sZW5ndGggKiAyKTtcbiAgICAgIGxlbmd0aCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBpbnB1dC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY29kZSA8PSAweGZmKSB7XG4gICAgICAgICAgZGF0YVtsZW5ndGgrK10gPSBjb2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGFbbGVuZ3RoKytdID0gY29kZSA+Pj4gODtcbiAgICAgICAgICBkYXRhW2xlbmd0aCsrXSA9IGNvZGUgJiAweGZmO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoaW5wdXQpKSB7XG4gICAgICBkYXRhID0gaW5wdXQuc2xpY2UoKTtcbiAgICAgIGxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRhIGZvcm1hdCwgbXVzdCBiZSBhIHN0cmluZyBvciBUeXBlZEFycmF5LlwiKTtcbiAgICB9XG4gICAgY29uc3QgYmxvY2tDb3VudHMgPSBsZW5ndGggPj4gMjtcbiAgICBjb25zdCB0YWlsTGVuZ3RoID0gbGVuZ3RoIC0gYmxvY2tDb3VudHMgKiA0O1xuICAgIGNvbnN0IGRhdGFVaW50MzIgPSBuZXcgVWludDMyQXJyYXkoZGF0YS5idWZmZXIsIDAsIGJsb2NrQ291bnRzKTtcbiAgICBsZXQgazEgPSAwLFxuICAgICAgazIgPSAwO1xuICAgIGxldCBoMSA9IHRoaXMuaDEsXG4gICAgICBoMiA9IHRoaXMuaDI7XG4gICAgY29uc3QgQzEgPSAweGNjOWUyZDUxLFxuICAgICAgQzIgPSAweDFiODczNTkzO1xuICAgIGNvbnN0IEMxX0xPVyA9IEMxICYgTUFTS19MT1csXG4gICAgICBDMl9MT1cgPSBDMiAmIE1BU0tfTE9XO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tDb3VudHM7IGkrKykge1xuICAgICAgaWYgKGkgJiAxKSB7XG4gICAgICAgIGsxID0gZGF0YVVpbnQzMltpXTtcbiAgICAgICAgazEgPSBrMSAqIEMxICYgTUFTS19ISUdIIHwgazEgKiBDMV9MT1cgJiBNQVNLX0xPVztcbiAgICAgICAgazEgPSBrMSA8PCAxNSB8IGsxID4+PiAxNztcbiAgICAgICAgazEgPSBrMSAqIEMyICYgTUFTS19ISUdIIHwgazEgKiBDMl9MT1cgJiBNQVNLX0xPVztcbiAgICAgICAgaDEgXj0gazE7XG4gICAgICAgIGgxID0gaDEgPDwgMTMgfCBoMSA+Pj4gMTk7XG4gICAgICAgIGgxID0gaDEgKiA1ICsgMHhlNjU0NmI2NDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGsyID0gZGF0YVVpbnQzMltpXTtcbiAgICAgICAgazIgPSBrMiAqIEMxICYgTUFTS19ISUdIIHwgazIgKiBDMV9MT1cgJiBNQVNLX0xPVztcbiAgICAgICAgazIgPSBrMiA8PCAxNSB8IGsyID4+PiAxNztcbiAgICAgICAgazIgPSBrMiAqIEMyICYgTUFTS19ISUdIIHwgazIgKiBDMl9MT1cgJiBNQVNLX0xPVztcbiAgICAgICAgaDIgXj0gazI7XG4gICAgICAgIGgyID0gaDIgPDwgMTMgfCBoMiA+Pj4gMTk7XG4gICAgICAgIGgyID0gaDIgKiA1ICsgMHhlNjU0NmI2NDtcbiAgICAgIH1cbiAgICB9XG4gICAgazEgPSAwO1xuICAgIHN3aXRjaCAodGFpbExlbmd0aCkge1xuICAgICAgY2FzZSAzOlxuICAgICAgICBrMSBePSBkYXRhW2Jsb2NrQ291bnRzICogNCArIDJdIDw8IDE2O1xuICAgICAgY2FzZSAyOlxuICAgICAgICBrMSBePSBkYXRhW2Jsb2NrQ291bnRzICogNCArIDFdIDw8IDg7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGsxIF49IGRhdGFbYmxvY2tDb3VudHMgKiA0XTtcbiAgICAgICAgazEgPSBrMSAqIEMxICYgTUFTS19ISUdIIHwgazEgKiBDMV9MT1cgJiBNQVNLX0xPVztcbiAgICAgICAgazEgPSBrMSA8PCAxNSB8IGsxID4+PiAxNztcbiAgICAgICAgazEgPSBrMSAqIEMyICYgTUFTS19ISUdIIHwgazEgKiBDMl9MT1cgJiBNQVNLX0xPVztcbiAgICAgICAgaWYgKGJsb2NrQ291bnRzICYgMSkge1xuICAgICAgICAgIGgxIF49IGsxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGgyIF49IGsxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuaDEgPSBoMTtcbiAgICB0aGlzLmgyID0gaDI7XG4gIH1cbiAgaGV4ZGlnZXN0KCkge1xuICAgIGxldCBoMSA9IHRoaXMuaDEsXG4gICAgICBoMiA9IHRoaXMuaDI7XG4gICAgaDEgXj0gaDIgPj4+IDE7XG4gICAgaDEgPSBoMSAqIDB4ZWQ1NThjY2QgJiBNQVNLX0hJR0ggfCBoMSAqIDB4OGNjZCAmIE1BU0tfTE9XO1xuICAgIGgyID0gaDIgKiAweGZmNTFhZmQ3ICYgTUFTS19ISUdIIHwgKChoMiA8PCAxNiB8IGgxID4+PiAxNikgKiAweGFmZDdlZDU1ICYgTUFTS19ISUdIKSA+Pj4gMTY7XG4gICAgaDEgXj0gaDIgPj4+IDE7XG4gICAgaDEgPSBoMSAqIDB4MWE4NWVjNTMgJiBNQVNLX0hJR0ggfCBoMSAqIDB4ZWM1MyAmIE1BU0tfTE9XO1xuICAgIGgyID0gaDIgKiAweGM0Y2ViOWZlICYgTUFTS19ISUdIIHwgKChoMiA8PCAxNiB8IGgxID4+PiAxNikgKiAweGI5ZmUxYTg1ICYgTUFTS19ISUdIKSA+Pj4gMTY7XG4gICAgaDEgXj0gaDIgPj4+IDE7XG4gICAgcmV0dXJuIChoMSA+Pj4gMCkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDgsIFwiMFwiKSArIChoMiA+Pj4gMCkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDgsIFwiMFwiKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9hbm5vdGF0aW9uX3N0b3JhZ2UuanNcblxuXG5cbmNvbnN0IFNlcmlhbGl6YWJsZUVtcHR5ID0gT2JqZWN0LmZyZWV6ZSh7XG4gIG1hcDogbnVsbCxcbiAgaGFzaDogXCJcIixcbiAgdHJhbnNmZXI6IHVuZGVmaW5lZFxufSk7XG5jbGFzcyBBbm5vdGF0aW9uU3RvcmFnZSB7XG4gICNtb2RpZmllZCA9IGZhbHNlO1xuICAjbW9kaWZpZWRJZHMgPSBudWxsO1xuICAjc3RvcmFnZSA9IG5ldyBNYXAoKTtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5vblNldE1vZGlmaWVkID0gbnVsbDtcbiAgICB0aGlzLm9uUmVzZXRNb2RpZmllZCA9IG51bGw7XG4gICAgdGhpcy5vbkFubm90YXRpb25FZGl0b3IgPSBudWxsO1xuICB9XG4gIGdldFZhbHVlKGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLiNzdG9yYWdlLmdldChrZXkpO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihkZWZhdWx0VmFsdWUsIHZhbHVlKTtcbiAgfVxuICBnZXRSYXdWYWx1ZShrZXkpIHtcbiAgICByZXR1cm4gdGhpcy4jc3RvcmFnZS5nZXQoa2V5KTtcbiAgfVxuICByZW1vdmUoa2V5KSB7XG4gICAgdGhpcy4jc3RvcmFnZS5kZWxldGUoa2V5KTtcbiAgICBpZiAodGhpcy4jc3RvcmFnZS5zaXplID09PSAwKSB7XG4gICAgICB0aGlzLnJlc2V0TW9kaWZpZWQoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLm9uQW5ub3RhdGlvbkVkaXRvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRoaXMuI3N0b3JhZ2UudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQW5ub3RhdGlvbkVkaXRvcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5vbkFubm90YXRpb25FZGl0b3IobnVsbCk7XG4gICAgfVxuICB9XG4gIHNldFZhbHVlKGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBvYmogPSB0aGlzLiNzdG9yYWdlLmdldChrZXkpO1xuICAgIGxldCBtb2RpZmllZCA9IGZhbHNlO1xuICAgIGlmIChvYmogIT09IHVuZGVmaW5lZCkge1xuICAgICAgZm9yIChjb25zdCBbZW50cnksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgIGlmIChvYmpbZW50cnldICE9PSB2YWwpIHtcbiAgICAgICAgICBtb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgb2JqW2VudHJ5XSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtb2RpZmllZCA9IHRydWU7XG4gICAgICB0aGlzLiNzdG9yYWdlLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVkKSB7XG4gICAgICB0aGlzLiNzZXRNb2RpZmllZCgpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBbm5vdGF0aW9uRWRpdG9yICYmIHR5cGVvZiB0aGlzLm9uQW5ub3RhdGlvbkVkaXRvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aGlzLm9uQW5ub3RhdGlvbkVkaXRvcih2YWx1ZS5jb25zdHJ1Y3Rvci5fdHlwZSk7XG4gICAgfVxuICB9XG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy4jc3RvcmFnZS5oYXMoa2V5KTtcbiAgfVxuICBnZXRBbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3N0b3JhZ2Uuc2l6ZSA+IDAgPyBvYmplY3RGcm9tTWFwKHRoaXMuI3N0b3JhZ2UpIDogbnVsbDtcbiAgfVxuICBzZXRBbGwob2JqKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKG9iaikpIHtcbiAgICAgIHRoaXMuc2V0VmFsdWUoa2V5LCB2YWwpO1xuICAgIH1cbiAgfVxuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jc3RvcmFnZS5zaXplO1xuICB9XG4gICNzZXRNb2RpZmllZCgpIHtcbiAgICBpZiAoIXRoaXMuI21vZGlmaWVkKSB7XG4gICAgICB0aGlzLiNtb2RpZmllZCA9IHRydWU7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub25TZXRNb2RpZmllZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMub25TZXRNb2RpZmllZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXNldE1vZGlmaWVkKCkge1xuICAgIGlmICh0aGlzLiNtb2RpZmllZCkge1xuICAgICAgdGhpcy4jbW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vblJlc2V0TW9kaWZpZWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLm9uUmVzZXRNb2RpZmllZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgcHJpbnQoKSB7XG4gICAgcmV0dXJuIG5ldyBQcmludEFubm90YXRpb25TdG9yYWdlKHRoaXMpO1xuICB9XG4gIGdldCBzZXJpYWxpemFibGUoKSB7XG4gICAgaWYgKHRoaXMuI3N0b3JhZ2Uuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIFNlcmlhbGl6YWJsZUVtcHR5O1xuICAgIH1cbiAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCksXG4gICAgICBoYXNoID0gbmV3IE11cm11ckhhc2gzXzY0KCksXG4gICAgICB0cmFuc2ZlciA9IFtdO1xuICAgIGNvbnN0IGNvbnRleHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBoYXNCaXRtYXAgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgdGhpcy4jc3RvcmFnZSkge1xuICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IHZhbCBpbnN0YW5jZW9mIEFubm90YXRpb25FZGl0b3IgPyB2YWwuc2VyaWFsaXplKGZhbHNlLCBjb250ZXh0KSA6IHZhbDtcbiAgICAgIGlmIChzZXJpYWxpemVkKSB7XG4gICAgICAgIG1hcC5zZXQoa2V5LCBzZXJpYWxpemVkKTtcbiAgICAgICAgaGFzaC51cGRhdGUoYCR7a2V5fToke0pTT04uc3RyaW5naWZ5KHNlcmlhbGl6ZWQpfWApO1xuICAgICAgICBoYXNCaXRtYXAgfHw9ICEhc2VyaWFsaXplZC5iaXRtYXA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChoYXNCaXRtYXApIHtcbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgbWFwLnZhbHVlcygpKSB7XG4gICAgICAgIGlmICh2YWx1ZS5iaXRtYXApIHtcbiAgICAgICAgICB0cmFuc2Zlci5wdXNoKHZhbHVlLmJpdG1hcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcC5zaXplID4gMCA/IHtcbiAgICAgIG1hcCxcbiAgICAgIGhhc2g6IGhhc2guaGV4ZGlnZXN0KCksXG4gICAgICB0cmFuc2ZlclxuICAgIH0gOiBTZXJpYWxpemFibGVFbXB0eTtcbiAgfVxuICBnZXQgZWRpdG9yU3RhdHMoKSB7XG4gICAgbGV0IHN0YXRzID0gbnVsbDtcbiAgICBjb25zdCB0eXBlVG9FZGl0b3IgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0aGlzLiNzdG9yYWdlLnZhbHVlcygpKSB7XG4gICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEFubm90YXRpb25FZGl0b3IpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZWRpdG9yU3RhdHMgPSB2YWx1ZS50ZWxlbWV0cnlGaW5hbERhdGE7XG4gICAgICBpZiAoIWVkaXRvclN0YXRzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICB0eXBlXG4gICAgICB9ID0gZWRpdG9yU3RhdHM7XG4gICAgICBpZiAoIXR5cGVUb0VkaXRvci5oYXModHlwZSkpIHtcbiAgICAgICAgdHlwZVRvRWRpdG9yLnNldCh0eXBlLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpLmNvbnN0cnVjdG9yKTtcbiAgICAgIH1cbiAgICAgIHN0YXRzIHx8PSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgY29uc3QgbWFwID0gc3RhdHNbdHlwZV0gfHw9IG5ldyBNYXAoKTtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiBPYmplY3QuZW50cmllcyhlZGl0b3JTdGF0cykpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJ0eXBlXCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY291bnRlcnMgPSBtYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICghY291bnRlcnMpIHtcbiAgICAgICAgICBjb3VudGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICBtYXAuc2V0KGtleSwgY291bnRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvdW50ID0gY291bnRlcnMuZ2V0KHZhbCkgPz8gMDtcbiAgICAgICAgY291bnRlcnMuc2V0KHZhbCwgY291bnQgKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBbdHlwZSwgZWRpdG9yXSBvZiB0eXBlVG9FZGl0b3IpIHtcbiAgICAgIHN0YXRzW3R5cGVdID0gZWRpdG9yLmNvbXB1dGVUZWxlbWV0cnlGaW5hbERhdGEoc3RhdHNbdHlwZV0pO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdHM7XG4gIH1cbiAgcmVzZXRNb2RpZmllZElkcygpIHtcbiAgICB0aGlzLiNtb2RpZmllZElkcyA9IG51bGw7XG4gIH1cbiAgZ2V0IG1vZGlmaWVkSWRzKCkge1xuICAgIGlmICh0aGlzLiNtb2RpZmllZElkcykge1xuICAgICAgcmV0dXJuIHRoaXMuI21vZGlmaWVkSWRzO1xuICAgIH1cbiAgICBjb25zdCBpZHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRoaXMuI3N0b3JhZ2UudmFsdWVzKCkpIHtcbiAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgQW5ub3RhdGlvbkVkaXRvcikgfHwgIXZhbHVlLmFubm90YXRpb25FbGVtZW50SWQgfHwgIXZhbHVlLnNlcmlhbGl6ZSgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWRzLnB1c2godmFsdWUuYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNtb2RpZmllZElkcyA9IHtcbiAgICAgIGlkczogbmV3IFNldChpZHMpLFxuICAgICAgaGFzaDogaWRzLmpvaW4oXCIsXCIpXG4gICAgfTtcbiAgfVxufVxuY2xhc3MgUHJpbnRBbm5vdGF0aW9uU3RvcmFnZSBleHRlbmRzIEFubm90YXRpb25TdG9yYWdlIHtcbiAgI3NlcmlhbGl6YWJsZTtcbiAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCB7XG4gICAgICBtYXAsXG4gICAgICBoYXNoLFxuICAgICAgdHJhbnNmZXJcbiAgICB9ID0gcGFyZW50LnNlcmlhbGl6YWJsZTtcbiAgICBjb25zdCBjbG9uZSA9IHN0cnVjdHVyZWRDbG9uZShtYXAsIHRyYW5zZmVyID8ge1xuICAgICAgdHJhbnNmZXJcbiAgICB9IDogbnVsbCk7XG4gICAgdGhpcy4jc2VyaWFsaXphYmxlID0ge1xuICAgICAgbWFwOiBjbG9uZSxcbiAgICAgIGhhc2gsXG4gICAgICB0cmFuc2ZlclxuICAgIH07XG4gIH1cbiAgZ2V0IHByaW50KCkge1xuICAgIHVucmVhY2hhYmxlKFwiU2hvdWxkIG5vdCBjYWxsIFByaW50QW5ub3RhdGlvblN0b3JhZ2UucHJpbnRcIik7XG4gIH1cbiAgZ2V0IHNlcmlhbGl6YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jc2VyaWFsaXphYmxlO1xuICB9XG4gIGdldCBtb2RpZmllZElkcygpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwibW9kaWZpZWRJZHNcIiwge1xuICAgICAgaWRzOiBuZXcgU2V0KCksXG4gICAgICBoYXNoOiBcIlwiXG4gICAgfSk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZm9udF9sb2FkZXIuanNcblxuY2xhc3MgRm9udExvYWRlciB7XG4gICNzeXN0ZW1Gb250cyA9IG5ldyBTZXQoKTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG93bmVyRG9jdW1lbnQgPSBnbG9iYWxUaGlzLmRvY3VtZW50LFxuICAgIHN0eWxlRWxlbWVudCA9IG51bGxcbiAgfSkge1xuICAgIHRoaXMuX2RvY3VtZW50ID0gb3duZXJEb2N1bWVudDtcbiAgICB0aGlzLm5hdGl2ZUZvbnRGYWNlcyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLnN0eWxlRWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy5sb2FkaW5nUmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLmxvYWRUZXN0Rm9udElkID0gMDtcbiAgfVxuICBhZGROYXRpdmVGb250RmFjZShuYXRpdmVGb250RmFjZSkge1xuICAgIHRoaXMubmF0aXZlRm9udEZhY2VzLmFkZChuYXRpdmVGb250RmFjZSk7XG4gICAgdGhpcy5fZG9jdW1lbnQuZm9udHMuYWRkKG5hdGl2ZUZvbnRGYWNlKTtcbiAgfVxuICByZW1vdmVOYXRpdmVGb250RmFjZShuYXRpdmVGb250RmFjZSkge1xuICAgIHRoaXMubmF0aXZlRm9udEZhY2VzLmRlbGV0ZShuYXRpdmVGb250RmFjZSk7XG4gICAgdGhpcy5fZG9jdW1lbnQuZm9udHMuZGVsZXRlKG5hdGl2ZUZvbnRGYWNlKTtcbiAgfVxuICBpbnNlcnRSdWxlKHJ1bGUpIHtcbiAgICBpZiAoIXRoaXMuc3R5bGVFbGVtZW50KSB7XG4gICAgICB0aGlzLnN0eWxlRWxlbWVudCA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgIHRoaXMuX2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0uYXBwZW5kKHRoaXMuc3R5bGVFbGVtZW50KTtcbiAgICB9XG4gICAgY29uc3Qgc3R5bGVTaGVldCA9IHRoaXMuc3R5bGVFbGVtZW50LnNoZWV0O1xuICAgIHN0eWxlU2hlZXQuaW5zZXJ0UnVsZShydWxlLCBzdHlsZVNoZWV0LmNzc1J1bGVzLmxlbmd0aCk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgZm9yIChjb25zdCBuYXRpdmVGb250RmFjZSBvZiB0aGlzLm5hdGl2ZUZvbnRGYWNlcykge1xuICAgICAgdGhpcy5fZG9jdW1lbnQuZm9udHMuZGVsZXRlKG5hdGl2ZUZvbnRGYWNlKTtcbiAgICB9XG4gICAgdGhpcy5uYXRpdmVGb250RmFjZXMuY2xlYXIoKTtcbiAgICB0aGlzLiNzeXN0ZW1Gb250cy5jbGVhcigpO1xuICAgIGlmICh0aGlzLnN0eWxlRWxlbWVudCkge1xuICAgICAgdGhpcy5zdHlsZUVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICB0aGlzLnN0eWxlRWxlbWVudCA9IG51bGw7XG4gICAgfVxuICB9XG4gIGFzeW5jIGxvYWRTeXN0ZW1Gb250KHtcbiAgICBzeXN0ZW1Gb250SW5mbzogaW5mbyxcbiAgICBfaW5zcGVjdEZvbnRcbiAgfSkge1xuICAgIGlmICghaW5mbyB8fCB0aGlzLiNzeXN0ZW1Gb250cy5oYXMoaW5mby5sb2FkZWROYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhc3NlcnQoIXRoaXMuZGlzYWJsZUZvbnRGYWNlLCBcImxvYWRTeXN0ZW1Gb250IHNob3VsZG4ndCBiZSBjYWxsZWQgd2hlbiBgZGlzYWJsZUZvbnRGYWNlYCBpcyBzZXQuXCIpO1xuICAgIGlmICh0aGlzLmlzRm9udExvYWRpbmdBUElTdXBwb3J0ZWQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbG9hZGVkTmFtZSxcbiAgICAgICAgc3JjLFxuICAgICAgICBzdHlsZVxuICAgICAgfSA9IGluZm87XG4gICAgICBjb25zdCBmb250RmFjZSA9IG5ldyBGb250RmFjZShsb2FkZWROYW1lLCBzcmMsIHN0eWxlKTtcbiAgICAgIHRoaXMuYWRkTmF0aXZlRm9udEZhY2UoZm9udEZhY2UpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZm9udEZhY2UubG9hZCgpO1xuICAgICAgICB0aGlzLiNzeXN0ZW1Gb250cy5hZGQobG9hZGVkTmFtZSk7XG4gICAgICAgIF9pbnNwZWN0Rm9udD8uKGluZm8pO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHdhcm4oYENhbm5vdCBsb2FkIHN5c3RlbSBmb250OiAke2luZm8uYmFzZUZvbnROYW1lfSwgaW5zdGFsbGluZyBpdCBjb3VsZCBoZWxwIHRvIGltcHJvdmUgUERGIHJlbmRlcmluZy5gKTtcbiAgICAgICAgdGhpcy5yZW1vdmVOYXRpdmVGb250RmFjZShmb250RmFjZSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHVucmVhY2hhYmxlKFwiTm90IGltcGxlbWVudGVkOiBsb2FkU3lzdGVtRm9udCB3aXRob3V0IHRoZSBGb250IExvYWRpbmcgQVBJLlwiKTtcbiAgfVxuICBhc3luYyBiaW5kKGZvbnQpIHtcbiAgICBpZiAoZm9udC5hdHRhY2hlZCB8fCBmb250Lm1pc3NpbmdGaWxlICYmICFmb250LnN5c3RlbUZvbnRJbmZvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvbnQuYXR0YWNoZWQgPSB0cnVlO1xuICAgIGlmIChmb250LnN5c3RlbUZvbnRJbmZvKSB7XG4gICAgICBhd2FpdCB0aGlzLmxvYWRTeXN0ZW1Gb250KGZvbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkKSB7XG4gICAgICBjb25zdCBuYXRpdmVGb250RmFjZSA9IGZvbnQuY3JlYXRlTmF0aXZlRm9udEZhY2UoKTtcbiAgICAgIGlmIChuYXRpdmVGb250RmFjZSkge1xuICAgICAgICB0aGlzLmFkZE5hdGl2ZUZvbnRGYWNlKG5hdGl2ZUZvbnRGYWNlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBuYXRpdmVGb250RmFjZS5sb2FkZWQ7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgd2FybihgRmFpbGVkIHRvIGxvYWQgZm9udCAnJHtuYXRpdmVGb250RmFjZS5mYW1pbHl9JzogJyR7ZXh9Jy5gKTtcbiAgICAgICAgICBmb250LmRpc2FibGVGb250RmFjZSA9IHRydWU7XG4gICAgICAgICAgdGhyb3cgZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcnVsZSA9IGZvbnQuY3JlYXRlRm9udEZhY2VSdWxlKCk7XG4gICAgaWYgKHJ1bGUpIHtcbiAgICAgIHRoaXMuaW5zZXJ0UnVsZShydWxlKTtcbiAgICAgIGlmICh0aGlzLmlzU3luY0ZvbnRMb2FkaW5nU3VwcG9ydGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5fcXVldWVMb2FkaW5nQ2FsbGJhY2socmVzb2x2ZSk7XG4gICAgICAgIHRoaXMuX3ByZXBhcmVGb250TG9hZEV2ZW50KGZvbnQsIHJlcXVlc3QpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldCBpc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkKCkge1xuICAgIGNvbnN0IGhhc0ZvbnRzID0gISF0aGlzLl9kb2N1bWVudD8uZm9udHM7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzRm9udExvYWRpbmdBUElTdXBwb3J0ZWRcIiwgaGFzRm9udHMpO1xuICB9XG4gIGdldCBpc1N5bmNGb250TG9hZGluZ1N1cHBvcnRlZCgpIHtcbiAgICBsZXQgc3VwcG9ydGVkID0gZmFsc2U7XG4gICAgaWYgKGlzTm9kZUpTKSB7XG4gICAgICBzdXBwb3J0ZWQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgbmF2aWdhdG9yPy51c2VyQWdlbnQgPT09IFwic3RyaW5nXCIgJiYgL01vemlsbGFcXC81LjAuKj9ydjpcXGQrLio/IEdlY2tvLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICBzdXBwb3J0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNTeW5jRm9udExvYWRpbmdTdXBwb3J0ZWRcIiwgc3VwcG9ydGVkKTtcbiAgfVxuICBfcXVldWVMb2FkaW5nQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICBmdW5jdGlvbiBjb21wbGV0ZVJlcXVlc3QoKSB7XG4gICAgICBhc3NlcnQoIXJlcXVlc3QuZG9uZSwgXCJjb21wbGV0ZVJlcXVlc3QoKSBjYW5ub3QgYmUgY2FsbGVkIHR3aWNlLlwiKTtcbiAgICAgIHJlcXVlc3QuZG9uZSA9IHRydWU7XG4gICAgICB3aGlsZSAobG9hZGluZ1JlcXVlc3RzLmxlbmd0aCA+IDAgJiYgbG9hZGluZ1JlcXVlc3RzWzBdLmRvbmUpIHtcbiAgICAgICAgY29uc3Qgb3RoZXJSZXF1ZXN0ID0gbG9hZGluZ1JlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICAgIHNldFRpbWVvdXQob3RoZXJSZXF1ZXN0LmNhbGxiYWNrLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgbG9hZGluZ1JlcXVlc3RzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgY29tcGxldGU6IGNvbXBsZXRlUmVxdWVzdCxcbiAgICAgIGNhbGxiYWNrXG4gICAgfTtcbiAgICBsb2FkaW5nUmVxdWVzdHMucHVzaChyZXF1ZXN0KTtcbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfVxuICBnZXQgX2xvYWRUZXN0Rm9udCgpIHtcbiAgICBjb25zdCB0ZXN0Rm9udCA9IGF0b2IoXCJUMVJVVHdBTEFJQUFBd0F3UTBaR0lESHRaZzRBQUFPWUFBQUFnVVpHVkUxbGt6WndBQUFFSEFBQUFCeEhSRVZHQUJRQVwiICsgXCJGUUFBQkRnQUFBQWVUMU12TWxZTll3a0FBQUVnQUFBQVlHTnRZWEFCRFFMVUFBQUNOQUFBQVVKb1pXRmsveFZGRFFBQVwiICsgXCJBTHdBQUFBMmFHaGxZUWRrQStvQUFBRDBBQUFBSkdodGRIZ0Q2QUFBQUFBRVdBQUFBQVp0WVhod0FBSlFBQUFBQVJnQVwiICsgXCJBQUFHYm1GdFpWam1kSDRBQUFHQUFBQUFzWEJ2YzNUL2hnQXpBQUFEZUFBQUFDQUFBUUFBQUFFQUFMWlJGc1JmRHp6MVwiICsgXCJBQXNENkFBQUFBRE9CT1RMQUFBQUFNNEtIRHdBQUFBQUErZ0RJUUFBQUFnQUFnQUFBQUFBQUFBQkFBQURJUUFBQUZvRFwiICsgXCI2QUFBQUFBRDZBQUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFRQUFVQUFBQWdBQUFBUUQ2QUgwQUFVQUFBS0tBcndBQUFDTVwiICsgXCJBb29DdkFBQUFlQUFNUUVDQUFBQ0FBWUpBQUFBQUFBQUFBQUFBUUFBQUFBQUFBQUFBQUFBQUZCbVJXUUF3QUF1QUM0RFwiICsgXCJJUDg0QUZvRElRQUFBQUFBQVFBQUFBQUFBQUFBQUNBQUlBQUJBQUFBRGdDdUFBRUFBQUFBQUFBQUFRQUFBQUVBQUFBQVwiICsgXCJBQUVBQVFBQUFBRUFBQUFBQUFJQUFRQUFBQUVBQUFBQUFBTUFBUUFBQUFFQUFBQUFBQVFBQVFBQUFBRUFBQUFBQUFVQVwiICsgXCJBUUFBQUFFQUFBQUFBQVlBQVFBQUFBTUFBUVFKQUFBQUFnQUJBQU1BQVFRSkFBRUFBZ0FCQUFNQUFRUUpBQUlBQWdBQlwiICsgXCJBQU1BQVFRSkFBTUFBZ0FCQUFNQUFRUUpBQVFBQWdBQkFBTUFBUVFKQUFVQUFnQUJBQU1BQVFRSkFBWUFBZ0FCV0FCWVwiICsgXCJBQUFBQUFBQUF3QUFBQU1BQUFBY0FBRUFBQUFBQUR3QUF3QUJBQUFBSEFBRUFDQUFBQUFFQUFRQUFRQUFBQzcvL3dBQVwiICsgXCJBQzcvLy8vVEFBRUFBQUFBQUFBQkJnQUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFNQUFBQUFBQUQvZ3dBeUFBQUFBUUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFCQUFRRUFBRUJBUUpZQUFFQkFTSDREd0Q0R3dIRUF2Z2NBL2dYQkl3TUFZdUwrbno1dFFYa0Q1ajNDQkxuRVFBQ1wiICsgXCJBUUVCSVZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlBQUFCQVFBQUR3QUNBUUVFRS90M1wiICsgXCJEb3Y2ZkFINmZBVCtmUHA4K253SERvc01Ddm0xQ3ZtMURBejZmQlFBQUFBQUFBQUJBQUFBQU1tSmJ6RUFBQUFBemdUalwiICsgXCJGUUFBQUFET0JPUXBBQUVBQUFBQUFBQUFEQUFVQUFRQUFBQUJBQUFBQWdBQkFBQUFBQUFBQUFBRDZBQUFBQUFBQUE9PVwiKTtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2xvYWRUZXN0Rm9udFwiLCB0ZXN0Rm9udCk7XG4gIH1cbiAgX3ByZXBhcmVGb250TG9hZEV2ZW50KGZvbnQsIHJlcXVlc3QpIHtcbiAgICBmdW5jdGlvbiBpbnQzMihkYXRhLCBvZmZzZXQpIHtcbiAgICAgIHJldHVybiBkYXRhLmNoYXJDb2RlQXQob2Zmc2V0KSA8PCAyNCB8IGRhdGEuY2hhckNvZGVBdChvZmZzZXQgKyAxKSA8PCAxNiB8IGRhdGEuY2hhckNvZGVBdChvZmZzZXQgKyAyKSA8PCA4IHwgZGF0YS5jaGFyQ29kZUF0KG9mZnNldCArIDMpICYgMHhmZjtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3BsaWNlU3RyaW5nKHMsIG9mZnNldCwgcmVtb3ZlLCBpbnNlcnQpIHtcbiAgICAgIGNvbnN0IGNodW5rMSA9IHMuc3Vic3RyaW5nKDAsIG9mZnNldCk7XG4gICAgICBjb25zdCBjaHVuazIgPSBzLnN1YnN0cmluZyhvZmZzZXQgKyByZW1vdmUpO1xuICAgICAgcmV0dXJuIGNodW5rMSArIGluc2VydCArIGNodW5rMjtcbiAgICB9XG4gICAgbGV0IGksIGlpO1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLndpZHRoID0gMTtcbiAgICBjYW52YXMuaGVpZ2h0ID0gMTtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGxldCBjYWxsZWQgPSAwO1xuICAgIGZ1bmN0aW9uIGlzRm9udFJlYWR5KG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoKytjYWxsZWQgPiAzMCkge1xuICAgICAgICB3YXJuKFwiTG9hZCB0ZXN0IGZvbnQgbmV2ZXIgbG9hZGVkLlwiKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3R4LmZvbnQgPSBcIjMwcHggXCIgKyBuYW1lO1xuICAgICAgY3R4LmZpbGxUZXh0KFwiLlwiLCAwLCAyMCk7XG4gICAgICBjb25zdCBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpO1xuICAgICAgaWYgKGltYWdlRGF0YS5kYXRhWzNdID4gMCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KGlzRm9udFJlYWR5LmJpbmQobnVsbCwgbmFtZSwgY2FsbGJhY2spKTtcbiAgICB9XG4gICAgY29uc3QgbG9hZFRlc3RGb250SWQgPSBgbHQke0RhdGUubm93KCl9JHt0aGlzLmxvYWRUZXN0Rm9udElkKyt9YDtcbiAgICBsZXQgZGF0YSA9IHRoaXMuX2xvYWRUZXN0Rm9udDtcbiAgICBjb25zdCBDT01NRU5UX09GRlNFVCA9IDk3NjtcbiAgICBkYXRhID0gc3BsaWNlU3RyaW5nKGRhdGEsIENPTU1FTlRfT0ZGU0VULCBsb2FkVGVzdEZvbnRJZC5sZW5ndGgsIGxvYWRUZXN0Rm9udElkKTtcbiAgICBjb25zdCBDRkZfQ0hFQ0tTVU1fT0ZGU0VUID0gMTY7XG4gICAgY29uc3QgWFhYWF9WQUxVRSA9IDB4NTg1ODU4NTg7XG4gICAgbGV0IGNoZWNrc3VtID0gaW50MzIoZGF0YSwgQ0ZGX0NIRUNLU1VNX09GRlNFVCk7XG4gICAgZm9yIChpID0gMCwgaWkgPSBsb2FkVGVzdEZvbnRJZC5sZW5ndGggLSAzOyBpIDwgaWk7IGkgKz0gNCkge1xuICAgICAgY2hlY2tzdW0gPSBjaGVja3N1bSAtIFhYWFhfVkFMVUUgKyBpbnQzMihsb2FkVGVzdEZvbnRJZCwgaSkgfCAwO1xuICAgIH1cbiAgICBpZiAoaSA8IGxvYWRUZXN0Rm9udElkLmxlbmd0aCkge1xuICAgICAgY2hlY2tzdW0gPSBjaGVja3N1bSAtIFhYWFhfVkFMVUUgKyBpbnQzMihsb2FkVGVzdEZvbnRJZCArIFwiWFhYXCIsIGkpIHwgMDtcbiAgICB9XG4gICAgZGF0YSA9IHNwbGljZVN0cmluZyhkYXRhLCBDRkZfQ0hFQ0tTVU1fT0ZGU0VULCA0LCBzdHJpbmczMihjaGVja3N1bSkpO1xuICAgIGNvbnN0IHVybCA9IGB1cmwoZGF0YTpmb250L29wZW50eXBlO2Jhc2U2NCwke2J0b2EoZGF0YSl9KTtgO1xuICAgIGNvbnN0IHJ1bGUgPSBgQGZvbnQtZmFjZSB7Zm9udC1mYW1pbHk6XCIke2xvYWRUZXN0Rm9udElkfVwiO3NyYzoke3VybH19YDtcbiAgICB0aGlzLmluc2VydFJ1bGUocnVsZSk7XG4gICAgY29uc3QgZGl2ID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkaXYuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgZGl2LnN0eWxlLndpZHRoID0gZGl2LnN0eWxlLmhlaWdodCA9IFwiMTBweFwiO1xuICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICBkaXYuc3R5bGUudG9wID0gZGl2LnN0eWxlLmxlZnQgPSBcIjBweFwiO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBbZm9udC5sb2FkZWROYW1lLCBsb2FkVGVzdEZvbnRJZF0pIHtcbiAgICAgIGNvbnN0IHNwYW4gPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIHNwYW4udGV4dENvbnRlbnQgPSBcIkhpXCI7XG4gICAgICBzcGFuLnN0eWxlLmZvbnRGYW1pbHkgPSBuYW1lO1xuICAgICAgZGl2LmFwcGVuZChzcGFuKTtcbiAgICB9XG4gICAgdGhpcy5fZG9jdW1lbnQuYm9keS5hcHBlbmQoZGl2KTtcbiAgICBpc0ZvbnRSZWFkeShsb2FkVGVzdEZvbnRJZCwgKCkgPT4ge1xuICAgICAgZGl2LnJlbW92ZSgpO1xuICAgICAgcmVxdWVzdC5jb21wbGV0ZSgpO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBGb250RmFjZU9iamVjdCB7XG4gIGNvbnN0cnVjdG9yKHRyYW5zbGF0ZWREYXRhLCB7XG4gICAgZGlzYWJsZUZvbnRGYWNlID0gZmFsc2UsXG4gICAgaW5zcGVjdEZvbnQgPSBudWxsXG4gIH0pIHtcbiAgICB0aGlzLmNvbXBpbGVkR2x5cGhzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdHJhbnNsYXRlZERhdGEpIHtcbiAgICAgIHRoaXNbaV0gPSB0cmFuc2xhdGVkRGF0YVtpXTtcbiAgICB9XG4gICAgdGhpcy5kaXNhYmxlRm9udEZhY2UgPSBkaXNhYmxlRm9udEZhY2UgPT09IHRydWU7XG4gICAgdGhpcy5faW5zcGVjdEZvbnQgPSBpbnNwZWN0Rm9udDtcbiAgfVxuICBjcmVhdGVOYXRpdmVGb250RmFjZSgpIHtcbiAgICBpZiAoIXRoaXMuZGF0YSB8fCB0aGlzLmRpc2FibGVGb250RmFjZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCBuYXRpdmVGb250RmFjZTtcbiAgICBpZiAoIXRoaXMuY3NzRm9udEluZm8pIHtcbiAgICAgIG5hdGl2ZUZvbnRGYWNlID0gbmV3IEZvbnRGYWNlKHRoaXMubG9hZGVkTmFtZSwgdGhpcy5kYXRhLCB7fSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNzcyA9IHtcbiAgICAgICAgd2VpZ2h0OiB0aGlzLmNzc0ZvbnRJbmZvLmZvbnRXZWlnaHRcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5jc3NGb250SW5mby5pdGFsaWNBbmdsZSkge1xuICAgICAgICBjc3Muc3R5bGUgPSBgb2JsaXF1ZSAke3RoaXMuY3NzRm9udEluZm8uaXRhbGljQW5nbGV9ZGVnYDtcbiAgICAgIH1cbiAgICAgIG5hdGl2ZUZvbnRGYWNlID0gbmV3IEZvbnRGYWNlKHRoaXMuY3NzRm9udEluZm8uZm9udEZhbWlseSwgdGhpcy5kYXRhLCBjc3MpO1xuICAgIH1cbiAgICB0aGlzLl9pbnNwZWN0Rm9udD8uKHRoaXMpO1xuICAgIHJldHVybiBuYXRpdmVGb250RmFjZTtcbiAgfVxuICBjcmVhdGVGb250RmFjZVJ1bGUoKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEgfHwgdGhpcy5kaXNhYmxlRm9udEZhY2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBgdXJsKGRhdGE6JHt0aGlzLm1pbWV0eXBlfTtiYXNlNjQsJHt0b0Jhc2U2NFV0aWwodGhpcy5kYXRhKX0pO2A7XG4gICAgbGV0IHJ1bGU7XG4gICAgaWYgKCF0aGlzLmNzc0ZvbnRJbmZvKSB7XG4gICAgICBydWxlID0gYEBmb250LWZhY2Uge2ZvbnQtZmFtaWx5OlwiJHt0aGlzLmxvYWRlZE5hbWV9XCI7c3JjOiR7dXJsfX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgY3NzID0gYGZvbnQtd2VpZ2h0OiAke3RoaXMuY3NzRm9udEluZm8uZm9udFdlaWdodH07YDtcbiAgICAgIGlmICh0aGlzLmNzc0ZvbnRJbmZvLml0YWxpY0FuZ2xlKSB7XG4gICAgICAgIGNzcyArPSBgZm9udC1zdHlsZTogb2JsaXF1ZSAke3RoaXMuY3NzRm9udEluZm8uaXRhbGljQW5nbGV9ZGVnO2A7XG4gICAgICB9XG4gICAgICBydWxlID0gYEBmb250LWZhY2Uge2ZvbnQtZmFtaWx5OlwiJHt0aGlzLmNzc0ZvbnRJbmZvLmZvbnRGYW1pbHl9XCI7JHtjc3N9c3JjOiR7dXJsfX1gO1xuICAgIH1cbiAgICB0aGlzLl9pbnNwZWN0Rm9udD8uKHRoaXMsIHVybCk7XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH1cbiAgZ2V0UGF0aEdlbmVyYXRvcihvYmpzLCBjaGFyYWN0ZXIpIHtcbiAgICBpZiAodGhpcy5jb21waWxlZEdseXBoc1tjaGFyYWN0ZXJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVkR2x5cGhzW2NoYXJhY3Rlcl07XG4gICAgfVxuICAgIGxldCBjbWRzO1xuICAgIHRyeSB7XG4gICAgICBjbWRzID0gb2Jqcy5nZXQodGhpcy5sb2FkZWROYW1lICsgXCJfcGF0aF9cIiArIGNoYXJhY3Rlcik7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHdhcm4oYGdldFBhdGhHZW5lcmF0b3IgLSBpZ25vcmluZyBjaGFyYWN0ZXI6IFwiJHtleH1cIi5gKTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNtZHMpIHx8IGNtZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21waWxlZEdseXBoc1tjaGFyYWN0ZXJdID0gZnVuY3Rpb24gKGMsIHNpemUpIHt9O1xuICAgIH1cbiAgICBjb25zdCBjb21tYW5kcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGNtZHMubGVuZ3RoOyBpIDwgaWk7KSB7XG4gICAgICBzd2l0Y2ggKGNtZHNbaSsrXSkge1xuICAgICAgICBjYXNlIEZvbnRSZW5kZXJPcHMuQkVaSUVSX0NVUlZFX1RPOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IFthLCBiLCBjLCBkLCBlLCBmXSA9IGNtZHMuc2xpY2UoaSwgaSArIDYpO1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaChjdHggPT4gY3R4LmJlemllckN1cnZlVG8oYSwgYiwgYywgZCwgZSwgZikpO1xuICAgICAgICAgICAgaSArPSA2O1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBGb250UmVuZGVyT3BzLk1PVkVfVE86XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgW2EsIGJdID0gY21kcy5zbGljZShpLCBpICsgMik7XG4gICAgICAgICAgICBjb21tYW5kcy5wdXNoKGN0eCA9PiBjdHgubW92ZVRvKGEsIGIpKTtcbiAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRm9udFJlbmRlck9wcy5MSU5FX1RPOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IFthLCBiXSA9IGNtZHMuc2xpY2UoaSwgaSArIDIpO1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaChjdHggPT4gY3R4LmxpbmVUbyhhLCBiKSk7XG4gICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEZvbnRSZW5kZXJPcHMuUVVBRFJBVElDX0NVUlZFX1RPOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IFthLCBiLCBjLCBkXSA9IGNtZHMuc2xpY2UoaSwgaSArIDQpO1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaChjdHggPT4gY3R4LnF1YWRyYXRpY0N1cnZlVG8oYSwgYiwgYywgZCkpO1xuICAgICAgICAgICAgaSArPSA0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBGb250UmVuZGVyT3BzLlJFU1RPUkU6XG4gICAgICAgICAgY29tbWFuZHMucHVzaChjdHggPT4gY3R4LnJlc3RvcmUoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRm9udFJlbmRlck9wcy5TQVZFOlxuICAgICAgICAgIGNvbW1hbmRzLnB1c2goY3R4ID0+IGN0eC5zYXZlKCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEZvbnRSZW5kZXJPcHMuU0NBTEU6XG4gICAgICAgICAgYXNzZXJ0KGNvbW1hbmRzLmxlbmd0aCA9PT0gMiwgXCJTY2FsZSBjb21tYW5kIGlzIG9ubHkgdmFsaWQgYXQgdGhlIHRoaXJkIHBvc2l0aW9uLlwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBGb250UmVuZGVyT3BzLlRSQU5TRk9STTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBbYSwgYiwgYywgZCwgZSwgZl0gPSBjbWRzLnNsaWNlKGksIGkgKyA2KTtcbiAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goY3R4ID0+IGN0eC50cmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZikpO1xuICAgICAgICAgICAgaSArPSA2O1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBGb250UmVuZGVyT3BzLlRSQU5TTEFURTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBbYSwgYl0gPSBjbWRzLnNsaWNlKGksIGkgKyAyKTtcbiAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goY3R4ID0+IGN0eC50cmFuc2xhdGUoYSwgYikpO1xuICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgY29tbWFuZHMucHVzaChjdHggPT4gY3R4LmNsb3NlUGF0aCgpKTtcbiAgICByZXR1cm4gdGhpcy5jb21waWxlZEdseXBoc1tjaGFyYWN0ZXJdID0gZnVuY3Rpb24gZ2x5cGhEcmF3ZXIoY3R4LCBzaXplKSB7XG4gICAgICBjb21tYW5kc1swXShjdHgpO1xuICAgICAgY29tbWFuZHNbMV0oY3R4KTtcbiAgICAgIGN0eC5zY2FsZShzaXplLCAtc2l6ZSk7XG4gICAgICBmb3IgKGxldCBpID0gMiwgaWkgPSBjb21tYW5kcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGNvbW1hbmRzW2ldKGN0eCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9jYW52YXNfZmFjdG9yeS5qc1xuXG5jbGFzcyBCYXNlQ2FudmFzRmFjdG9yeSB7XG4gICNlbmFibGVIV0EgPSBmYWxzZTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGVuYWJsZUhXQSA9IGZhbHNlXG4gIH0pIHtcbiAgICB0aGlzLiNlbmFibGVIV0EgPSBlbmFibGVIV0E7XG4gIH1cbiAgY3JlYXRlKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjYW52YXMgc2l6ZVwiKTtcbiAgICB9XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5fY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICAgIHJldHVybiB7XG4gICAgICBjYW52YXMsXG4gICAgICBjb250ZXh0OiBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgICAgd2lsbFJlYWRGcmVxdWVudGx5OiAhdGhpcy4jZW5hYmxlSFdBXG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgcmVzZXQoY2FudmFzQW5kQ29udGV4dCwgd2lkdGgsIGhlaWdodCkge1xuICAgIGlmICghY2FudmFzQW5kQ29udGV4dC5jYW52YXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbnZhcyBpcyBub3Qgc3BlY2lmaWVkXCIpO1xuICAgIH1cbiAgICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjYW52YXMgc2l6ZVwiKTtcbiAgICB9XG4gICAgY2FudmFzQW5kQ29udGV4dC5jYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cbiAgZGVzdHJveShjYW52YXNBbmRDb250ZXh0KSB7XG4gICAgaWYgKCFjYW52YXNBbmRDb250ZXh0LmNhbnZhcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIGlzIG5vdCBzcGVjaWZpZWRcIik7XG4gICAgfVxuICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzLndpZHRoID0gMDtcbiAgICBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy5oZWlnaHQgPSAwO1xuICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzID0gbnVsbDtcbiAgICBjYW52YXNBbmRDb250ZXh0LmNvbnRleHQgPSBudWxsO1xuICB9XG4gIF9jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIGBfY3JlYXRlQ2FudmFzYCBjYWxsZWQuXCIpO1xuICB9XG59XG5jbGFzcyBET01DYW52YXNGYWN0b3J5IGV4dGVuZHMgQmFzZUNhbnZhc0ZhY3Rvcnkge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgb3duZXJEb2N1bWVudCA9IGdsb2JhbFRoaXMuZG9jdW1lbnQsXG4gICAgZW5hYmxlSFdBID0gZmFsc2VcbiAgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGVuYWJsZUhXQVxuICAgIH0pO1xuICAgIHRoaXMuX2RvY3VtZW50ID0gb3duZXJEb2N1bWVudDtcbiAgfVxuICBfY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9jbWFwX3JlYWRlcl9mYWN0b3J5LmpzXG5cblxuY2xhc3MgQmFzZUNNYXBSZWFkZXJGYWN0b3J5IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGJhc2VVcmwgPSBudWxsLFxuICAgIGlzQ29tcHJlc3NlZCA9IHRydWVcbiAgfSkge1xuICAgIHRoaXMuYmFzZVVybCA9IGJhc2VVcmw7XG4gICAgdGhpcy5pc0NvbXByZXNzZWQgPSBpc0NvbXByZXNzZWQ7XG4gIH1cbiAgYXN5bmMgZmV0Y2goe1xuICAgIG5hbWVcbiAgfSkge1xuICAgIGlmICghdGhpcy5iYXNlVXJsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhhdCB0aGUgYGNNYXBVcmxgIGFuZCBgY01hcFBhY2tlZGAgQVBJIHBhcmFtZXRlcnMgYXJlIHByb3ZpZGVkLlwiKTtcbiAgICB9XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDTWFwIG5hbWUgbXVzdCBiZSBzcGVjaWZpZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSB0aGlzLmJhc2VVcmwgKyBuYW1lICsgKHRoaXMuaXNDb21wcmVzc2VkID8gXCIuYmNtYXBcIiA6IFwiXCIpO1xuICAgIHJldHVybiB0aGlzLl9mZXRjaCh1cmwpLnRoZW4oY01hcERhdGEgPT4gKHtcbiAgICAgIGNNYXBEYXRhLFxuICAgICAgaXNDb21wcmVzc2VkOiB0aGlzLmlzQ29tcHJlc3NlZFxuICAgIH0pKS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gbG9hZCAke3RoaXMuaXNDb21wcmVzc2VkID8gXCJiaW5hcnkgXCIgOiBcIlwifUNNYXAgYXQ6ICR7dXJsfWApO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIF9mZXRjaCh1cmwpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IG1ldGhvZCBgX2ZldGNoYCBjYWxsZWQuXCIpO1xuICB9XG59XG5jbGFzcyBET01DTWFwUmVhZGVyRmFjdG9yeSBleHRlbmRzIEJhc2VDTWFwUmVhZGVyRmFjdG9yeSB7XG4gIGFzeW5jIF9mZXRjaCh1cmwpIHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgZmV0Y2hEYXRhKHVybCwgdGhpcy5pc0NvbXByZXNzZWQgPyBcImFycmF5YnVmZmVyXCIgOiBcInRleHRcIik7XG4gICAgcmV0dXJuIGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IG5ldyBVaW50OEFycmF5KGRhdGEpIDogc3RyaW5nVG9CeXRlcyhkYXRhKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9maWx0ZXJfZmFjdG9yeS5qc1xuXG5cbmNsYXNzIEJhc2VGaWx0ZXJGYWN0b3J5IHtcbiAgYWRkRmlsdGVyKG1hcHMpIHtcbiAgICByZXR1cm4gXCJub25lXCI7XG4gIH1cbiAgYWRkSENNRmlsdGVyKGZnQ29sb3IsIGJnQ29sb3IpIHtcbiAgICByZXR1cm4gXCJub25lXCI7XG4gIH1cbiAgYWRkQWxwaGFGaWx0ZXIobWFwKSB7XG4gICAgcmV0dXJuIFwibm9uZVwiO1xuICB9XG4gIGFkZEx1bWlub3NpdHlGaWx0ZXIobWFwKSB7XG4gICAgcmV0dXJuIFwibm9uZVwiO1xuICB9XG4gIGFkZEhpZ2hsaWdodEhDTUZpbHRlcihmaWx0ZXJOYW1lLCBmZ0NvbG9yLCBiZ0NvbG9yLCBuZXdGZ0NvbG9yLCBuZXdCZ0NvbG9yKSB7XG4gICAgcmV0dXJuIFwibm9uZVwiO1xuICB9XG4gIGRlc3Ryb3koa2VlcEhDTSA9IGZhbHNlKSB7fVxufVxuY2xhc3MgRE9NRmlsdGVyRmFjdG9yeSBleHRlbmRzIEJhc2VGaWx0ZXJGYWN0b3J5IHtcbiAgI2Jhc2VVcmw7XG4gICNfY2FjaGU7XG4gICNfZGVmcztcbiAgI2RvY0lkO1xuICAjZG9jdW1lbnQ7XG4gICNfaGNtQ2FjaGU7XG4gICNpZCA9IDA7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBkb2NJZCxcbiAgICBvd25lckRvY3VtZW50ID0gZ2xvYmFsVGhpcy5kb2N1bWVudFxuICB9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLiNkb2NJZCA9IGRvY0lkO1xuICAgIHRoaXMuI2RvY3VtZW50ID0gb3duZXJEb2N1bWVudDtcbiAgfVxuICBnZXQgI2NhY2hlKCkge1xuICAgIHJldHVybiB0aGlzLiNfY2FjaGUgfHw9IG5ldyBNYXAoKTtcbiAgfVxuICBnZXQgI2hjbUNhY2hlKCkge1xuICAgIHJldHVybiB0aGlzLiNfaGNtQ2FjaGUgfHw9IG5ldyBNYXAoKTtcbiAgfVxuICBnZXQgI2RlZnMoKSB7XG4gICAgaWYgKCF0aGlzLiNfZGVmcykge1xuICAgICAgY29uc3QgZGl2ID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3R5bGVcbiAgICAgIH0gPSBkaXY7XG4gICAgICBzdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgIHN0eWxlLmNvbnRhaW4gPSBcInN0cmljdFwiO1xuICAgICAgc3R5bGUud2lkdGggPSBzdHlsZS5oZWlnaHQgPSAwO1xuICAgICAgc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICBzdHlsZS50b3AgPSBzdHlsZS5sZWZ0ID0gMDtcbiAgICAgIHN0eWxlLnpJbmRleCA9IC0xO1xuICAgICAgY29uc3Qgc3ZnID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJzdmdcIik7XG4gICAgICBzdmcuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgMCk7XG4gICAgICBzdmcuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIDApO1xuICAgICAgdGhpcy4jX2RlZnMgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcImRlZnNcIik7XG4gICAgICBkaXYuYXBwZW5kKHN2Zyk7XG4gICAgICBzdmcuYXBwZW5kKHRoaXMuI19kZWZzKTtcbiAgICAgIHRoaXMuI2RvY3VtZW50LmJvZHkuYXBwZW5kKGRpdik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNfZGVmcztcbiAgfVxuICAjY3JlYXRlVGFibGVzKG1hcHMpIHtcbiAgICBpZiAobWFwcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IG1hcFIgPSBtYXBzWzBdO1xuICAgICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5KDI1Nik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgIGJ1ZmZlcltpXSA9IG1hcFJbaV0gLyAyNTU7XG4gICAgICB9XG4gICAgICBjb25zdCB0YWJsZSA9IGJ1ZmZlci5qb2luKFwiLFwiKTtcbiAgICAgIHJldHVybiBbdGFibGUsIHRhYmxlLCB0YWJsZV07XG4gICAgfVxuICAgIGNvbnN0IFttYXBSLCBtYXBHLCBtYXBCXSA9IG1hcHM7XG4gICAgY29uc3QgYnVmZmVyUiA9IG5ldyBBcnJheSgyNTYpO1xuICAgIGNvbnN0IGJ1ZmZlckcgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICBjb25zdCBidWZmZXJCID0gbmV3IEFycmF5KDI1Nik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgYnVmZmVyUltpXSA9IG1hcFJbaV0gLyAyNTU7XG4gICAgICBidWZmZXJHW2ldID0gbWFwR1tpXSAvIDI1NTtcbiAgICAgIGJ1ZmZlckJbaV0gPSBtYXBCW2ldIC8gMjU1O1xuICAgIH1cbiAgICByZXR1cm4gW2J1ZmZlclIuam9pbihcIixcIiksIGJ1ZmZlckcuam9pbihcIixcIiksIGJ1ZmZlckIuam9pbihcIixcIildO1xuICB9XG4gICNjcmVhdGVVcmwoaWQpIHtcbiAgICBpZiAodGhpcy4jYmFzZVVybCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLiNiYXNlVXJsID0gXCJcIjtcbiAgICAgIGNvbnN0IHVybCA9IHRoaXMuI2RvY3VtZW50LlVSTDtcbiAgICAgIGlmICh1cmwgIT09IHRoaXMuI2RvY3VtZW50LmJhc2VVUkkpIHtcbiAgICAgICAgaWYgKGlzRGF0YVNjaGVtZSh1cmwpKSB7XG4gICAgICAgICAgd2FybignI2NyZWF0ZVVybDogaWdub3JlIFwiZGF0YTpcIi1VUkwgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy4jYmFzZVVybCA9IHVybC5zcGxpdChcIiNcIiwgMSlbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGB1cmwoJHt0aGlzLiNiYXNlVXJsfSMke2lkfSlgO1xuICB9XG4gIGFkZEZpbHRlcihtYXBzKSB7XG4gICAgaWYgKCFtYXBzKSB7XG4gICAgICByZXR1cm4gXCJub25lXCI7XG4gICAgfVxuICAgIGxldCB2YWx1ZSA9IHRoaXMuI2NhY2hlLmdldChtYXBzKTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgW3RhYmxlUiwgdGFibGVHLCB0YWJsZUJdID0gdGhpcy4jY3JlYXRlVGFibGVzKG1hcHMpO1xuICAgIGNvbnN0IGtleSA9IG1hcHMubGVuZ3RoID09PSAxID8gdGFibGVSIDogYCR7dGFibGVSfSR7dGFibGVHfSR7dGFibGVCfWA7XG4gICAgdmFsdWUgPSB0aGlzLiNjYWNoZS5nZXQoa2V5KTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuI2NhY2hlLnNldChtYXBzLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IGlkID0gYGdfJHt0aGlzLiNkb2NJZH1fdHJhbnNmZXJfbWFwXyR7dGhpcy4jaWQrK31gO1xuICAgIGNvbnN0IHVybCA9IHRoaXMuI2NyZWF0ZVVybChpZCk7XG4gICAgdGhpcy4jY2FjaGUuc2V0KG1hcHMsIHVybCk7XG4gICAgdGhpcy4jY2FjaGUuc2V0KGtleSwgdXJsKTtcbiAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLiNjcmVhdGVGaWx0ZXIoaWQpO1xuICAgIHRoaXMuI2FkZFRyYW5zZmVyTWFwQ29udmVyc2lvbih0YWJsZVIsIHRhYmxlRywgdGFibGVCLCBmaWx0ZXIpO1xuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgYWRkSENNRmlsdGVyKGZnQ29sb3IsIGJnQ29sb3IpIHtcbiAgICBjb25zdCBrZXkgPSBgJHtmZ0NvbG9yfS0ke2JnQ29sb3J9YDtcbiAgICBjb25zdCBmaWx0ZXJOYW1lID0gXCJiYXNlXCI7XG4gICAgbGV0IGluZm8gPSB0aGlzLiNoY21DYWNoZS5nZXQoZmlsdGVyTmFtZSk7XG4gICAgaWYgKGluZm8/LmtleSA9PT0ga2V5KSB7XG4gICAgICByZXR1cm4gaW5mby51cmw7XG4gICAgfVxuICAgIGlmIChpbmZvKSB7XG4gICAgICBpbmZvLmZpbHRlcj8ucmVtb3ZlKCk7XG4gICAgICBpbmZvLmtleSA9IGtleTtcbiAgICAgIGluZm8udXJsID0gXCJub25lXCI7XG4gICAgICBpbmZvLmZpbHRlciA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8gPSB7XG4gICAgICAgIGtleSxcbiAgICAgICAgdXJsOiBcIm5vbmVcIixcbiAgICAgICAgZmlsdGVyOiBudWxsXG4gICAgICB9O1xuICAgICAgdGhpcy4jaGNtQ2FjaGUuc2V0KGZpbHRlck5hbWUsIGluZm8pO1xuICAgIH1cbiAgICBpZiAoIWZnQ29sb3IgfHwgIWJnQ29sb3IpIHtcbiAgICAgIHJldHVybiBpbmZvLnVybDtcbiAgICB9XG4gICAgY29uc3QgZmdSR0IgPSB0aGlzLiNnZXRSR0IoZmdDb2xvcik7XG4gICAgZmdDb2xvciA9IFV0aWwubWFrZUhleENvbG9yKC4uLmZnUkdCKTtcbiAgICBjb25zdCBiZ1JHQiA9IHRoaXMuI2dldFJHQihiZ0NvbG9yKTtcbiAgICBiZ0NvbG9yID0gVXRpbC5tYWtlSGV4Q29sb3IoLi4uYmdSR0IpO1xuICAgIHRoaXMuI2RlZnMuc3R5bGUuY29sb3IgPSBcIlwiO1xuICAgIGlmIChmZ0NvbG9yID09PSBcIiMwMDAwMDBcIiAmJiBiZ0NvbG9yID09PSBcIiNmZmZmZmZcIiB8fCBmZ0NvbG9yID09PSBiZ0NvbG9yKSB7XG4gICAgICByZXR1cm4gaW5mby51cmw7XG4gICAgfVxuICAgIGNvbnN0IG1hcCA9IG5ldyBBcnJheSgyNTYpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IDI1NTsgaSsrKSB7XG4gICAgICBjb25zdCB4ID0gaSAvIDI1NTtcbiAgICAgIG1hcFtpXSA9IHggPD0gMC4wMzkyOCA/IHggLyAxMi45MiA6ICgoeCArIDAuMDU1KSAvIDEuMDU1KSAqKiAyLjQ7XG4gICAgfVxuICAgIGNvbnN0IHRhYmxlID0gbWFwLmpvaW4oXCIsXCIpO1xuICAgIGNvbnN0IGlkID0gYGdfJHt0aGlzLiNkb2NJZH1faGNtX2ZpbHRlcmA7XG4gICAgY29uc3QgZmlsdGVyID0gaW5mby5maWx0ZXIgPSB0aGlzLiNjcmVhdGVGaWx0ZXIoaWQpO1xuICAgIHRoaXMuI2FkZFRyYW5zZmVyTWFwQ29udmVyc2lvbih0YWJsZSwgdGFibGUsIHRhYmxlLCBmaWx0ZXIpO1xuICAgIHRoaXMuI2FkZEdyYXlDb252ZXJzaW9uKGZpbHRlcik7XG4gICAgY29uc3QgZ2V0U3RlcHMgPSAoYywgbikgPT4ge1xuICAgICAgY29uc3Qgc3RhcnQgPSBmZ1JHQltjXSAvIDI1NTtcbiAgICAgIGNvbnN0IGVuZCA9IGJnUkdCW2NdIC8gMjU1O1xuICAgICAgY29uc3QgYXJyID0gbmV3IEFycmF5KG4gKyAxKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG47IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBzdGFydCArIGkgLyBuICogKGVuZCAtIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnIuam9pbihcIixcIik7XG4gICAgfTtcbiAgICB0aGlzLiNhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24oZ2V0U3RlcHMoMCwgNSksIGdldFN0ZXBzKDEsIDUpLCBnZXRTdGVwcygyLCA1KSwgZmlsdGVyKTtcbiAgICBpbmZvLnVybCA9IHRoaXMuI2NyZWF0ZVVybChpZCk7XG4gICAgcmV0dXJuIGluZm8udXJsO1xuICB9XG4gIGFkZEFscGhhRmlsdGVyKG1hcCkge1xuICAgIGxldCB2YWx1ZSA9IHRoaXMuI2NhY2hlLmdldChtYXApO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBbdGFibGVBXSA9IHRoaXMuI2NyZWF0ZVRhYmxlcyhbbWFwXSk7XG4gICAgY29uc3Qga2V5ID0gYGFscGhhXyR7dGFibGVBfWA7XG4gICAgdmFsdWUgPSB0aGlzLiNjYWNoZS5nZXQoa2V5KTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuI2NhY2hlLnNldChtYXAsIHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgaWQgPSBgZ18ke3RoaXMuI2RvY0lkfV9hbHBoYV9tYXBfJHt0aGlzLiNpZCsrfWA7XG4gICAgY29uc3QgdXJsID0gdGhpcy4jY3JlYXRlVXJsKGlkKTtcbiAgICB0aGlzLiNjYWNoZS5zZXQobWFwLCB1cmwpO1xuICAgIHRoaXMuI2NhY2hlLnNldChrZXksIHVybCk7XG4gICAgY29uc3QgZmlsdGVyID0gdGhpcy4jY3JlYXRlRmlsdGVyKGlkKTtcbiAgICB0aGlzLiNhZGRUcmFuc2Zlck1hcEFscGhhQ29udmVyc2lvbih0YWJsZUEsIGZpbHRlcik7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBhZGRMdW1pbm9zaXR5RmlsdGVyKG1hcCkge1xuICAgIGxldCB2YWx1ZSA9IHRoaXMuI2NhY2hlLmdldChtYXAgfHwgXCJsdW1pbm9zaXR5XCIpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBsZXQgdGFibGVBLCBrZXk7XG4gICAgaWYgKG1hcCkge1xuICAgICAgW3RhYmxlQV0gPSB0aGlzLiNjcmVhdGVUYWJsZXMoW21hcF0pO1xuICAgICAga2V5ID0gYGx1bWlub3NpdHlfJHt0YWJsZUF9YDtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5ID0gXCJsdW1pbm9zaXR5XCI7XG4gICAgfVxuICAgIHZhbHVlID0gdGhpcy4jY2FjaGUuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLiNjYWNoZS5zZXQobWFwLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IGlkID0gYGdfJHt0aGlzLiNkb2NJZH1fbHVtaW5vc2l0eV9tYXBfJHt0aGlzLiNpZCsrfWA7XG4gICAgY29uc3QgdXJsID0gdGhpcy4jY3JlYXRlVXJsKGlkKTtcbiAgICB0aGlzLiNjYWNoZS5zZXQobWFwLCB1cmwpO1xuICAgIHRoaXMuI2NhY2hlLnNldChrZXksIHVybCk7XG4gICAgY29uc3QgZmlsdGVyID0gdGhpcy4jY3JlYXRlRmlsdGVyKGlkKTtcbiAgICB0aGlzLiNhZGRMdW1pbm9zaXR5Q29udmVyc2lvbihmaWx0ZXIpO1xuICAgIGlmIChtYXApIHtcbiAgICAgIHRoaXMuI2FkZFRyYW5zZmVyTWFwQWxwaGFDb252ZXJzaW9uKHRhYmxlQSwgZmlsdGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBhZGRIaWdobGlnaHRIQ01GaWx0ZXIoZmlsdGVyTmFtZSwgZmdDb2xvciwgYmdDb2xvciwgbmV3RmdDb2xvciwgbmV3QmdDb2xvcikge1xuICAgIGNvbnN0IGtleSA9IGAke2ZnQ29sb3J9LSR7YmdDb2xvcn0tJHtuZXdGZ0NvbG9yfS0ke25ld0JnQ29sb3J9YDtcbiAgICBsZXQgaW5mbyA9IHRoaXMuI2hjbUNhY2hlLmdldChmaWx0ZXJOYW1lKTtcbiAgICBpZiAoaW5mbz8ua2V5ID09PSBrZXkpIHtcbiAgICAgIHJldHVybiBpbmZvLnVybDtcbiAgICB9XG4gICAgaWYgKGluZm8pIHtcbiAgICAgIGluZm8uZmlsdGVyPy5yZW1vdmUoKTtcbiAgICAgIGluZm8ua2V5ID0ga2V5O1xuICAgICAgaW5mby51cmwgPSBcIm5vbmVcIjtcbiAgICAgIGluZm8uZmlsdGVyID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5mbyA9IHtcbiAgICAgICAga2V5LFxuICAgICAgICB1cmw6IFwibm9uZVwiLFxuICAgICAgICBmaWx0ZXI6IG51bGxcbiAgICAgIH07XG4gICAgICB0aGlzLiNoY21DYWNoZS5zZXQoZmlsdGVyTmFtZSwgaW5mbyk7XG4gICAgfVxuICAgIGlmICghZmdDb2xvciB8fCAhYmdDb2xvcikge1xuICAgICAgcmV0dXJuIGluZm8udXJsO1xuICAgIH1cbiAgICBjb25zdCBbZmdSR0IsIGJnUkdCXSA9IFtmZ0NvbG9yLCBiZ0NvbG9yXS5tYXAodGhpcy4jZ2V0UkdCLmJpbmQodGhpcykpO1xuICAgIGxldCBmZ0dyYXkgPSBNYXRoLnJvdW5kKDAuMjEyNiAqIGZnUkdCWzBdICsgMC43MTUyICogZmdSR0JbMV0gKyAwLjA3MjIgKiBmZ1JHQlsyXSk7XG4gICAgbGV0IGJnR3JheSA9IE1hdGgucm91bmQoMC4yMTI2ICogYmdSR0JbMF0gKyAwLjcxNTIgKiBiZ1JHQlsxXSArIDAuMDcyMiAqIGJnUkdCWzJdKTtcbiAgICBsZXQgW25ld0ZnUkdCLCBuZXdCZ1JHQl0gPSBbbmV3RmdDb2xvciwgbmV3QmdDb2xvcl0ubWFwKHRoaXMuI2dldFJHQi5iaW5kKHRoaXMpKTtcbiAgICBpZiAoYmdHcmF5IDwgZmdHcmF5KSB7XG4gICAgICBbZmdHcmF5LCBiZ0dyYXksIG5ld0ZnUkdCLCBuZXdCZ1JHQl0gPSBbYmdHcmF5LCBmZ0dyYXksIG5ld0JnUkdCLCBuZXdGZ1JHQl07XG4gICAgfVxuICAgIHRoaXMuI2RlZnMuc3R5bGUuY29sb3IgPSBcIlwiO1xuICAgIGNvbnN0IGdldFN0ZXBzID0gKGZnLCBiZywgbikgPT4ge1xuICAgICAgY29uc3QgYXJyID0gbmV3IEFycmF5KDI1Nik7XG4gICAgICBjb25zdCBzdGVwID0gKGJnR3JheSAtIGZnR3JheSkgLyBuO1xuICAgICAgY29uc3QgbmV3U3RhcnQgPSBmZyAvIDI1NTtcbiAgICAgIGNvbnN0IG5ld1N0ZXAgPSAoYmcgLSBmZykgLyAoMjU1ICogbik7XG4gICAgICBsZXQgcHJldiA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBuOyBpKyspIHtcbiAgICAgICAgY29uc3QgayA9IE1hdGgucm91bmQoZmdHcmF5ICsgaSAqIHN0ZXApO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG5ld1N0YXJ0ICsgaSAqIG5ld1N0ZXA7XG4gICAgICAgIGZvciAobGV0IGogPSBwcmV2OyBqIDw9IGs7IGorKykge1xuICAgICAgICAgIGFycltqXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHByZXYgPSBrICsgMTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSBwcmV2OyBpIDwgMjU2OyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYXJyW3ByZXYgLSAxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnIuam9pbihcIixcIik7XG4gICAgfTtcbiAgICBjb25zdCBpZCA9IGBnXyR7dGhpcy4jZG9jSWR9X2hjbV8ke2ZpbHRlck5hbWV9X2ZpbHRlcmA7XG4gICAgY29uc3QgZmlsdGVyID0gaW5mby5maWx0ZXIgPSB0aGlzLiNjcmVhdGVGaWx0ZXIoaWQpO1xuICAgIHRoaXMuI2FkZEdyYXlDb252ZXJzaW9uKGZpbHRlcik7XG4gICAgdGhpcy4jYWRkVHJhbnNmZXJNYXBDb252ZXJzaW9uKGdldFN0ZXBzKG5ld0ZnUkdCWzBdLCBuZXdCZ1JHQlswXSwgNSksIGdldFN0ZXBzKG5ld0ZnUkdCWzFdLCBuZXdCZ1JHQlsxXSwgNSksIGdldFN0ZXBzKG5ld0ZnUkdCWzJdLCBuZXdCZ1JHQlsyXSwgNSksIGZpbHRlcik7XG4gICAgaW5mby51cmwgPSB0aGlzLiNjcmVhdGVVcmwoaWQpO1xuICAgIHJldHVybiBpbmZvLnVybDtcbiAgfVxuICBkZXN0cm95KGtlZXBIQ00gPSBmYWxzZSkge1xuICAgIGlmIChrZWVwSENNICYmIHRoaXMuI19oY21DYWNoZT8uc2l6ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNfZGVmcz8ucGFyZW50Tm9kZS5wYXJlbnROb2RlLnJlbW92ZSgpO1xuICAgIHRoaXMuI19kZWZzID0gbnVsbDtcbiAgICB0aGlzLiNfY2FjaGU/LmNsZWFyKCk7XG4gICAgdGhpcy4jX2NhY2hlID0gbnVsbDtcbiAgICB0aGlzLiNfaGNtQ2FjaGU/LmNsZWFyKCk7XG4gICAgdGhpcy4jX2hjbUNhY2hlID0gbnVsbDtcbiAgICB0aGlzLiNpZCA9IDA7XG4gIH1cbiAgI2FkZEx1bWlub3NpdHlDb252ZXJzaW9uKGZpbHRlcikge1xuICAgIGNvbnN0IGZlQ29sb3JNYXRyaXggPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcImZlQ29sb3JNYXRyaXhcIik7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwibWF0cml4XCIpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKFwidmFsdWVzXCIsIFwiMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMC4zIDAuNTkgMC4xMSAwIDBcIik7XG4gICAgZmlsdGVyLmFwcGVuZChmZUNvbG9yTWF0cml4KTtcbiAgfVxuICAjYWRkR3JheUNvbnZlcnNpb24oZmlsdGVyKSB7XG4gICAgY29uc3QgZmVDb2xvck1hdHJpeCA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIFwiZmVDb2xvck1hdHJpeFwiKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJtYXRyaXhcIik7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZXNcIiwgXCIwLjIxMjYgMC43MTUyIDAuMDcyMiAwIDAgMC4yMTI2IDAuNzE1MiAwLjA3MjIgMCAwIDAuMjEyNiAwLjcxNTIgMC4wNzIyIDAgMCAwIDAgMCAxIDBcIik7XG4gICAgZmlsdGVyLmFwcGVuZChmZUNvbG9yTWF0cml4KTtcbiAgfVxuICAjY3JlYXRlRmlsdGVyKGlkKSB7XG4gICAgY29uc3QgZmlsdGVyID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJmaWx0ZXJcIik7XG4gICAgZmlsdGVyLnNldEF0dHJpYnV0ZShcImNvbG9yLWludGVycG9sYXRpb24tZmlsdGVyc1wiLCBcInNSR0JcIik7XG4gICAgZmlsdGVyLnNldEF0dHJpYnV0ZShcImlkXCIsIGlkKTtcbiAgICB0aGlzLiNkZWZzLmFwcGVuZChmaWx0ZXIpO1xuICAgIHJldHVybiBmaWx0ZXI7XG4gIH1cbiAgI2FwcGVuZEZlRnVuYyhmZUNvbXBvbmVudFRyYW5zZmVyLCBmdW5jLCB0YWJsZSkge1xuICAgIGNvbnN0IGZlRnVuYyA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIGZ1bmMpO1xuICAgIGZlRnVuYy5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwiZGlzY3JldGVcIik7XG4gICAgZmVGdW5jLnNldEF0dHJpYnV0ZShcInRhYmxlVmFsdWVzXCIsIHRhYmxlKTtcbiAgICBmZUNvbXBvbmVudFRyYW5zZmVyLmFwcGVuZChmZUZ1bmMpO1xuICB9XG4gICNhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24oclRhYmxlLCBnVGFibGUsIGJUYWJsZSwgZmlsdGVyKSB7XG4gICAgY29uc3QgZmVDb21wb25lbnRUcmFuc2ZlciA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIFwiZmVDb21wb25lbnRUcmFuc2ZlclwiKTtcbiAgICBmaWx0ZXIuYXBwZW5kKGZlQ29tcG9uZW50VHJhbnNmZXIpO1xuICAgIHRoaXMuI2FwcGVuZEZlRnVuYyhmZUNvbXBvbmVudFRyYW5zZmVyLCBcImZlRnVuY1JcIiwgclRhYmxlKTtcbiAgICB0aGlzLiNhcHBlbmRGZUZ1bmMoZmVDb21wb25lbnRUcmFuc2ZlciwgXCJmZUZ1bmNHXCIsIGdUYWJsZSk7XG4gICAgdGhpcy4jYXBwZW5kRmVGdW5jKGZlQ29tcG9uZW50VHJhbnNmZXIsIFwiZmVGdW5jQlwiLCBiVGFibGUpO1xuICB9XG4gICNhZGRUcmFuc2Zlck1hcEFscGhhQ29udmVyc2lvbihhVGFibGUsIGZpbHRlcikge1xuICAgIGNvbnN0IGZlQ29tcG9uZW50VHJhbnNmZXIgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcImZlQ29tcG9uZW50VHJhbnNmZXJcIik7XG4gICAgZmlsdGVyLmFwcGVuZChmZUNvbXBvbmVudFRyYW5zZmVyKTtcbiAgICB0aGlzLiNhcHBlbmRGZUZ1bmMoZmVDb21wb25lbnRUcmFuc2ZlciwgXCJmZUZ1bmNBXCIsIGFUYWJsZSk7XG4gIH1cbiAgI2dldFJHQihjb2xvcikge1xuICAgIHRoaXMuI2RlZnMuc3R5bGUuY29sb3IgPSBjb2xvcjtcbiAgICByZXR1cm4gZ2V0UkdCKGdldENvbXB1dGVkU3R5bGUodGhpcy4jZGVmcykuZ2V0UHJvcGVydHlWYWx1ZShcImNvbG9yXCIpKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9zdGFuZGFyZF9mb250ZGF0YV9mYWN0b3J5LmpzXG5cblxuY2xhc3MgQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGJhc2VVcmwgPSBudWxsXG4gIH0pIHtcbiAgICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xuICB9XG4gIGFzeW5jIGZldGNoKHtcbiAgICBmaWxlbmFtZVxuICB9KSB7XG4gICAgaWYgKCF0aGlzLmJhc2VVcmwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuc3VyZSB0aGF0IHRoZSBgc3RhbmRhcmRGb250RGF0YVVybGAgQVBJIHBhcmFtZXRlciBpcyBwcm92aWRlZC5cIik7XG4gICAgfVxuICAgIGlmICghZmlsZW5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZvbnQgZmlsZW5hbWUgbXVzdCBiZSBzcGVjaWZpZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmJhc2VVcmx9JHtmaWxlbmFtZX1gO1xuICAgIHJldHVybiB0aGlzLl9mZXRjaCh1cmwpLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBsb2FkIGZvbnQgZGF0YSBhdDogJHt1cmx9YCk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgX2ZldGNoKHVybCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIGBfZmV0Y2hgIGNhbGxlZC5cIik7XG4gIH1cbn1cbmNsYXNzIERPTVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IGV4dGVuZHMgQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IHtcbiAgYXN5bmMgX2ZldGNoKHVybCkge1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBmZXRjaERhdGEodXJsLCBcImFycmF5YnVmZmVyXCIpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9ub2RlX3V0aWxzLmpzXG5cblxuXG5cblxuYXN5bmMgZnVuY3Rpb24gbm9kZV91dGlsc19mZXRjaERhdGEodXJsKSB7XG4gIGNvbnN0IGZzID0gcHJvY2Vzcy5nZXRCdWlsdGluTW9kdWxlKFwiZnNcIik7XG4gIGNvbnN0IGRhdGEgPSBhd2FpdCBmcy5wcm9taXNlcy5yZWFkRmlsZSh1cmwpO1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG59XG5jbGFzcyBOb2RlRmlsdGVyRmFjdG9yeSBleHRlbmRzIEJhc2VGaWx0ZXJGYWN0b3J5IHt9XG5jbGFzcyBOb2RlQ2FudmFzRmFjdG9yeSBleHRlbmRzIEJhc2VDYW52YXNGYWN0b3J5IHtcbiAgX2NyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgcmVxdWlyZSA9IHByb2Nlc3MuZ2V0QnVpbHRpbk1vZHVsZShcIm1vZHVsZVwiKS5jcmVhdGVSZXF1aXJlKGltcG9ydC5tZXRhLnVybCk7XG4gICAgY29uc3QgY2FudmFzID0gcmVxdWlyZShcIkBuYXBpLXJzL2NhbnZhc1wiKTtcbiAgICByZXR1cm4gY2FudmFzLmNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgfVxufVxuY2xhc3MgTm9kZUNNYXBSZWFkZXJGYWN0b3J5IGV4dGVuZHMgQmFzZUNNYXBSZWFkZXJGYWN0b3J5IHtcbiAgYXN5bmMgX2ZldGNoKHVybCkge1xuICAgIHJldHVybiBub2RlX3V0aWxzX2ZldGNoRGF0YSh1cmwpO1xuICB9XG59XG5jbGFzcyBOb2RlU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgZXh0ZW5kcyBCYXNlU3RhbmRhcmRGb250RGF0YUZhY3Rvcnkge1xuICBhc3luYyBfZmV0Y2godXJsKSB7XG4gICAgcmV0dXJuIG5vZGVfdXRpbHNfZmV0Y2hEYXRhKHVybCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvcGF0dGVybl9oZWxwZXIuanNcblxuXG5jb25zdCBQYXRoVHlwZSA9IHtcbiAgRklMTDogXCJGaWxsXCIsXG4gIFNUUk9LRTogXCJTdHJva2VcIixcbiAgU0hBRElORzogXCJTaGFkaW5nXCJcbn07XG5mdW5jdGlvbiBhcHBseUJvdW5kaW5nQm94KGN0eCwgYmJveCkge1xuICBpZiAoIWJib3gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgd2lkdGggPSBiYm94WzJdIC0gYmJveFswXTtcbiAgY29uc3QgaGVpZ2h0ID0gYmJveFszXSAtIGJib3hbMV07XG4gIGNvbnN0IHJlZ2lvbiA9IG5ldyBQYXRoMkQoKTtcbiAgcmVnaW9uLnJlY3QoYmJveFswXSwgYmJveFsxXSwgd2lkdGgsIGhlaWdodCk7XG4gIGN0eC5jbGlwKHJlZ2lvbik7XG59XG5jbGFzcyBCYXNlU2hhZGluZ1BhdHRlcm4ge1xuICBnZXRQYXR0ZXJuKCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIGBnZXRQYXR0ZXJuYCBjYWxsZWQuXCIpO1xuICB9XG59XG5jbGFzcyBSYWRpYWxBeGlhbFNoYWRpbmdQYXR0ZXJuIGV4dGVuZHMgQmFzZVNoYWRpbmdQYXR0ZXJuIHtcbiAgY29uc3RydWN0b3IoSVIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3R5cGUgPSBJUlsxXTtcbiAgICB0aGlzLl9iYm94ID0gSVJbMl07XG4gICAgdGhpcy5fY29sb3JTdG9wcyA9IElSWzNdO1xuICAgIHRoaXMuX3AwID0gSVJbNF07XG4gICAgdGhpcy5fcDEgPSBJUls1XTtcbiAgICB0aGlzLl9yMCA9IElSWzZdO1xuICAgIHRoaXMuX3IxID0gSVJbN107XG4gICAgdGhpcy5tYXRyaXggPSBudWxsO1xuICB9XG4gIF9jcmVhdGVHcmFkaWVudChjdHgpIHtcbiAgICBsZXQgZ3JhZDtcbiAgICBpZiAodGhpcy5fdHlwZSA9PT0gXCJheGlhbFwiKSB7XG4gICAgICBncmFkID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHRoaXMuX3AwWzBdLCB0aGlzLl9wMFsxXSwgdGhpcy5fcDFbMF0sIHRoaXMuX3AxWzFdKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3R5cGUgPT09IFwicmFkaWFsXCIpIHtcbiAgICAgIGdyYWQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQodGhpcy5fcDBbMF0sIHRoaXMuX3AwWzFdLCB0aGlzLl9yMCwgdGhpcy5fcDFbMF0sIHRoaXMuX3AxWzFdLCB0aGlzLl9yMSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgY29sb3JTdG9wIG9mIHRoaXMuX2NvbG9yU3RvcHMpIHtcbiAgICAgIGdyYWQuYWRkQ29sb3JTdG9wKGNvbG9yU3RvcFswXSwgY29sb3JTdG9wWzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIGdyYWQ7XG4gIH1cbiAgZ2V0UGF0dGVybihjdHgsIG93bmVyLCBpbnZlcnNlLCBwYXRoVHlwZSkge1xuICAgIGxldCBwYXR0ZXJuO1xuICAgIGlmIChwYXRoVHlwZSA9PT0gUGF0aFR5cGUuU1RST0tFIHx8IHBhdGhUeXBlID09PSBQYXRoVHlwZS5GSUxMKSB7XG4gICAgICBjb25zdCBvd25lckJCb3ggPSBvd25lci5jdXJyZW50LmdldENsaXBwZWRQYXRoQm91bmRpbmdCb3gocGF0aFR5cGUsIGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KSkgfHwgWzAsIDAsIDAsIDBdO1xuICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLmNlaWwob3duZXJCQm94WzJdIC0gb3duZXJCQm94WzBdKSB8fCAxO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5jZWlsKG93bmVyQkJveFszXSAtIG93bmVyQkJveFsxXSkgfHwgMTtcbiAgICAgIGNvbnN0IHRtcENhbnZhcyA9IG93bmVyLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcInBhdHRlcm5cIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjb25zdCB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICAgIHRtcEN0eC5jbGVhclJlY3QoMCwgMCwgdG1wQ3R4LmNhbnZhcy53aWR0aCwgdG1wQ3R4LmNhbnZhcy5oZWlnaHQpO1xuICAgICAgdG1wQ3R4LmJlZ2luUGF0aCgpO1xuICAgICAgdG1wQ3R4LnJlY3QoMCwgMCwgdG1wQ3R4LmNhbnZhcy53aWR0aCwgdG1wQ3R4LmNhbnZhcy5oZWlnaHQpO1xuICAgICAgdG1wQ3R4LnRyYW5zbGF0ZSgtb3duZXJCQm94WzBdLCAtb3duZXJCQm94WzFdKTtcbiAgICAgIGludmVyc2UgPSBVdGlsLnRyYW5zZm9ybShpbnZlcnNlLCBbMSwgMCwgMCwgMSwgb3duZXJCQm94WzBdLCBvd25lckJCb3hbMV1dKTtcbiAgICAgIHRtcEN0eC50cmFuc2Zvcm0oLi4ub3duZXIuYmFzZVRyYW5zZm9ybSk7XG4gICAgICBpZiAodGhpcy5tYXRyaXgpIHtcbiAgICAgICAgdG1wQ3R4LnRyYW5zZm9ybSguLi50aGlzLm1hdHJpeCk7XG4gICAgICB9XG4gICAgICBhcHBseUJvdW5kaW5nQm94KHRtcEN0eCwgdGhpcy5fYmJveCk7XG4gICAgICB0bXBDdHguZmlsbFN0eWxlID0gdGhpcy5fY3JlYXRlR3JhZGllbnQodG1wQ3R4KTtcbiAgICAgIHRtcEN0eC5maWxsKCk7XG4gICAgICBwYXR0ZXJuID0gY3R4LmNyZWF0ZVBhdHRlcm4odG1wQ2FudmFzLmNhbnZhcywgXCJuby1yZXBlYXRcIik7XG4gICAgICBjb25zdCBkb21NYXRyaXggPSBuZXcgRE9NTWF0cml4KGludmVyc2UpO1xuICAgICAgcGF0dGVybi5zZXRUcmFuc2Zvcm0oZG9tTWF0cml4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBwbHlCb3VuZGluZ0JveChjdHgsIHRoaXMuX2Jib3gpO1xuICAgICAgcGF0dGVybiA9IHRoaXMuX2NyZWF0ZUdyYWRpZW50KGN0eCk7XG4gICAgfVxuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9XG59XG5mdW5jdGlvbiBkcmF3VHJpYW5nbGUoZGF0YSwgY29udGV4dCwgcDEsIHAyLCBwMywgYzEsIGMyLCBjMykge1xuICBjb25zdCBjb29yZHMgPSBjb250ZXh0LmNvb3JkcyxcbiAgICBjb2xvcnMgPSBjb250ZXh0LmNvbG9ycztcbiAgY29uc3QgYnl0ZXMgPSBkYXRhLmRhdGEsXG4gICAgcm93U2l6ZSA9IGRhdGEud2lkdGggKiA0O1xuICBsZXQgdG1wO1xuICBpZiAoY29vcmRzW3AxICsgMV0gPiBjb29yZHNbcDIgKyAxXSkge1xuICAgIHRtcCA9IHAxO1xuICAgIHAxID0gcDI7XG4gICAgcDIgPSB0bXA7XG4gICAgdG1wID0gYzE7XG4gICAgYzEgPSBjMjtcbiAgICBjMiA9IHRtcDtcbiAgfVxuICBpZiAoY29vcmRzW3AyICsgMV0gPiBjb29yZHNbcDMgKyAxXSkge1xuICAgIHRtcCA9IHAyO1xuICAgIHAyID0gcDM7XG4gICAgcDMgPSB0bXA7XG4gICAgdG1wID0gYzI7XG4gICAgYzIgPSBjMztcbiAgICBjMyA9IHRtcDtcbiAgfVxuICBpZiAoY29vcmRzW3AxICsgMV0gPiBjb29yZHNbcDIgKyAxXSkge1xuICAgIHRtcCA9IHAxO1xuICAgIHAxID0gcDI7XG4gICAgcDIgPSB0bXA7XG4gICAgdG1wID0gYzE7XG4gICAgYzEgPSBjMjtcbiAgICBjMiA9IHRtcDtcbiAgfVxuICBjb25zdCB4MSA9IChjb29yZHNbcDFdICsgY29udGV4dC5vZmZzZXRYKSAqIGNvbnRleHQuc2NhbGVYO1xuICBjb25zdCB5MSA9IChjb29yZHNbcDEgKyAxXSArIGNvbnRleHQub2Zmc2V0WSkgKiBjb250ZXh0LnNjYWxlWTtcbiAgY29uc3QgeDIgPSAoY29vcmRzW3AyXSArIGNvbnRleHQub2Zmc2V0WCkgKiBjb250ZXh0LnNjYWxlWDtcbiAgY29uc3QgeTIgPSAoY29vcmRzW3AyICsgMV0gKyBjb250ZXh0Lm9mZnNldFkpICogY29udGV4dC5zY2FsZVk7XG4gIGNvbnN0IHgzID0gKGNvb3Jkc1twM10gKyBjb250ZXh0Lm9mZnNldFgpICogY29udGV4dC5zY2FsZVg7XG4gIGNvbnN0IHkzID0gKGNvb3Jkc1twMyArIDFdICsgY29udGV4dC5vZmZzZXRZKSAqIGNvbnRleHQuc2NhbGVZO1xuICBpZiAoeTEgPj0geTMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgYzFyID0gY29sb3JzW2MxXSxcbiAgICBjMWcgPSBjb2xvcnNbYzEgKyAxXSxcbiAgICBjMWIgPSBjb2xvcnNbYzEgKyAyXTtcbiAgY29uc3QgYzJyID0gY29sb3JzW2MyXSxcbiAgICBjMmcgPSBjb2xvcnNbYzIgKyAxXSxcbiAgICBjMmIgPSBjb2xvcnNbYzIgKyAyXTtcbiAgY29uc3QgYzNyID0gY29sb3JzW2MzXSxcbiAgICBjM2cgPSBjb2xvcnNbYzMgKyAxXSxcbiAgICBjM2IgPSBjb2xvcnNbYzMgKyAyXTtcbiAgY29uc3QgbWluWSA9IE1hdGgucm91bmQoeTEpLFxuICAgIG1heFkgPSBNYXRoLnJvdW5kKHkzKTtcbiAgbGV0IHhhLCBjYXIsIGNhZywgY2FiO1xuICBsZXQgeGIsIGNiciwgY2JnLCBjYmI7XG4gIGZvciAobGV0IHkgPSBtaW5ZOyB5IDw9IG1heFk7IHkrKykge1xuICAgIGlmICh5IDwgeTIpIHtcbiAgICAgIGNvbnN0IGsgPSB5IDwgeTEgPyAwIDogKHkxIC0geSkgLyAoeTEgLSB5Mik7XG4gICAgICB4YSA9IHgxIC0gKHgxIC0geDIpICogaztcbiAgICAgIGNhciA9IGMxciAtIChjMXIgLSBjMnIpICogaztcbiAgICAgIGNhZyA9IGMxZyAtIChjMWcgLSBjMmcpICogaztcbiAgICAgIGNhYiA9IGMxYiAtIChjMWIgLSBjMmIpICogaztcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGs7XG4gICAgICBpZiAoeSA+IHkzKSB7XG4gICAgICAgIGsgPSAxO1xuICAgICAgfSBlbHNlIGlmICh5MiA9PT0geTMpIHtcbiAgICAgICAgayA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrID0gKHkyIC0geSkgLyAoeTIgLSB5Myk7XG4gICAgICB9XG4gICAgICB4YSA9IHgyIC0gKHgyIC0geDMpICogaztcbiAgICAgIGNhciA9IGMyciAtIChjMnIgLSBjM3IpICogaztcbiAgICAgIGNhZyA9IGMyZyAtIChjMmcgLSBjM2cpICogaztcbiAgICAgIGNhYiA9IGMyYiAtIChjMmIgLSBjM2IpICogaztcbiAgICB9XG4gICAgbGV0IGs7XG4gICAgaWYgKHkgPCB5MSkge1xuICAgICAgayA9IDA7XG4gICAgfSBlbHNlIGlmICh5ID4geTMpIHtcbiAgICAgIGsgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBrID0gKHkxIC0geSkgLyAoeTEgLSB5Myk7XG4gICAgfVxuICAgIHhiID0geDEgLSAoeDEgLSB4MykgKiBrO1xuICAgIGNiciA9IGMxciAtIChjMXIgLSBjM3IpICogaztcbiAgICBjYmcgPSBjMWcgLSAoYzFnIC0gYzNnKSAqIGs7XG4gICAgY2JiID0gYzFiIC0gKGMxYiAtIGMzYikgKiBrO1xuICAgIGNvbnN0IHgxXyA9IE1hdGgucm91bmQoTWF0aC5taW4oeGEsIHhiKSk7XG4gICAgY29uc3QgeDJfID0gTWF0aC5yb3VuZChNYXRoLm1heCh4YSwgeGIpKTtcbiAgICBsZXQgaiA9IHJvd1NpemUgKiB5ICsgeDFfICogNDtcbiAgICBmb3IgKGxldCB4ID0geDFfOyB4IDw9IHgyXzsgeCsrKSB7XG4gICAgICBrID0gKHhhIC0geCkgLyAoeGEgLSB4Yik7XG4gICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgayA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGsgPiAxKSB7XG4gICAgICAgIGsgPSAxO1xuICAgICAgfVxuICAgICAgYnl0ZXNbaisrXSA9IGNhciAtIChjYXIgLSBjYnIpICogayB8IDA7XG4gICAgICBieXRlc1tqKytdID0gY2FnIC0gKGNhZyAtIGNiZykgKiBrIHwgMDtcbiAgICAgIGJ5dGVzW2orK10gPSBjYWIgLSAoY2FiIC0gY2JiKSAqIGsgfCAwO1xuICAgICAgYnl0ZXNbaisrXSA9IDI1NTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRyYXdGaWd1cmUoZGF0YSwgZmlndXJlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHBzID0gZmlndXJlLmNvb3JkcztcbiAgY29uc3QgY3MgPSBmaWd1cmUuY29sb3JzO1xuICBsZXQgaSwgaWk7XG4gIHN3aXRjaCAoZmlndXJlLnR5cGUpIHtcbiAgICBjYXNlIFwibGF0dGljZVwiOlxuICAgICAgY29uc3QgdmVydGljZXNQZXJSb3cgPSBmaWd1cmUudmVydGljZXNQZXJSb3c7XG4gICAgICBjb25zdCByb3dzID0gTWF0aC5mbG9vcihwcy5sZW5ndGggLyB2ZXJ0aWNlc1BlclJvdykgLSAxO1xuICAgICAgY29uc3QgY29scyA9IHZlcnRpY2VzUGVyUm93IC0gMTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgbGV0IHEgPSBpICogdmVydGljZXNQZXJSb3c7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sczsgaisrLCBxKyspIHtcbiAgICAgICAgICBkcmF3VHJpYW5nbGUoZGF0YSwgY29udGV4dCwgcHNbcV0sIHBzW3EgKyAxXSwgcHNbcSArIHZlcnRpY2VzUGVyUm93XSwgY3NbcV0sIGNzW3EgKyAxXSwgY3NbcSArIHZlcnRpY2VzUGVyUm93XSk7XG4gICAgICAgICAgZHJhd1RyaWFuZ2xlKGRhdGEsIGNvbnRleHQsIHBzW3EgKyB2ZXJ0aWNlc1BlclJvdyArIDFdLCBwc1txICsgMV0sIHBzW3EgKyB2ZXJ0aWNlc1BlclJvd10sIGNzW3EgKyB2ZXJ0aWNlc1BlclJvdyArIDFdLCBjc1txICsgMV0sIGNzW3EgKyB2ZXJ0aWNlc1BlclJvd10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwidHJpYW5nbGVzXCI6XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IHBzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDMpIHtcbiAgICAgICAgZHJhd1RyaWFuZ2xlKGRhdGEsIGNvbnRleHQsIHBzW2ldLCBwc1tpICsgMV0sIHBzW2kgKyAyXSwgY3NbaV0sIGNzW2kgKyAxXSwgY3NbaSArIDJdKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGZpZ3VyZVwiKTtcbiAgfVxufVxuY2xhc3MgTWVzaFNoYWRpbmdQYXR0ZXJuIGV4dGVuZHMgQmFzZVNoYWRpbmdQYXR0ZXJuIHtcbiAgY29uc3RydWN0b3IoSVIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2Nvb3JkcyA9IElSWzJdO1xuICAgIHRoaXMuX2NvbG9ycyA9IElSWzNdO1xuICAgIHRoaXMuX2ZpZ3VyZXMgPSBJUls0XTtcbiAgICB0aGlzLl9ib3VuZHMgPSBJUls1XTtcbiAgICB0aGlzLl9iYm94ID0gSVJbN107XG4gICAgdGhpcy5fYmFja2dyb3VuZCA9IElSWzhdO1xuICAgIHRoaXMubWF0cml4ID0gbnVsbDtcbiAgfVxuICBfY3JlYXRlTWVzaENhbnZhcyhjb21iaW5lZFNjYWxlLCBiYWNrZ3JvdW5kQ29sb3IsIGNhY2hlZENhbnZhc2VzKSB7XG4gICAgY29uc3QgRVhQRUNURURfU0NBTEUgPSAxLjE7XG4gICAgY29uc3QgTUFYX1BBVFRFUk5fU0laRSA9IDMwMDA7XG4gICAgY29uc3QgQk9SREVSX1NJWkUgPSAyO1xuICAgIGNvbnN0IG9mZnNldFggPSBNYXRoLmZsb29yKHRoaXMuX2JvdW5kc1swXSk7XG4gICAgY29uc3Qgb2Zmc2V0WSA9IE1hdGguZmxvb3IodGhpcy5fYm91bmRzWzFdKTtcbiAgICBjb25zdCBib3VuZHNXaWR0aCA9IE1hdGguY2VpbCh0aGlzLl9ib3VuZHNbMl0pIC0gb2Zmc2V0WDtcbiAgICBjb25zdCBib3VuZHNIZWlnaHQgPSBNYXRoLmNlaWwodGhpcy5fYm91bmRzWzNdKSAtIG9mZnNldFk7XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLm1pbihNYXRoLmNlaWwoTWF0aC5hYnMoYm91bmRzV2lkdGggKiBjb21iaW5lZFNjYWxlWzBdICogRVhQRUNURURfU0NBTEUpKSwgTUFYX1BBVFRFUk5fU0laRSk7XG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5taW4oTWF0aC5jZWlsKE1hdGguYWJzKGJvdW5kc0hlaWdodCAqIGNvbWJpbmVkU2NhbGVbMV0gKiBFWFBFQ1RFRF9TQ0FMRSkpLCBNQVhfUEFUVEVSTl9TSVpFKTtcbiAgICBjb25zdCBzY2FsZVggPSBib3VuZHNXaWR0aCAvIHdpZHRoO1xuICAgIGNvbnN0IHNjYWxlWSA9IGJvdW5kc0hlaWdodCAvIGhlaWdodDtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgY29vcmRzOiB0aGlzLl9jb29yZHMsXG4gICAgICBjb2xvcnM6IHRoaXMuX2NvbG9ycyxcbiAgICAgIG9mZnNldFg6IC1vZmZzZXRYLFxuICAgICAgb2Zmc2V0WTogLW9mZnNldFksXG4gICAgICBzY2FsZVg6IDEgLyBzY2FsZVgsXG4gICAgICBzY2FsZVk6IDEgLyBzY2FsZVlcbiAgICB9O1xuICAgIGNvbnN0IHBhZGRlZFdpZHRoID0gd2lkdGggKyBCT1JERVJfU0laRSAqIDI7XG4gICAgY29uc3QgcGFkZGVkSGVpZ2h0ID0gaGVpZ2h0ICsgQk9SREVSX1NJWkUgKiAyO1xuICAgIGNvbnN0IHRtcENhbnZhcyA9IGNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcIm1lc2hcIiwgcGFkZGVkV2lkdGgsIHBhZGRlZEhlaWdodCk7XG4gICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgY29uc3QgZGF0YSA9IHRtcEN0eC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIGhlaWdodCk7XG4gICAgaWYgKGJhY2tncm91bmRDb2xvcikge1xuICAgICAgY29uc3QgYnl0ZXMgPSBkYXRhLmRhdGE7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBieXRlcy5sZW5ndGg7IGkgPCBpaTsgaSArPSA0KSB7XG4gICAgICAgIGJ5dGVzW2ldID0gYmFja2dyb3VuZENvbG9yWzBdO1xuICAgICAgICBieXRlc1tpICsgMV0gPSBiYWNrZ3JvdW5kQ29sb3JbMV07XG4gICAgICAgIGJ5dGVzW2kgKyAyXSA9IGJhY2tncm91bmRDb2xvclsyXTtcbiAgICAgICAgYnl0ZXNbaSArIDNdID0gMjU1O1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGZpZ3VyZSBvZiB0aGlzLl9maWd1cmVzKSB7XG4gICAgICBkcmF3RmlndXJlKGRhdGEsIGZpZ3VyZSwgY29udGV4dCk7XG4gICAgfVxuICAgIHRtcEN0eC5wdXRJbWFnZURhdGEoZGF0YSwgQk9SREVSX1NJWkUsIEJPUkRFUl9TSVpFKTtcbiAgICBjb25zdCBjYW52YXMgPSB0bXBDYW52YXMuY2FudmFzO1xuICAgIHJldHVybiB7XG4gICAgICBjYW52YXMsXG4gICAgICBvZmZzZXRYOiBvZmZzZXRYIC0gQk9SREVSX1NJWkUgKiBzY2FsZVgsXG4gICAgICBvZmZzZXRZOiBvZmZzZXRZIC0gQk9SREVSX1NJWkUgKiBzY2FsZVksXG4gICAgICBzY2FsZVgsXG4gICAgICBzY2FsZVlcbiAgICB9O1xuICB9XG4gIGdldFBhdHRlcm4oY3R4LCBvd25lciwgaW52ZXJzZSwgcGF0aFR5cGUpIHtcbiAgICBhcHBseUJvdW5kaW5nQm94KGN0eCwgdGhpcy5fYmJveCk7XG4gICAgbGV0IHNjYWxlO1xuICAgIGlmIChwYXRoVHlwZSA9PT0gUGF0aFR5cGUuU0hBRElORykge1xuICAgICAgc2NhbGUgPSBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlID0gVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZShvd25lci5iYXNlVHJhbnNmb3JtKTtcbiAgICAgIGlmICh0aGlzLm1hdHJpeCkge1xuICAgICAgICBjb25zdCBtYXRyaXhTY2FsZSA9IFV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodGhpcy5tYXRyaXgpO1xuICAgICAgICBzY2FsZSA9IFtzY2FsZVswXSAqIG1hdHJpeFNjYWxlWzBdLCBzY2FsZVsxXSAqIG1hdHJpeFNjYWxlWzFdXTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdGVtcG9yYXJ5UGF0dGVybkNhbnZhcyA9IHRoaXMuX2NyZWF0ZU1lc2hDYW52YXMoc2NhbGUsIHBhdGhUeXBlID09PSBQYXRoVHlwZS5TSEFESU5HID8gbnVsbCA6IHRoaXMuX2JhY2tncm91bmQsIG93bmVyLmNhY2hlZENhbnZhc2VzKTtcbiAgICBpZiAocGF0aFR5cGUgIT09IFBhdGhUeXBlLlNIQURJTkcpIHtcbiAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oLi4ub3duZXIuYmFzZVRyYW5zZm9ybSk7XG4gICAgICBpZiAodGhpcy5tYXRyaXgpIHtcbiAgICAgICAgY3R4LnRyYW5zZm9ybSguLi50aGlzLm1hdHJpeCk7XG4gICAgICB9XG4gICAgfVxuICAgIGN0eC50cmFuc2xhdGUodGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5vZmZzZXRYLCB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLm9mZnNldFkpO1xuICAgIGN0eC5zY2FsZSh0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLnNjYWxlWCwgdGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5zY2FsZVkpO1xuICAgIHJldHVybiBjdHguY3JlYXRlUGF0dGVybih0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLmNhbnZhcywgXCJuby1yZXBlYXRcIik7XG4gIH1cbn1cbmNsYXNzIER1bW15U2hhZGluZ1BhdHRlcm4gZXh0ZW5kcyBCYXNlU2hhZGluZ1BhdHRlcm4ge1xuICBnZXRQYXR0ZXJuKCkge1xuICAgIHJldHVybiBcImhvdHBpbmtcIjtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0U2hhZGluZ1BhdHRlcm4oSVIpIHtcbiAgc3dpdGNoIChJUlswXSkge1xuICAgIGNhc2UgXCJSYWRpYWxBeGlhbFwiOlxuICAgICAgcmV0dXJuIG5ldyBSYWRpYWxBeGlhbFNoYWRpbmdQYXR0ZXJuKElSKTtcbiAgICBjYXNlIFwiTWVzaFwiOlxuICAgICAgcmV0dXJuIG5ldyBNZXNoU2hhZGluZ1BhdHRlcm4oSVIpO1xuICAgIGNhc2UgXCJEdW1teVwiOlxuICAgICAgcmV0dXJuIG5ldyBEdW1teVNoYWRpbmdQYXR0ZXJuKCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIElSIHR5cGU6ICR7SVJbMF19YCk7XG59XG5jb25zdCBQYWludFR5cGUgPSB7XG4gIENPTE9SRUQ6IDEsXG4gIFVOQ09MT1JFRDogMlxufTtcbmNsYXNzIFRpbGluZ1BhdHRlcm4ge1xuICBzdGF0aWMgTUFYX1BBVFRFUk5fU0laRSA9IDMwMDA7XG4gIGNvbnN0cnVjdG9yKElSLCBjb2xvciwgY3R4LCBjYW52YXNHcmFwaGljc0ZhY3RvcnksIGJhc2VUcmFuc2Zvcm0pIHtcbiAgICB0aGlzLm9wZXJhdG9yTGlzdCA9IElSWzJdO1xuICAgIHRoaXMubWF0cml4ID0gSVJbM107XG4gICAgdGhpcy5iYm94ID0gSVJbNF07XG4gICAgdGhpcy54c3RlcCA9IElSWzVdO1xuICAgIHRoaXMueXN0ZXAgPSBJUls2XTtcbiAgICB0aGlzLnBhaW50VHlwZSA9IElSWzddO1xuICAgIHRoaXMudGlsaW5nVHlwZSA9IElSWzhdO1xuICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLmNhbnZhc0dyYXBoaWNzRmFjdG9yeSA9IGNhbnZhc0dyYXBoaWNzRmFjdG9yeTtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSBiYXNlVHJhbnNmb3JtO1xuICB9XG4gIGNyZWF0ZVBhdHRlcm5DYW52YXMob3duZXIpIHtcbiAgICBjb25zdCB7XG4gICAgICBiYm94LFxuICAgICAgb3BlcmF0b3JMaXN0LFxuICAgICAgcGFpbnRUeXBlLFxuICAgICAgdGlsaW5nVHlwZSxcbiAgICAgIGNvbG9yLFxuICAgICAgY2FudmFzR3JhcGhpY3NGYWN0b3J5XG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHtcbiAgICAgIHhzdGVwLFxuICAgICAgeXN0ZXBcbiAgICB9ID0gdGhpcztcbiAgICB4c3RlcCA9IE1hdGguYWJzKHhzdGVwKTtcbiAgICB5c3RlcCA9IE1hdGguYWJzKHlzdGVwKTtcbiAgICBpbmZvKFwiVGlsaW5nVHlwZTogXCIgKyB0aWxpbmdUeXBlKTtcbiAgICBjb25zdCB4MCA9IGJib3hbMF0sXG4gICAgICB5MCA9IGJib3hbMV0sXG4gICAgICB4MSA9IGJib3hbMl0sXG4gICAgICB5MSA9IGJib3hbM107XG4gICAgY29uc3Qgd2lkdGggPSB4MSAtIHgwO1xuICAgIGNvbnN0IGhlaWdodCA9IHkxIC0geTA7XG4gICAgY29uc3QgbWF0cml4U2NhbGUgPSBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRoaXMubWF0cml4KTtcbiAgICBjb25zdCBjdXJNYXRyaXhTY2FsZSA9IFV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodGhpcy5iYXNlVHJhbnNmb3JtKTtcbiAgICBjb25zdCBjb21iaW5lZFNjYWxlWCA9IG1hdHJpeFNjYWxlWzBdICogY3VyTWF0cml4U2NhbGVbMF07XG4gICAgY29uc3QgY29tYmluZWRTY2FsZVkgPSBtYXRyaXhTY2FsZVsxXSAqIGN1ck1hdHJpeFNjYWxlWzFdO1xuICAgIGxldCBjYW52YXNXaWR0aCA9IHdpZHRoLFxuICAgICAgY2FudmFzSGVpZ2h0ID0gaGVpZ2h0LFxuICAgICAgcmVkcmF3SG9yaXpvbnRhbGx5ID0gZmFsc2UsXG4gICAgICByZWRyYXdWZXJ0aWNhbGx5ID0gZmFsc2U7XG4gICAgY29uc3QgeFNjYWxlZFN0ZXAgPSBNYXRoLmNlaWwoeHN0ZXAgKiBjb21iaW5lZFNjYWxlWCk7XG4gICAgY29uc3QgeVNjYWxlZFN0ZXAgPSBNYXRoLmNlaWwoeXN0ZXAgKiBjb21iaW5lZFNjYWxlWSk7XG4gICAgY29uc3QgeFNjYWxlZFdpZHRoID0gTWF0aC5jZWlsKHdpZHRoICogY29tYmluZWRTY2FsZVgpO1xuICAgIGNvbnN0IHlTY2FsZWRIZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0ICogY29tYmluZWRTY2FsZVkpO1xuICAgIGlmICh4U2NhbGVkU3RlcCA+PSB4U2NhbGVkV2lkdGgpIHtcbiAgICAgIGNhbnZhc1dpZHRoID0geHN0ZXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZHJhd0hvcml6b250YWxseSA9IHRydWU7XG4gICAgfVxuICAgIGlmICh5U2NhbGVkU3RlcCA+PSB5U2NhbGVkSGVpZ2h0KSB7XG4gICAgICBjYW52YXNIZWlnaHQgPSB5c3RlcDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVkcmF3VmVydGljYWxseSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGRpbXggPSB0aGlzLmdldFNpemVBbmRTY2FsZShjYW52YXNXaWR0aCwgdGhpcy5jdHguY2FudmFzLndpZHRoLCBjb21iaW5lZFNjYWxlWCk7XG4gICAgY29uc3QgZGlteSA9IHRoaXMuZ2V0U2l6ZUFuZFNjYWxlKGNhbnZhc0hlaWdodCwgdGhpcy5jdHguY2FudmFzLmhlaWdodCwgY29tYmluZWRTY2FsZVkpO1xuICAgIGNvbnN0IHRtcENhbnZhcyA9IG93bmVyLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcInBhdHRlcm5cIiwgZGlteC5zaXplLCBkaW15LnNpemUpO1xuICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgIGNvbnN0IGdyYXBoaWNzID0gY2FudmFzR3JhcGhpY3NGYWN0b3J5LmNyZWF0ZUNhbnZhc0dyYXBoaWNzKHRtcEN0eCk7XG4gICAgZ3JhcGhpY3MuZ3JvdXBMZXZlbCA9IG93bmVyLmdyb3VwTGV2ZWw7XG4gICAgdGhpcy5zZXRGaWxsQW5kU3Ryb2tlU3R5bGVUb0NvbnRleHQoZ3JhcGhpY3MsIHBhaW50VHlwZSwgY29sb3IpO1xuICAgIHRtcEN0eC50cmFuc2xhdGUoLWRpbXguc2NhbGUgKiB4MCwgLWRpbXkuc2NhbGUgKiB5MCk7XG4gICAgZ3JhcGhpY3MudHJhbnNmb3JtKGRpbXguc2NhbGUsIDAsIDAsIGRpbXkuc2NhbGUsIDAsIDApO1xuICAgIHRtcEN0eC5zYXZlKCk7XG4gICAgdGhpcy5jbGlwQmJveChncmFwaGljcywgeDAsIHkwLCB4MSwgeTEpO1xuICAgIGdyYXBoaWNzLmJhc2VUcmFuc2Zvcm0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKGdyYXBoaWNzLmN0eCk7XG4gICAgZ3JhcGhpY3MuZXhlY3V0ZU9wZXJhdG9yTGlzdChvcGVyYXRvckxpc3QpO1xuICAgIGdyYXBoaWNzLmVuZERyYXdpbmcoKTtcbiAgICB0bXBDdHgucmVzdG9yZSgpO1xuICAgIGlmIChyZWRyYXdIb3Jpem9udGFsbHkgfHwgcmVkcmF3VmVydGljYWxseSkge1xuICAgICAgY29uc3QgaW1hZ2UgPSB0bXBDYW52YXMuY2FudmFzO1xuICAgICAgaWYgKHJlZHJhd0hvcml6b250YWxseSkge1xuICAgICAgICBjYW52YXNXaWR0aCA9IHhzdGVwO1xuICAgICAgfVxuICAgICAgaWYgKHJlZHJhd1ZlcnRpY2FsbHkpIHtcbiAgICAgICAgY2FudmFzSGVpZ2h0ID0geXN0ZXA7XG4gICAgICB9XG4gICAgICBjb25zdCBkaW14MiA9IHRoaXMuZ2V0U2l6ZUFuZFNjYWxlKGNhbnZhc1dpZHRoLCB0aGlzLmN0eC5jYW52YXMud2lkdGgsIGNvbWJpbmVkU2NhbGVYKTtcbiAgICAgIGNvbnN0IGRpbXkyID0gdGhpcy5nZXRTaXplQW5kU2NhbGUoY2FudmFzSGVpZ2h0LCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0LCBjb21iaW5lZFNjYWxlWSk7XG4gICAgICBjb25zdCB4U2l6ZSA9IGRpbXgyLnNpemU7XG4gICAgICBjb25zdCB5U2l6ZSA9IGRpbXkyLnNpemU7XG4gICAgICBjb25zdCB0bXBDYW52YXMyID0gb3duZXIuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwicGF0dGVybi13b3JrYXJvdW5kXCIsIHhTaXplLCB5U2l6ZSk7XG4gICAgICBjb25zdCB0bXBDdHgyID0gdG1wQ2FudmFzMi5jb250ZXh0O1xuICAgICAgY29uc3QgaWkgPSByZWRyYXdIb3Jpem9udGFsbHkgPyBNYXRoLmZsb29yKHdpZHRoIC8geHN0ZXApIDogMDtcbiAgICAgIGNvbnN0IGpqID0gcmVkcmF3VmVydGljYWxseSA/IE1hdGguZmxvb3IoaGVpZ2h0IC8geXN0ZXApIDogMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGlpOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPD0gamo7IGorKykge1xuICAgICAgICAgIHRtcEN0eDIuZHJhd0ltYWdlKGltYWdlLCB4U2l6ZSAqIGksIHlTaXplICogaiwgeFNpemUsIHlTaXplLCAwLCAwLCB4U2l6ZSwgeVNpemUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYW52YXM6IHRtcENhbnZhczIuY2FudmFzLFxuICAgICAgICBzY2FsZVg6IGRpbXgyLnNjYWxlLFxuICAgICAgICBzY2FsZVk6IGRpbXkyLnNjYWxlLFxuICAgICAgICBvZmZzZXRYOiB4MCxcbiAgICAgICAgb2Zmc2V0WTogeTBcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBjYW52YXM6IHRtcENhbnZhcy5jYW52YXMsXG4gICAgICBzY2FsZVg6IGRpbXguc2NhbGUsXG4gICAgICBzY2FsZVk6IGRpbXkuc2NhbGUsXG4gICAgICBvZmZzZXRYOiB4MCxcbiAgICAgIG9mZnNldFk6IHkwXG4gICAgfTtcbiAgfVxuICBnZXRTaXplQW5kU2NhbGUoc3RlcCwgcmVhbE91dHB1dFNpemUsIHNjYWxlKSB7XG4gICAgY29uc3QgbWF4U2l6ZSA9IE1hdGgubWF4KFRpbGluZ1BhdHRlcm4uTUFYX1BBVFRFUk5fU0laRSwgcmVhbE91dHB1dFNpemUpO1xuICAgIGxldCBzaXplID0gTWF0aC5jZWlsKHN0ZXAgKiBzY2FsZSk7XG4gICAgaWYgKHNpemUgPj0gbWF4U2l6ZSkge1xuICAgICAgc2l6ZSA9IG1heFNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlID0gc2l6ZSAvIHN0ZXA7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzY2FsZSxcbiAgICAgIHNpemVcbiAgICB9O1xuICB9XG4gIGNsaXBCYm94KGdyYXBoaWNzLCB4MCwgeTAsIHgxLCB5MSkge1xuICAgIGNvbnN0IGJib3hXaWR0aCA9IHgxIC0geDA7XG4gICAgY29uc3QgYmJveEhlaWdodCA9IHkxIC0geTA7XG4gICAgZ3JhcGhpY3MuY3R4LnJlY3QoeDAsIHkwLCBiYm94V2lkdGgsIGJib3hIZWlnaHQpO1xuICAgIGdyYXBoaWNzLmN1cnJlbnQudXBkYXRlUmVjdE1pbk1heChnZXRDdXJyZW50VHJhbnNmb3JtKGdyYXBoaWNzLmN0eCksIFt4MCwgeTAsIHgxLCB5MV0pO1xuICAgIGdyYXBoaWNzLmNsaXAoKTtcbiAgICBncmFwaGljcy5lbmRQYXRoKCk7XG4gIH1cbiAgc2V0RmlsbEFuZFN0cm9rZVN0eWxlVG9Db250ZXh0KGdyYXBoaWNzLCBwYWludFR5cGUsIGNvbG9yKSB7XG4gICAgY29uc3QgY29udGV4dCA9IGdyYXBoaWNzLmN0eCxcbiAgICAgIGN1cnJlbnQgPSBncmFwaGljcy5jdXJyZW50O1xuICAgIHN3aXRjaCAocGFpbnRUeXBlKSB7XG4gICAgICBjYXNlIFBhaW50VHlwZS5DT0xPUkVEOlxuICAgICAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBjdHguZmlsbFN0eWxlO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY3R4LnN0cm9rZVN0eWxlO1xuICAgICAgICBjdXJyZW50LmZpbGxDb2xvciA9IGN0eC5maWxsU3R5bGU7XG4gICAgICAgIGN1cnJlbnQuc3Ryb2tlQ29sb3IgPSBjdHguc3Ryb2tlU3R5bGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQYWludFR5cGUuVU5DT0xPUkVEOlxuICAgICAgICBjb25zdCBjc3NDb2xvciA9IFV0aWwubWFrZUhleENvbG9yKGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0pO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNzc0NvbG9yO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY3NzQ29sb3I7XG4gICAgICAgIGN1cnJlbnQuZmlsbENvbG9yID0gY3NzQ29sb3I7XG4gICAgICAgIGN1cnJlbnQuc3Ryb2tlQ29sb3IgPSBjc3NDb2xvcjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXJyb3IoYFVuc3VwcG9ydGVkIHBhaW50IHR5cGU6ICR7cGFpbnRUeXBlfWApO1xuICAgIH1cbiAgfVxuICBnZXRQYXR0ZXJuKGN0eCwgb3duZXIsIGludmVyc2UsIHBhdGhUeXBlKSB7XG4gICAgbGV0IG1hdHJpeCA9IGludmVyc2U7XG4gICAgaWYgKHBhdGhUeXBlICE9PSBQYXRoVHlwZS5TSEFESU5HKSB7XG4gICAgICBtYXRyaXggPSBVdGlsLnRyYW5zZm9ybShtYXRyaXgsIG93bmVyLmJhc2VUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRoaXMubWF0cml4KSB7XG4gICAgICAgIG1hdHJpeCA9IFV0aWwudHJhbnNmb3JtKG1hdHJpeCwgdGhpcy5tYXRyaXgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzID0gdGhpcy5jcmVhdGVQYXR0ZXJuQ2FudmFzKG93bmVyKTtcbiAgICBsZXQgZG9tTWF0cml4ID0gbmV3IERPTU1hdHJpeChtYXRyaXgpO1xuICAgIGRvbU1hdHJpeCA9IGRvbU1hdHJpeC50cmFuc2xhdGUodGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5vZmZzZXRYLCB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLm9mZnNldFkpO1xuICAgIGRvbU1hdHJpeCA9IGRvbU1hdHJpeC5zY2FsZSgxIC8gdGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5zY2FsZVgsIDEgLyB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLnNjYWxlWSk7XG4gICAgY29uc3QgcGF0dGVybiA9IGN0eC5jcmVhdGVQYXR0ZXJuKHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuY2FudmFzLCBcInJlcGVhdFwiKTtcbiAgICBwYXR0ZXJuLnNldFRyYW5zZm9ybShkb21NYXRyaXgpO1xuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9XG59XG5cbjsvLyAuL3NyYy9zaGFyZWQvaW1hZ2VfdXRpbHMuanNcblxuZnVuY3Rpb24gY29udmVydFRvUkdCQShwYXJhbXMpIHtcbiAgc3dpdGNoIChwYXJhbXMua2luZCkge1xuICAgIGNhc2UgSW1hZ2VLaW5kLkdSQVlTQ0FMRV8xQlBQOlxuICAgICAgcmV0dXJuIGNvbnZlcnRCbGFja0FuZFdoaXRlVG9SR0JBKHBhcmFtcyk7XG4gICAgY2FzZSBJbWFnZUtpbmQuUkdCXzI0QlBQOlxuICAgICAgcmV0dXJuIGNvbnZlcnRSR0JUb1JHQkEocGFyYW1zKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRCbGFja0FuZFdoaXRlVG9SR0JBKHtcbiAgc3JjLFxuICBzcmNQb3MgPSAwLFxuICBkZXN0LFxuICB3aWR0aCxcbiAgaGVpZ2h0LFxuICBub25CbGFja0NvbG9yID0gMHhmZmZmZmZmZixcbiAgaW52ZXJzZURlY29kZSA9IGZhbHNlXG59KSB7XG4gIGNvbnN0IGJsYWNrID0gdXRpbF9GZWF0dXJlVGVzdC5pc0xpdHRsZUVuZGlhbiA/IDB4ZmYwMDAwMDAgOiAweDAwMDAwMGZmO1xuICBjb25zdCBbemVyb01hcHBpbmcsIG9uZU1hcHBpbmddID0gaW52ZXJzZURlY29kZSA/IFtub25CbGFja0NvbG9yLCBibGFja10gOiBbYmxhY2ssIG5vbkJsYWNrQ29sb3JdO1xuICBjb25zdCB3aWR0aEluU291cmNlID0gd2lkdGggPj4gMztcbiAgY29uc3Qgd2lkdGhSZW1haW5kZXIgPSB3aWR0aCAmIDc7XG4gIGNvbnN0IHNyY0xlbmd0aCA9IHNyYy5sZW5ndGg7XG4gIGRlc3QgPSBuZXcgVWludDMyQXJyYXkoZGVzdC5idWZmZXIpO1xuICBsZXQgZGVzdFBvcyA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaGVpZ2h0OyBpKyspIHtcbiAgICBmb3IgKGNvbnN0IG1heCA9IHNyY1BvcyArIHdpZHRoSW5Tb3VyY2U7IHNyY1BvcyA8IG1heDsgc3JjUG9zKyspIHtcbiAgICAgIGNvbnN0IGVsZW0gPSBzcmNQb3MgPCBzcmNMZW5ndGggPyBzcmNbc3JjUG9zXSA6IDI1NTtcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMDAwMDAwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAwMDAwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMDAwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMDAwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMSA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICB9XG4gICAgaWYgKHdpZHRoUmVtYWluZGVyID09PSAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgZWxlbSA9IHNyY1BvcyA8IHNyY0xlbmd0aCA/IHNyY1tzcmNQb3MrK10gOiAyNTU7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB3aWR0aFJlbWFpbmRlcjsgaisrKSB7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMSA8PCA3IC0gaiA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzcmNQb3MsXG4gICAgZGVzdFBvc1xuICB9O1xufVxuZnVuY3Rpb24gY29udmVydFJHQlRvUkdCQSh7XG4gIHNyYyxcbiAgc3JjUG9zID0gMCxcbiAgZGVzdCxcbiAgZGVzdFBvcyA9IDAsXG4gIHdpZHRoLFxuICBoZWlnaHRcbn0pIHtcbiAgbGV0IGkgPSAwO1xuICBjb25zdCBsZW4gPSB3aWR0aCAqIGhlaWdodCAqIDM7XG4gIGNvbnN0IGxlbjMyID0gbGVuID4+IDI7XG4gIGNvbnN0IHNyYzMyID0gbmV3IFVpbnQzMkFycmF5KHNyYy5idWZmZXIsIHNyY1BvcywgbGVuMzIpO1xuICBpZiAoRmVhdHVyZVRlc3QuaXNMaXR0bGVFbmRpYW4pIHtcbiAgICBmb3IgKDsgaSA8IGxlbjMyIC0gMjsgaSArPSAzLCBkZXN0UG9zICs9IDQpIHtcbiAgICAgIGNvbnN0IHMxID0gc3JjMzJbaV07XG4gICAgICBjb25zdCBzMiA9IHNyYzMyW2kgKyAxXTtcbiAgICAgIGNvbnN0IHMzID0gc3JjMzJbaSArIDJdO1xuICAgICAgZGVzdFtkZXN0UG9zXSA9IHMxIHwgMHhmZjAwMDAwMDtcbiAgICAgIGRlc3RbZGVzdFBvcyArIDFdID0gczEgPj4+IDI0IHwgczIgPDwgOCB8IDB4ZmYwMDAwMDA7XG4gICAgICBkZXN0W2Rlc3RQb3MgKyAyXSA9IHMyID4+PiAxNiB8IHMzIDw8IDE2IHwgMHhmZjAwMDAwMDtcbiAgICAgIGRlc3RbZGVzdFBvcyArIDNdID0gczMgPj4+IDggfCAweGZmMDAwMDAwO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gaSAqIDQsIGpqID0gc3JjUG9zICsgbGVuOyBqIDwgamo7IGogKz0gMykge1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW2pdIHwgc3JjW2ogKyAxXSA8PCA4IHwgc3JjW2ogKyAyXSA8PCAxNiB8IDB4ZmYwMDAwMDA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoOyBpIDwgbGVuMzIgLSAyOyBpICs9IDMsIGRlc3RQb3MgKz0gNCkge1xuICAgICAgY29uc3QgczEgPSBzcmMzMltpXTtcbiAgICAgIGNvbnN0IHMyID0gc3JjMzJbaSArIDFdO1xuICAgICAgY29uc3QgczMgPSBzcmMzMltpICsgMl07XG4gICAgICBkZXN0W2Rlc3RQb3NdID0gczEgfCAweGZmO1xuICAgICAgZGVzdFtkZXN0UG9zICsgMV0gPSBzMSA8PCAyNCB8IHMyID4+PiA4IHwgMHhmZjtcbiAgICAgIGRlc3RbZGVzdFBvcyArIDJdID0gczIgPDwgMTYgfCBzMyA+Pj4gMTYgfCAweGZmO1xuICAgICAgZGVzdFtkZXN0UG9zICsgM10gPSBzMyA8PCA4IHwgMHhmZjtcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IGkgKiA0LCBqaiA9IHNyY1BvcyArIGxlbjsgaiA8IGpqOyBqICs9IDMpIHtcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IHNyY1tqXSA8PCAyNCB8IHNyY1tqICsgMV0gPDwgMTYgfCBzcmNbaiArIDJdIDw8IDggfCAweGZmO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHNyY1Bvczogc3JjUG9zICsgbGVuLFxuICAgIGRlc3RQb3NcbiAgfTtcbn1cbmZ1bmN0aW9uIGdyYXlUb1JHQkEoc3JjLCBkZXN0KSB7XG4gIGlmIChGZWF0dXJlVGVzdC5pc0xpdHRsZUVuZGlhbikge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHNyYy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBkZXN0W2ldID0gc3JjW2ldICogMHgxMDEwMSB8IDB4ZmYwMDAwMDA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHNyYy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBkZXN0W2ldID0gc3JjW2ldICogMHgxMDEwMTAwIHwgMHgwMDAwMDBmZjtcbiAgICB9XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvY2FudmFzLmpzXG5cblxuXG5cbmNvbnN0IE1JTl9GT05UX1NJWkUgPSAxNjtcbmNvbnN0IE1BWF9GT05UX1NJWkUgPSAxMDA7XG5jb25zdCBFWEVDVVRJT05fVElNRSA9IDE1O1xuY29uc3QgRVhFQ1VUSU9OX1NURVBTID0gMTA7XG5jb25zdCBNQVhfU0laRV9UT19DT01QSUxFID0gMTAwMDtcbmNvbnN0IEZVTExfQ0hVTktfSEVJR0hUID0gMTY7XG5mdW5jdGlvbiBtaXJyb3JDb250ZXh0T3BlcmF0aW9ucyhjdHgsIGRlc3RDdHgpIHtcbiAgaWYgKGN0eC5fcmVtb3ZlTWlycm9yaW5nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udGV4dCBpcyBhbHJlYWR5IGZvcndhcmRpbmcgb3BlcmF0aW9ucy5cIik7XG4gIH1cbiAgY3R4Ll9fb3JpZ2luYWxTYXZlID0gY3R4LnNhdmU7XG4gIGN0eC5fX29yaWdpbmFsUmVzdG9yZSA9IGN0eC5yZXN0b3JlO1xuICBjdHguX19vcmlnaW5hbFJvdGF0ZSA9IGN0eC5yb3RhdGU7XG4gIGN0eC5fX29yaWdpbmFsU2NhbGUgPSBjdHguc2NhbGU7XG4gIGN0eC5fX29yaWdpbmFsVHJhbnNsYXRlID0gY3R4LnRyYW5zbGF0ZTtcbiAgY3R4Ll9fb3JpZ2luYWxUcmFuc2Zvcm0gPSBjdHgudHJhbnNmb3JtO1xuICBjdHguX19vcmlnaW5hbFNldFRyYW5zZm9ybSA9IGN0eC5zZXRUcmFuc2Zvcm07XG4gIGN0eC5fX29yaWdpbmFsUmVzZXRUcmFuc2Zvcm0gPSBjdHgucmVzZXRUcmFuc2Zvcm07XG4gIGN0eC5fX29yaWdpbmFsQ2xpcCA9IGN0eC5jbGlwO1xuICBjdHguX19vcmlnaW5hbE1vdmVUbyA9IGN0eC5tb3ZlVG87XG4gIGN0eC5fX29yaWdpbmFsTGluZVRvID0gY3R4LmxpbmVUbztcbiAgY3R4Ll9fb3JpZ2luYWxCZXppZXJDdXJ2ZVRvID0gY3R4LmJlemllckN1cnZlVG87XG4gIGN0eC5fX29yaWdpbmFsUmVjdCA9IGN0eC5yZWN0O1xuICBjdHguX19vcmlnaW5hbENsb3NlUGF0aCA9IGN0eC5jbG9zZVBhdGg7XG4gIGN0eC5fX29yaWdpbmFsQmVnaW5QYXRoID0gY3R4LmJlZ2luUGF0aDtcbiAgY3R4Ll9yZW1vdmVNaXJyb3JpbmcgPSAoKSA9PiB7XG4gICAgY3R4LnNhdmUgPSBjdHguX19vcmlnaW5hbFNhdmU7XG4gICAgY3R4LnJlc3RvcmUgPSBjdHguX19vcmlnaW5hbFJlc3RvcmU7XG4gICAgY3R4LnJvdGF0ZSA9IGN0eC5fX29yaWdpbmFsUm90YXRlO1xuICAgIGN0eC5zY2FsZSA9IGN0eC5fX29yaWdpbmFsU2NhbGU7XG4gICAgY3R4LnRyYW5zbGF0ZSA9IGN0eC5fX29yaWdpbmFsVHJhbnNsYXRlO1xuICAgIGN0eC50cmFuc2Zvcm0gPSBjdHguX19vcmlnaW5hbFRyYW5zZm9ybTtcbiAgICBjdHguc2V0VHJhbnNmb3JtID0gY3R4Ll9fb3JpZ2luYWxTZXRUcmFuc2Zvcm07XG4gICAgY3R4LnJlc2V0VHJhbnNmb3JtID0gY3R4Ll9fb3JpZ2luYWxSZXNldFRyYW5zZm9ybTtcbiAgICBjdHguY2xpcCA9IGN0eC5fX29yaWdpbmFsQ2xpcDtcbiAgICBjdHgubW92ZVRvID0gY3R4Ll9fb3JpZ2luYWxNb3ZlVG87XG4gICAgY3R4LmxpbmVUbyA9IGN0eC5fX29yaWdpbmFsTGluZVRvO1xuICAgIGN0eC5iZXppZXJDdXJ2ZVRvID0gY3R4Ll9fb3JpZ2luYWxCZXppZXJDdXJ2ZVRvO1xuICAgIGN0eC5yZWN0ID0gY3R4Ll9fb3JpZ2luYWxSZWN0O1xuICAgIGN0eC5jbG9zZVBhdGggPSBjdHguX19vcmlnaW5hbENsb3NlUGF0aDtcbiAgICBjdHguYmVnaW5QYXRoID0gY3R4Ll9fb3JpZ2luYWxCZWdpblBhdGg7XG4gICAgZGVsZXRlIGN0eC5fcmVtb3ZlTWlycm9yaW5nO1xuICB9O1xuICBjdHguc2F2ZSA9IGZ1bmN0aW9uIGN0eFNhdmUoKSB7XG4gICAgZGVzdEN0eC5zYXZlKCk7XG4gICAgdGhpcy5fX29yaWdpbmFsU2F2ZSgpO1xuICB9O1xuICBjdHgucmVzdG9yZSA9IGZ1bmN0aW9uIGN0eFJlc3RvcmUoKSB7XG4gICAgZGVzdEN0eC5yZXN0b3JlKCk7XG4gICAgdGhpcy5fX29yaWdpbmFsUmVzdG9yZSgpO1xuICB9O1xuICBjdHgudHJhbnNsYXRlID0gZnVuY3Rpb24gY3R4VHJhbnNsYXRlKHgsIHkpIHtcbiAgICBkZXN0Q3R4LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxUcmFuc2xhdGUoeCwgeSk7XG4gIH07XG4gIGN0eC5zY2FsZSA9IGZ1bmN0aW9uIGN0eFNjYWxlKHgsIHkpIHtcbiAgICBkZXN0Q3R4LnNjYWxlKHgsIHkpO1xuICAgIHRoaXMuX19vcmlnaW5hbFNjYWxlKHgsIHkpO1xuICB9O1xuICBjdHgudHJhbnNmb3JtID0gZnVuY3Rpb24gY3R4VHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICBkZXN0Q3R4LnRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxUcmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZik7XG4gIH07XG4gIGN0eC5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiBjdHhTZXRUcmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZikge1xuICAgIGRlc3RDdHguc2V0VHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgIHRoaXMuX19vcmlnaW5hbFNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKTtcbiAgfTtcbiAgY3R4LnJlc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gY3R4UmVzZXRUcmFuc2Zvcm0oKSB7XG4gICAgZGVzdEN0eC5yZXNldFRyYW5zZm9ybSgpO1xuICAgIHRoaXMuX19vcmlnaW5hbFJlc2V0VHJhbnNmb3JtKCk7XG4gIH07XG4gIGN0eC5yb3RhdGUgPSBmdW5jdGlvbiBjdHhSb3RhdGUoYW5nbGUpIHtcbiAgICBkZXN0Q3R4LnJvdGF0ZShhbmdsZSk7XG4gICAgdGhpcy5fX29yaWdpbmFsUm90YXRlKGFuZ2xlKTtcbiAgfTtcbiAgY3R4LmNsaXAgPSBmdW5jdGlvbiBjdHhSb3RhdGUocnVsZSkge1xuICAgIGRlc3RDdHguY2xpcChydWxlKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxDbGlwKHJ1bGUpO1xuICB9O1xuICBjdHgubW92ZVRvID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICBkZXN0Q3R4Lm1vdmVUbyh4LCB5KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxNb3ZlVG8oeCwgeSk7XG4gIH07XG4gIGN0eC5saW5lVG8gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIGRlc3RDdHgubGluZVRvKHgsIHkpO1xuICAgIHRoaXMuX19vcmlnaW5hbExpbmVUbyh4LCB5KTtcbiAgfTtcbiAgY3R4LmJlemllckN1cnZlVG8gPSBmdW5jdGlvbiAoY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSkge1xuICAgIGRlc3RDdHguYmV6aWVyQ3VydmVUbyhjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxCZXppZXJDdXJ2ZVRvKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpO1xuICB9O1xuICBjdHgucmVjdCA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgZGVzdEN0eC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuX19vcmlnaW5hbFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gIH07XG4gIGN0eC5jbG9zZVBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgZGVzdEN0eC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxDbG9zZVBhdGgoKTtcbiAgfTtcbiAgY3R4LmJlZ2luUGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICBkZXN0Q3R4LmJlZ2luUGF0aCgpO1xuICAgIHRoaXMuX19vcmlnaW5hbEJlZ2luUGF0aCgpO1xuICB9O1xufVxuY2xhc3MgQ2FjaGVkQ2FudmFzZXMge1xuICBjb25zdHJ1Y3RvcihjYW52YXNGYWN0b3J5KSB7XG4gICAgdGhpcy5jYW52YXNGYWN0b3J5ID0gY2FudmFzRmFjdG9yeTtcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICBnZXRDYW52YXMoaWQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBsZXQgY2FudmFzRW50cnk7XG4gICAgaWYgKHRoaXMuY2FjaGVbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNhbnZhc0VudHJ5ID0gdGhpcy5jYWNoZVtpZF07XG4gICAgICB0aGlzLmNhbnZhc0ZhY3RvcnkucmVzZXQoY2FudmFzRW50cnksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYW52YXNFbnRyeSA9IHRoaXMuY2FudmFzRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLmNhY2hlW2lkXSA9IGNhbnZhc0VudHJ5O1xuICAgIH1cbiAgICByZXR1cm4gY2FudmFzRW50cnk7XG4gIH1cbiAgZGVsZXRlKGlkKSB7XG4gICAgZGVsZXRlIHRoaXMuY2FjaGVbaWRdO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIGZvciAoY29uc3QgaWQgaW4gdGhpcy5jYWNoZSkge1xuICAgICAgY29uc3QgY2FudmFzRW50cnkgPSB0aGlzLmNhY2hlW2lkXTtcbiAgICAgIHRoaXMuY2FudmFzRmFjdG9yeS5kZXN0cm95KGNhbnZhc0VudHJ5KTtcbiAgICAgIGRlbGV0ZSB0aGlzLmNhY2hlW2lkXTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRyYXdJbWFnZUF0SW50ZWdlckNvb3JkcyhjdHgsIHNyY0ltZywgc3JjWCwgc3JjWSwgc3JjVywgc3JjSCwgZGVzdFgsIGRlc3RZLCBkZXN0VywgZGVzdEgpIHtcbiAgY29uc3QgW2EsIGIsIGMsIGQsIHR4LCB0eV0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCk7XG4gIGlmIChiID09PSAwICYmIGMgPT09IDApIHtcbiAgICBjb25zdCB0bFggPSBkZXN0WCAqIGEgKyB0eDtcbiAgICBjb25zdCByVGxYID0gTWF0aC5yb3VuZCh0bFgpO1xuICAgIGNvbnN0IHRsWSA9IGRlc3RZICogZCArIHR5O1xuICAgIGNvbnN0IHJUbFkgPSBNYXRoLnJvdW5kKHRsWSk7XG4gICAgY29uc3QgYnJYID0gKGRlc3RYICsgZGVzdFcpICogYSArIHR4O1xuICAgIGNvbnN0IHJXaWR0aCA9IE1hdGguYWJzKE1hdGgucm91bmQoYnJYKSAtIHJUbFgpIHx8IDE7XG4gICAgY29uc3QgYnJZID0gKGRlc3RZICsgZGVzdEgpICogZCArIHR5O1xuICAgIGNvbnN0IHJIZWlnaHQgPSBNYXRoLmFicyhNYXRoLnJvdW5kKGJyWSkgLSByVGxZKSB8fCAxO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oTWF0aC5zaWduKGEpLCAwLCAwLCBNYXRoLnNpZ24oZCksIHJUbFgsIHJUbFkpO1xuICAgIGN0eC5kcmF3SW1hZ2Uoc3JjSW1nLCBzcmNYLCBzcmNZLCBzcmNXLCBzcmNILCAwLCAwLCByV2lkdGgsIHJIZWlnaHQpO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oYSwgYiwgYywgZCwgdHgsIHR5KTtcbiAgICByZXR1cm4gW3JXaWR0aCwgckhlaWdodF07XG4gIH1cbiAgaWYgKGEgPT09IDAgJiYgZCA9PT0gMCkge1xuICAgIGNvbnN0IHRsWCA9IGRlc3RZICogYyArIHR4O1xuICAgIGNvbnN0IHJUbFggPSBNYXRoLnJvdW5kKHRsWCk7XG4gICAgY29uc3QgdGxZID0gZGVzdFggKiBiICsgdHk7XG4gICAgY29uc3QgclRsWSA9IE1hdGgucm91bmQodGxZKTtcbiAgICBjb25zdCBiclggPSAoZGVzdFkgKyBkZXN0SCkgKiBjICsgdHg7XG4gICAgY29uc3QgcldpZHRoID0gTWF0aC5hYnMoTWF0aC5yb3VuZChiclgpIC0gclRsWCkgfHwgMTtcbiAgICBjb25zdCBiclkgPSAoZGVzdFggKyBkZXN0VykgKiBiICsgdHk7XG4gICAgY29uc3QgckhlaWdodCA9IE1hdGguYWJzKE1hdGgucm91bmQoYnJZKSAtIHJUbFkpIHx8IDE7XG4gICAgY3R4LnNldFRyYW5zZm9ybSgwLCBNYXRoLnNpZ24oYiksIE1hdGguc2lnbihjKSwgMCwgclRsWCwgclRsWSk7XG4gICAgY3R4LmRyYXdJbWFnZShzcmNJbWcsIHNyY1gsIHNyY1ksIHNyY1csIHNyY0gsIDAsIDAsIHJIZWlnaHQsIHJXaWR0aCk7XG4gICAgY3R4LnNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCB0eCwgdHkpO1xuICAgIHJldHVybiBbckhlaWdodCwgcldpZHRoXTtcbiAgfVxuICBjdHguZHJhd0ltYWdlKHNyY0ltZywgc3JjWCwgc3JjWSwgc3JjVywgc3JjSCwgZGVzdFgsIGRlc3RZLCBkZXN0VywgZGVzdEgpO1xuICBjb25zdCBzY2FsZVggPSBNYXRoLmh5cG90KGEsIGIpO1xuICBjb25zdCBzY2FsZVkgPSBNYXRoLmh5cG90KGMsIGQpO1xuICByZXR1cm4gW3NjYWxlWCAqIGRlc3RXLCBzY2FsZVkgKiBkZXN0SF07XG59XG5mdW5jdGlvbiBjb21waWxlVHlwZTNHbHlwaChpbWdEYXRhKSB7XG4gIGNvbnN0IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IGltZ0RhdGE7XG4gIGlmICh3aWR0aCA+IE1BWF9TSVpFX1RPX0NPTVBJTEUgfHwgaGVpZ2h0ID4gTUFYX1NJWkVfVE9fQ09NUElMRSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IFBPSU5UX1RPX1BST0NFU1NfTElNSVQgPSAxMDAwO1xuICBjb25zdCBQT0lOVF9UWVBFUyA9IG5ldyBVaW50OEFycmF5KFswLCAyLCA0LCAwLCAxLCAwLCA1LCA0LCA4LCAxMCwgMCwgOCwgMCwgMiwgMSwgMF0pO1xuICBjb25zdCB3aWR0aDEgPSB3aWR0aCArIDE7XG4gIGxldCBwb2ludHMgPSBuZXcgVWludDhBcnJheSh3aWR0aDEgKiAoaGVpZ2h0ICsgMSkpO1xuICBsZXQgaSwgaiwgajA7XG4gIGNvbnN0IGxpbmVTaXplID0gd2lkdGggKyA3ICYgfjc7XG4gIGxldCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkobGluZVNpemUgKiBoZWlnaHQpLFxuICAgIHBvcyA9IDA7XG4gIGZvciAoY29uc3QgZWxlbSBvZiBpbWdEYXRhLmRhdGEpIHtcbiAgICBsZXQgbWFzayA9IDEyODtcbiAgICB3aGlsZSAobWFzayA+IDApIHtcbiAgICAgIGRhdGFbcG9zKytdID0gZWxlbSAmIG1hc2sgPyAwIDogMjU1O1xuICAgICAgbWFzayA+Pj0gMTtcbiAgICB9XG4gIH1cbiAgbGV0IGNvdW50ID0gMDtcbiAgcG9zID0gMDtcbiAgaWYgKGRhdGFbcG9zXSAhPT0gMCkge1xuICAgIHBvaW50c1swXSA9IDE7XG4gICAgKytjb3VudDtcbiAgfVxuICBmb3IgKGogPSAxOyBqIDwgd2lkdGg7IGorKykge1xuICAgIGlmIChkYXRhW3Bvc10gIT09IGRhdGFbcG9zICsgMV0pIHtcbiAgICAgIHBvaW50c1tqXSA9IGRhdGFbcG9zXSA/IDIgOiAxO1xuICAgICAgKytjb3VudDtcbiAgICB9XG4gICAgcG9zKys7XG4gIH1cbiAgaWYgKGRhdGFbcG9zXSAhPT0gMCkge1xuICAgIHBvaW50c1tqXSA9IDI7XG4gICAgKytjb3VudDtcbiAgfVxuICBmb3IgKGkgPSAxOyBpIDwgaGVpZ2h0OyBpKyspIHtcbiAgICBwb3MgPSBpICogbGluZVNpemU7XG4gICAgajAgPSBpICogd2lkdGgxO1xuICAgIGlmIChkYXRhW3BvcyAtIGxpbmVTaXplXSAhPT0gZGF0YVtwb3NdKSB7XG4gICAgICBwb2ludHNbajBdID0gZGF0YVtwb3NdID8gMSA6IDg7XG4gICAgICArK2NvdW50O1xuICAgIH1cbiAgICBsZXQgc3VtID0gKGRhdGFbcG9zXSA/IDQgOiAwKSArIChkYXRhW3BvcyAtIGxpbmVTaXplXSA/IDggOiAwKTtcbiAgICBmb3IgKGogPSAxOyBqIDwgd2lkdGg7IGorKykge1xuICAgICAgc3VtID0gKHN1bSA+PiAyKSArIChkYXRhW3BvcyArIDFdID8gNCA6IDApICsgKGRhdGFbcG9zIC0gbGluZVNpemUgKyAxXSA/IDggOiAwKTtcbiAgICAgIGlmIChQT0lOVF9UWVBFU1tzdW1dKSB7XG4gICAgICAgIHBvaW50c1tqMCArIGpdID0gUE9JTlRfVFlQRVNbc3VtXTtcbiAgICAgICAgKytjb3VudDtcbiAgICAgIH1cbiAgICAgIHBvcysrO1xuICAgIH1cbiAgICBpZiAoZGF0YVtwb3MgLSBsaW5lU2l6ZV0gIT09IGRhdGFbcG9zXSkge1xuICAgICAgcG9pbnRzW2owICsgal0gPSBkYXRhW3Bvc10gPyAyIDogNDtcbiAgICAgICsrY291bnQ7XG4gICAgfVxuICAgIGlmIChjb3VudCA+IFBPSU5UX1RPX1BST0NFU1NfTElNSVQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBwb3MgPSBsaW5lU2l6ZSAqIChoZWlnaHQgLSAxKTtcbiAgajAgPSBpICogd2lkdGgxO1xuICBpZiAoZGF0YVtwb3NdICE9PSAwKSB7XG4gICAgcG9pbnRzW2owXSA9IDg7XG4gICAgKytjb3VudDtcbiAgfVxuICBmb3IgKGogPSAxOyBqIDwgd2lkdGg7IGorKykge1xuICAgIGlmIChkYXRhW3Bvc10gIT09IGRhdGFbcG9zICsgMV0pIHtcbiAgICAgIHBvaW50c1tqMCArIGpdID0gZGF0YVtwb3NdID8gNCA6IDg7XG4gICAgICArK2NvdW50O1xuICAgIH1cbiAgICBwb3MrKztcbiAgfVxuICBpZiAoZGF0YVtwb3NdICE9PSAwKSB7XG4gICAgcG9pbnRzW2owICsgal0gPSA0O1xuICAgICsrY291bnQ7XG4gIH1cbiAgaWYgKGNvdW50ID4gUE9JTlRfVE9fUFJPQ0VTU19MSU1JVCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHN0ZXBzID0gbmV3IEludDMyQXJyYXkoWzAsIHdpZHRoMSwgLTEsIDAsIC13aWR0aDEsIDAsIDAsIDAsIDFdKTtcbiAgY29uc3QgcGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgZm9yIChpID0gMDsgY291bnQgJiYgaSA8PSBoZWlnaHQ7IGkrKykge1xuICAgIGxldCBwID0gaSAqIHdpZHRoMTtcbiAgICBjb25zdCBlbmQgPSBwICsgd2lkdGg7XG4gICAgd2hpbGUgKHAgPCBlbmQgJiYgIXBvaW50c1twXSkge1xuICAgICAgcCsrO1xuICAgIH1cbiAgICBpZiAocCA9PT0gZW5kKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcGF0aC5tb3ZlVG8ocCAlIHdpZHRoMSwgaSk7XG4gICAgY29uc3QgcDAgPSBwO1xuICAgIGxldCB0eXBlID0gcG9pbnRzW3BdO1xuICAgIGRvIHtcbiAgICAgIGNvbnN0IHN0ZXAgPSBzdGVwc1t0eXBlXTtcbiAgICAgIGRvIHtcbiAgICAgICAgcCArPSBzdGVwO1xuICAgICAgfSB3aGlsZSAoIXBvaW50c1twXSk7XG4gICAgICBjb25zdCBwcCA9IHBvaW50c1twXTtcbiAgICAgIGlmIChwcCAhPT0gNSAmJiBwcCAhPT0gMTApIHtcbiAgICAgICAgdHlwZSA9IHBwO1xuICAgICAgICBwb2ludHNbcF0gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZSA9IHBwICYgMHgzMyAqIHR5cGUgPj4gNDtcbiAgICAgICAgcG9pbnRzW3BdICY9IHR5cGUgPj4gMiB8IHR5cGUgPDwgMjtcbiAgICAgIH1cbiAgICAgIHBhdGgubGluZVRvKHAgJSB3aWR0aDEsIHAgLyB3aWR0aDEgfCAwKTtcbiAgICAgIGlmICghcG9pbnRzW3BdKSB7XG4gICAgICAgIC0tY291bnQ7XG4gICAgICB9XG4gICAgfSB3aGlsZSAocDAgIT09IHApO1xuICAgIC0taTtcbiAgfVxuICBkYXRhID0gbnVsbDtcbiAgcG9pbnRzID0gbnVsbDtcbiAgY29uc3QgZHJhd091dGxpbmUgPSBmdW5jdGlvbiAoYykge1xuICAgIGMuc2F2ZSgpO1xuICAgIGMuc2NhbGUoMSAvIHdpZHRoLCAtMSAvIGhlaWdodCk7XG4gICAgYy50cmFuc2xhdGUoMCwgLWhlaWdodCk7XG4gICAgYy5maWxsKHBhdGgpO1xuICAgIGMuYmVnaW5QYXRoKCk7XG4gICAgYy5yZXN0b3JlKCk7XG4gIH07XG4gIHJldHVybiBkcmF3T3V0bGluZTtcbn1cbmNsYXNzIENhbnZhc0V4dHJhU3RhdGUge1xuICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy5hbHBoYUlzU2hhcGUgPSBmYWxzZTtcbiAgICB0aGlzLmZvbnRTaXplID0gMDtcbiAgICB0aGlzLmZvbnRTaXplU2NhbGUgPSAxO1xuICAgIHRoaXMudGV4dE1hdHJpeCA9IElERU5USVRZX01BVFJJWDtcbiAgICB0aGlzLnRleHRNYXRyaXhTY2FsZSA9IDE7XG4gICAgdGhpcy5mb250TWF0cml4ID0gRk9OVF9JREVOVElUWV9NQVRSSVg7XG4gICAgdGhpcy5sZWFkaW5nID0gMDtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy5saW5lWCA9IDA7XG4gICAgdGhpcy5saW5lWSA9IDA7XG4gICAgdGhpcy5jaGFyU3BhY2luZyA9IDA7XG4gICAgdGhpcy53b3JkU3BhY2luZyA9IDA7XG4gICAgdGhpcy50ZXh0SFNjYWxlID0gMTtcbiAgICB0aGlzLnRleHRSZW5kZXJpbmdNb2RlID0gVGV4dFJlbmRlcmluZ01vZGUuRklMTDtcbiAgICB0aGlzLnRleHRSaXNlID0gMDtcbiAgICB0aGlzLmZpbGxDb2xvciA9IFwiIzAwMDAwMFwiO1xuICAgIHRoaXMuc3Ryb2tlQ29sb3IgPSBcIiMwMDAwMDBcIjtcbiAgICB0aGlzLnBhdHRlcm5GaWxsID0gZmFsc2U7XG4gICAgdGhpcy5wYXR0ZXJuU3Ryb2tlID0gZmFsc2U7XG4gICAgdGhpcy5maWxsQWxwaGEgPSAxO1xuICAgIHRoaXMuc3Ryb2tlQWxwaGEgPSAxO1xuICAgIHRoaXMubGluZVdpZHRoID0gMTtcbiAgICB0aGlzLmFjdGl2ZVNNYXNrID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zZmVyTWFwcyA9IFwibm9uZVwiO1xuICAgIHRoaXMuc3RhcnROZXdQYXRoQW5kQ2xpcEJveChbMCwgMCwgd2lkdGgsIGhlaWdodF0pO1xuICB9XG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGNsb25lID0gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcbiAgICBjbG9uZS5jbGlwQm94ID0gdGhpcy5jbGlwQm94LnNsaWNlKCk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG4gIHNldEN1cnJlbnRQb2ludCh4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9XG4gIHVwZGF0ZVBhdGhNaW5NYXgodHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgW3gsIHldID0gVXRpbC5hcHBseVRyYW5zZm9ybShbeCwgeV0sIHRyYW5zZm9ybSk7XG4gICAgdGhpcy5taW5YID0gTWF0aC5taW4odGhpcy5taW5YLCB4KTtcbiAgICB0aGlzLm1pblkgPSBNYXRoLm1pbih0aGlzLm1pblksIHkpO1xuICAgIHRoaXMubWF4WCA9IE1hdGgubWF4KHRoaXMubWF4WCwgeCk7XG4gICAgdGhpcy5tYXhZID0gTWF0aC5tYXgodGhpcy5tYXhZLCB5KTtcbiAgfVxuICB1cGRhdGVSZWN0TWluTWF4KHRyYW5zZm9ybSwgcmVjdCkge1xuICAgIGNvbnN0IHAxID0gVXRpbC5hcHBseVRyYW5zZm9ybShyZWN0LCB0cmFuc2Zvcm0pO1xuICAgIGNvbnN0IHAyID0gVXRpbC5hcHBseVRyYW5zZm9ybShyZWN0LnNsaWNlKDIpLCB0cmFuc2Zvcm0pO1xuICAgIGNvbnN0IHAzID0gVXRpbC5hcHBseVRyYW5zZm9ybShbcmVjdFswXSwgcmVjdFszXV0sIHRyYW5zZm9ybSk7XG4gICAgY29uc3QgcDQgPSBVdGlsLmFwcGx5VHJhbnNmb3JtKFtyZWN0WzJdLCByZWN0WzFdXSwgdHJhbnNmb3JtKTtcbiAgICB0aGlzLm1pblggPSBNYXRoLm1pbih0aGlzLm1pblgsIHAxWzBdLCBwMlswXSwgcDNbMF0sIHA0WzBdKTtcbiAgICB0aGlzLm1pblkgPSBNYXRoLm1pbih0aGlzLm1pblksIHAxWzFdLCBwMlsxXSwgcDNbMV0sIHA0WzFdKTtcbiAgICB0aGlzLm1heFggPSBNYXRoLm1heCh0aGlzLm1heFgsIHAxWzBdLCBwMlswXSwgcDNbMF0sIHA0WzBdKTtcbiAgICB0aGlzLm1heFkgPSBNYXRoLm1heCh0aGlzLm1heFksIHAxWzFdLCBwMlsxXSwgcDNbMV0sIHA0WzFdKTtcbiAgfVxuICB1cGRhdGVTY2FsaW5nUGF0aE1pbk1heCh0cmFuc2Zvcm0sIG1pbk1heCkge1xuICAgIFV0aWwuc2NhbGVNaW5NYXgodHJhbnNmb3JtLCBtaW5NYXgpO1xuICAgIHRoaXMubWluWCA9IE1hdGgubWluKHRoaXMubWluWCwgbWluTWF4WzBdKTtcbiAgICB0aGlzLm1pblkgPSBNYXRoLm1pbih0aGlzLm1pblksIG1pbk1heFsxXSk7XG4gICAgdGhpcy5tYXhYID0gTWF0aC5tYXgodGhpcy5tYXhYLCBtaW5NYXhbMl0pO1xuICAgIHRoaXMubWF4WSA9IE1hdGgubWF4KHRoaXMubWF4WSwgbWluTWF4WzNdKTtcbiAgfVxuICB1cGRhdGVDdXJ2ZVBhdGhNaW5NYXgodHJhbnNmb3JtLCB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIG1pbk1heCkge1xuICAgIGNvbnN0IGJveCA9IFV0aWwuYmV6aWVyQm91bmRpbmdCb3goeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCBtaW5NYXgpO1xuICAgIGlmIChtaW5NYXgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVSZWN0TWluTWF4KHRyYW5zZm9ybSwgYm94KTtcbiAgfVxuICBnZXRQYXRoQm91bmRpbmdCb3gocGF0aFR5cGUgPSBQYXRoVHlwZS5GSUxMLCB0cmFuc2Zvcm0gPSBudWxsKSB7XG4gICAgY29uc3QgYm94ID0gW3RoaXMubWluWCwgdGhpcy5taW5ZLCB0aGlzLm1heFgsIHRoaXMubWF4WV07XG4gICAgaWYgKHBhdGhUeXBlID09PSBQYXRoVHlwZS5TVFJPS0UpIHtcbiAgICAgIGlmICghdHJhbnNmb3JtKSB7XG4gICAgICAgIHVucmVhY2hhYmxlKFwiU3Ryb2tlIGJvdW5kaW5nIGJveCBtdXN0IGluY2x1ZGUgdHJhbnNmb3JtLlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNjYWxlID0gVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSh0cmFuc2Zvcm0pO1xuICAgICAgY29uc3QgeFN0cm9rZVBhZCA9IHNjYWxlWzBdICogdGhpcy5saW5lV2lkdGggLyAyO1xuICAgICAgY29uc3QgeVN0cm9rZVBhZCA9IHNjYWxlWzFdICogdGhpcy5saW5lV2lkdGggLyAyO1xuICAgICAgYm94WzBdIC09IHhTdHJva2VQYWQ7XG4gICAgICBib3hbMV0gLT0geVN0cm9rZVBhZDtcbiAgICAgIGJveFsyXSArPSB4U3Ryb2tlUGFkO1xuICAgICAgYm94WzNdICs9IHlTdHJva2VQYWQ7XG4gICAgfVxuICAgIHJldHVybiBib3g7XG4gIH1cbiAgdXBkYXRlQ2xpcEZyb21QYXRoKCkge1xuICAgIGNvbnN0IGludGVyc2VjdCA9IFV0aWwuaW50ZXJzZWN0KHRoaXMuY2xpcEJveCwgdGhpcy5nZXRQYXRoQm91bmRpbmdCb3goKSk7XG4gICAgdGhpcy5zdGFydE5ld1BhdGhBbmRDbGlwQm94KGludGVyc2VjdCB8fCBbMCwgMCwgMCwgMF0pO1xuICB9XG4gIGlzRW1wdHlDbGlwKCkge1xuICAgIHJldHVybiB0aGlzLm1pblggPT09IEluZmluaXR5O1xuICB9XG4gIHN0YXJ0TmV3UGF0aEFuZENsaXBCb3goYm94KSB7XG4gICAgdGhpcy5jbGlwQm94ID0gYm94O1xuICAgIHRoaXMubWluWCA9IEluZmluaXR5O1xuICAgIHRoaXMubWluWSA9IEluZmluaXR5O1xuICAgIHRoaXMubWF4WCA9IDA7XG4gICAgdGhpcy5tYXhZID0gMDtcbiAgfVxuICBnZXRDbGlwcGVkUGF0aEJvdW5kaW5nQm94KHBhdGhUeXBlID0gUGF0aFR5cGUuRklMTCwgdHJhbnNmb3JtID0gbnVsbCkge1xuICAgIHJldHVybiBVdGlsLmludGVyc2VjdCh0aGlzLmNsaXBCb3gsIHRoaXMuZ2V0UGF0aEJvdW5kaW5nQm94KHBhdGhUeXBlLCB0cmFuc2Zvcm0pKTtcbiAgfVxufVxuZnVuY3Rpb24gcHV0QmluYXJ5SW1hZ2VEYXRhKGN0eCwgaW1nRGF0YSkge1xuICBpZiAoaW1nRGF0YSBpbnN0YW5jZW9mIEltYWdlRGF0YSkge1xuICAgIGN0eC5wdXRJbWFnZURhdGEoaW1nRGF0YSwgMCwgMCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0LFxuICAgIHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgY29uc3QgcGFydGlhbENodW5rSGVpZ2h0ID0gaGVpZ2h0ICUgRlVMTF9DSFVOS19IRUlHSFQ7XG4gIGNvbnN0IGZ1bGxDaHVua3MgPSAoaGVpZ2h0IC0gcGFydGlhbENodW5rSGVpZ2h0KSAvIEZVTExfQ0hVTktfSEVJR0hUO1xuICBjb25zdCB0b3RhbENodW5rcyA9IHBhcnRpYWxDaHVua0hlaWdodCA9PT0gMCA/IGZ1bGxDaHVua3MgOiBmdWxsQ2h1bmtzICsgMTtcbiAgY29uc3QgY2h1bmtJbWdEYXRhID0gY3R4LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgRlVMTF9DSFVOS19IRUlHSFQpO1xuICBsZXQgc3JjUG9zID0gMCxcbiAgICBkZXN0UG9zO1xuICBjb25zdCBzcmMgPSBpbWdEYXRhLmRhdGE7XG4gIGNvbnN0IGRlc3QgPSBjaHVua0ltZ0RhdGEuZGF0YTtcbiAgbGV0IGksIGosIHRoaXNDaHVua0hlaWdodCwgZWxlbXNJblRoaXNDaHVuaztcbiAgaWYgKGltZ0RhdGEua2luZCA9PT0gdXRpbF9JbWFnZUtpbmQuR1JBWVNDQUxFXzFCUFApIHtcbiAgICBjb25zdCBzcmNMZW5ndGggPSBzcmMuYnl0ZUxlbmd0aDtcbiAgICBjb25zdCBkZXN0MzIgPSBuZXcgVWludDMyQXJyYXkoZGVzdC5idWZmZXIsIDAsIGRlc3QuYnl0ZUxlbmd0aCA+PiAyKTtcbiAgICBjb25zdCBkZXN0MzJEYXRhTGVuZ3RoID0gZGVzdDMyLmxlbmd0aDtcbiAgICBjb25zdCBmdWxsU3JjRGlmZiA9IHdpZHRoICsgNyA+PiAzO1xuICAgIGNvbnN0IHdoaXRlID0gMHhmZmZmZmZmZjtcbiAgICBjb25zdCBibGFjayA9IHV0aWxfRmVhdHVyZVRlc3QuaXNMaXR0bGVFbmRpYW4gPyAweGZmMDAwMDAwIDogMHgwMDAwMDBmZjtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWxDaHVua3M7IGkrKykge1xuICAgICAgdGhpc0NodW5rSGVpZ2h0ID0gaSA8IGZ1bGxDaHVua3MgPyBGVUxMX0NIVU5LX0hFSUdIVCA6IHBhcnRpYWxDaHVua0hlaWdodDtcbiAgICAgIGRlc3RQb3MgPSAwO1xuICAgICAgZm9yIChqID0gMDsgaiA8IHRoaXNDaHVua0hlaWdodDsgaisrKSB7XG4gICAgICAgIGNvbnN0IHNyY0RpZmYgPSBzcmNMZW5ndGggLSBzcmNQb3M7XG4gICAgICAgIGxldCBrID0gMDtcbiAgICAgICAgY29uc3Qga0VuZCA9IHNyY0RpZmYgPiBmdWxsU3JjRGlmZiA/IHdpZHRoIDogc3JjRGlmZiAqIDggLSA3O1xuICAgICAgICBjb25zdCBrRW5kVW5yb2xsZWQgPSBrRW5kICYgfjc7XG4gICAgICAgIGxldCBtYXNrID0gMDtcbiAgICAgICAgbGV0IHNyY0J5dGUgPSAwO1xuICAgICAgICBmb3IgKDsgayA8IGtFbmRVbnJvbGxlZDsgayArPSA4KSB7XG4gICAgICAgICAgc3JjQnl0ZSA9IHNyY1tzcmNQb3MrK107XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMTI4ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiA2NCA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMzIgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDE2ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiA4ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiA0ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAyID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAxID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgayA8IGtFbmQ7IGsrKykge1xuICAgICAgICAgIGlmIChtYXNrID09PSAwKSB7XG4gICAgICAgICAgICBzcmNCeXRlID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgICAgIG1hc2sgPSAxMjg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIG1hc2sgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIG1hc2sgPj49IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChkZXN0UG9zIDwgZGVzdDMyRGF0YUxlbmd0aCkge1xuICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IDA7XG4gICAgICB9XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKGNodW5rSW1nRGF0YSwgMCwgaSAqIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaW1nRGF0YS5raW5kID09PSB1dGlsX0ltYWdlS2luZC5SR0JBXzMyQlBQKSB7XG4gICAgaiA9IDA7XG4gICAgZWxlbXNJblRoaXNDaHVuayA9IHdpZHRoICogRlVMTF9DSFVOS19IRUlHSFQgKiA0O1xuICAgIGZvciAoaSA9IDA7IGkgPCBmdWxsQ2h1bmtzOyBpKyspIHtcbiAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNQb3MsIHNyY1BvcyArIGVsZW1zSW5UaGlzQ2h1bmspKTtcbiAgICAgIHNyY1BvcyArPSBlbGVtc0luVGhpc0NodW5rO1xuICAgICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGopO1xuICAgICAgaiArPSBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgICB9XG4gICAgaWYgKGkgPCB0b3RhbENodW5rcykge1xuICAgICAgZWxlbXNJblRoaXNDaHVuayA9IHdpZHRoICogcGFydGlhbENodW5rSGVpZ2h0ICogNDtcbiAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNQb3MsIHNyY1BvcyArIGVsZW1zSW5UaGlzQ2h1bmspKTtcbiAgICAgIGN0eC5wdXRJbWFnZURhdGEoY2h1bmtJbWdEYXRhLCAwLCBqKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaW1nRGF0YS5raW5kID09PSB1dGlsX0ltYWdlS2luZC5SR0JfMjRCUFApIHtcbiAgICB0aGlzQ2h1bmtIZWlnaHQgPSBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgICBlbGVtc0luVGhpc0NodW5rID0gd2lkdGggKiB0aGlzQ2h1bmtIZWlnaHQ7XG4gICAgZm9yIChpID0gMDsgaSA8IHRvdGFsQ2h1bmtzOyBpKyspIHtcbiAgICAgIGlmIChpID49IGZ1bGxDaHVua3MpIHtcbiAgICAgICAgdGhpc0NodW5rSGVpZ2h0ID0gcGFydGlhbENodW5rSGVpZ2h0O1xuICAgICAgICBlbGVtc0luVGhpc0NodW5rID0gd2lkdGggKiB0aGlzQ2h1bmtIZWlnaHQ7XG4gICAgICB9XG4gICAgICBkZXN0UG9zID0gMDtcbiAgICAgIGZvciAoaiA9IGVsZW1zSW5UaGlzQ2h1bms7IGotLTspIHtcbiAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gMjU1O1xuICAgICAgfVxuICAgICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGkgKiBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgYmFkIGltYWdlIGtpbmQ6ICR7aW1nRGF0YS5raW5kfWApO1xuICB9XG59XG5mdW5jdGlvbiBwdXRCaW5hcnlJbWFnZU1hc2soY3R4LCBpbWdEYXRhKSB7XG4gIGlmIChpbWdEYXRhLmJpdG1hcCkge1xuICAgIGN0eC5kcmF3SW1hZ2UoaW1nRGF0YS5iaXRtYXAsIDAsIDApO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodCxcbiAgICB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gIGNvbnN0IHBhcnRpYWxDaHVua0hlaWdodCA9IGhlaWdodCAlIEZVTExfQ0hVTktfSEVJR0hUO1xuICBjb25zdCBmdWxsQ2h1bmtzID0gKGhlaWdodCAtIHBhcnRpYWxDaHVua0hlaWdodCkgLyBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgY29uc3QgdG90YWxDaHVua3MgPSBwYXJ0aWFsQ2h1bmtIZWlnaHQgPT09IDAgPyBmdWxsQ2h1bmtzIDogZnVsbENodW5rcyArIDE7XG4gIGNvbnN0IGNodW5rSW1nRGF0YSA9IGN0eC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgbGV0IHNyY1BvcyA9IDA7XG4gIGNvbnN0IHNyYyA9IGltZ0RhdGEuZGF0YTtcbiAgY29uc3QgZGVzdCA9IGNodW5rSW1nRGF0YS5kYXRhO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsQ2h1bmtzOyBpKyspIHtcbiAgICBjb25zdCB0aGlzQ2h1bmtIZWlnaHQgPSBpIDwgZnVsbENodW5rcyA/IEZVTExfQ0hVTktfSEVJR0hUIDogcGFydGlhbENodW5rSGVpZ2h0O1xuICAgICh7XG4gICAgICBzcmNQb3NcbiAgICB9ID0gY29udmVydEJsYWNrQW5kV2hpdGVUb1JHQkEoe1xuICAgICAgc3JjLFxuICAgICAgc3JjUG9zLFxuICAgICAgZGVzdCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzQ2h1bmtIZWlnaHQsXG4gICAgICBub25CbGFja0NvbG9yOiAwXG4gICAgfSkpO1xuICAgIGN0eC5wdXRJbWFnZURhdGEoY2h1bmtJbWdEYXRhLCAwLCBpICogRlVMTF9DSFVOS19IRUlHSFQpO1xuICB9XG59XG5mdW5jdGlvbiBjb3B5Q3R4U3RhdGUoc291cmNlQ3R4LCBkZXN0Q3R4KSB7XG4gIGNvbnN0IHByb3BlcnRpZXMgPSBbXCJzdHJva2VTdHlsZVwiLCBcImZpbGxTdHlsZVwiLCBcImZpbGxSdWxlXCIsIFwiZ2xvYmFsQWxwaGFcIiwgXCJsaW5lV2lkdGhcIiwgXCJsaW5lQ2FwXCIsIFwibGluZUpvaW5cIiwgXCJtaXRlckxpbWl0XCIsIFwiZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXCIsIFwiZm9udFwiLCBcImZpbHRlclwiXTtcbiAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKHNvdXJjZUN0eFtwcm9wZXJ0eV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVzdEN0eFtwcm9wZXJ0eV0gPSBzb3VyY2VDdHhbcHJvcGVydHldO1xuICAgIH1cbiAgfVxuICBpZiAoc291cmNlQ3R4LnNldExpbmVEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICBkZXN0Q3R4LnNldExpbmVEYXNoKHNvdXJjZUN0eC5nZXRMaW5lRGFzaCgpKTtcbiAgICBkZXN0Q3R4LmxpbmVEYXNoT2Zmc2V0ID0gc291cmNlQ3R4LmxpbmVEYXNoT2Zmc2V0O1xuICB9XG59XG5mdW5jdGlvbiByZXNldEN0eFRvRGVmYXVsdChjdHgpIHtcbiAgY3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZSA9IFwiIzAwMDAwMFwiO1xuICBjdHguZmlsbFJ1bGUgPSBcIm5vbnplcm9cIjtcbiAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gIGN0eC5saW5lQ2FwID0gXCJidXR0XCI7XG4gIGN0eC5saW5lSm9pbiA9IFwibWl0ZXJcIjtcbiAgY3R4Lm1pdGVyTGltaXQgPSAxMDtcbiAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLW92ZXJcIjtcbiAgY3R4LmZvbnQgPSBcIjEwcHggc2Fucy1zZXJpZlwiO1xuICBpZiAoY3R4LnNldExpbmVEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICBjdHguc2V0TGluZURhc2goW10pO1xuICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IDA7XG4gIH1cbiAgaWYgKCFpc05vZGVKUykge1xuICAgIGNvbnN0IHtcbiAgICAgIGZpbHRlclxuICAgIH0gPSBjdHg7XG4gICAgaWYgKGZpbHRlciAhPT0gXCJub25lXCIgJiYgZmlsdGVyICE9PSBcIlwiKSB7XG4gICAgICBjdHguZmlsdGVyID0gXCJub25lXCI7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRJbWFnZVNtb290aGluZ0VuYWJsZWQodHJhbnNmb3JtLCBpbnRlcnBvbGF0ZSkge1xuICBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBzY2FsZSA9IFV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodHJhbnNmb3JtKTtcbiAgc2NhbGVbMF0gPSBNYXRoLmZyb3VuZChzY2FsZVswXSk7XG4gIHNjYWxlWzFdID0gTWF0aC5mcm91bmQoc2NhbGVbMV0pO1xuICBjb25zdCBhY3R1YWxTY2FsZSA9IE1hdGguZnJvdW5kKChnbG9iYWxUaGlzLmRldmljZVBpeGVsUmF0aW8gfHwgMSkgKiBQaXhlbHNQZXJJbmNoLlBERl9UT19DU1NfVU5JVFMpO1xuICByZXR1cm4gc2NhbGVbMF0gPD0gYWN0dWFsU2NhbGUgJiYgc2NhbGVbMV0gPD0gYWN0dWFsU2NhbGU7XG59XG5jb25zdCBMSU5FX0NBUF9TVFlMRVMgPSBbXCJidXR0XCIsIFwicm91bmRcIiwgXCJzcXVhcmVcIl07XG5jb25zdCBMSU5FX0pPSU5fU1RZTEVTID0gW1wibWl0ZXJcIiwgXCJyb3VuZFwiLCBcImJldmVsXCJdO1xuY29uc3QgTk9STUFMX0NMSVAgPSB7fTtcbmNvbnN0IEVPX0NMSVAgPSB7fTtcbmNsYXNzIENhbnZhc0dyYXBoaWNzIHtcbiAgY29uc3RydWN0b3IoY2FudmFzQ3R4LCBjb21tb25PYmpzLCBvYmpzLCBjYW52YXNGYWN0b3J5LCBmaWx0ZXJGYWN0b3J5LCB7XG4gICAgb3B0aW9uYWxDb250ZW50Q29uZmlnLFxuICAgIG1hcmtlZENvbnRlbnRTdGFjayA9IG51bGxcbiAgfSwgYW5ub3RhdGlvbkNhbnZhc01hcCwgcGFnZUNvbG9ycykge1xuICAgIHRoaXMuY3R4ID0gY2FudmFzQ3R4O1xuICAgIHRoaXMuY3VycmVudCA9IG5ldyBDYW52YXNFeHRyYVN0YXRlKHRoaXMuY3R4LmNhbnZhcy53aWR0aCwgdGhpcy5jdHguY2FudmFzLmhlaWdodCk7XG4gICAgdGhpcy5zdGF0ZVN0YWNrID0gW107XG4gICAgdGhpcy5wZW5kaW5nQ2xpcCA9IG51bGw7XG4gICAgdGhpcy5wZW5kaW5nRU9GaWxsID0gZmFsc2U7XG4gICAgdGhpcy5yZXMgPSBudWxsO1xuICAgIHRoaXMueG9ianMgPSBudWxsO1xuICAgIHRoaXMuY29tbW9uT2JqcyA9IGNvbW1vbk9ianM7XG4gICAgdGhpcy5vYmpzID0gb2JqcztcbiAgICB0aGlzLmNhbnZhc0ZhY3RvcnkgPSBjYW52YXNGYWN0b3J5O1xuICAgIHRoaXMuZmlsdGVyRmFjdG9yeSA9IGZpbHRlckZhY3Rvcnk7XG4gICAgdGhpcy5ncm91cFN0YWNrID0gW107XG4gICAgdGhpcy5wcm9jZXNzaW5nVHlwZTMgPSBudWxsO1xuICAgIHRoaXMuYmFzZVRyYW5zZm9ybSA9IG51bGw7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtU3RhY2sgPSBbXTtcbiAgICB0aGlzLmdyb3VwTGV2ZWwgPSAwO1xuICAgIHRoaXMuc21hc2tTdGFjayA9IFtdO1xuICAgIHRoaXMuc21hc2tDb3VudGVyID0gMDtcbiAgICB0aGlzLnRlbXBTTWFzayA9IG51bGw7XG4gICAgdGhpcy5zdXNwZW5kZWRDdHggPSBudWxsO1xuICAgIHRoaXMuY29udGVudFZpc2libGUgPSB0cnVlO1xuICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrID0gbWFya2VkQ29udGVudFN0YWNrIHx8IFtdO1xuICAgIHRoaXMub3B0aW9uYWxDb250ZW50Q29uZmlnID0gb3B0aW9uYWxDb250ZW50Q29uZmlnO1xuICAgIHRoaXMuY2FjaGVkQ2FudmFzZXMgPSBuZXcgQ2FjaGVkQ2FudmFzZXModGhpcy5jYW52YXNGYWN0b3J5KTtcbiAgICB0aGlzLmNhY2hlZFBhdHRlcm5zID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuYW5ub3RhdGlvbkNhbnZhc01hcCA9IGFubm90YXRpb25DYW52YXNNYXA7XG4gICAgdGhpcy52aWV3cG9ydFNjYWxlID0gMTtcbiAgICB0aGlzLm91dHB1dFNjYWxlWCA9IDE7XG4gICAgdGhpcy5vdXRwdXRTY2FsZVkgPSAxO1xuICAgIHRoaXMucGFnZUNvbG9ycyA9IHBhZ2VDb2xvcnM7XG4gICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZyA9IFstMSwgMF07XG4gICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IG51bGw7XG4gICAgdGhpcy5fY2FjaGVkQml0bWFwc01hcCA9IG5ldyBNYXAoKTtcbiAgfVxuICBnZXRPYmplY3QoZGF0YSwgZmFsbGJhY2sgPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gZGF0YS5zdGFydHNXaXRoKFwiZ19cIikgPyB0aGlzLmNvbW1vbk9ianMuZ2V0KGRhdGEpIDogdGhpcy5vYmpzLmdldChkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbGxiYWNrO1xuICB9XG4gIGJlZ2luRHJhd2luZyh7XG4gICAgdHJhbnNmb3JtLFxuICAgIHZpZXdwb3J0LFxuICAgIHRyYW5zcGFyZW5jeSA9IGZhbHNlLFxuICAgIGJhY2tncm91bmQgPSBudWxsXG4gIH0pIHtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMuY3R4LmNhbnZhcy53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0O1xuICAgIGNvbnN0IHNhdmVkRmlsbFN0eWxlID0gdGhpcy5jdHguZmlsbFN0eWxlO1xuICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmQgfHwgXCIjZmZmZmZmXCI7XG4gICAgdGhpcy5jdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5jdHguZmlsbFN0eWxlID0gc2F2ZWRGaWxsU3R5bGU7XG4gICAgaWYgKHRyYW5zcGFyZW5jeSkge1xuICAgICAgY29uc3QgdHJhbnNwYXJlbnRDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcInRyYW5zcGFyZW50XCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5jb21wb3NpdGVDdHggPSB0aGlzLmN0eDtcbiAgICAgIHRoaXMudHJhbnNwYXJlbnRDYW52YXMgPSB0cmFuc3BhcmVudENhbnZhcy5jYW52YXM7XG4gICAgICB0aGlzLmN0eCA9IHRyYW5zcGFyZW50Q2FudmFzLmNvbnRleHQ7XG4gICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICB0aGlzLmN0eC50cmFuc2Zvcm0oLi4uZ2V0Q3VycmVudFRyYW5zZm9ybSh0aGlzLmNvbXBvc2l0ZUN0eCkpO1xuICAgIH1cbiAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgcmVzZXRDdHhUb0RlZmF1bHQodGhpcy5jdHgpO1xuICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgIHRoaXMuY3R4LnRyYW5zZm9ybSguLi50cmFuc2Zvcm0pO1xuICAgICAgdGhpcy5vdXRwdXRTY2FsZVggPSB0cmFuc2Zvcm1bMF07XG4gICAgICB0aGlzLm91dHB1dFNjYWxlWSA9IHRyYW5zZm9ybVswXTtcbiAgICB9XG4gICAgdGhpcy5jdHgudHJhbnNmb3JtKC4uLnZpZXdwb3J0LnRyYW5zZm9ybSk7XG4gICAgdGhpcy52aWV3cG9ydFNjYWxlID0gdmlld3BvcnQuc2NhbGU7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtID0gZ2V0Q3VycmVudFRyYW5zZm9ybSh0aGlzLmN0eCk7XG4gIH1cbiAgZXhlY3V0ZU9wZXJhdG9yTGlzdChvcGVyYXRvckxpc3QsIGV4ZWN1dGlvblN0YXJ0SWR4LCBjb250aW51ZUNhbGxiYWNrLCBzdGVwcGVyKSB7XG4gICAgY29uc3QgYXJnc0FycmF5ID0gb3BlcmF0b3JMaXN0LmFyZ3NBcnJheTtcbiAgICBjb25zdCBmbkFycmF5ID0gb3BlcmF0b3JMaXN0LmZuQXJyYXk7XG4gICAgbGV0IGkgPSBleGVjdXRpb25TdGFydElkeCB8fCAwO1xuICAgIGNvbnN0IGFyZ3NBcnJheUxlbiA9IGFyZ3NBcnJheS5sZW5ndGg7XG4gICAgaWYgKGFyZ3NBcnJheUxlbiA9PT0gaSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIGNvbnN0IGNodW5rT3BlcmF0aW9ucyA9IGFyZ3NBcnJheUxlbiAtIGkgPiBFWEVDVVRJT05fU1RFUFMgJiYgdHlwZW9mIGNvbnRpbnVlQ2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIjtcbiAgICBjb25zdCBlbmRUaW1lID0gY2h1bmtPcGVyYXRpb25zID8gRGF0ZS5ub3coKSArIEVYRUNVVElPTl9USU1FIDogMDtcbiAgICBsZXQgc3RlcHMgPSAwO1xuICAgIGNvbnN0IGNvbW1vbk9ianMgPSB0aGlzLmNvbW1vbk9ianM7XG4gICAgY29uc3Qgb2JqcyA9IHRoaXMub2JqcztcbiAgICBsZXQgZm5JZDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKHN0ZXBwZXIgIT09IHVuZGVmaW5lZCAmJiBpID09PSBzdGVwcGVyLm5leHRCcmVha1BvaW50KSB7XG4gICAgICAgIHN0ZXBwZXIuYnJlYWtJdChpLCBjb250aW51ZUNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgICBmbklkID0gZm5BcnJheVtpXTtcbiAgICAgIGlmIChmbklkICE9PSBPUFMuZGVwZW5kZW5jeSkge1xuICAgICAgICB0aGlzW2ZuSWRdLmFwcGx5KHRoaXMsIGFyZ3NBcnJheVtpXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IGRlcE9iaklkIG9mIGFyZ3NBcnJheVtpXSkge1xuICAgICAgICAgIGNvbnN0IG9ianNQb29sID0gZGVwT2JqSWQuc3RhcnRzV2l0aChcImdfXCIpID8gY29tbW9uT2JqcyA6IG9ianM7XG4gICAgICAgICAgaWYgKCFvYmpzUG9vbC5oYXMoZGVwT2JqSWQpKSB7XG4gICAgICAgICAgICBvYmpzUG9vbC5nZXQoZGVwT2JqSWQsIGNvbnRpbnVlQ2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgICBpZiAoaSA9PT0gYXJnc0FycmF5TGVuKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgICAgaWYgKGNodW5rT3BlcmF0aW9ucyAmJiArK3N0ZXBzID4gRVhFQ1VUSU9OX1NURVBTKSB7XG4gICAgICAgIGlmIChEYXRlLm5vdygpID4gZW5kVGltZSkge1xuICAgICAgICAgIGNvbnRpbnVlQ2FsbGJhY2soKTtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICBzdGVwcyA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gICNyZXN0b3JlSW5pdGlhbFN0YXRlKCkge1xuICAgIHdoaWxlICh0aGlzLnN0YXRlU3RhY2subGVuZ3RoIHx8IHRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgPSBudWxsO1xuICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICBpZiAodGhpcy50cmFuc3BhcmVudENhbnZhcykge1xuICAgICAgdGhpcy5jdHggPSB0aGlzLmNvbXBvc2l0ZUN0eDtcbiAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZSh0aGlzLnRyYW5zcGFyZW50Q2FudmFzLCAwLCAwKTtcbiAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMudHJhbnNwYXJlbnRDYW52YXMgPSBudWxsO1xuICAgIH1cbiAgfVxuICBlbmREcmF3aW5nKCkge1xuICAgIHRoaXMuI3Jlc3RvcmVJbml0aWFsU3RhdGUoKTtcbiAgICB0aGlzLmNhY2hlZENhbnZhc2VzLmNsZWFyKCk7XG4gICAgdGhpcy5jYWNoZWRQYXR0ZXJucy5jbGVhcigpO1xuICAgIGZvciAoY29uc3QgY2FjaGUgb2YgdGhpcy5fY2FjaGVkQml0bWFwc01hcC52YWx1ZXMoKSkge1xuICAgICAgZm9yIChjb25zdCBjYW52YXMgb2YgY2FjaGUudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xuICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICB0aGlzLl9jYWNoZWRCaXRtYXBzTWFwLmNsZWFyKCk7XG4gICAgdGhpcy4jZHJhd0ZpbHRlcigpO1xuICB9XG4gICNkcmF3RmlsdGVyKCkge1xuICAgIGlmICh0aGlzLnBhZ2VDb2xvcnMpIHtcbiAgICAgIGNvbnN0IGhjbUZpbHRlcklkID0gdGhpcy5maWx0ZXJGYWN0b3J5LmFkZEhDTUZpbHRlcih0aGlzLnBhZ2VDb2xvcnMuZm9yZWdyb3VuZCwgdGhpcy5wYWdlQ29sb3JzLmJhY2tncm91bmQpO1xuICAgICAgaWYgKGhjbUZpbHRlcklkICE9PSBcIm5vbmVcIikge1xuICAgICAgICBjb25zdCBzYXZlZEZpbHRlciA9IHRoaXMuY3R4LmZpbHRlcjtcbiAgICAgICAgdGhpcy5jdHguZmlsdGVyID0gaGNtRmlsdGVySWQ7XG4gICAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZSh0aGlzLmN0eC5jYW52YXMsIDAsIDApO1xuICAgICAgICB0aGlzLmN0eC5maWx0ZXIgPSBzYXZlZEZpbHRlcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3NjYWxlSW1hZ2UoaW1nLCBpbnZlcnNlVHJhbnNmb3JtKSB7XG4gICAgY29uc3Qgd2lkdGggPSBpbWcud2lkdGggPz8gaW1nLmRpc3BsYXlXaWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWcuaGVpZ2h0ID8/IGltZy5kaXNwbGF5SGVpZ2h0O1xuICAgIGxldCB3aWR0aFNjYWxlID0gTWF0aC5tYXgoTWF0aC5oeXBvdChpbnZlcnNlVHJhbnNmb3JtWzBdLCBpbnZlcnNlVHJhbnNmb3JtWzFdKSwgMSk7XG4gICAgbGV0IGhlaWdodFNjYWxlID0gTWF0aC5tYXgoTWF0aC5oeXBvdChpbnZlcnNlVHJhbnNmb3JtWzJdLCBpbnZlcnNlVHJhbnNmb3JtWzNdKSwgMSk7XG4gICAgbGV0IHBhaW50V2lkdGggPSB3aWR0aCxcbiAgICAgIHBhaW50SGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGxldCB0bXBDYW52YXNJZCA9IFwicHJlc2NhbGUxXCI7XG4gICAgbGV0IHRtcENhbnZhcywgdG1wQ3R4O1xuICAgIHdoaWxlICh3aWR0aFNjYWxlID4gMiAmJiBwYWludFdpZHRoID4gMSB8fCBoZWlnaHRTY2FsZSA+IDIgJiYgcGFpbnRIZWlnaHQgPiAxKSB7XG4gICAgICBsZXQgbmV3V2lkdGggPSBwYWludFdpZHRoLFxuICAgICAgICBuZXdIZWlnaHQgPSBwYWludEhlaWdodDtcbiAgICAgIGlmICh3aWR0aFNjYWxlID4gMiAmJiBwYWludFdpZHRoID4gMSkge1xuICAgICAgICBuZXdXaWR0aCA9IHBhaW50V2lkdGggPj0gMTYzODQgPyBNYXRoLmZsb29yKHBhaW50V2lkdGggLyAyKSAtIDEgfHwgMSA6IE1hdGguY2VpbChwYWludFdpZHRoIC8gMik7XG4gICAgICAgIHdpZHRoU2NhbGUgLz0gcGFpbnRXaWR0aCAvIG5ld1dpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKGhlaWdodFNjYWxlID4gMiAmJiBwYWludEhlaWdodCA+IDEpIHtcbiAgICAgICAgbmV3SGVpZ2h0ID0gcGFpbnRIZWlnaHQgPj0gMTYzODQgPyBNYXRoLmZsb29yKHBhaW50SGVpZ2h0IC8gMikgLSAxIHx8IDEgOiBNYXRoLmNlaWwocGFpbnRIZWlnaHQpIC8gMjtcbiAgICAgICAgaGVpZ2h0U2NhbGUgLz0gcGFpbnRIZWlnaHQgLyBuZXdIZWlnaHQ7XG4gICAgICB9XG4gICAgICB0bXBDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyh0bXBDYW52YXNJZCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICAgIHRtcEN0eC5jbGVhclJlY3QoMCwgMCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICB0bXBDdHguZHJhd0ltYWdlKGltZywgMCwgMCwgcGFpbnRXaWR0aCwgcGFpbnRIZWlnaHQsIDAsIDAsIG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgaW1nID0gdG1wQ2FudmFzLmNhbnZhcztcbiAgICAgIHBhaW50V2lkdGggPSBuZXdXaWR0aDtcbiAgICAgIHBhaW50SGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgdG1wQ2FudmFzSWQgPSB0bXBDYW52YXNJZCA9PT0gXCJwcmVzY2FsZTFcIiA/IFwicHJlc2NhbGUyXCIgOiBcInByZXNjYWxlMVwiO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaW1nLFxuICAgICAgcGFpbnRXaWR0aCxcbiAgICAgIHBhaW50SGVpZ2h0XG4gICAgfTtcbiAgfVxuICBfY3JlYXRlTWFza0NhbnZhcyhpbWcpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBpbWc7XG4gICAgY29uc3QgZmlsbENvbG9yID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvcjtcbiAgICBjb25zdCBpc1BhdHRlcm5GaWxsID0gdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsO1xuICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCk7XG4gICAgbGV0IGNhY2hlLCBjYWNoZUtleSwgc2NhbGVkLCBtYXNrQ2FudmFzO1xuICAgIGlmICgoaW1nLmJpdG1hcCB8fCBpbWcuZGF0YSkgJiYgaW1nLmNvdW50ID4gMSkge1xuICAgICAgY29uc3QgbWFpbktleSA9IGltZy5iaXRtYXAgfHwgaW1nLmRhdGEuYnVmZmVyO1xuICAgICAgY2FjaGVLZXkgPSBKU09OLnN0cmluZ2lmeShpc1BhdHRlcm5GaWxsID8gY3VycmVudFRyYW5zZm9ybSA6IFtjdXJyZW50VHJhbnNmb3JtLnNsaWNlKDAsIDQpLCBmaWxsQ29sb3JdKTtcbiAgICAgIGNhY2hlID0gdGhpcy5fY2FjaGVkQml0bWFwc01hcC5nZXQobWFpbktleSk7XG4gICAgICBpZiAoIWNhY2hlKSB7XG4gICAgICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jYWNoZWRCaXRtYXBzTWFwLnNldChtYWluS2V5LCBjYWNoZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBjYWNoZWRJbWFnZSA9IGNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICBpZiAoY2FjaGVkSW1hZ2UgJiYgIWlzUGF0dGVybkZpbGwpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IE1hdGgucm91bmQoTWF0aC5taW4oY3VycmVudFRyYW5zZm9ybVswXSwgY3VycmVudFRyYW5zZm9ybVsyXSkgKyBjdXJyZW50VHJhbnNmb3JtWzRdKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WSA9IE1hdGgucm91bmQoTWF0aC5taW4oY3VycmVudFRyYW5zZm9ybVsxXSwgY3VycmVudFRyYW5zZm9ybVszXSkgKyBjdXJyZW50VHJhbnNmb3JtWzVdKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjYW52YXM6IGNhY2hlZEltYWdlLFxuICAgICAgICAgIG9mZnNldFgsXG4gICAgICAgICAgb2Zmc2V0WVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgc2NhbGVkID0gY2FjaGVkSW1hZ2U7XG4gICAgfVxuICAgIGlmICghc2NhbGVkKSB7XG4gICAgICBtYXNrQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJtYXNrQ2FudmFzXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgcHV0QmluYXJ5SW1hZ2VNYXNrKG1hc2tDYW52YXMuY29udGV4dCwgaW1nKTtcbiAgICB9XG4gICAgbGV0IG1hc2tUb0NhbnZhcyA9IFV0aWwudHJhbnNmb3JtKGN1cnJlbnRUcmFuc2Zvcm0sIFsxIC8gd2lkdGgsIDAsIDAsIC0xIC8gaGVpZ2h0LCAwLCAwXSk7XG4gICAgbWFza1RvQ2FudmFzID0gVXRpbC50cmFuc2Zvcm0obWFza1RvQ2FudmFzLCBbMSwgMCwgMCwgMSwgMCwgLWhlaWdodF0pO1xuICAgIGNvbnN0IFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSA9IFV0aWwuZ2V0QXhpYWxBbGlnbmVkQm91bmRpbmdCb3goWzAsIDAsIHdpZHRoLCBoZWlnaHRdLCBtYXNrVG9DYW52YXMpO1xuICAgIGNvbnN0IGRyYXduV2lkdGggPSBNYXRoLnJvdW5kKG1heFggLSBtaW5YKSB8fCAxO1xuICAgIGNvbnN0IGRyYXduSGVpZ2h0ID0gTWF0aC5yb3VuZChtYXhZIC0gbWluWSkgfHwgMTtcbiAgICBjb25zdCBmaWxsQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJmaWxsQ2FudmFzXCIsIGRyYXduV2lkdGgsIGRyYXduSGVpZ2h0KTtcbiAgICBjb25zdCBmaWxsQ3R4ID0gZmlsbENhbnZhcy5jb250ZXh0O1xuICAgIGNvbnN0IG9mZnNldFggPSBtaW5YO1xuICAgIGNvbnN0IG9mZnNldFkgPSBtaW5ZO1xuICAgIGZpbGxDdHgudHJhbnNsYXRlKC1vZmZzZXRYLCAtb2Zmc2V0WSk7XG4gICAgZmlsbEN0eC50cmFuc2Zvcm0oLi4ubWFza1RvQ2FudmFzKTtcbiAgICBpZiAoIXNjYWxlZCkge1xuICAgICAgc2NhbGVkID0gdGhpcy5fc2NhbGVJbWFnZShtYXNrQ2FudmFzLmNhbnZhcywgZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoZmlsbEN0eCkpO1xuICAgICAgc2NhbGVkID0gc2NhbGVkLmltZztcbiAgICAgIGlmIChjYWNoZSAmJiBpc1BhdHRlcm5GaWxsKSB7XG4gICAgICAgIGNhY2hlLnNldChjYWNoZUtleSwgc2NhbGVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZmlsbEN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBnZXRJbWFnZVNtb290aGluZ0VuYWJsZWQoZ2V0Q3VycmVudFRyYW5zZm9ybShmaWxsQ3R4KSwgaW1nLmludGVycG9sYXRlKTtcbiAgICBkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMoZmlsbEN0eCwgc2NhbGVkLCAwLCAwLCBzY2FsZWQud2lkdGgsIHNjYWxlZC5oZWlnaHQsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGZpbGxDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJzb3VyY2UtaW5cIjtcbiAgICBjb25zdCBpbnZlcnNlID0gVXRpbC50cmFuc2Zvcm0oZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoZmlsbEN0eCksIFsxLCAwLCAwLCAxLCAtb2Zmc2V0WCwgLW9mZnNldFldKTtcbiAgICBmaWxsQ3R4LmZpbGxTdHlsZSA9IGlzUGF0dGVybkZpbGwgPyBmaWxsQ29sb3IuZ2V0UGF0dGVybihjdHgsIHRoaXMsIGludmVyc2UsIFBhdGhUeXBlLkZJTEwpIDogZmlsbENvbG9yO1xuICAgIGZpbGxDdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgaWYgKGNhY2hlICYmICFpc1BhdHRlcm5GaWxsKSB7XG4gICAgICB0aGlzLmNhY2hlZENhbnZhc2VzLmRlbGV0ZShcImZpbGxDYW52YXNcIik7XG4gICAgICBjYWNoZS5zZXQoY2FjaGVLZXksIGZpbGxDYW52YXMuY2FudmFzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbnZhczogZmlsbENhbnZhcy5jYW52YXMsXG4gICAgICBvZmZzZXRYOiBNYXRoLnJvdW5kKG9mZnNldFgpLFxuICAgICAgb2Zmc2V0WTogTWF0aC5yb3VuZChvZmZzZXRZKVxuICAgIH07XG4gIH1cbiAgc2V0TGluZVdpZHRoKHdpZHRoKSB7XG4gICAgaWYgKHdpZHRoICE9PSB0aGlzLmN1cnJlbnQubGluZVdpZHRoKSB7XG4gICAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID0gLTE7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudC5saW5lV2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmN0eC5saW5lV2lkdGggPSB3aWR0aDtcbiAgfVxuICBzZXRMaW5lQ2FwKHN0eWxlKSB7XG4gICAgdGhpcy5jdHgubGluZUNhcCA9IExJTkVfQ0FQX1NUWUxFU1tzdHlsZV07XG4gIH1cbiAgc2V0TGluZUpvaW4oc3R5bGUpIHtcbiAgICB0aGlzLmN0eC5saW5lSm9pbiA9IExJTkVfSk9JTl9TVFlMRVNbc3R5bGVdO1xuICB9XG4gIHNldE1pdGVyTGltaXQobGltaXQpIHtcbiAgICB0aGlzLmN0eC5taXRlckxpbWl0ID0gbGltaXQ7XG4gIH1cbiAgc2V0RGFzaChkYXNoQXJyYXksIGRhc2hQaGFzZSkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGlmIChjdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgY3R4LnNldExpbmVEYXNoKGRhc2hBcnJheSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBkYXNoUGhhc2U7XG4gICAgfVxuICB9XG4gIHNldFJlbmRlcmluZ0ludGVudChpbnRlbnQpIHt9XG4gIHNldEZsYXRuZXNzKGZsYXRuZXNzKSB7fVxuICBzZXRHU3RhdGUoc3RhdGVzKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc3RhdGVzKSB7XG4gICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICBjYXNlIFwiTFdcIjpcbiAgICAgICAgICB0aGlzLnNldExpbmVXaWR0aCh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJMQ1wiOlxuICAgICAgICAgIHRoaXMuc2V0TGluZUNhcCh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJMSlwiOlxuICAgICAgICAgIHRoaXMuc2V0TGluZUpvaW4odmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTUxcIjpcbiAgICAgICAgICB0aGlzLnNldE1pdGVyTGltaXQodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRFwiOlxuICAgICAgICAgIHRoaXMuc2V0RGFzaCh2YWx1ZVswXSwgdmFsdWVbMV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiUklcIjpcbiAgICAgICAgICB0aGlzLnNldFJlbmRlcmluZ0ludGVudCh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJGTFwiOlxuICAgICAgICAgIHRoaXMuc2V0RmxhdG5lc3ModmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRm9udFwiOlxuICAgICAgICAgIHRoaXMuc2V0Rm9udCh2YWx1ZVswXSwgdmFsdWVbMV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQ0FcIjpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQWxwaGEgPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNhXCI6XG4gICAgICAgICAgdGhpcy5jdXJyZW50LmZpbGxBbHBoYSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJCTVwiOlxuICAgICAgICAgIHRoaXMuY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiU01hc2tcIjpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgPSB2YWx1ZSA/IHRoaXMudGVtcFNNYXNrIDogbnVsbDtcbiAgICAgICAgICB0aGlzLnRlbXBTTWFzayA9IG51bGw7XG4gICAgICAgICAgdGhpcy5jaGVja1NNYXNrU3RhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlRSXCI6XG4gICAgICAgICAgdGhpcy5jdHguZmlsdGVyID0gdGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcyA9IHRoaXMuZmlsdGVyRmFjdG9yeS5hZGRGaWx0ZXIodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgaW5TTWFza01vZGUoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5zdXNwZW5kZWRDdHg7XG4gIH1cbiAgY2hlY2tTTWFza1N0YXRlKCkge1xuICAgIGNvbnN0IGluU01hc2tNb2RlID0gdGhpcy5pblNNYXNrTW9kZTtcbiAgICBpZiAodGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrICYmICFpblNNYXNrTW9kZSkge1xuICAgICAgdGhpcy5iZWdpblNNYXNrTW9kZSgpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuY3VycmVudC5hY3RpdmVTTWFzayAmJiBpblNNYXNrTW9kZSkge1xuICAgICAgdGhpcy5lbmRTTWFza01vZGUoKTtcbiAgICB9XG4gIH1cbiAgYmVnaW5TTWFza01vZGUoKSB7XG4gICAgaWYgKHRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImJlZ2luU01hc2tNb2RlIGNhbGxlZCB3aGlsZSBhbHJlYWR5IGluIHNtYXNrIG1vZGVcIik7XG4gICAgfVxuICAgIGNvbnN0IGRyYXduV2lkdGggPSB0aGlzLmN0eC5jYW52YXMud2lkdGg7XG4gICAgY29uc3QgZHJhd25IZWlnaHQgPSB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0O1xuICAgIGNvbnN0IGNhY2hlSWQgPSBcInNtYXNrR3JvdXBBdFwiICsgdGhpcy5ncm91cExldmVsO1xuICAgIGNvbnN0IHNjcmF0Y2hDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhjYWNoZUlkLCBkcmF3bldpZHRoLCBkcmF3bkhlaWdodCk7XG4gICAgdGhpcy5zdXNwZW5kZWRDdHggPSB0aGlzLmN0eDtcbiAgICB0aGlzLmN0eCA9IHNjcmF0Y2hDYW52YXMuY29udGV4dDtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjdHguc2V0VHJhbnNmb3JtKC4uLmdldEN1cnJlbnRUcmFuc2Zvcm0odGhpcy5zdXNwZW5kZWRDdHgpKTtcbiAgICBjb3B5Q3R4U3RhdGUodGhpcy5zdXNwZW5kZWRDdHgsIGN0eCk7XG4gICAgbWlycm9yQ29udGV4dE9wZXJhdGlvbnMoY3R4LCB0aGlzLnN1c3BlbmRlZEN0eCk7XG4gICAgdGhpcy5zZXRHU3RhdGUoW1tcIkJNXCIsIFwic291cmNlLW92ZXJcIl0sIFtcImNhXCIsIDFdLCBbXCJDQVwiLCAxXV0pO1xuICB9XG4gIGVuZFNNYXNrTW9kZSgpIHtcbiAgICBpZiAoIXRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImVuZFNNYXNrTW9kZSBjYWxsZWQgd2hpbGUgbm90IGluIHNtYXNrIG1vZGVcIik7XG4gICAgfVxuICAgIHRoaXMuY3R4Ll9yZW1vdmVNaXJyb3JpbmcoKTtcbiAgICBjb3B5Q3R4U3RhdGUodGhpcy5jdHgsIHRoaXMuc3VzcGVuZGVkQ3R4KTtcbiAgICB0aGlzLmN0eCA9IHRoaXMuc3VzcGVuZGVkQ3R4O1xuICAgIHRoaXMuc3VzcGVuZGVkQ3R4ID0gbnVsbDtcbiAgfVxuICBjb21wb3NlKGRpcnR5Qm94KSB7XG4gICAgaWYgKCF0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFkaXJ0eUJveCkge1xuICAgICAgZGlydHlCb3ggPSBbMCwgMCwgdGhpcy5jdHguY2FudmFzLndpZHRoLCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlydHlCb3hbMF0gPSBNYXRoLmZsb29yKGRpcnR5Qm94WzBdKTtcbiAgICAgIGRpcnR5Qm94WzFdID0gTWF0aC5mbG9vcihkaXJ0eUJveFsxXSk7XG4gICAgICBkaXJ0eUJveFsyXSA9IE1hdGguY2VpbChkaXJ0eUJveFsyXSk7XG4gICAgICBkaXJ0eUJveFszXSA9IE1hdGguY2VpbChkaXJ0eUJveFszXSk7XG4gICAgfVxuICAgIGNvbnN0IHNtYXNrID0gdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrO1xuICAgIGNvbnN0IHN1c3BlbmRlZEN0eCA9IHRoaXMuc3VzcGVuZGVkQ3R4O1xuICAgIHRoaXMuY29tcG9zZVNNYXNrKHN1c3BlbmRlZEN0eCwgc21hc2ssIHRoaXMuY3R4LCBkaXJ0eUJveCk7XG4gICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICB0aGlzLmN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jdHguY2FudmFzLndpZHRoLCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgY29tcG9zZVNNYXNrKGN0eCwgc21hc2ssIGxheWVyQ3R4LCBsYXllckJveCkge1xuICAgIGNvbnN0IGxheWVyT2Zmc2V0WCA9IGxheWVyQm94WzBdO1xuICAgIGNvbnN0IGxheWVyT2Zmc2V0WSA9IGxheWVyQm94WzFdO1xuICAgIGNvbnN0IGxheWVyV2lkdGggPSBsYXllckJveFsyXSAtIGxheWVyT2Zmc2V0WDtcbiAgICBjb25zdCBsYXllckhlaWdodCA9IGxheWVyQm94WzNdIC0gbGF5ZXJPZmZzZXRZO1xuICAgIGlmIChsYXllcldpZHRoID09PSAwIHx8IGxheWVySGVpZ2h0ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZ2VuZXJpY0NvbXBvc2VTTWFzayhzbWFzay5jb250ZXh0LCBsYXllckN0eCwgbGF5ZXJXaWR0aCwgbGF5ZXJIZWlnaHQsIHNtYXNrLnN1YnR5cGUsIHNtYXNrLmJhY2tkcm9wLCBzbWFzay50cmFuc2Zlck1hcCwgbGF5ZXJPZmZzZXRYLCBsYXllck9mZnNldFksIHNtYXNrLm9mZnNldFgsIHNtYXNrLm9mZnNldFkpO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJzb3VyY2Utb3ZlclwiO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgY3R4LmRyYXdJbWFnZShsYXllckN0eC5jYW52YXMsIDAsIDApO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgZ2VuZXJpY0NvbXBvc2VTTWFzayhtYXNrQ3R4LCBsYXllckN0eCwgd2lkdGgsIGhlaWdodCwgc3VidHlwZSwgYmFja2Ryb3AsIHRyYW5zZmVyTWFwLCBsYXllck9mZnNldFgsIGxheWVyT2Zmc2V0WSwgbWFza09mZnNldFgsIG1hc2tPZmZzZXRZKSB7XG4gICAgbGV0IG1hc2tDYW52YXMgPSBtYXNrQ3R4LmNhbnZhcztcbiAgICBsZXQgbWFza1ggPSBsYXllck9mZnNldFggLSBtYXNrT2Zmc2V0WDtcbiAgICBsZXQgbWFza1kgPSBsYXllck9mZnNldFkgLSBtYXNrT2Zmc2V0WTtcbiAgICBpZiAoYmFja2Ryb3ApIHtcbiAgICAgIGNvbnN0IGJhY2tkcm9wUkdCID0gVXRpbC5tYWtlSGV4Q29sb3IoLi4uYmFja2Ryb3ApO1xuICAgICAgaWYgKG1hc2tYIDwgMCB8fCBtYXNrWSA8IDAgfHwgbWFza1ggKyB3aWR0aCA+IG1hc2tDYW52YXMud2lkdGggfHwgbWFza1kgKyBoZWlnaHQgPiBtYXNrQ2FudmFzLmhlaWdodCkge1xuICAgICAgICBjb25zdCBjYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcIm1hc2tFeHRlbnNpb25cIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5jb250ZXh0O1xuICAgICAgICBjdHguZHJhd0ltYWdlKG1hc2tDYW52YXMsIC1tYXNrWCwgLW1hc2tZKTtcbiAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwiZGVzdGluYXRpb24tYXRvcFwiO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gYmFja2Ryb3BSR0I7XG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLW92ZXJcIjtcbiAgICAgICAgbWFza0NhbnZhcyA9IGNhbnZhcy5jYW52YXM7XG4gICAgICAgIG1hc2tYID0gbWFza1kgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFza0N0eC5zYXZlKCk7XG4gICAgICAgIG1hc2tDdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICBtYXNrQ3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgY29uc3QgY2xpcCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgICAgY2xpcC5yZWN0KG1hc2tYLCBtYXNrWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIG1hc2tDdHguY2xpcChjbGlwKTtcbiAgICAgICAgbWFza0N0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcImRlc3RpbmF0aW9uLWF0b3BcIjtcbiAgICAgICAgbWFza0N0eC5maWxsU3R5bGUgPSBiYWNrZHJvcFJHQjtcbiAgICAgICAgbWFza0N0eC5maWxsUmVjdChtYXNrWCwgbWFza1ksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBtYXNrQ3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGF5ZXJDdHguc2F2ZSgpO1xuICAgIGxheWVyQ3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICBsYXllckN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgaWYgKHN1YnR5cGUgPT09IFwiQWxwaGFcIiAmJiB0cmFuc2Zlck1hcCkge1xuICAgICAgbGF5ZXJDdHguZmlsdGVyID0gdGhpcy5maWx0ZXJGYWN0b3J5LmFkZEFscGhhRmlsdGVyKHRyYW5zZmVyTWFwKTtcbiAgICB9IGVsc2UgaWYgKHN1YnR5cGUgPT09IFwiTHVtaW5vc2l0eVwiKSB7XG4gICAgICBsYXllckN0eC5maWx0ZXIgPSB0aGlzLmZpbHRlckZhY3RvcnkuYWRkTHVtaW5vc2l0eUZpbHRlcih0cmFuc2Zlck1hcCk7XG4gICAgfVxuICAgIGNvbnN0IGNsaXAgPSBuZXcgUGF0aDJEKCk7XG4gICAgY2xpcC5yZWN0KGxheWVyT2Zmc2V0WCwgbGF5ZXJPZmZzZXRZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBsYXllckN0eC5jbGlwKGNsaXApO1xuICAgIGxheWVyQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwiZGVzdGluYXRpb24taW5cIjtcbiAgICBsYXllckN0eC5kcmF3SW1hZ2UobWFza0NhbnZhcywgbWFza1gsIG1hc2tZLCB3aWR0aCwgaGVpZ2h0LCBsYXllck9mZnNldFgsIGxheWVyT2Zmc2V0WSwgd2lkdGgsIGhlaWdodCk7XG4gICAgbGF5ZXJDdHgucmVzdG9yZSgpO1xuICB9XG4gIHNhdmUoKSB7XG4gICAgaWYgKHRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIGNvcHlDdHhTdGF0ZSh0aGlzLmN0eCwgdGhpcy5zdXNwZW5kZWRDdHgpO1xuICAgICAgdGhpcy5zdXNwZW5kZWRDdHguc2F2ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgfVxuICAgIGNvbnN0IG9sZCA9IHRoaXMuY3VycmVudDtcbiAgICB0aGlzLnN0YXRlU3RhY2sucHVzaChvbGQpO1xuICAgIHRoaXMuY3VycmVudCA9IG9sZC5jbG9uZSgpO1xuICB9XG4gIHJlc3RvcmUoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGVTdGFjay5sZW5ndGggPT09IDAgJiYgdGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgdGhpcy5lbmRTTWFza01vZGUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RhdGVTdGFjay5sZW5ndGggIT09IDApIHtcbiAgICAgIHRoaXMuY3VycmVudCA9IHRoaXMuc3RhdGVTdGFjay5wb3AoKTtcbiAgICAgIGlmICh0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICAgIHRoaXMuc3VzcGVuZGVkQ3R4LnJlc3RvcmUoKTtcbiAgICAgICAgY29weUN0eFN0YXRlKHRoaXMuc3VzcGVuZGVkQ3R4LCB0aGlzLmN0eCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNoZWNrU01hc2tTdGF0ZSgpO1xuICAgICAgdGhpcy5wZW5kaW5nQ2xpcCA9IG51bGw7XG4gICAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID0gLTE7XG4gICAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgdHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICB0aGlzLmN0eC50cmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZik7XG4gICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1swXSA9IC0xO1xuICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSBudWxsO1xuICB9XG4gIGNvbnN0cnVjdFBhdGgob3BzLCBhcmdzLCBtaW5NYXgpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGxldCB4ID0gY3VycmVudC54LFxuICAgICAgeSA9IGN1cnJlbnQueTtcbiAgICBsZXQgc3RhcnRYLCBzdGFydFk7XG4gICAgY29uc3QgY3VycmVudFRyYW5zZm9ybSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KTtcbiAgICBjb25zdCBpc1NjYWxpbmdNYXRyaXggPSBjdXJyZW50VHJhbnNmb3JtWzBdID09PSAwICYmIGN1cnJlbnRUcmFuc2Zvcm1bM10gPT09IDAgfHwgY3VycmVudFRyYW5zZm9ybVsxXSA9PT0gMCAmJiBjdXJyZW50VHJhbnNmb3JtWzJdID09PSAwO1xuICAgIGNvbnN0IG1pbk1heEZvckJlemllciA9IGlzU2NhbGluZ01hdHJpeCA/IG1pbk1heC5zbGljZSgwKSA6IG51bGw7XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSAwLCBpaSA9IG9wcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBzd2l0Y2ggKG9wc1tpXSB8IDApIHtcbiAgICAgICAgY2FzZSBPUFMucmVjdGFuZ2xlOlxuICAgICAgICAgIHggPSBhcmdzW2orK107XG4gICAgICAgICAgeSA9IGFyZ3NbaisrXTtcbiAgICAgICAgICBjb25zdCB3aWR0aCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICBjb25zdCBoZWlnaHQgPSBhcmdzW2orK107XG4gICAgICAgICAgY29uc3QgeHcgPSB4ICsgd2lkdGg7XG4gICAgICAgICAgY29uc3QgeWggPSB5ICsgaGVpZ2h0O1xuICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgaWYgKHdpZHRoID09PSAwIHx8IGhlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4dywgeWgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHh3LCB5KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeHcsIHloKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeWgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzU2NhbGluZ01hdHJpeCkge1xuICAgICAgICAgICAgY3VycmVudC51cGRhdGVSZWN0TWluTWF4KGN1cnJlbnRUcmFuc2Zvcm0sIFt4LCB5LCB4dywgeWhdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE9QUy5tb3ZlVG86XG4gICAgICAgICAgeCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICB5ID0gYXJnc1tqKytdO1xuICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgaWYgKCFpc1NjYWxpbmdNYXRyaXgpIHtcbiAgICAgICAgICAgIGN1cnJlbnQudXBkYXRlUGF0aE1pbk1heChjdXJyZW50VHJhbnNmb3JtLCB4LCB5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgT1BTLmxpbmVUbzpcbiAgICAgICAgICB4ID0gYXJnc1tqKytdO1xuICAgICAgICAgIHkgPSBhcmdzW2orK107XG4gICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICBpZiAoIWlzU2NhbGluZ01hdHJpeCkge1xuICAgICAgICAgICAgY3VycmVudC51cGRhdGVQYXRoTWluTWF4KGN1cnJlbnRUcmFuc2Zvcm0sIHgsIHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBPUFMuY3VydmVUbzpcbiAgICAgICAgICBzdGFydFggPSB4O1xuICAgICAgICAgIHN0YXJ0WSA9IHk7XG4gICAgICAgICAgeCA9IGFyZ3NbaiArIDRdO1xuICAgICAgICAgIHkgPSBhcmdzW2ogKyA1XTtcbiAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhhcmdzW2pdLCBhcmdzW2ogKyAxXSwgYXJnc1tqICsgMl0sIGFyZ3NbaiArIDNdLCB4LCB5KTtcbiAgICAgICAgICBjdXJyZW50LnVwZGF0ZUN1cnZlUGF0aE1pbk1heChjdXJyZW50VHJhbnNmb3JtLCBzdGFydFgsIHN0YXJ0WSwgYXJnc1tqXSwgYXJnc1tqICsgMV0sIGFyZ3NbaiArIDJdLCBhcmdzW2ogKyAzXSwgeCwgeSwgbWluTWF4Rm9yQmV6aWVyKTtcbiAgICAgICAgICBqICs9IDY7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgT1BTLmN1cnZlVG8yOlxuICAgICAgICAgIHN0YXJ0WCA9IHg7XG4gICAgICAgICAgc3RhcnRZID0geTtcbiAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh4LCB5LCBhcmdzW2pdLCBhcmdzW2ogKyAxXSwgYXJnc1tqICsgMl0sIGFyZ3NbaiArIDNdKTtcbiAgICAgICAgICBjdXJyZW50LnVwZGF0ZUN1cnZlUGF0aE1pbk1heChjdXJyZW50VHJhbnNmb3JtLCBzdGFydFgsIHN0YXJ0WSwgeCwgeSwgYXJnc1tqXSwgYXJnc1tqICsgMV0sIGFyZ3NbaiArIDJdLCBhcmdzW2ogKyAzXSwgbWluTWF4Rm9yQmV6aWVyKTtcbiAgICAgICAgICB4ID0gYXJnc1tqICsgMl07XG4gICAgICAgICAgeSA9IGFyZ3NbaiArIDNdO1xuICAgICAgICAgIGogKz0gNDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBPUFMuY3VydmVUbzM6XG4gICAgICAgICAgc3RhcnRYID0geDtcbiAgICAgICAgICBzdGFydFkgPSB5O1xuICAgICAgICAgIHggPSBhcmdzW2ogKyAyXTtcbiAgICAgICAgICB5ID0gYXJnc1tqICsgM107XG4gICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oYXJnc1tqXSwgYXJnc1tqICsgMV0sIHgsIHksIHgsIHkpO1xuICAgICAgICAgIGN1cnJlbnQudXBkYXRlQ3VydmVQYXRoTWluTWF4KGN1cnJlbnRUcmFuc2Zvcm0sIHN0YXJ0WCwgc3RhcnRZLCBhcmdzW2pdLCBhcmdzW2ogKyAxXSwgeCwgeSwgeCwgeSwgbWluTWF4Rm9yQmV6aWVyKTtcbiAgICAgICAgICBqICs9IDQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgT1BTLmNsb3NlUGF0aDpcbiAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc1NjYWxpbmdNYXRyaXgpIHtcbiAgICAgIGN1cnJlbnQudXBkYXRlU2NhbGluZ1BhdGhNaW5NYXgoY3VycmVudFRyYW5zZm9ybSwgbWluTWF4Rm9yQmV6aWVyKTtcbiAgICB9XG4gICAgY3VycmVudC5zZXRDdXJyZW50UG9pbnQoeCwgeSk7XG4gIH1cbiAgY2xvc2VQYXRoKCkge1xuICAgIHRoaXMuY3R4LmNsb3NlUGF0aCgpO1xuICB9XG4gIHN0cm9rZShjb25zdW1lUGF0aCA9IHRydWUpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBzdHJva2VDb2xvciA9IHRoaXMuY3VycmVudC5zdHJva2VDb2xvcjtcbiAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmN1cnJlbnQuc3Ryb2tlQWxwaGE7XG4gICAgaWYgKHRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIGlmICh0eXBlb2Ygc3Ryb2tlQ29sb3IgPT09IFwib2JqZWN0XCIgJiYgc3Ryb2tlQ29sb3I/LmdldFBhdHRlcm4pIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlQ29sb3IuZ2V0UGF0dGVybihjdHgsIHRoaXMsIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGN0eCksIFBhdGhUeXBlLlNUUk9LRSk7XG4gICAgICAgIHRoaXMucmVzY2FsZUFuZFN0cm9rZShmYWxzZSk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlc2NhbGVBbmRTdHJva2UodHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb25zdW1lUGF0aCkge1xuICAgICAgdGhpcy5jb25zdW1lUGF0aCh0aGlzLmN1cnJlbnQuZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveCgpKTtcbiAgICB9XG4gICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5jdXJyZW50LmZpbGxBbHBoYTtcbiAgfVxuICBjbG9zZVN0cm9rZSgpIHtcbiAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuc3Ryb2tlKCk7XG4gIH1cbiAgZmlsbChjb25zdW1lUGF0aCA9IHRydWUpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBmaWxsQ29sb3IgPSB0aGlzLmN1cnJlbnQuZmlsbENvbG9yO1xuICAgIGNvbnN0IGlzUGF0dGVybkZpbGwgPSB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGw7XG4gICAgbGV0IG5lZWRSZXN0b3JlID0gZmFsc2U7XG4gICAgaWYgKGlzUGF0dGVybkZpbGwpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gZmlsbENvbG9yLmdldFBhdHRlcm4oY3R4LCB0aGlzLCBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShjdHgpLCBQYXRoVHlwZS5GSUxMKTtcbiAgICAgIG5lZWRSZXN0b3JlID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgaW50ZXJzZWN0ID0gdGhpcy5jdXJyZW50LmdldENsaXBwZWRQYXRoQm91bmRpbmdCb3goKTtcbiAgICBpZiAodGhpcy5jb250ZW50VmlzaWJsZSAmJiBpbnRlcnNlY3QgIT09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLnBlbmRpbmdFT0ZpbGwpIHtcbiAgICAgICAgY3R4LmZpbGwoXCJldmVub2RkXCIpO1xuICAgICAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZWVkUmVzdG9yZSkge1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgaWYgKGNvbnN1bWVQYXRoKSB7XG4gICAgICB0aGlzLmNvbnN1bWVQYXRoKGludGVyc2VjdCk7XG4gICAgfVxuICB9XG4gIGVvRmlsbCgpIHtcbiAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSB0cnVlO1xuICAgIHRoaXMuZmlsbCgpO1xuICB9XG4gIGZpbGxTdHJva2UoKSB7XG4gICAgdGhpcy5maWxsKGZhbHNlKTtcbiAgICB0aGlzLnN0cm9rZShmYWxzZSk7XG4gICAgdGhpcy5jb25zdW1lUGF0aCgpO1xuICB9XG4gIGVvRmlsbFN0cm9rZSgpIHtcbiAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSB0cnVlO1xuICAgIHRoaXMuZmlsbFN0cm9rZSgpO1xuICB9XG4gIGNsb3NlRmlsbFN0cm9rZSgpIHtcbiAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuZmlsbFN0cm9rZSgpO1xuICB9XG4gIGNsb3NlRU9GaWxsU3Ryb2tlKCkge1xuICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IHRydWU7XG4gICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLmZpbGxTdHJva2UoKTtcbiAgfVxuICBlbmRQYXRoKCkge1xuICAgIHRoaXMuY29uc3VtZVBhdGgoKTtcbiAgfVxuICBjbGlwKCkge1xuICAgIHRoaXMucGVuZGluZ0NsaXAgPSBOT1JNQUxfQ0xJUDtcbiAgfVxuICBlb0NsaXAoKSB7XG4gICAgdGhpcy5wZW5kaW5nQ2xpcCA9IEVPX0NMSVA7XG4gIH1cbiAgYmVnaW5UZXh0KCkge1xuICAgIHRoaXMuY3VycmVudC50ZXh0TWF0cml4ID0gSURFTlRJVFlfTUFUUklYO1xuICAgIHRoaXMuY3VycmVudC50ZXh0TWF0cml4U2NhbGUgPSAxO1xuICAgIHRoaXMuY3VycmVudC54ID0gdGhpcy5jdXJyZW50LmxpbmVYID0gMDtcbiAgICB0aGlzLmN1cnJlbnQueSA9IHRoaXMuY3VycmVudC5saW5lWSA9IDA7XG4gIH1cbiAgZW5kVGV4dCgpIHtcbiAgICBjb25zdCBwYXRocyA9IHRoaXMucGVuZGluZ1RleHRQYXRocztcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBpZiAocGF0aHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oLi4ucGF0aC50cmFuc2Zvcm0pO1xuICAgICAgY3R4LnRyYW5zbGF0ZShwYXRoLngsIHBhdGgueSk7XG4gICAgICBwYXRoLmFkZFRvUGF0aChjdHgsIHBhdGguZm9udFNpemUpO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIGN0eC5jbGlwKCk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdUZXh0UGF0aHM7XG4gIH1cbiAgc2V0Q2hhclNwYWNpbmcoc3BhY2luZykge1xuICAgIHRoaXMuY3VycmVudC5jaGFyU3BhY2luZyA9IHNwYWNpbmc7XG4gIH1cbiAgc2V0V29yZFNwYWNpbmcoc3BhY2luZykge1xuICAgIHRoaXMuY3VycmVudC53b3JkU3BhY2luZyA9IHNwYWNpbmc7XG4gIH1cbiAgc2V0SFNjYWxlKHNjYWxlKSB7XG4gICAgdGhpcy5jdXJyZW50LnRleHRIU2NhbGUgPSBzY2FsZSAvIDEwMDtcbiAgfVxuICBzZXRMZWFkaW5nKGxlYWRpbmcpIHtcbiAgICB0aGlzLmN1cnJlbnQubGVhZGluZyA9IC1sZWFkaW5nO1xuICB9XG4gIHNldEZvbnQoZm9udFJlZk5hbWUsIHNpemUpIHtcbiAgICBjb25zdCBmb250T2JqID0gdGhpcy5jb21tb25PYmpzLmdldChmb250UmVmTmFtZSk7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBpZiAoIWZvbnRPYmopIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgZmluZCBmb250IGZvciAke2ZvbnRSZWZOYW1lfWApO1xuICAgIH1cbiAgICBjdXJyZW50LmZvbnRNYXRyaXggPSBmb250T2JqLmZvbnRNYXRyaXggfHwgRk9OVF9JREVOVElUWV9NQVRSSVg7XG4gICAgaWYgKGN1cnJlbnQuZm9udE1hdHJpeFswXSA9PT0gMCB8fCBjdXJyZW50LmZvbnRNYXRyaXhbM10gPT09IDApIHtcbiAgICAgIHdhcm4oXCJJbnZhbGlkIGZvbnQgbWF0cml4IGZvciBmb250IFwiICsgZm9udFJlZk5hbWUpO1xuICAgIH1cbiAgICBpZiAoc2l6ZSA8IDApIHtcbiAgICAgIHNpemUgPSAtc2l6ZTtcbiAgICAgIGN1cnJlbnQuZm9udERpcmVjdGlvbiA9IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50LmZvbnREaXJlY3Rpb24gPSAxO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQuZm9udCA9IGZvbnRPYmo7XG4gICAgdGhpcy5jdXJyZW50LmZvbnRTaXplID0gc2l6ZTtcbiAgICBpZiAoZm9udE9iai5pc1R5cGUzRm9udCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuYW1lID0gZm9udE9iai5sb2FkZWROYW1lIHx8IFwic2Fucy1zZXJpZlwiO1xuICAgIGNvbnN0IHR5cGVmYWNlID0gZm9udE9iai5zeXN0ZW1Gb250SW5mbz8uY3NzIHx8IGBcIiR7bmFtZX1cIiwgJHtmb250T2JqLmZhbGxiYWNrTmFtZX1gO1xuICAgIGxldCBib2xkID0gXCJub3JtYWxcIjtcbiAgICBpZiAoZm9udE9iai5ibGFjaykge1xuICAgICAgYm9sZCA9IFwiOTAwXCI7XG4gICAgfSBlbHNlIGlmIChmb250T2JqLmJvbGQpIHtcbiAgICAgIGJvbGQgPSBcImJvbGRcIjtcbiAgICB9XG4gICAgY29uc3QgaXRhbGljID0gZm9udE9iai5pdGFsaWMgPyBcIml0YWxpY1wiIDogXCJub3JtYWxcIjtcbiAgICBsZXQgYnJvd3NlckZvbnRTaXplID0gc2l6ZTtcbiAgICBpZiAoc2l6ZSA8IE1JTl9GT05UX1NJWkUpIHtcbiAgICAgIGJyb3dzZXJGb250U2l6ZSA9IE1JTl9GT05UX1NJWkU7XG4gICAgfSBlbHNlIGlmIChzaXplID4gTUFYX0ZPTlRfU0laRSkge1xuICAgICAgYnJvd3NlckZvbnRTaXplID0gTUFYX0ZPTlRfU0laRTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50LmZvbnRTaXplU2NhbGUgPSBzaXplIC8gYnJvd3NlckZvbnRTaXplO1xuICAgIHRoaXMuY3R4LmZvbnQgPSBgJHtpdGFsaWN9ICR7Ym9sZH0gJHticm93c2VyRm9udFNpemV9cHggJHt0eXBlZmFjZX1gO1xuICB9XG4gIHNldFRleHRSZW5kZXJpbmdNb2RlKG1vZGUpIHtcbiAgICB0aGlzLmN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgPSBtb2RlO1xuICB9XG4gIHNldFRleHRSaXNlKHJpc2UpIHtcbiAgICB0aGlzLmN1cnJlbnQudGV4dFJpc2UgPSByaXNlO1xuICB9XG4gIG1vdmVUZXh0KHgsIHkpIHtcbiAgICB0aGlzLmN1cnJlbnQueCA9IHRoaXMuY3VycmVudC5saW5lWCArPSB4O1xuICAgIHRoaXMuY3VycmVudC55ID0gdGhpcy5jdXJyZW50LmxpbmVZICs9IHk7XG4gIH1cbiAgc2V0TGVhZGluZ01vdmVUZXh0KHgsIHkpIHtcbiAgICB0aGlzLnNldExlYWRpbmcoLXkpO1xuICAgIHRoaXMubW92ZVRleHQoeCwgeSk7XG4gIH1cbiAgc2V0VGV4dE1hdHJpeChhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgdGhpcy5jdXJyZW50LnRleHRNYXRyaXggPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgdGhpcy5jdXJyZW50LnRleHRNYXRyaXhTY2FsZSA9IE1hdGguaHlwb3QoYSwgYik7XG4gICAgdGhpcy5jdXJyZW50LnggPSB0aGlzLmN1cnJlbnQubGluZVggPSAwO1xuICAgIHRoaXMuY3VycmVudC55ID0gdGhpcy5jdXJyZW50LmxpbmVZID0gMDtcbiAgfVxuICBuZXh0TGluZSgpIHtcbiAgICB0aGlzLm1vdmVUZXh0KDAsIHRoaXMuY3VycmVudC5sZWFkaW5nKTtcbiAgfVxuICBwYWludENoYXIoY2hhcmFjdGVyLCB4LCB5LCBwYXR0ZXJuRmlsbFRyYW5zZm9ybSwgcGF0dGVyblN0cm9rZVRyYW5zZm9ybSkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgY29uc3QgZm9udCA9IGN1cnJlbnQuZm9udDtcbiAgICBjb25zdCB0ZXh0UmVuZGVyaW5nTW9kZSA9IGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGU7XG4gICAgY29uc3QgZm9udFNpemUgPSBjdXJyZW50LmZvbnRTaXplIC8gY3VycmVudC5mb250U2l6ZVNjYWxlO1xuICAgIGNvbnN0IGZpbGxTdHJva2VNb2RlID0gdGV4dFJlbmRlcmluZ01vZGUgJiBUZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRV9NQVNLO1xuICAgIGNvbnN0IGlzQWRkVG9QYXRoU2V0ID0gISEodGV4dFJlbmRlcmluZ01vZGUgJiBUZXh0UmVuZGVyaW5nTW9kZS5BRERfVE9fUEFUSF9GTEFHKTtcbiAgICBjb25zdCBwYXR0ZXJuRmlsbCA9IGN1cnJlbnQucGF0dGVybkZpbGwgJiYgIWZvbnQubWlzc2luZ0ZpbGU7XG4gICAgY29uc3QgcGF0dGVyblN0cm9rZSA9IGN1cnJlbnQucGF0dGVyblN0cm9rZSAmJiAhZm9udC5taXNzaW5nRmlsZTtcbiAgICBsZXQgYWRkVG9QYXRoO1xuICAgIGlmIChmb250LmRpc2FibGVGb250RmFjZSB8fCBpc0FkZFRvUGF0aFNldCB8fCBwYXR0ZXJuRmlsbCB8fCBwYXR0ZXJuU3Ryb2tlKSB7XG4gICAgICBhZGRUb1BhdGggPSBmb250LmdldFBhdGhHZW5lcmF0b3IodGhpcy5jb21tb25PYmpzLCBjaGFyYWN0ZXIpO1xuICAgIH1cbiAgICBpZiAoZm9udC5kaXNhYmxlRm9udEZhY2UgfHwgcGF0dGVybkZpbGwgfHwgcGF0dGVyblN0cm9rZSkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBhZGRUb1BhdGgoY3R4LCBmb250U2l6ZSk7XG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLkZJTEwgfHwgZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgIGlmIChwYXR0ZXJuRmlsbFRyYW5zZm9ybSkge1xuICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oLi4ucGF0dGVybkZpbGxUcmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICB9XG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLlNUUk9LRSB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgaWYgKHBhdHRlcm5TdHJva2VUcmFuc2Zvcm0pIHtcbiAgICAgICAgICBjdHguc2V0VHJhbnNmb3JtKC4uLnBhdHRlcm5TdHJva2VUcmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChmaWxsU3Ryb2tlTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuRklMTCB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgY3R4LmZpbGxUZXh0KGNoYXJhY3RlciwgeCwgeSk7XG4gICAgICB9XG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLlNUUk9LRSB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgY3R4LnN0cm9rZVRleHQoY2hhcmFjdGVyLCB4LCB5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzQWRkVG9QYXRoU2V0KSB7XG4gICAgICBjb25zdCBwYXRocyA9IHRoaXMucGVuZGluZ1RleHRQYXRocyB8fD0gW107XG4gICAgICBwYXRocy5wdXNoKHtcbiAgICAgICAgdHJhbnNmb3JtOiBnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCksXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIGZvbnRTaXplLFxuICAgICAgICBhZGRUb1BhdGhcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXQgaXNGb250U3VicGl4ZWxBQUVuYWJsZWQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dDogY3R4XG4gICAgfSA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwiaXNGb250U3VicGl4ZWxBQUVuYWJsZWRcIiwgMTAsIDEwKTtcbiAgICBjdHguc2NhbGUoMS41LCAxKTtcbiAgICBjdHguZmlsbFRleHQoXCJJXCIsIDAsIDEwKTtcbiAgICBjb25zdCBkYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCAxMCwgMTApLmRhdGE7XG4gICAgbGV0IGVuYWJsZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMzsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgIGlmIChkYXRhW2ldID4gMCAmJiBkYXRhW2ldIDwgMjU1KSB7XG4gICAgICAgIGVuYWJsZWQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzRm9udFN1YnBpeGVsQUFFbmFibGVkXCIsIGVuYWJsZWQpO1xuICB9XG4gIHNob3dUZXh0KGdseXBocykge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgY29uc3QgZm9udCA9IGN1cnJlbnQuZm9udDtcbiAgICBpZiAoZm9udC5pc1R5cGUzRm9udCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2hvd1R5cGUzVGV4dChnbHlwaHMpO1xuICAgIH1cbiAgICBjb25zdCBmb250U2l6ZSA9IGN1cnJlbnQuZm9udFNpemU7XG4gICAgaWYgKGZvbnRTaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBmb250U2l6ZVNjYWxlID0gY3VycmVudC5mb250U2l6ZVNjYWxlO1xuICAgIGNvbnN0IGNoYXJTcGFjaW5nID0gY3VycmVudC5jaGFyU3BhY2luZztcbiAgICBjb25zdCB3b3JkU3BhY2luZyA9IGN1cnJlbnQud29yZFNwYWNpbmc7XG4gICAgY29uc3QgZm9udERpcmVjdGlvbiA9IGN1cnJlbnQuZm9udERpcmVjdGlvbjtcbiAgICBjb25zdCB0ZXh0SFNjYWxlID0gY3VycmVudC50ZXh0SFNjYWxlICogZm9udERpcmVjdGlvbjtcbiAgICBjb25zdCBnbHlwaHNMZW5ndGggPSBnbHlwaHMubGVuZ3RoO1xuICAgIGNvbnN0IHZlcnRpY2FsID0gZm9udC52ZXJ0aWNhbDtcbiAgICBjb25zdCBzcGFjaW5nRGlyID0gdmVydGljYWwgPyAxIDogLTE7XG4gICAgY29uc3QgZGVmYXVsdFZNZXRyaWNzID0gZm9udC5kZWZhdWx0Vk1ldHJpY3M7XG4gICAgY29uc3Qgd2lkdGhBZHZhbmNlU2NhbGUgPSBmb250U2l6ZSAqIGN1cnJlbnQuZm9udE1hdHJpeFswXTtcbiAgICBjb25zdCBzaW1wbGVGaWxsVGV4dCA9IGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLkZJTEwgJiYgIWZvbnQuZGlzYWJsZUZvbnRGYWNlICYmICFjdXJyZW50LnBhdHRlcm5GaWxsO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnRyYW5zZm9ybSguLi5jdXJyZW50LnRleHRNYXRyaXgpO1xuICAgIGN0eC50cmFuc2xhdGUoY3VycmVudC54LCBjdXJyZW50LnkgKyBjdXJyZW50LnRleHRSaXNlKTtcbiAgICBpZiAoZm9udERpcmVjdGlvbiA+IDApIHtcbiAgICAgIGN0eC5zY2FsZSh0ZXh0SFNjYWxlLCAtMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5zY2FsZSh0ZXh0SFNjYWxlLCAxKTtcbiAgICB9XG4gICAgbGV0IHBhdHRlcm5GaWxsVHJhbnNmb3JtLCBwYXR0ZXJuU3Ryb2tlVHJhbnNmb3JtO1xuICAgIGlmIChjdXJyZW50LnBhdHRlcm5GaWxsKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY29uc3QgcGF0dGVybiA9IGN1cnJlbnQuZmlsbENvbG9yLmdldFBhdHRlcm4oY3R4LCB0aGlzLCBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShjdHgpLCBQYXRoVHlwZS5GSUxMKTtcbiAgICAgIHBhdHRlcm5GaWxsVHJhbnNmb3JtID0gZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBwYXR0ZXJuO1xuICAgIH1cbiAgICBpZiAoY3VycmVudC5wYXR0ZXJuU3Ryb2tlKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY29uc3QgcGF0dGVybiA9IGN1cnJlbnQuc3Ryb2tlQ29sb3IuZ2V0UGF0dGVybihjdHgsIHRoaXMsIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGN0eCksIFBhdGhUeXBlLlNUUk9LRSk7XG4gICAgICBwYXR0ZXJuU3Ryb2tlVHJhbnNmb3JtID0gZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHBhdHRlcm47XG4gICAgfVxuICAgIGxldCBsaW5lV2lkdGggPSBjdXJyZW50LmxpbmVXaWR0aDtcbiAgICBjb25zdCBzY2FsZSA9IGN1cnJlbnQudGV4dE1hdHJpeFNjYWxlO1xuICAgIGlmIChzY2FsZSA9PT0gMCB8fCBsaW5lV2lkdGggPT09IDApIHtcbiAgICAgIGNvbnN0IGZpbGxTdHJva2VNb2RlID0gY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSAmIFRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFX01BU0s7XG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLlNUUk9LRSB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgbGluZVdpZHRoID0gdGhpcy5nZXRTaW5nbGVQaXhlbFdpZHRoKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmVXaWR0aCAvPSBzY2FsZTtcbiAgICB9XG4gICAgaWYgKGZvbnRTaXplU2NhbGUgIT09IDEuMCkge1xuICAgICAgY3R4LnNjYWxlKGZvbnRTaXplU2NhbGUsIGZvbnRTaXplU2NhbGUpO1xuICAgICAgbGluZVdpZHRoIC89IGZvbnRTaXplU2NhbGU7XG4gICAgfVxuICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgaWYgKGZvbnQuaXNJbnZhbGlkUERGanNGb250KSB7XG4gICAgICBjb25zdCBjaGFycyA9IFtdO1xuICAgICAgbGV0IHdpZHRoID0gMDtcbiAgICAgIGZvciAoY29uc3QgZ2x5cGggb2YgZ2x5cGhzKSB7XG4gICAgICAgIGNoYXJzLnB1c2goZ2x5cGgudW5pY29kZSk7XG4gICAgICAgIHdpZHRoICs9IGdseXBoLndpZHRoO1xuICAgICAgfVxuICAgICAgY3R4LmZpbGxUZXh0KGNoYXJzLmpvaW4oXCJcIiksIDAsIDApO1xuICAgICAgY3VycmVudC54ICs9IHdpZHRoICogd2lkdGhBZHZhbmNlU2NhbGUgKiB0ZXh0SFNjYWxlO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMuY29tcG9zZSgpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbGV0IHggPSAwLFxuICAgICAgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2x5cGhzTGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBnbHlwaCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB4ICs9IHNwYWNpbmdEaXIgKiBnbHlwaCAqIGZvbnRTaXplIC8gMTAwMDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsZXQgcmVzdG9yZU5lZWRlZCA9IGZhbHNlO1xuICAgICAgY29uc3Qgc3BhY2luZyA9IChnbHlwaC5pc1NwYWNlID8gd29yZFNwYWNpbmcgOiAwKSArIGNoYXJTcGFjaW5nO1xuICAgICAgY29uc3QgY2hhcmFjdGVyID0gZ2x5cGguZm9udENoYXI7XG4gICAgICBjb25zdCBhY2NlbnQgPSBnbHlwaC5hY2NlbnQ7XG4gICAgICBsZXQgc2NhbGVkWCwgc2NhbGVkWTtcbiAgICAgIGxldCB3aWR0aCA9IGdseXBoLndpZHRoO1xuICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgIGNvbnN0IHZtZXRyaWMgPSBnbHlwaC52bWV0cmljIHx8IGRlZmF1bHRWTWV0cmljcztcbiAgICAgICAgY29uc3QgdnggPSAtKGdseXBoLnZtZXRyaWMgPyB2bWV0cmljWzFdIDogd2lkdGggKiAwLjUpICogd2lkdGhBZHZhbmNlU2NhbGU7XG4gICAgICAgIGNvbnN0IHZ5ID0gdm1ldHJpY1syXSAqIHdpZHRoQWR2YW5jZVNjYWxlO1xuICAgICAgICB3aWR0aCA9IHZtZXRyaWMgPyAtdm1ldHJpY1swXSA6IHdpZHRoO1xuICAgICAgICBzY2FsZWRYID0gdnggLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICBzY2FsZWRZID0gKHggKyB2eSkgLyBmb250U2l6ZVNjYWxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NhbGVkWCA9IHggLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICBzY2FsZWRZID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChmb250LnJlbWVhc3VyZSAmJiB3aWR0aCA+IDApIHtcbiAgICAgICAgY29uc3QgbWVhc3VyZWRXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChjaGFyYWN0ZXIpLndpZHRoICogMTAwMCAvIGZvbnRTaXplICogZm9udFNpemVTY2FsZTtcbiAgICAgICAgaWYgKHdpZHRoIDwgbWVhc3VyZWRXaWR0aCAmJiB0aGlzLmlzRm9udFN1YnBpeGVsQUFFbmFibGVkKSB7XG4gICAgICAgICAgY29uc3QgY2hhcmFjdGVyU2NhbGVYID0gd2lkdGggLyBtZWFzdXJlZFdpZHRoO1xuICAgICAgICAgIHJlc3RvcmVOZWVkZWQgPSB0cnVlO1xuICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgY3R4LnNjYWxlKGNoYXJhY3RlclNjYWxlWCwgMSk7XG4gICAgICAgICAgc2NhbGVkWCAvPSBjaGFyYWN0ZXJTY2FsZVg7XG4gICAgICAgIH0gZWxzZSBpZiAod2lkdGggIT09IG1lYXN1cmVkV2lkdGgpIHtcbiAgICAgICAgICBzY2FsZWRYICs9ICh3aWR0aCAtIG1lYXN1cmVkV2lkdGgpIC8gMjAwMCAqIGZvbnRTaXplIC8gZm9udFNpemVTY2FsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29udGVudFZpc2libGUgJiYgKGdseXBoLmlzSW5Gb250IHx8IGZvbnQubWlzc2luZ0ZpbGUpKSB7XG4gICAgICAgIGlmIChzaW1wbGVGaWxsVGV4dCAmJiAhYWNjZW50KSB7XG4gICAgICAgICAgY3R4LmZpbGxUZXh0KGNoYXJhY3Rlciwgc2NhbGVkWCwgc2NhbGVkWSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wYWludENoYXIoY2hhcmFjdGVyLCBzY2FsZWRYLCBzY2FsZWRZLCBwYXR0ZXJuRmlsbFRyYW5zZm9ybSwgcGF0dGVyblN0cm9rZVRyYW5zZm9ybSk7XG4gICAgICAgICAgaWYgKGFjY2VudCkge1xuICAgICAgICAgICAgY29uc3Qgc2NhbGVkQWNjZW50WCA9IHNjYWxlZFggKyBmb250U2l6ZSAqIGFjY2VudC5vZmZzZXQueCAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgICAgICBjb25zdCBzY2FsZWRBY2NlbnRZID0gc2NhbGVkWSAtIGZvbnRTaXplICogYWNjZW50Lm9mZnNldC55IC8gZm9udFNpemVTY2FsZTtcbiAgICAgICAgICAgIHRoaXMucGFpbnRDaGFyKGFjY2VudC5mb250Q2hhciwgc2NhbGVkQWNjZW50WCwgc2NhbGVkQWNjZW50WSwgcGF0dGVybkZpbGxUcmFuc2Zvcm0sIHBhdHRlcm5TdHJva2VUcmFuc2Zvcm0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgY2hhcldpZHRoID0gdmVydGljYWwgPyB3aWR0aCAqIHdpZHRoQWR2YW5jZVNjYWxlIC0gc3BhY2luZyAqIGZvbnREaXJlY3Rpb24gOiB3aWR0aCAqIHdpZHRoQWR2YW5jZVNjYWxlICsgc3BhY2luZyAqIGZvbnREaXJlY3Rpb247XG4gICAgICB4ICs9IGNoYXJXaWR0aDtcbiAgICAgIGlmIChyZXN0b3JlTmVlZGVkKSB7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgY3VycmVudC55IC09IHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQueCArPSB4ICogdGV4dEhTY2FsZTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHNob3dUeXBlM1RleHQoZ2x5cGhzKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBjb25zdCBmb250ID0gY3VycmVudC5mb250O1xuICAgIGNvbnN0IGZvbnRTaXplID0gY3VycmVudC5mb250U2l6ZTtcbiAgICBjb25zdCBmb250RGlyZWN0aW9uID0gY3VycmVudC5mb250RGlyZWN0aW9uO1xuICAgIGNvbnN0IHNwYWNpbmdEaXIgPSBmb250LnZlcnRpY2FsID8gMSA6IC0xO1xuICAgIGNvbnN0IGNoYXJTcGFjaW5nID0gY3VycmVudC5jaGFyU3BhY2luZztcbiAgICBjb25zdCB3b3JkU3BhY2luZyA9IGN1cnJlbnQud29yZFNwYWNpbmc7XG4gICAgY29uc3QgdGV4dEhTY2FsZSA9IGN1cnJlbnQudGV4dEhTY2FsZSAqIGZvbnREaXJlY3Rpb247XG4gICAgY29uc3QgZm9udE1hdHJpeCA9IGN1cnJlbnQuZm9udE1hdHJpeCB8fCBGT05UX0lERU5USVRZX01BVFJJWDtcbiAgICBjb25zdCBnbHlwaHNMZW5ndGggPSBnbHlwaHMubGVuZ3RoO1xuICAgIGNvbnN0IGlzVGV4dEludmlzaWJsZSA9IGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLklOVklTSUJMRTtcbiAgICBsZXQgaSwgZ2x5cGgsIHdpZHRoLCBzcGFjaW5nTGVuZ3RoO1xuICAgIGlmIChpc1RleHRJbnZpc2libGUgfHwgZm9udFNpemUgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1swXSA9IC0xO1xuICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSBudWxsO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnRyYW5zZm9ybSguLi5jdXJyZW50LnRleHRNYXRyaXgpO1xuICAgIGN0eC50cmFuc2xhdGUoY3VycmVudC54LCBjdXJyZW50LnkpO1xuICAgIGN0eC5zY2FsZSh0ZXh0SFNjYWxlLCBmb250RGlyZWN0aW9uKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2x5cGhzTGVuZ3RoOyArK2kpIHtcbiAgICAgIGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBnbHlwaCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBzcGFjaW5nTGVuZ3RoID0gc3BhY2luZ0RpciAqIGdseXBoICogZm9udFNpemUgLyAxMDAwO1xuICAgICAgICB0aGlzLmN0eC50cmFuc2xhdGUoc3BhY2luZ0xlbmd0aCwgMCk7XG4gICAgICAgIGN1cnJlbnQueCArPSBzcGFjaW5nTGVuZ3RoICogdGV4dEhTY2FsZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBzcGFjaW5nID0gKGdseXBoLmlzU3BhY2UgPyB3b3JkU3BhY2luZyA6IDApICsgY2hhclNwYWNpbmc7XG4gICAgICBjb25zdCBvcGVyYXRvckxpc3QgPSBmb250LmNoYXJQcm9jT3BlcmF0b3JMaXN0W2dseXBoLm9wZXJhdG9yTGlzdElkXTtcbiAgICAgIGlmICghb3BlcmF0b3JMaXN0KSB7XG4gICAgICAgIHdhcm4oYFR5cGUzIGNoYXJhY3RlciBcIiR7Z2x5cGgub3BlcmF0b3JMaXN0SWR9XCIgaXMgbm90IGF2YWlsYWJsZS5gKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmdUeXBlMyA9IGdseXBoO1xuICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICAgICAgY3R4LnNjYWxlKGZvbnRTaXplLCBmb250U2l6ZSk7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0oLi4uZm9udE1hdHJpeCk7XG4gICAgICAgIHRoaXMuZXhlY3V0ZU9wZXJhdG9yTGlzdChvcGVyYXRvckxpc3QpO1xuICAgICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRyYW5zZm9ybWVkID0gVXRpbC5hcHBseVRyYW5zZm9ybShbZ2x5cGgud2lkdGgsIDBdLCBmb250TWF0cml4KTtcbiAgICAgIHdpZHRoID0gdHJhbnNmb3JtZWRbMF0gKiBmb250U2l6ZSArIHNwYWNpbmc7XG4gICAgICBjdHgudHJhbnNsYXRlKHdpZHRoLCAwKTtcbiAgICAgIGN1cnJlbnQueCArPSB3aWR0aCAqIHRleHRIU2NhbGU7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgdGhpcy5wcm9jZXNzaW5nVHlwZTMgPSBudWxsO1xuICB9XG4gIHNldENoYXJXaWR0aCh4V2lkdGgsIHlXaWR0aCkge31cbiAgc2V0Q2hhcldpZHRoQW5kQm91bmRzKHhXaWR0aCwgeVdpZHRoLCBsbHgsIGxseSwgdXJ4LCB1cnkpIHtcbiAgICB0aGlzLmN0eC5yZWN0KGxseCwgbGx5LCB1cnggLSBsbHgsIHVyeSAtIGxseSk7XG4gICAgdGhpcy5jdHguY2xpcCgpO1xuICAgIHRoaXMuZW5kUGF0aCgpO1xuICB9XG4gIGdldENvbG9yTl9QYXR0ZXJuKElSKSB7XG4gICAgbGV0IHBhdHRlcm47XG4gICAgaWYgKElSWzBdID09PSBcIlRpbGluZ1BhdHRlcm5cIikge1xuICAgICAgY29uc3QgY29sb3IgPSBJUlsxXTtcbiAgICAgIGNvbnN0IGJhc2VUcmFuc2Zvcm0gPSB0aGlzLmJhc2VUcmFuc2Zvcm0gfHwgZ2V0Q3VycmVudFRyYW5zZm9ybSh0aGlzLmN0eCk7XG4gICAgICBjb25zdCBjYW52YXNHcmFwaGljc0ZhY3RvcnkgPSB7XG4gICAgICAgIGNyZWF0ZUNhbnZhc0dyYXBoaWNzOiBjdHggPT4gbmV3IENhbnZhc0dyYXBoaWNzKGN0eCwgdGhpcy5jb21tb25PYmpzLCB0aGlzLm9ianMsIHRoaXMuY2FudmFzRmFjdG9yeSwgdGhpcy5maWx0ZXJGYWN0b3J5LCB7XG4gICAgICAgICAgb3B0aW9uYWxDb250ZW50Q29uZmlnOiB0aGlzLm9wdGlvbmFsQ29udGVudENvbmZpZyxcbiAgICAgICAgICBtYXJrZWRDb250ZW50U3RhY2s6IHRoaXMubWFya2VkQ29udGVudFN0YWNrXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgICAgcGF0dGVybiA9IG5ldyBUaWxpbmdQYXR0ZXJuKElSLCBjb2xvciwgdGhpcy5jdHgsIGNhbnZhc0dyYXBoaWNzRmFjdG9yeSwgYmFzZVRyYW5zZm9ybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdHRlcm4gPSB0aGlzLl9nZXRQYXR0ZXJuKElSWzFdLCBJUlsyXSk7XG4gICAgfVxuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9XG4gIHNldFN0cm9rZUNvbG9yTigpIHtcbiAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3IgPSB0aGlzLmdldENvbG9yTl9QYXR0ZXJuKGFyZ3VtZW50cyk7XG4gICAgdGhpcy5jdXJyZW50LnBhdHRlcm5TdHJva2UgPSB0cnVlO1xuICB9XG4gIHNldEZpbGxDb2xvck4oKSB7XG4gICAgdGhpcy5jdXJyZW50LmZpbGxDb2xvciA9IHRoaXMuZ2V0Q29sb3JOX1BhdHRlcm4oYXJndW1lbnRzKTtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGwgPSB0cnVlO1xuICB9XG4gIHNldFN0cm9rZVJHQkNvbG9yKHIsIGcsIGIpIHtcbiAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY3VycmVudC5zdHJva2VDb2xvciA9IFV0aWwubWFrZUhleENvbG9yKHIsIGcsIGIpO1xuICAgIHRoaXMuY3VycmVudC5wYXR0ZXJuU3Ryb2tlID0gZmFsc2U7XG4gIH1cbiAgc2V0U3Ryb2tlVHJhbnNwYXJlbnQoKSB7XG4gICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3IgPSBcInRyYW5zcGFyZW50XCI7XG4gICAgdGhpcy5jdXJyZW50LnBhdHRlcm5TdHJva2UgPSBmYWxzZTtcbiAgfVxuICBzZXRGaWxsUkdCQ29sb3IociwgZywgYikge1xuICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IHRoaXMuY3VycmVudC5maWxsQ29sb3IgPSBVdGlsLm1ha2VIZXhDb2xvcihyLCBnLCBiKTtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGwgPSBmYWxzZTtcbiAgfVxuICBzZXRGaWxsVHJhbnNwYXJlbnQoKSB7XG4gICAgdGhpcy5jdHguZmlsbFN0eWxlID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvciA9IFwidHJhbnNwYXJlbnRcIjtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGwgPSBmYWxzZTtcbiAgfVxuICBfZ2V0UGF0dGVybihvYmpJZCwgbWF0cml4ID0gbnVsbCkge1xuICAgIGxldCBwYXR0ZXJuO1xuICAgIGlmICh0aGlzLmNhY2hlZFBhdHRlcm5zLmhhcyhvYmpJZCkpIHtcbiAgICAgIHBhdHRlcm4gPSB0aGlzLmNhY2hlZFBhdHRlcm5zLmdldChvYmpJZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdHRlcm4gPSBnZXRTaGFkaW5nUGF0dGVybih0aGlzLmdldE9iamVjdChvYmpJZCkpO1xuICAgICAgdGhpcy5jYWNoZWRQYXR0ZXJucy5zZXQob2JqSWQsIHBhdHRlcm4pO1xuICAgIH1cbiAgICBpZiAobWF0cml4KSB7XG4gICAgICBwYXR0ZXJuLm1hdHJpeCA9IG1hdHJpeDtcbiAgICB9XG4gICAgcmV0dXJuIHBhdHRlcm47XG4gIH1cbiAgc2hhZGluZ0ZpbGwob2JqSWQpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgdGhpcy5zYXZlKCk7XG4gICAgY29uc3QgcGF0dGVybiA9IHRoaXMuX2dldFBhdHRlcm4ob2JqSWQpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBwYXR0ZXJuLmdldFBhdHRlcm4oY3R4LCB0aGlzLCBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShjdHgpLCBQYXRoVHlwZS5TSEFESU5HKTtcbiAgICBjb25zdCBpbnYgPSBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShjdHgpO1xuICAgIGlmIChpbnYpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSA9IGN0eC5jYW52YXM7XG4gICAgICBjb25zdCBbeDAsIHkwLCB4MSwgeTFdID0gVXRpbC5nZXRBeGlhbEFsaWduZWRCb3VuZGluZ0JveChbMCwgMCwgd2lkdGgsIGhlaWdodF0sIGludik7XG4gICAgICB0aGlzLmN0eC5maWxsUmVjdCh4MCwgeTAsIHgxIC0geDAsIHkxIC0geTApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN0eC5maWxsUmVjdCgtMWUxMCwgLTFlMTAsIDJlMTAsIDJlMTApO1xuICAgIH1cbiAgICB0aGlzLmNvbXBvc2UodGhpcy5jdXJyZW50LmdldENsaXBwZWRQYXRoQm91bmRpbmdCb3goKSk7XG4gICAgdGhpcy5yZXN0b3JlKCk7XG4gIH1cbiAgYmVnaW5JbmxpbmVJbWFnZSgpIHtcbiAgICB1bnJlYWNoYWJsZShcIlNob3VsZCBub3QgY2FsbCBiZWdpbklubGluZUltYWdlXCIpO1xuICB9XG4gIGJlZ2luSW1hZ2VEYXRhKCkge1xuICAgIHVucmVhY2hhYmxlKFwiU2hvdWxkIG5vdCBjYWxsIGJlZ2luSW1hZ2VEYXRhXCIpO1xuICB9XG4gIHBhaW50Rm9ybVhPYmplY3RCZWdpbihtYXRyaXgsIGJib3gpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zYXZlKCk7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtU3RhY2sucHVzaCh0aGlzLmJhc2VUcmFuc2Zvcm0pO1xuICAgIGlmIChtYXRyaXgpIHtcbiAgICAgIHRoaXMudHJhbnNmb3JtKC4uLm1hdHJpeCk7XG4gICAgfVxuICAgIHRoaXMuYmFzZVRyYW5zZm9ybSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0odGhpcy5jdHgpO1xuICAgIGlmIChiYm94KSB7XG4gICAgICBjb25zdCB3aWR0aCA9IGJib3hbMl0gLSBiYm94WzBdO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gYmJveFszXSAtIGJib3hbMV07XG4gICAgICB0aGlzLmN0eC5yZWN0KGJib3hbMF0sIGJib3hbMV0sIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5jdXJyZW50LnVwZGF0ZVJlY3RNaW5NYXgoZ2V0Q3VycmVudFRyYW5zZm9ybSh0aGlzLmN0eCksIGJib3gpO1xuICAgICAgdGhpcy5jbGlwKCk7XG4gICAgICB0aGlzLmVuZFBhdGgoKTtcbiAgICB9XG4gIH1cbiAgcGFpbnRGb3JtWE9iamVjdEVuZCgpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtID0gdGhpcy5iYXNlVHJhbnNmb3JtU3RhY2sucG9wKCk7XG4gIH1cbiAgYmVnaW5Hcm91cChncm91cCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNhdmUoKTtcbiAgICBpZiAodGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgdGhpcy5lbmRTTWFza01vZGUoKTtcbiAgICAgIHRoaXMuY3VycmVudC5hY3RpdmVTTWFzayA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRDdHggPSB0aGlzLmN0eDtcbiAgICBpZiAoIWdyb3VwLmlzb2xhdGVkKSB7XG4gICAgICBpbmZvKFwiVE9ETzogU3VwcG9ydCBub24taXNvbGF0ZWQgZ3JvdXBzLlwiKTtcbiAgICB9XG4gICAgaWYgKGdyb3VwLmtub2Nrb3V0KSB7XG4gICAgICB3YXJuKFwiS25vY2tvdXQgZ3JvdXBzIG5vdCBzdXBwb3J0ZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50VHJhbnNmb3JtID0gZ2V0Q3VycmVudFRyYW5zZm9ybShjdXJyZW50Q3R4KTtcbiAgICBpZiAoZ3JvdXAubWF0cml4KSB7XG4gICAgICBjdXJyZW50Q3R4LnRyYW5zZm9ybSguLi5ncm91cC5tYXRyaXgpO1xuICAgIH1cbiAgICBpZiAoIWdyb3VwLmJib3gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkJvdW5kaW5nIGJveCBpcyByZXF1aXJlZC5cIik7XG4gICAgfVxuICAgIGxldCBib3VuZHMgPSBVdGlsLmdldEF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KGdyb3VwLmJib3gsIGdldEN1cnJlbnRUcmFuc2Zvcm0oY3VycmVudEN0eCkpO1xuICAgIGNvbnN0IGNhbnZhc0JvdW5kcyA9IFswLCAwLCBjdXJyZW50Q3R4LmNhbnZhcy53aWR0aCwgY3VycmVudEN0eC5jYW52YXMuaGVpZ2h0XTtcbiAgICBib3VuZHMgPSBVdGlsLmludGVyc2VjdChib3VuZHMsIGNhbnZhc0JvdW5kcykgfHwgWzAsIDAsIDAsIDBdO1xuICAgIGNvbnN0IG9mZnNldFggPSBNYXRoLmZsb29yKGJvdW5kc1swXSk7XG4gICAgY29uc3Qgb2Zmc2V0WSA9IE1hdGguZmxvb3IoYm91bmRzWzFdKTtcbiAgICBjb25zdCBkcmF3bldpZHRoID0gTWF0aC5tYXgoTWF0aC5jZWlsKGJvdW5kc1syXSkgLSBvZmZzZXRYLCAxKTtcbiAgICBjb25zdCBkcmF3bkhlaWdodCA9IE1hdGgubWF4KE1hdGguY2VpbChib3VuZHNbM10pIC0gb2Zmc2V0WSwgMSk7XG4gICAgdGhpcy5jdXJyZW50LnN0YXJ0TmV3UGF0aEFuZENsaXBCb3goWzAsIDAsIGRyYXduV2lkdGgsIGRyYXduSGVpZ2h0XSk7XG4gICAgbGV0IGNhY2hlSWQgPSBcImdyb3VwQXRcIiArIHRoaXMuZ3JvdXBMZXZlbDtcbiAgICBpZiAoZ3JvdXAuc21hc2spIHtcbiAgICAgIGNhY2hlSWQgKz0gXCJfc21hc2tfXCIgKyB0aGlzLnNtYXNrQ291bnRlcisrICUgMjtcbiAgICB9XG4gICAgY29uc3Qgc2NyYXRjaENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKGNhY2hlSWQsIGRyYXduV2lkdGgsIGRyYXduSGVpZ2h0KTtcbiAgICBjb25zdCBncm91cEN0eCA9IHNjcmF0Y2hDYW52YXMuY29udGV4dDtcbiAgICBncm91cEN0eC50cmFuc2xhdGUoLW9mZnNldFgsIC1vZmZzZXRZKTtcbiAgICBncm91cEN0eC50cmFuc2Zvcm0oLi4uY3VycmVudFRyYW5zZm9ybSk7XG4gICAgaWYgKGdyb3VwLnNtYXNrKSB7XG4gICAgICB0aGlzLnNtYXNrU3RhY2sucHVzaCh7XG4gICAgICAgIGNhbnZhczogc2NyYXRjaENhbnZhcy5jYW52YXMsXG4gICAgICAgIGNvbnRleHQ6IGdyb3VwQ3R4LFxuICAgICAgICBvZmZzZXRYLFxuICAgICAgICBvZmZzZXRZLFxuICAgICAgICBzdWJ0eXBlOiBncm91cC5zbWFzay5zdWJ0eXBlLFxuICAgICAgICBiYWNrZHJvcDogZ3JvdXAuc21hc2suYmFja2Ryb3AsXG4gICAgICAgIHRyYW5zZmVyTWFwOiBncm91cC5zbWFzay50cmFuc2Zlck1hcCB8fCBudWxsLFxuICAgICAgICBzdGFydFRyYW5zZm9ybUludmVyc2U6IG51bGxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Q3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIGN1cnJlbnRDdHgudHJhbnNsYXRlKG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgY3VycmVudEN0eC5zYXZlKCk7XG4gICAgfVxuICAgIGNvcHlDdHhTdGF0ZShjdXJyZW50Q3R4LCBncm91cEN0eCk7XG4gICAgdGhpcy5jdHggPSBncm91cEN0eDtcbiAgICB0aGlzLnNldEdTdGF0ZShbW1wiQk1cIiwgXCJzb3VyY2Utb3ZlclwiXSwgW1wiY2FcIiwgMV0sIFtcIkNBXCIsIDFdXSk7XG4gICAgdGhpcy5ncm91cFN0YWNrLnB1c2goY3VycmVudEN0eCk7XG4gICAgdGhpcy5ncm91cExldmVsKys7XG4gIH1cbiAgZW5kR3JvdXAoZ3JvdXApIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5ncm91cExldmVsLS07XG4gICAgY29uc3QgZ3JvdXBDdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBjdHggPSB0aGlzLmdyb3VwU3RhY2sucG9wKCk7XG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy5jdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XG4gICAgaWYgKGdyb3VwLnNtYXNrKSB7XG4gICAgICB0aGlzLnRlbXBTTWFzayA9IHRoaXMuc21hc2tTdGFjay5wb3AoKTtcbiAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICBjb25zdCBjdXJyZW50TXR4ID0gZ2V0Q3VycmVudFRyYW5zZm9ybSh0aGlzLmN0eCk7XG4gICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSguLi5jdXJyZW50TXR4KTtcbiAgICAgIGNvbnN0IGRpcnR5Qm94ID0gVXRpbC5nZXRBeGlhbEFsaWduZWRCb3VuZGluZ0JveChbMCwgMCwgZ3JvdXBDdHguY2FudmFzLndpZHRoLCBncm91cEN0eC5jYW52YXMuaGVpZ2h0XSwgY3VycmVudE10eCk7XG4gICAgICB0aGlzLmN0eC5kcmF3SW1hZ2UoZ3JvdXBDdHguY2FudmFzLCAwLCAwKTtcbiAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMuY29tcG9zZShkaXJ0eUJveCk7XG4gICAgfVxuICB9XG4gIGJlZ2luQW5ub3RhdGlvbihpZCwgcmVjdCwgdHJhbnNmb3JtLCBtYXRyaXgsIGhhc093bkNhbnZhcykge1xuICAgIHRoaXMuI3Jlc3RvcmVJbml0aWFsU3RhdGUoKTtcbiAgICByZXNldEN0eFRvRGVmYXVsdCh0aGlzLmN0eCk7XG4gICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgIHRoaXMuc2F2ZSgpO1xuICAgIGlmICh0aGlzLmJhc2VUcmFuc2Zvcm0pIHtcbiAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSguLi50aGlzLmJhc2VUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBpZiAocmVjdCkge1xuICAgICAgY29uc3Qgd2lkdGggPSByZWN0WzJdIC0gcmVjdFswXTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHJlY3RbM10gLSByZWN0WzFdO1xuICAgICAgaWYgKGhhc093bkNhbnZhcyAmJiB0aGlzLmFubm90YXRpb25DYW52YXNNYXApIHtcbiAgICAgICAgdHJhbnNmb3JtID0gdHJhbnNmb3JtLnNsaWNlKCk7XG4gICAgICAgIHRyYW5zZm9ybVs0XSAtPSByZWN0WzBdO1xuICAgICAgICB0cmFuc2Zvcm1bNV0gLT0gcmVjdFsxXTtcbiAgICAgICAgcmVjdCA9IHJlY3Quc2xpY2UoKTtcbiAgICAgICAgcmVjdFswXSA9IHJlY3RbMV0gPSAwO1xuICAgICAgICByZWN0WzJdID0gd2lkdGg7XG4gICAgICAgIHJlY3RbM10gPSBoZWlnaHQ7XG4gICAgICAgIGNvbnN0IFtzY2FsZVgsIHNjYWxlWV0gPSBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKGdldEN1cnJlbnRUcmFuc2Zvcm0odGhpcy5jdHgpKTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHZpZXdwb3J0U2NhbGVcbiAgICAgICAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGNhbnZhc1dpZHRoID0gTWF0aC5jZWlsKHdpZHRoICogdGhpcy5vdXRwdXRTY2FsZVggKiB2aWV3cG9ydFNjYWxlKTtcbiAgICAgICAgY29uc3QgY2FudmFzSGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCAqIHRoaXMub3V0cHV0U2NhbGVZICogdmlld3BvcnRTY2FsZSk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbkNhbnZhcyA9IHRoaXMuY2FudmFzRmFjdG9yeS5jcmVhdGUoY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBjYW52YXMsXG4gICAgICAgICAgY29udGV4dFxuICAgICAgICB9ID0gdGhpcy5hbm5vdGF0aW9uQ2FudmFzO1xuICAgICAgICB0aGlzLmFubm90YXRpb25DYW52YXNNYXAuc2V0KGlkLCBjYW52YXMpO1xuICAgICAgICB0aGlzLmFubm90YXRpb25DYW52YXMuc2F2ZWRDdHggPSB0aGlzLmN0eDtcbiAgICAgICAgdGhpcy5jdHggPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybShzY2FsZVgsIDAsIDAsIC1zY2FsZVksIDAsIGhlaWdodCAqIHNjYWxlWSk7XG4gICAgICAgIHJlc2V0Q3R4VG9EZWZhdWx0KHRoaXMuY3R4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2V0Q3R4VG9EZWZhdWx0KHRoaXMuY3R4KTtcbiAgICAgICAgdGhpcy5lbmRQYXRoKCk7XG4gICAgICAgIHRoaXMuY3R4LnJlY3QocmVjdFswXSwgcmVjdFsxXSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuY3R4LmNsaXAoKTtcbiAgICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY3VycmVudCA9IG5ldyBDYW52YXNFeHRyYVN0YXRlKHRoaXMuY3R4LmNhbnZhcy53aWR0aCwgdGhpcy5jdHguY2FudmFzLmhlaWdodCk7XG4gICAgdGhpcy50cmFuc2Zvcm0oLi4udHJhbnNmb3JtKTtcbiAgICB0aGlzLnRyYW5zZm9ybSguLi5tYXRyaXgpO1xuICB9XG4gIGVuZEFubm90YXRpb24oKSB7XG4gICAgaWYgKHRoaXMuYW5ub3RhdGlvbkNhbnZhcykge1xuICAgICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgICAgdGhpcy4jZHJhd0ZpbHRlcigpO1xuICAgICAgdGhpcy5jdHggPSB0aGlzLmFubm90YXRpb25DYW52YXMuc2F2ZWRDdHg7XG4gICAgICBkZWxldGUgdGhpcy5hbm5vdGF0aW9uQ2FudmFzLnNhdmVkQ3R4O1xuICAgICAgZGVsZXRlIHRoaXMuYW5ub3RhdGlvbkNhbnZhcztcbiAgICB9XG4gIH1cbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0KGltZykge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb3VudCA9IGltZy5jb3VudDtcbiAgICBpbWcgPSB0aGlzLmdldE9iamVjdChpbWcuZGF0YSwgaW1nKTtcbiAgICBpbWcuY291bnQgPSBjb3VudDtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBnbHlwaCA9IHRoaXMucHJvY2Vzc2luZ1R5cGUzO1xuICAgIGlmIChnbHlwaCkge1xuICAgICAgaWYgKGdseXBoLmNvbXBpbGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZ2x5cGguY29tcGlsZWQgPSBjb21waWxlVHlwZTNHbHlwaChpbWcpO1xuICAgICAgfVxuICAgICAgaWYgKGdseXBoLmNvbXBpbGVkKSB7XG4gICAgICAgIGdseXBoLmNvbXBpbGVkKGN0eCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWFzayA9IHRoaXMuX2NyZWF0ZU1hc2tDYW52YXMoaW1nKTtcbiAgICBjb25zdCBtYXNrQ2FudmFzID0gbWFzay5jYW52YXM7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIGN0eC5kcmF3SW1hZ2UobWFza0NhbnZhcywgbWFzay5vZmZzZXRYLCBtYXNrLm9mZnNldFkpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgdGhpcy5jb21wb3NlKCk7XG4gIH1cbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0UmVwZWF0KGltZywgc2NhbGVYLCBza2V3WCA9IDAsIHNrZXdZID0gMCwgc2NhbGVZLCBwb3NpdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW1nID0gdGhpcy5nZXRPYmplY3QoaW1nLmRhdGEsIGltZyk7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjb25zdCBjdXJyZW50VHJhbnNmb3JtID0gZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpO1xuICAgIGN0eC50cmFuc2Zvcm0oc2NhbGVYLCBza2V3WCwgc2tld1ksIHNjYWxlWSwgMCwgMCk7XG4gICAgY29uc3QgbWFzayA9IHRoaXMuX2NyZWF0ZU1hc2tDYW52YXMoaW1nKTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIG1hc2sub2Zmc2V0WCAtIGN1cnJlbnRUcmFuc2Zvcm1bNF0sIG1hc2sub2Zmc2V0WSAtIGN1cnJlbnRUcmFuc2Zvcm1bNV0pO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBjb25zdCB0cmFucyA9IFV0aWwudHJhbnNmb3JtKGN1cnJlbnRUcmFuc2Zvcm0sIFtzY2FsZVgsIHNrZXdYLCBza2V3WSwgc2NhbGVZLCBwb3NpdGlvbnNbaV0sIHBvc2l0aW9uc1tpICsgMV1dKTtcbiAgICAgIGNvbnN0IFt4LCB5XSA9IFV0aWwuYXBwbHlUcmFuc2Zvcm0oWzAsIDBdLCB0cmFucyk7XG4gICAgICBjdHguZHJhd0ltYWdlKG1hc2suY2FudmFzLCB4LCB5KTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgfVxuICBwYWludEltYWdlTWFza1hPYmplY3RHcm91cChpbWFnZXMpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZmlsbENvbG9yID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvcjtcbiAgICBjb25zdCBpc1BhdHRlcm5GaWxsID0gdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsO1xuICAgIGZvciAoY29uc3QgaW1hZ2Ugb2YgaW1hZ2VzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGEsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHRyYW5zZm9ybVxuICAgICAgfSA9IGltYWdlO1xuICAgICAgY29uc3QgbWFza0NhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwibWFza0NhbnZhc1wiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGNvbnN0IG1hc2tDdHggPSBtYXNrQ2FudmFzLmNvbnRleHQ7XG4gICAgICBtYXNrQ3R4LnNhdmUoKTtcbiAgICAgIGNvbnN0IGltZyA9IHRoaXMuZ2V0T2JqZWN0KGRhdGEsIGltYWdlKTtcbiAgICAgIHB1dEJpbmFyeUltYWdlTWFzayhtYXNrQ3R4LCBpbWcpO1xuICAgICAgbWFza0N0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1pblwiO1xuICAgICAgbWFza0N0eC5maWxsU3R5bGUgPSBpc1BhdHRlcm5GaWxsID8gZmlsbENvbG9yLmdldFBhdHRlcm4obWFza0N0eCwgdGhpcywgZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoY3R4KSwgUGF0aFR5cGUuRklMTCkgOiBmaWxsQ29sb3I7XG4gICAgICBtYXNrQ3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgbWFza0N0eC5yZXN0b3JlKCk7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zZm9ybSguLi50cmFuc2Zvcm0pO1xuICAgICAgY3R4LnNjYWxlKDEsIC0xKTtcbiAgICAgIGRyYXdJbWFnZUF0SW50ZWdlckNvb3JkcyhjdHgsIG1hc2tDYW52YXMuY2FudmFzLCAwLCAwLCB3aWR0aCwgaGVpZ2h0LCAwLCAtMSwgMSwgMSk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgfVxuICBwYWludEltYWdlWE9iamVjdChvYmpJZCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbWdEYXRhID0gdGhpcy5nZXRPYmplY3Qob2JqSWQpO1xuICAgIGlmICghaW1nRGF0YSkge1xuICAgICAgd2FybihcIkRlcGVuZGVudCBpbWFnZSBpc24ndCByZWFkeSB5ZXRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGFpbnRJbmxpbmVJbWFnZVhPYmplY3QoaW1nRGF0YSk7XG4gIH1cbiAgcGFpbnRJbWFnZVhPYmplY3RSZXBlYXQob2JqSWQsIHNjYWxlWCwgc2NhbGVZLCBwb3NpdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW1nRGF0YSA9IHRoaXMuZ2V0T2JqZWN0KG9iaklkKTtcbiAgICBpZiAoIWltZ0RhdGEpIHtcbiAgICAgIHdhcm4oXCJEZXBlbmRlbnQgaW1hZ2UgaXNuJ3QgcmVhZHkgeWV0XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1nRGF0YS5oZWlnaHQ7XG4gICAgY29uc3QgbWFwID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIG1hcC5wdXNoKHtcbiAgICAgICAgdHJhbnNmb3JtOiBbc2NhbGVYLCAwLCAwLCBzY2FsZVksIHBvc2l0aW9uc1tpXSwgcG9zaXRpb25zW2kgKyAxXV0sXG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHc6IHdpZHRoLFxuICAgICAgICBoOiBoZWlnaHRcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnBhaW50SW5saW5lSW1hZ2VYT2JqZWN0R3JvdXAoaW1nRGF0YSwgbWFwKTtcbiAgfVxuICBhcHBseVRyYW5zZmVyTWFwc1RvQ2FudmFzKGN0eCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnQudHJhbnNmZXJNYXBzICE9PSBcIm5vbmVcIikge1xuICAgICAgY3R4LmZpbHRlciA9IHRoaXMuY3VycmVudC50cmFuc2Zlck1hcHM7XG4gICAgICBjdHguZHJhd0ltYWdlKGN0eC5jYW52YXMsIDAsIDApO1xuICAgICAgY3R4LmZpbHRlciA9IFwibm9uZVwiO1xuICAgIH1cbiAgICByZXR1cm4gY3R4LmNhbnZhcztcbiAgfVxuICBhcHBseVRyYW5zZmVyTWFwc1RvQml0bWFwKGltZ0RhdGEpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcyA9PT0gXCJub25lXCIpIHtcbiAgICAgIHJldHVybiBpbWdEYXRhLmJpdG1hcDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYml0bWFwLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gaW1nRGF0YTtcbiAgICBjb25zdCB0bXBDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcImlubGluZUltYWdlXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgIHRtcEN0eC5maWx0ZXIgPSB0aGlzLmN1cnJlbnQudHJhbnNmZXJNYXBzO1xuICAgIHRtcEN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwKTtcbiAgICB0bXBDdHguZmlsdGVyID0gXCJub25lXCI7XG4gICAgcmV0dXJuIHRtcENhbnZhcy5jYW52YXM7XG4gIH1cbiAgcGFpbnRJbmxpbmVJbWFnZVhPYmplY3QoaW1nRGF0YSkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1nRGF0YS5oZWlnaHQ7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgdGhpcy5zYXZlKCk7XG4gICAgaWYgKCFpc05vZGVKUykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBmaWx0ZXJcbiAgICAgIH0gPSBjdHg7XG4gICAgICBpZiAoZmlsdGVyICE9PSBcIm5vbmVcIiAmJiBmaWx0ZXIgIT09IFwiXCIpIHtcbiAgICAgICAgY3R4LmZpbHRlciA9IFwibm9uZVwiO1xuICAgICAgfVxuICAgIH1cbiAgICBjdHguc2NhbGUoMSAvIHdpZHRoLCAtMSAvIGhlaWdodCk7XG4gICAgbGV0IGltZ1RvUGFpbnQ7XG4gICAgaWYgKGltZ0RhdGEuYml0bWFwKSB7XG4gICAgICBpbWdUb1BhaW50ID0gdGhpcy5hcHBseVRyYW5zZmVyTWFwc1RvQml0bWFwKGltZ0RhdGEpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSBcImZ1bmN0aW9uXCIgJiYgaW1nRGF0YSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8ICFpbWdEYXRhLmRhdGEpIHtcbiAgICAgIGltZ1RvUGFpbnQgPSBpbWdEYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0bXBDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcImlubGluZUltYWdlXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgICBwdXRCaW5hcnlJbWFnZURhdGEodG1wQ3R4LCBpbWdEYXRhKTtcbiAgICAgIGltZ1RvUGFpbnQgPSB0aGlzLmFwcGx5VHJhbnNmZXJNYXBzVG9DYW52YXModG1wQ3R4KTtcbiAgICB9XG4gICAgY29uc3Qgc2NhbGVkID0gdGhpcy5fc2NhbGVJbWFnZShpbWdUb1BhaW50LCBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShjdHgpKTtcbiAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZ2V0SW1hZ2VTbW9vdGhpbmdFbmFibGVkKGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KSwgaW1nRGF0YS5pbnRlcnBvbGF0ZSk7XG4gICAgZHJhd0ltYWdlQXRJbnRlZ2VyQ29vcmRzKGN0eCwgc2NhbGVkLmltZywgMCwgMCwgc2NhbGVkLnBhaW50V2lkdGgsIHNjYWxlZC5wYWludEhlaWdodCwgMCwgLWhlaWdodCwgd2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5jb21wb3NlKCk7XG4gICAgdGhpcy5yZXN0b3JlKCk7XG4gIH1cbiAgcGFpbnRJbmxpbmVJbWFnZVhPYmplY3RHcm91cChpbWdEYXRhLCBtYXApIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgbGV0IGltZ1RvUGFpbnQ7XG4gICAgaWYgKGltZ0RhdGEuYml0bWFwKSB7XG4gICAgICBpbWdUb1BhaW50ID0gaW1nRGF0YS5iaXRtYXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHcgPSBpbWdEYXRhLndpZHRoO1xuICAgICAgY29uc3QgaCA9IGltZ0RhdGEuaGVpZ2h0O1xuICAgICAgY29uc3QgdG1wQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJpbmxpbmVJbWFnZVwiLCB3LCBoKTtcbiAgICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgICAgcHV0QmluYXJ5SW1hZ2VEYXRhKHRtcEN0eCwgaW1nRGF0YSk7XG4gICAgICBpbWdUb1BhaW50ID0gdGhpcy5hcHBseVRyYW5zZmVyTWFwc1RvQ2FudmFzKHRtcEN0eCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZW50cnkgb2YgbWFwKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zZm9ybSguLi5lbnRyeS50cmFuc2Zvcm0pO1xuICAgICAgY3R4LnNjYWxlKDEsIC0xKTtcbiAgICAgIGRyYXdJbWFnZUF0SW50ZWdlckNvb3JkcyhjdHgsIGltZ1RvUGFpbnQsIGVudHJ5LngsIGVudHJ5LnksIGVudHJ5LncsIGVudHJ5LmgsIDAsIC0xLCAxLCAxKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIHRoaXMuY29tcG9zZSgpO1xuICB9XG4gIHBhaW50U29saWRDb2xvckltYWdlTWFzaygpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG4gICAgdGhpcy5jb21wb3NlKCk7XG4gIH1cbiAgbWFya1BvaW50KHRhZykge31cbiAgbWFya1BvaW50UHJvcHModGFnLCBwcm9wZXJ0aWVzKSB7fVxuICBiZWdpbk1hcmtlZENvbnRlbnQodGFnKSB7XG4gICAgdGhpcy5tYXJrZWRDb250ZW50U3RhY2sucHVzaCh7XG4gICAgICB2aXNpYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgYmVnaW5NYXJrZWRDb250ZW50UHJvcHModGFnLCBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKHRhZyA9PT0gXCJPQ1wiKSB7XG4gICAgICB0aGlzLm1hcmtlZENvbnRlbnRTdGFjay5wdXNoKHtcbiAgICAgICAgdmlzaWJsZTogdGhpcy5vcHRpb25hbENvbnRlbnRDb25maWcuaXNWaXNpYmxlKHByb3BlcnRpZXMpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tYXJrZWRDb250ZW50U3RhY2sucHVzaCh7XG4gICAgICAgIHZpc2libGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmNvbnRlbnRWaXNpYmxlID0gdGhpcy5pc0NvbnRlbnRWaXNpYmxlKCk7XG4gIH1cbiAgZW5kTWFya2VkQ29udGVudCgpIHtcbiAgICB0aGlzLm1hcmtlZENvbnRlbnRTdGFjay5wb3AoKTtcbiAgICB0aGlzLmNvbnRlbnRWaXNpYmxlID0gdGhpcy5pc0NvbnRlbnRWaXNpYmxlKCk7XG4gIH1cbiAgYmVnaW5Db21wYXQoKSB7fVxuICBlbmRDb21wYXQoKSB7fVxuICBjb25zdW1lUGF0aChjbGlwQm94KSB7XG4gICAgY29uc3QgaXNFbXB0eSA9IHRoaXMuY3VycmVudC5pc0VtcHR5Q2xpcCgpO1xuICAgIGlmICh0aGlzLnBlbmRpbmdDbGlwKSB7XG4gICAgICB0aGlzLmN1cnJlbnQudXBkYXRlQ2xpcEZyb21QYXRoKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5wZW5kaW5nQ2xpcCkge1xuICAgICAgdGhpcy5jb21wb3NlKGNsaXBCb3gpO1xuICAgIH1cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBpZiAodGhpcy5wZW5kaW5nQ2xpcCkge1xuICAgICAgaWYgKCFpc0VtcHR5KSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdDbGlwID09PSBFT19DTElQKSB7XG4gICAgICAgICAgY3R4LmNsaXAoXCJldmVub2RkXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eC5jbGlwKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucGVuZGluZ0NsaXAgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQuc3RhcnROZXdQYXRoQW5kQ2xpcEJveCh0aGlzLmN1cnJlbnQuY2xpcEJveCk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICB9XG4gIGdldFNpbmdsZVBpeGVsV2lkdGgoKSB7XG4gICAgaWYgKCF0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoKSB7XG4gICAgICBjb25zdCBtID0gZ2V0Q3VycmVudFRyYW5zZm9ybSh0aGlzLmN0eCk7XG4gICAgICBpZiAobVsxXSA9PT0gMCAmJiBtWzJdID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSAxIC8gTWF0aC5taW4oTWF0aC5hYnMobVswXSksIE1hdGguYWJzKG1bM10pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGFic0RldCA9IE1hdGguYWJzKG1bMF0gKiBtWzNdIC0gbVsyXSAqIG1bMV0pO1xuICAgICAgICBjb25zdCBub3JtWCA9IE1hdGguaHlwb3QobVswXSwgbVsyXSk7XG4gICAgICAgIGNvbnN0IG5vcm1ZID0gTWF0aC5oeXBvdChtWzFdLCBtWzNdKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IE1hdGgubWF4KG5vcm1YLCBub3JtWSkgLyBhYnNEZXQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoO1xuICB9XG4gIGdldFNjYWxlRm9yU3Ryb2tpbmcoKSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMF0gPT09IC0xKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxpbmVXaWR0aFxuICAgICAgfSA9IHRoaXMuY3VycmVudDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYSxcbiAgICAgICAgYixcbiAgICAgICAgYyxcbiAgICAgICAgZFxuICAgICAgfSA9IHRoaXMuY3R4LmdldFRyYW5zZm9ybSgpO1xuICAgICAgbGV0IHNjYWxlWCwgc2NhbGVZO1xuICAgICAgaWYgKGIgPT09IDAgJiYgYyA9PT0gMCkge1xuICAgICAgICBjb25zdCBub3JtWCA9IE1hdGguYWJzKGEpO1xuICAgICAgICBjb25zdCBub3JtWSA9IE1hdGguYWJzKGQpO1xuICAgICAgICBpZiAobm9ybVggPT09IG5vcm1ZKSB7XG4gICAgICAgICAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgc2NhbGVYID0gc2NhbGVZID0gMSAvIG5vcm1YO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzY2FsZWRMaW5lV2lkdGggPSBub3JtWCAqIGxpbmVXaWR0aDtcbiAgICAgICAgICAgIHNjYWxlWCA9IHNjYWxlWSA9IHNjYWxlZExpbmVXaWR0aCA8IDEgPyAxIC8gc2NhbGVkTGluZVdpZHRoIDogMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgICAgICAgc2NhbGVYID0gMSAvIG5vcm1YO1xuICAgICAgICAgIHNjYWxlWSA9IDEgLyBub3JtWTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBzY2FsZWRYTGluZVdpZHRoID0gbm9ybVggKiBsaW5lV2lkdGg7XG4gICAgICAgICAgY29uc3Qgc2NhbGVkWUxpbmVXaWR0aCA9IG5vcm1ZICogbGluZVdpZHRoO1xuICAgICAgICAgIHNjYWxlWCA9IHNjYWxlZFhMaW5lV2lkdGggPCAxID8gMSAvIHNjYWxlZFhMaW5lV2lkdGggOiAxO1xuICAgICAgICAgIHNjYWxlWSA9IHNjYWxlZFlMaW5lV2lkdGggPCAxID8gMSAvIHNjYWxlZFlMaW5lV2lkdGggOiAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBhYnNEZXQgPSBNYXRoLmFicyhhICogZCAtIGIgKiBjKTtcbiAgICAgICAgY29uc3Qgbm9ybVggPSBNYXRoLmh5cG90KGEsIGIpO1xuICAgICAgICBjb25zdCBub3JtWSA9IE1hdGguaHlwb3QoYywgZCk7XG4gICAgICAgIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICAgICAgICBzY2FsZVggPSBub3JtWSAvIGFic0RldDtcbiAgICAgICAgICBzY2FsZVkgPSBub3JtWCAvIGFic0RldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBiYXNlQXJlYSA9IGxpbmVXaWR0aCAqIGFic0RldDtcbiAgICAgICAgICBzY2FsZVggPSBub3JtWSA+IGJhc2VBcmVhID8gbm9ybVkgLyBiYXNlQXJlYSA6IDE7XG4gICAgICAgICAgc2NhbGVZID0gbm9ybVggPiBiYXNlQXJlYSA/IG5vcm1YIC8gYmFzZUFyZWEgOiAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID0gc2NhbGVYO1xuICAgICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1sxXSA9IHNjYWxlWTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmc7XG4gIH1cbiAgcmVzY2FsZUFuZFN0cm9rZShzYXZlUmVzdG9yZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGN0eFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIGxpbmVXaWR0aFxuICAgIH0gPSB0aGlzLmN1cnJlbnQ7XG4gICAgY29uc3QgW3NjYWxlWCwgc2NhbGVZXSA9IHRoaXMuZ2V0U2NhbGVGb3JTdHJva2luZygpO1xuICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGggfHwgMTtcbiAgICBpZiAoc2NhbGVYID09PSAxICYmIHNjYWxlWSA9PT0gMSkge1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkYXNoZXMgPSBjdHguZ2V0TGluZURhc2goKTtcbiAgICBpZiAoc2F2ZVJlc3RvcmUpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgfVxuICAgIGN0eC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgaWYgKGRhc2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBzY2FsZSA9IE1hdGgubWF4KHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChkYXNoZXMubWFwKHggPT4geCAvIHNjYWxlKSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgLz0gc2NhbGU7XG4gICAgfVxuICAgIGN0eC5zdHJva2UoKTtcbiAgICBpZiAoc2F2ZVJlc3RvcmUpIHtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG4gIGlzQ29udGVudFZpc2libGUoKSB7XG4gICAgZm9yIChsZXQgaSA9IHRoaXMubWFya2VkQ29udGVudFN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoIXRoaXMubWFya2VkQ29udGVudFN0YWNrW2ldLnZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuZm9yIChjb25zdCBvcCBpbiBPUFMpIHtcbiAgaWYgKENhbnZhc0dyYXBoaWNzLnByb3RvdHlwZVtvcF0gIT09IHVuZGVmaW5lZCkge1xuICAgIENhbnZhc0dyYXBoaWNzLnByb3RvdHlwZVtPUFNbb3BdXSA9IENhbnZhc0dyYXBoaWNzLnByb3RvdHlwZVtvcF07XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvd29ya2VyX29wdGlvbnMuanNcbmNsYXNzIEdsb2JhbFdvcmtlck9wdGlvbnMge1xuICBzdGF0aWMgI3BvcnQgPSBudWxsO1xuICBzdGF0aWMgI3NyYyA9IFwiXCI7XG4gIHN0YXRpYyBnZXQgd29ya2VyUG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9ydDtcbiAgfVxuICBzdGF0aWMgc2V0IHdvcmtlclBvcnQodmFsKSB7XG4gICAgaWYgKCEodHlwZW9mIFdvcmtlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiB2YWwgaW5zdGFuY2VvZiBXb3JrZXIpICYmIHZhbCAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBgd29ya2VyUG9ydGAgdHlwZS5cIik7XG4gICAgfVxuICAgIHRoaXMuI3BvcnQgPSB2YWw7XG4gIH1cbiAgc3RhdGljIGdldCB3b3JrZXJTcmMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NyYztcbiAgfVxuICBzdGF0aWMgc2V0IHdvcmtlclNyYyh2YWwpIHtcbiAgICBpZiAodHlwZW9mIHZhbCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBgd29ya2VyU3JjYCB0eXBlLlwiKTtcbiAgICB9XG4gICAgdGhpcy4jc3JjID0gdmFsO1xuICB9XG59XG5cbjsvLyAuL3NyYy9zaGFyZWQvbWVzc2FnZV9oYW5kbGVyLmpzXG5cbmNvbnN0IENhbGxiYWNrS2luZCA9IHtcbiAgVU5LTk9XTjogMCxcbiAgREFUQTogMSxcbiAgRVJST1I6IDJcbn07XG5jb25zdCBTdHJlYW1LaW5kID0ge1xuICBVTktOT1dOOiAwLFxuICBDQU5DRUw6IDEsXG4gIENBTkNFTF9DT01QTEVURTogMixcbiAgQ0xPU0U6IDMsXG4gIEVOUVVFVUU6IDQsXG4gIEVSUk9SOiA1LFxuICBQVUxMOiA2LFxuICBQVUxMX0NPTVBMRVRFOiA3LFxuICBTVEFSVF9DT01QTEVURTogOFxufTtcbmZ1bmN0aW9uIG9uRm4oKSB7fVxuZnVuY3Rpb24gd3JhcFJlYXNvbihyZWFzb24pIHtcbiAgaWYgKCEocmVhc29uIGluc3RhbmNlb2YgRXJyb3IgfHwgdHlwZW9mIHJlYXNvbiA9PT0gXCJvYmplY3RcIiAmJiByZWFzb24gIT09IG51bGwpKSB7XG4gICAgdW5yZWFjaGFibGUoJ3dyYXBSZWFzb246IEV4cGVjdGVkIFwicmVhc29uXCIgdG8gYmUgYSAocG9zc2libHkgY2xvbmVkKSBFcnJvci4nKTtcbiAgfVxuICBzd2l0Y2ggKHJlYXNvbi5uYW1lKSB7XG4gICAgY2FzZSBcIkFib3J0RXhjZXB0aW9uXCI6XG4gICAgICByZXR1cm4gbmV3IEFib3J0RXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlKTtcbiAgICBjYXNlIFwiTWlzc2luZ1BERkV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBNaXNzaW5nUERGRXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlKTtcbiAgICBjYXNlIFwiUGFzc3dvcmRFeGNlcHRpb25cIjpcbiAgICAgIHJldHVybiBuZXcgUGFzc3dvcmRFeGNlcHRpb24ocmVhc29uLm1lc3NhZ2UsIHJlYXNvbi5jb2RlKTtcbiAgICBjYXNlIFwiVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uXCI6XG4gICAgICByZXR1cm4gbmV3IFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbihyZWFzb24ubWVzc2FnZSwgcmVhc29uLnN0YXR1cyk7XG4gICAgY2FzZSBcIlVua25vd25FcnJvckV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBVbmtub3duRXJyb3JFeGNlcHRpb24ocmVhc29uLm1lc3NhZ2UsIHJlYXNvbi5kZXRhaWxzKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG5ldyBVbmtub3duRXJyb3JFeGNlcHRpb24ocmVhc29uLm1lc3NhZ2UsIHJlYXNvbi50b1N0cmluZygpKTtcbiAgfVxufVxuY2xhc3MgTWVzc2FnZUhhbmRsZXIge1xuICAjbWVzc2FnZUFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICBjb25zdHJ1Y3Rvcihzb3VyY2VOYW1lLCB0YXJnZXROYW1lLCBjb21PYmopIHtcbiAgICB0aGlzLnNvdXJjZU5hbWUgPSBzb3VyY2VOYW1lO1xuICAgIHRoaXMudGFyZ2V0TmFtZSA9IHRhcmdldE5hbWU7XG4gICAgdGhpcy5jb21PYmogPSBjb21PYmo7XG4gICAgdGhpcy5jYWxsYmFja0lkID0gMTtcbiAgICB0aGlzLnN0cmVhbUlkID0gMTtcbiAgICB0aGlzLnN0cmVhbVNpbmtzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmNhbGxiYWNrQ2FwYWJpbGl0aWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmFjdGlvbkhhbmRsZXIgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGNvbU9iai5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLiNvbk1lc3NhZ2UuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsOiB0aGlzLiNtZXNzYWdlQUMuc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgI29uTWVzc2FnZSh7XG4gICAgZGF0YVxuICB9KSB7XG4gICAgaWYgKGRhdGEudGFyZ2V0TmFtZSAhPT0gdGhpcy5zb3VyY2VOYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkYXRhLnN0cmVhbSkge1xuICAgICAgdGhpcy4jcHJvY2Vzc1N0cmVhbU1lc3NhZ2UoZGF0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkYXRhLmNhbGxiYWNrKSB7XG4gICAgICBjb25zdCBjYWxsYmFja0lkID0gZGF0YS5jYWxsYmFja0lkO1xuICAgICAgY29uc3QgY2FwYWJpbGl0eSA9IHRoaXMuY2FsbGJhY2tDYXBhYmlsaXRpZXNbY2FsbGJhY2tJZF07XG4gICAgICBpZiAoIWNhcGFiaWxpdHkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVzb2x2ZSBjYWxsYmFjayAke2NhbGxiYWNrSWR9YCk7XG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy5jYWxsYmFja0NhcGFiaWxpdGllc1tjYWxsYmFja0lkXTtcbiAgICAgIGlmIChkYXRhLmNhbGxiYWNrID09PSBDYWxsYmFja0tpbmQuREFUQSkge1xuICAgICAgICBjYXBhYmlsaXR5LnJlc29sdmUoZGF0YS5kYXRhKTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YS5jYWxsYmFjayA9PT0gQ2FsbGJhY2tLaW5kLkVSUk9SKSB7XG4gICAgICAgIGNhcGFiaWxpdHkucmVqZWN0KHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgY2FsbGJhY2sgY2FzZVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYWN0aW9uID0gdGhpcy5hY3Rpb25IYW5kbGVyW2RhdGEuYWN0aW9uXTtcbiAgICBpZiAoIWFjdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGFjdGlvbiBmcm9tIHdvcmtlcjogJHtkYXRhLmFjdGlvbn1gKTtcbiAgICB9XG4gICAgaWYgKGRhdGEuY2FsbGJhY2tJZCkge1xuICAgICAgY29uc3Qgc291cmNlTmFtZSA9IHRoaXMuc291cmNlTmFtZSxcbiAgICAgICAgdGFyZ2V0TmFtZSA9IGRhdGEuc291cmNlTmFtZSxcbiAgICAgICAgY29tT2JqID0gdGhpcy5jb21PYmo7XG4gICAgICBQcm9taXNlLnRyeShhY3Rpb24sIGRhdGEuZGF0YSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIGNhbGxiYWNrOiBDYWxsYmFja0tpbmQuREFUQSxcbiAgICAgICAgICBjYWxsYmFja0lkOiBkYXRhLmNhbGxiYWNrSWQsXG4gICAgICAgICAgZGF0YTogcmVzdWx0XG4gICAgICAgIH0pO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBjYWxsYmFjazogQ2FsbGJhY2tLaW5kLkVSUk9SLFxuICAgICAgICAgIGNhbGxiYWNrSWQ6IGRhdGEuY2FsbGJhY2tJZCxcbiAgICAgICAgICByZWFzb246IHdyYXBSZWFzb24ocmVhc29uKVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGF0YS5zdHJlYW1JZCkge1xuICAgICAgdGhpcy4jY3JlYXRlU3RyZWFtU2luayhkYXRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYWN0aW9uKGRhdGEuZGF0YSk7XG4gIH1cbiAgb24oYWN0aW9uTmFtZSwgaGFuZGxlcikge1xuICAgIGNvbnN0IGFoID0gdGhpcy5hY3Rpb25IYW5kbGVyO1xuICAgIGlmIChhaFthY3Rpb25OYW1lXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGVyZSBpcyBhbHJlYWR5IGFuIGFjdGlvbk5hbWUgY2FsbGVkIFwiJHthY3Rpb25OYW1lfVwiYCk7XG4gICAgfVxuICAgIGFoW2FjdGlvbk5hbWVdID0gaGFuZGxlcjtcbiAgfVxuICBzZW5kKGFjdGlvbk5hbWUsIGRhdGEsIHRyYW5zZmVycykge1xuICAgIHRoaXMuY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgIHNvdXJjZU5hbWU6IHRoaXMuc291cmNlTmFtZSxcbiAgICAgIHRhcmdldE5hbWU6IHRoaXMudGFyZ2V0TmFtZSxcbiAgICAgIGFjdGlvbjogYWN0aW9uTmFtZSxcbiAgICAgIGRhdGFcbiAgICB9LCB0cmFuc2ZlcnMpO1xuICB9XG4gIHNlbmRXaXRoUHJvbWlzZShhY3Rpb25OYW1lLCBkYXRhLCB0cmFuc2ZlcnMpIHtcbiAgICBjb25zdCBjYWxsYmFja0lkID0gdGhpcy5jYWxsYmFja0lkKys7XG4gICAgY29uc3QgY2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuY2FsbGJhY2tDYXBhYmlsaXRpZXNbY2FsbGJhY2tJZF0gPSBjYXBhYmlsaXR5O1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHNvdXJjZU5hbWU6IHRoaXMuc291cmNlTmFtZSxcbiAgICAgICAgdGFyZ2V0TmFtZTogdGhpcy50YXJnZXROYW1lLFxuICAgICAgICBhY3Rpb246IGFjdGlvbk5hbWUsXG4gICAgICAgIGNhbGxiYWNrSWQsXG4gICAgICAgIGRhdGFcbiAgICAgIH0sIHRyYW5zZmVycyk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGNhcGFiaWxpdHkucmVqZWN0KGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBzZW5kV2l0aFN0cmVhbShhY3Rpb25OYW1lLCBkYXRhLCBxdWV1ZWluZ1N0cmF0ZWd5LCB0cmFuc2ZlcnMpIHtcbiAgICBjb25zdCBzdHJlYW1JZCA9IHRoaXMuc3RyZWFtSWQrKyxcbiAgICAgIHNvdXJjZU5hbWUgPSB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICB0YXJnZXROYW1lID0gdGhpcy50YXJnZXROYW1lLFxuICAgICAgY29tT2JqID0gdGhpcy5jb21PYmo7XG4gICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICBzdGFydDogY29udHJvbGxlciA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0Q2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXSA9IHtcbiAgICAgICAgICBjb250cm9sbGVyLFxuICAgICAgICAgIHN0YXJ0Q2FsbDogc3RhcnRDYXBhYmlsaXR5LFxuICAgICAgICAgIHB1bGxDYWxsOiBudWxsLFxuICAgICAgICAgIGNhbmNlbENhbGw6IG51bGwsXG4gICAgICAgICAgaXNDbG9zZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uTmFtZSxcbiAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIGRlc2lyZWRTaXplOiBjb250cm9sbGVyLmRlc2lyZWRTaXplXG4gICAgICAgIH0sIHRyYW5zZmVycyk7XG4gICAgICAgIHJldHVybiBzdGFydENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICAgIH0sXG4gICAgICBwdWxsOiBjb250cm9sbGVyID0+IHtcbiAgICAgICAgY29uc3QgcHVsbENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0ucHVsbENhbGwgPSBwdWxsQ2FwYWJpbGl0eTtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlBVTEwsXG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgZGVzaXJlZFNpemU6IGNvbnRyb2xsZXIuZGVzaXJlZFNpemVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwdWxsQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgICAgfSxcbiAgICAgIGNhbmNlbDogcmVhc29uID0+IHtcbiAgICAgICAgYXNzZXJ0KHJlYXNvbiBpbnN0YW5jZW9mIEVycm9yLCBcImNhbmNlbCBtdXN0IGhhdmUgYSB2YWxpZCByZWFzb25cIik7XG4gICAgICAgIGNvbnN0IGNhbmNlbENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0uY2FuY2VsQ2FsbCA9IGNhbmNlbENhcGFiaWxpdHk7XG4gICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkNBTkNFTCxcbiAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICByZWFzb246IHdyYXBSZWFzb24ocmVhc29uKVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNhbmNlbENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICAgIH1cbiAgICB9LCBxdWV1ZWluZ1N0cmF0ZWd5KTtcbiAgfVxuICAjY3JlYXRlU3RyZWFtU2luayhkYXRhKSB7XG4gICAgY29uc3Qgc3RyZWFtSWQgPSBkYXRhLnN0cmVhbUlkLFxuICAgICAgc291cmNlTmFtZSA9IHRoaXMuc291cmNlTmFtZSxcbiAgICAgIHRhcmdldE5hbWUgPSBkYXRhLnNvdXJjZU5hbWUsXG4gICAgICBjb21PYmogPSB0aGlzLmNvbU9iajtcbiAgICBjb25zdCBzZWxmID0gdGhpcyxcbiAgICAgIGFjdGlvbiA9IHRoaXMuYWN0aW9uSGFuZGxlcltkYXRhLmFjdGlvbl07XG4gICAgY29uc3Qgc3RyZWFtU2luayA9IHtcbiAgICAgIGVucXVldWUoY2h1bmssIHNpemUgPSAxLCB0cmFuc2ZlcnMpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFzdERlc2lyZWRTaXplID0gdGhpcy5kZXNpcmVkU2l6ZTtcbiAgICAgICAgdGhpcy5kZXNpcmVkU2l6ZSAtPSBzaXplO1xuICAgICAgICBpZiAobGFzdERlc2lyZWRTaXplID4gMCAmJiB0aGlzLmRlc2lyZWRTaXplIDw9IDApIHtcbiAgICAgICAgICB0aGlzLnNpbmtDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgICAgICAgdGhpcy5yZWFkeSA9IHRoaXMuc2lua0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuRU5RVUVVRSxcbiAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICBjaHVua1xuICAgICAgICB9LCB0cmFuc2ZlcnMpO1xuICAgICAgfSxcbiAgICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5pc0NhbmNlbGxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkNMT1NFLFxuICAgICAgICAgIHN0cmVhbUlkXG4gICAgICAgIH0pO1xuICAgICAgICBkZWxldGUgc2VsZi5zdHJlYW1TaW5rc1tzdHJlYW1JZF07XG4gICAgICB9LFxuICAgICAgZXJyb3IocmVhc29uKSB7XG4gICAgICAgIGFzc2VydChyZWFzb24gaW5zdGFuY2VvZiBFcnJvciwgXCJlcnJvciBtdXN0IGhhdmUgYSB2YWxpZCByZWFzb25cIik7XG4gICAgICAgIGlmICh0aGlzLmlzQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNDYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuRVJST1IsXG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgc2lua0NhcGFiaWxpdHk6IFByb21pc2Uud2l0aFJlc29sdmVycygpLFxuICAgICAgb25QdWxsOiBudWxsLFxuICAgICAgb25DYW5jZWw6IG51bGwsXG4gICAgICBpc0NhbmNlbGxlZDogZmFsc2UsXG4gICAgICBkZXNpcmVkU2l6ZTogZGF0YS5kZXNpcmVkU2l6ZSxcbiAgICAgIHJlYWR5OiBudWxsXG4gICAgfTtcbiAgICBzdHJlYW1TaW5rLnNpbmtDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICBzdHJlYW1TaW5rLnJlYWR5ID0gc3RyZWFtU2luay5zaW5rQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIHRoaXMuc3RyZWFtU2lua3Nbc3RyZWFtSWRdID0gc3RyZWFtU2luaztcbiAgICBQcm9taXNlLnRyeShhY3Rpb24sIGRhdGEuZGF0YSwgc3RyZWFtU2luaykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuU1RBUlRfQ09NUExFVEUsXG4gICAgICAgIHN0cmVhbUlkLFxuICAgICAgICBzdWNjZXNzOiB0cnVlXG4gICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuU1RBUlRfQ09NUExFVEUsXG4gICAgICAgIHN0cmVhbUlkLFxuICAgICAgICByZWFzb246IHdyYXBSZWFzb24ocmVhc29uKVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgI3Byb2Nlc3NTdHJlYW1NZXNzYWdlKGRhdGEpIHtcbiAgICBjb25zdCBzdHJlYW1JZCA9IGRhdGEuc3RyZWFtSWQsXG4gICAgICBzb3VyY2VOYW1lID0gdGhpcy5zb3VyY2VOYW1lLFxuICAgICAgdGFyZ2V0TmFtZSA9IGRhdGEuc291cmNlTmFtZSxcbiAgICAgIGNvbU9iaiA9IHRoaXMuY29tT2JqO1xuICAgIGNvbnN0IHN0cmVhbUNvbnRyb2xsZXIgPSB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXSxcbiAgICAgIHN0cmVhbVNpbmsgPSB0aGlzLnN0cmVhbVNpbmtzW3N0cmVhbUlkXTtcbiAgICBzd2l0Y2ggKGRhdGEuc3RyZWFtKSB7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuU1RBUlRfQ09NUExFVEU6XG4gICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLnN0YXJ0Q2FsbC5yZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5zdGFydENhbGwucmVqZWN0KHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5QVUxMX0NPTVBMRVRFOlxuICAgICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5wdWxsQ2FsbC5yZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5wdWxsQ2FsbC5yZWplY3Qod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLlBVTEw6XG4gICAgICAgIGlmICghc3RyZWFtU2luaykge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5QVUxMX0NPTVBMRVRFLFxuICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbVNpbmsuZGVzaXJlZFNpemUgPD0gMCAmJiBkYXRhLmRlc2lyZWRTaXplID4gMCkge1xuICAgICAgICAgIHN0cmVhbVNpbmsuc2lua0NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbVNpbmsuZGVzaXJlZFNpemUgPSBkYXRhLmRlc2lyZWRTaXplO1xuICAgICAgICBQcm9taXNlLnRyeShzdHJlYW1TaW5rLm9uUHVsbCB8fCBvbkZuKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuUFVMTF9DT01QTEVURSxcbiAgICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlBVTExfQ09NUExFVEUsXG4gICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5FTlFVRVVFOlxuICAgICAgICBhc3NlcnQoc3RyZWFtQ29udHJvbGxlciwgXCJlbnF1ZXVlIHNob3VsZCBoYXZlIHN0cmVhbSBjb250cm9sbGVyXCIpO1xuICAgICAgICBpZiAoc3RyZWFtQ29udHJvbGxlci5pc0Nsb3NlZCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuY29udHJvbGxlci5lbnF1ZXVlKGRhdGEuY2h1bmspO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5DTE9TRTpcbiAgICAgICAgYXNzZXJ0KHN0cmVhbUNvbnRyb2xsZXIsIFwiY2xvc2Ugc2hvdWxkIGhhdmUgc3RyZWFtIGNvbnRyb2xsZXJcIik7XG4gICAgICAgIGlmIChzdHJlYW1Db250cm9sbGVyLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtQ29udHJvbGxlci5pc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICB0aGlzLiNkZWxldGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIsIHN0cmVhbUlkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuRVJST1I6XG4gICAgICAgIGFzc2VydChzdHJlYW1Db250cm9sbGVyLCBcImVycm9yIHNob3VsZCBoYXZlIHN0cmVhbSBjb250cm9sbGVyXCIpO1xuICAgICAgICBzdHJlYW1Db250cm9sbGVyLmNvbnRyb2xsZXIuZXJyb3Iod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpO1xuICAgICAgICB0aGlzLiNkZWxldGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIsIHN0cmVhbUlkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuQ0FOQ0VMX0NPTVBMRVRFOlxuICAgICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5jYW5jZWxDYWxsLnJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLmNhbmNlbENhbGwucmVqZWN0KHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNkZWxldGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIsIHN0cmVhbUlkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuQ0FOQ0VMOlxuICAgICAgICBpZiAoIXN0cmVhbVNpbmspIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhUmVhc29uID0gd3JhcFJlYXNvbihkYXRhLnJlYXNvbik7XG4gICAgICAgIFByb21pc2UudHJ5KHN0cmVhbVNpbmsub25DYW5jZWwgfHwgb25GbiwgZGF0YVJlYXNvbikudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkNBTkNFTF9DT01QTEVURSxcbiAgICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkNBTkNFTF9DT01QTEVURSxcbiAgICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0cmVhbVNpbmsuc2lua0NhcGFiaWxpdHkucmVqZWN0KGRhdGFSZWFzb24pO1xuICAgICAgICBzdHJlYW1TaW5rLmlzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgZGVsZXRlIHRoaXMuc3RyZWFtU2lua3Nbc3RyZWFtSWRdO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgc3RyZWFtIGNhc2VcIik7XG4gICAgfVxuICB9XG4gIGFzeW5jICNkZWxldGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIsIHN0cmVhbUlkKSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKFtzdHJlYW1Db250cm9sbGVyLnN0YXJ0Q2FsbD8ucHJvbWlzZSwgc3RyZWFtQ29udHJvbGxlci5wdWxsQ2FsbD8ucHJvbWlzZSwgc3RyZWFtQ29udHJvbGxlci5jYW5jZWxDYWxsPy5wcm9taXNlXSk7XG4gICAgZGVsZXRlIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4jbWVzc2FnZUFDPy5hYm9ydCgpO1xuICAgIHRoaXMuI21lc3NhZ2VBQyA9IG51bGw7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvbWV0YWRhdGEuanNcblxuY2xhc3MgTWV0YWRhdGEge1xuICAjbWV0YWRhdGFNYXA7XG4gICNkYXRhO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcGFyc2VkRGF0YSxcbiAgICByYXdEYXRhXG4gIH0pIHtcbiAgICB0aGlzLiNtZXRhZGF0YU1hcCA9IHBhcnNlZERhdGE7XG4gICAgdGhpcy4jZGF0YSA9IHJhd0RhdGE7XG4gIH1cbiAgZ2V0UmF3KCkge1xuICAgIHJldHVybiB0aGlzLiNkYXRhO1xuICB9XG4gIGdldChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuI21ldGFkYXRhTWFwLmdldChuYW1lKSA/PyBudWxsO1xuICB9XG4gIGdldEFsbCgpIHtcbiAgICByZXR1cm4gb2JqZWN0RnJvbU1hcCh0aGlzLiNtZXRhZGF0YU1hcCk7XG4gIH1cbiAgaGFzKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy4jbWV0YWRhdGFNYXAuaGFzKG5hbWUpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L29wdGlvbmFsX2NvbnRlbnRfY29uZmlnLmpzXG5cblxuY29uc3QgSU5URVJOQUwgPSBTeW1ib2woXCJJTlRFUk5BTFwiKTtcbmNsYXNzIE9wdGlvbmFsQ29udGVudEdyb3VwIHtcbiAgI2lzRGlzcGxheSA9IGZhbHNlO1xuICAjaXNQcmludCA9IGZhbHNlO1xuICAjdXNlclNldCA9IGZhbHNlO1xuICAjdmlzaWJsZSA9IHRydWU7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmluZ0ludGVudCwge1xuICAgIG5hbWUsXG4gICAgaW50ZW50LFxuICAgIHVzYWdlLFxuICAgIHJiR3JvdXBzXG4gIH0pIHtcbiAgICB0aGlzLiNpc0Rpc3BsYXkgPSAhIShyZW5kZXJpbmdJbnRlbnQgJiBSZW5kZXJpbmdJbnRlbnRGbGFnLkRJU1BMQVkpO1xuICAgIHRoaXMuI2lzUHJpbnQgPSAhIShyZW5kZXJpbmdJbnRlbnQgJiBSZW5kZXJpbmdJbnRlbnRGbGFnLlBSSU5UKTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuaW50ZW50ID0gaW50ZW50O1xuICAgIHRoaXMudXNhZ2UgPSB1c2FnZTtcbiAgICB0aGlzLnJiR3JvdXBzID0gcmJHcm91cHM7XG4gIH1cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgaWYgKHRoaXMuI3VzZXJTZXQpIHtcbiAgICAgIHJldHVybiB0aGlzLiN2aXNpYmxlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI3Zpc2libGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcHJpbnQsXG4gICAgICB2aWV3XG4gICAgfSA9IHRoaXMudXNhZ2U7XG4gICAgaWYgKHRoaXMuI2lzRGlzcGxheSkge1xuICAgICAgcmV0dXJuIHZpZXc/LnZpZXdTdGF0ZSAhPT0gXCJPRkZcIjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuI2lzUHJpbnQpIHtcbiAgICAgIHJldHVybiBwcmludD8ucHJpbnRTdGF0ZSAhPT0gXCJPRkZcIjtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgX3NldFZpc2libGUoaW50ZXJuYWwsIHZpc2libGUsIHVzZXJTZXQgPSBmYWxzZSkge1xuICAgIGlmIChpbnRlcm5hbCAhPT0gSU5URVJOQUwpIHtcbiAgICAgIHVucmVhY2hhYmxlKFwiSW50ZXJuYWwgbWV0aG9kIGBfc2V0VmlzaWJsZWAgY2FsbGVkLlwiKTtcbiAgICB9XG4gICAgdGhpcy4jdXNlclNldCA9IHVzZXJTZXQ7XG4gICAgdGhpcy4jdmlzaWJsZSA9IHZpc2libGU7XG4gIH1cbn1cbmNsYXNzIE9wdGlvbmFsQ29udGVudENvbmZpZyB7XG4gICNjYWNoZWRHZXRIYXNoID0gbnVsbDtcbiAgI2dyb3VwcyA9IG5ldyBNYXAoKTtcbiAgI2luaXRpYWxIYXNoID0gbnVsbDtcbiAgI29yZGVyID0gbnVsbDtcbiAgY29uc3RydWN0b3IoZGF0YSwgcmVuZGVyaW5nSW50ZW50ID0gUmVuZGVyaW5nSW50ZW50RmxhZy5ESVNQTEFZKSB7XG4gICAgdGhpcy5yZW5kZXJpbmdJbnRlbnQgPSByZW5kZXJpbmdJbnRlbnQ7XG4gICAgdGhpcy5uYW1lID0gbnVsbDtcbiAgICB0aGlzLmNyZWF0b3IgPSBudWxsO1xuICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubmFtZSA9IGRhdGEubmFtZTtcbiAgICB0aGlzLmNyZWF0b3IgPSBkYXRhLmNyZWF0b3I7XG4gICAgdGhpcy4jb3JkZXIgPSBkYXRhLm9yZGVyO1xuICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgZGF0YS5ncm91cHMpIHtcbiAgICAgIHRoaXMuI2dyb3Vwcy5zZXQoZ3JvdXAuaWQsIG5ldyBPcHRpb25hbENvbnRlbnRHcm91cChyZW5kZXJpbmdJbnRlbnQsIGdyb3VwKSk7XG4gICAgfVxuICAgIGlmIChkYXRhLmJhc2VTdGF0ZSA9PT0gXCJPRkZcIikge1xuICAgICAgZm9yIChjb25zdCBncm91cCBvZiB0aGlzLiNncm91cHMudmFsdWVzKCkpIHtcbiAgICAgICAgZ3JvdXAuX3NldFZpc2libGUoSU5URVJOQUwsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBvbiBvZiBkYXRhLm9uKSB7XG4gICAgICB0aGlzLiNncm91cHMuZ2V0KG9uKS5fc2V0VmlzaWJsZShJTlRFUk5BTCwgdHJ1ZSk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgb2ZmIG9mIGRhdGEub2ZmKSB7XG4gICAgICB0aGlzLiNncm91cHMuZ2V0KG9mZikuX3NldFZpc2libGUoSU5URVJOQUwsIGZhbHNlKTtcbiAgICB9XG4gICAgdGhpcy4jaW5pdGlhbEhhc2ggPSB0aGlzLmdldEhhc2goKTtcbiAgfVxuICAjZXZhbHVhdGVWaXNpYmlsaXR5RXhwcmVzc2lvbihhcnJheSkge1xuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IG9wZXJhdG9yID0gYXJyYXlbMF07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGFycmF5W2ldO1xuICAgICAgbGV0IHN0YXRlO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZWxlbWVudCkpIHtcbiAgICAgICAgc3RhdGUgPSB0aGlzLiNldmFsdWF0ZVZpc2liaWxpdHlFeHByZXNzaW9uKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLiNncm91cHMuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgIHN0YXRlID0gdGhpcy4jZ3JvdXBzLmdldChlbGVtZW50KS52aXNpYmxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7ZWxlbWVudH1gKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgIGNhc2UgXCJBbmRcIjpcbiAgICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiT3JcIjpcbiAgICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk5vdFwiOlxuICAgICAgICAgIHJldHVybiAhc3RhdGU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcGVyYXRvciA9PT0gXCJBbmRcIjtcbiAgfVxuICBpc1Zpc2libGUoZ3JvdXApIHtcbiAgICBpZiAodGhpcy4jZ3JvdXBzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWdyb3VwKSB7XG4gICAgICBpbmZvKFwiT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZGVmaW5lZC5cIik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGdyb3VwLnR5cGUgPT09IFwiT0NHXCIpIHtcbiAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmhhcyhncm91cC5pZCkpIHtcbiAgICAgICAgd2FybihgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7Z3JvdXAuaWR9YCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuI2dyb3Vwcy5nZXQoZ3JvdXAuaWQpLnZpc2libGU7XG4gICAgfSBlbHNlIGlmIChncm91cC50eXBlID09PSBcIk9DTURcIikge1xuICAgICAgaWYgKGdyb3VwLmV4cHJlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2V2YWx1YXRlVmlzaWJpbGl0eUV4cHJlc3Npb24oZ3JvdXAuZXhwcmVzc2lvbik7XG4gICAgICB9XG4gICAgICBpZiAoIWdyb3VwLnBvbGljeSB8fCBncm91cC5wb2xpY3kgPT09IFwiQW55T25cIikge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGdyb3VwLmlkcykge1xuICAgICAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHdhcm4oYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2lkfWApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLiNncm91cHMuZ2V0KGlkKS52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChncm91cC5wb2xpY3kgPT09IFwiQWxsT25cIikge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGdyb3VwLmlkcykge1xuICAgICAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHdhcm4oYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2lkfWApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmdldChpZCkudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZ3JvdXAucG9saWN5ID09PSBcIkFueU9mZlwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgZ3JvdXAuaWRzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgd2FybihgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7aWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuZ2V0KGlkKS52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChncm91cC5wb2xpY3kgPT09IFwiQWxsT2ZmXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBncm91cC5pZHMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICB3YXJuKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtpZH1gKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy4jZ3JvdXBzLmdldChpZCkudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHdhcm4oYFVua25vd24gb3B0aW9uYWwgY29udGVudCBwb2xpY3kgJHtncm91cC5wb2xpY3l9LmApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHdhcm4oYFVua25vd24gZ3JvdXAgdHlwZSAke2dyb3VwLnR5cGV9LmApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHNldFZpc2liaWxpdHkoaWQsIHZpc2libGUgPSB0cnVlLCBwcmVzZXJ2ZVJCID0gdHJ1ZSkge1xuICAgIGNvbnN0IGdyb3VwID0gdGhpcy4jZ3JvdXBzLmdldChpZCk7XG4gICAgaWYgKCFncm91cCkge1xuICAgICAgd2FybihgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7aWR9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwcmVzZXJ2ZVJCICYmIHZpc2libGUgJiYgZ3JvdXAucmJHcm91cHMubGVuZ3RoKSB7XG4gICAgICBmb3IgKGNvbnN0IHJiR3JvdXAgb2YgZ3JvdXAucmJHcm91cHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBvdGhlcklkIG9mIHJiR3JvdXApIHtcbiAgICAgICAgICBpZiAob3RoZXJJZCAhPT0gaWQpIHtcbiAgICAgICAgICAgIHRoaXMuI2dyb3Vwcy5nZXQob3RoZXJJZCk/Ll9zZXRWaXNpYmxlKElOVEVSTkFMLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGdyb3VwLl9zZXRWaXNpYmxlKElOVEVSTkFMLCAhIXZpc2libGUsIHRydWUpO1xuICAgIHRoaXMuI2NhY2hlZEdldEhhc2ggPSBudWxsO1xuICB9XG4gIHNldE9DR1N0YXRlKHtcbiAgICBzdGF0ZSxcbiAgICBwcmVzZXJ2ZVJCXG4gIH0pIHtcbiAgICBsZXQgb3BlcmF0b3I7XG4gICAgZm9yIChjb25zdCBlbGVtIG9mIHN0YXRlKSB7XG4gICAgICBzd2l0Y2ggKGVsZW0pIHtcbiAgICAgICAgY2FzZSBcIk9OXCI6XG4gICAgICAgIGNhc2UgXCJPRkZcIjpcbiAgICAgICAgY2FzZSBcIlRvZ2dsZVwiOlxuICAgICAgICAgIG9wZXJhdG9yID0gZWxlbTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGdyb3VwID0gdGhpcy4jZ3JvdXBzLmdldChlbGVtKTtcbiAgICAgIGlmICghZ3JvdXApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgIGNhc2UgXCJPTlwiOlxuICAgICAgICAgIHRoaXMuc2V0VmlzaWJpbGl0eShlbGVtLCB0cnVlLCBwcmVzZXJ2ZVJCKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk9GRlwiOlxuICAgICAgICAgIHRoaXMuc2V0VmlzaWJpbGl0eShlbGVtLCBmYWxzZSwgcHJlc2VydmVSQik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJUb2dnbGVcIjpcbiAgICAgICAgICB0aGlzLnNldFZpc2liaWxpdHkoZWxlbSwgIWdyb3VwLnZpc2libGUsIHByZXNlcnZlUkIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNjYWNoZWRHZXRIYXNoID0gbnVsbDtcbiAgfVxuICBnZXQgaGFzSW5pdGlhbFZpc2liaWxpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2luaXRpYWxIYXNoID09PSBudWxsIHx8IHRoaXMuZ2V0SGFzaCgpID09PSB0aGlzLiNpbml0aWFsSGFzaDtcbiAgfVxuICBnZXRPcmRlcigpIHtcbiAgICBpZiAoIXRoaXMuI2dyb3Vwcy5zaXplKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuI29yZGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy4jb3JkZXIuc2xpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIFsuLi50aGlzLiNncm91cHMua2V5cygpXTtcbiAgfVxuICBnZXRHcm91cHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2dyb3Vwcy5zaXplID4gMCA/IG9iamVjdEZyb21NYXAodGhpcy4jZ3JvdXBzKSA6IG51bGw7XG4gIH1cbiAgZ2V0R3JvdXAoaWQpIHtcbiAgICByZXR1cm4gdGhpcy4jZ3JvdXBzLmdldChpZCkgfHwgbnVsbDtcbiAgfVxuICBnZXRIYXNoKCkge1xuICAgIGlmICh0aGlzLiNjYWNoZWRHZXRIYXNoICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy4jY2FjaGVkR2V0SGFzaDtcbiAgICB9XG4gICAgY29uc3QgaGFzaCA9IG5ldyBNdXJtdXJIYXNoM182NCgpO1xuICAgIGZvciAoY29uc3QgW2lkLCBncm91cF0gb2YgdGhpcy4jZ3JvdXBzKSB7XG4gICAgICBoYXNoLnVwZGF0ZShgJHtpZH06JHtncm91cC52aXNpYmxlfWApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4jY2FjaGVkR2V0SGFzaCA9IGhhc2guaGV4ZGlnZXN0KCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvdHJhbnNwb3J0X3N0cmVhbS5qc1xuXG5cbmNsYXNzIFBERkRhdGFUcmFuc3BvcnRTdHJlYW0ge1xuICBjb25zdHJ1Y3RvcihwZGZEYXRhUmFuZ2VUcmFuc3BvcnQsIHtcbiAgICBkaXNhYmxlUmFuZ2UgPSBmYWxzZSxcbiAgICBkaXNhYmxlU3RyZWFtID0gZmFsc2VcbiAgfSkge1xuICAgIGFzc2VydChwZGZEYXRhUmFuZ2VUcmFuc3BvcnQsICdQREZEYXRhVHJhbnNwb3J0U3RyZWFtIC0gbWlzc2luZyByZXF1aXJlZCBcInBkZkRhdGFSYW5nZVRyYW5zcG9ydFwiIGFyZ3VtZW50LicpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxlbmd0aCxcbiAgICAgIGluaXRpYWxEYXRhLFxuICAgICAgcHJvZ3Jlc3NpdmVEb25lLFxuICAgICAgY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWVcbiAgICB9ID0gcGRmRGF0YVJhbmdlVHJhbnNwb3J0O1xuICAgIHRoaXMuX3F1ZXVlZENodW5rcyA9IFtdO1xuICAgIHRoaXMuX3Byb2dyZXNzaXZlRG9uZSA9IHByb2dyZXNzaXZlRG9uZTtcbiAgICB0aGlzLl9jb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSA9IGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lO1xuICAgIGlmIChpbml0aWFsRGF0YT8ubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgYnVmZmVyID0gaW5pdGlhbERhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIGluaXRpYWxEYXRhLmJ5dGVMZW5ndGggPT09IGluaXRpYWxEYXRhLmJ1ZmZlci5ieXRlTGVuZ3RoID8gaW5pdGlhbERhdGEuYnVmZmVyIDogbmV3IFVpbnQ4QXJyYXkoaW5pdGlhbERhdGEpLmJ1ZmZlcjtcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rcy5wdXNoKGJ1ZmZlcik7XG4gICAgfVxuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydCA9IHBkZkRhdGFSYW5nZVRyYW5zcG9ydDtcbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9ICFkaXNhYmxlU3RyZWFtO1xuICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSAhZGlzYWJsZVJhbmdlO1xuICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBsZW5ndGg7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3JhbmdlUmVhZGVycyA9IFtdO1xuICAgIHBkZkRhdGFSYW5nZVRyYW5zcG9ydC5hZGRSYW5nZUxpc3RlbmVyKChiZWdpbiwgY2h1bmspID0+IHtcbiAgICAgIHRoaXMuX29uUmVjZWl2ZURhdGEoe1xuICAgICAgICBiZWdpbixcbiAgICAgICAgY2h1bmtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHBkZkRhdGFSYW5nZVRyYW5zcG9ydC5hZGRQcm9ncmVzc0xpc3RlbmVyKChsb2FkZWQsIHRvdGFsKSA9PiB7XG4gICAgICB0aGlzLl9vblByb2dyZXNzKHtcbiAgICAgICAgbG9hZGVkLFxuICAgICAgICB0b3RhbFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcGRmRGF0YVJhbmdlVHJhbnNwb3J0LmFkZFByb2dyZXNzaXZlUmVhZExpc3RlbmVyKGNodW5rID0+IHtcbiAgICAgIHRoaXMuX29uUmVjZWl2ZURhdGEoe1xuICAgICAgICBjaHVua1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcGRmRGF0YVJhbmdlVHJhbnNwb3J0LmFkZFByb2dyZXNzaXZlRG9uZUxpc3RlbmVyKCgpID0+IHtcbiAgICAgIHRoaXMuX29uUHJvZ3Jlc3NpdmVEb25lKCk7XG4gICAgfSk7XG4gICAgcGRmRGF0YVJhbmdlVHJhbnNwb3J0LnRyYW5zcG9ydFJlYWR5KCk7XG4gIH1cbiAgX29uUmVjZWl2ZURhdGEoe1xuICAgIGJlZ2luLFxuICAgIGNodW5rXG4gIH0pIHtcbiAgICBjb25zdCBidWZmZXIgPSBjaHVuayBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgY2h1bmsuYnl0ZUxlbmd0aCA9PT0gY2h1bmsuYnVmZmVyLmJ5dGVMZW5ndGggPyBjaHVuay5idWZmZXIgOiBuZXcgVWludDhBcnJheShjaHVuaykuYnVmZmVyO1xuICAgIGlmIChiZWdpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIpIHtcbiAgICAgICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIuX2VucXVldWUoYnVmZmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlZENodW5rcy5wdXNoKGJ1ZmZlcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZvdW5kID0gdGhpcy5fcmFuZ2VSZWFkZXJzLnNvbWUoZnVuY3Rpb24gKHJhbmdlUmVhZGVyKSB7XG4gICAgICAgIGlmIChyYW5nZVJlYWRlci5fYmVnaW4gIT09IGJlZ2luKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJhbmdlUmVhZGVyLl9lbnF1ZXVlKGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG4gICAgICBhc3NlcnQoZm91bmQsIFwiX29uUmVjZWl2ZURhdGEgLSBubyBgUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJhbmdlUmVhZGVyYCBpbnN0YW5jZSBmb3VuZC5cIik7XG4gICAgfVxuICB9XG4gIGdldCBfcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8uX2xvYWRlZCA/PyAwO1xuICB9XG4gIF9vblByb2dyZXNzKGV2dCkge1xuICAgIGlmIChldnQudG90YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcmFuZ2VSZWFkZXJzWzBdPy5vblByb2dyZXNzPy4oe1xuICAgICAgICBsb2FkZWQ6IGV2dC5sb2FkZWRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8ub25Qcm9ncmVzcz8uKHtcbiAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkLFxuICAgICAgICB0b3RhbDogZXZ0LnRvdGFsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgX29uUHJvZ3Jlc3NpdmVEb25lKCkge1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5wcm9ncmVzc2l2ZURvbmUoKTtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZURvbmUgPSB0cnVlO1xuICB9XG4gIF9yZW1vdmVSYW5nZVJlYWRlcihyZWFkZXIpIHtcbiAgICBjb25zdCBpID0gdGhpcy5fcmFuZ2VSZWFkZXJzLmluZGV4T2YocmVhZGVyKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICB0aGlzLl9yYW5nZVJlYWRlcnMuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxuICBnZXRGdWxsUmVhZGVyKCkge1xuICAgIGFzc2VydCghdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIsIFwiUERGRGF0YVRyYW5zcG9ydFN0cmVhbS5nZXRGdWxsUmVhZGVyIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLlwiKTtcbiAgICBjb25zdCBxdWV1ZWRDaHVua3MgPSB0aGlzLl9xdWV1ZWRDaHVua3M7XG4gICAgdGhpcy5fcXVldWVkQ2h1bmtzID0gbnVsbDtcbiAgICByZXR1cm4gbmV3IFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SZWFkZXIodGhpcywgcXVldWVkQ2h1bmtzLCB0aGlzLl9wcm9ncmVzc2l2ZURvbmUsIHRoaXMuX2NvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lKTtcbiAgfVxuICBnZXRSYW5nZVJlYWRlcihiZWdpbiwgZW5kKSB7XG4gICAgaWYgKGVuZCA8PSB0aGlzLl9wcm9ncmVzc2l2ZURhdGFMZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZWFkZXIgPSBuZXcgUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJhbmdlUmVhZGVyKHRoaXMsIGJlZ2luLCBlbmQpO1xuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydC5yZXF1ZXN0RGF0YVJhbmdlKGJlZ2luLCBlbmQpO1xuICAgIHRoaXMuX3JhbmdlUmVhZGVycy5wdXNoKHJlYWRlcik7XG4gICAgcmV0dXJuIHJlYWRlcjtcbiAgfVxuICBjYW5jZWxBbGxSZXF1ZXN0cyhyZWFzb24pIHtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8uY2FuY2VsKHJlYXNvbik7XG4gICAgZm9yIChjb25zdCByZWFkZXIgb2YgdGhpcy5fcmFuZ2VSZWFkZXJzLnNsaWNlKDApKSB7XG4gICAgICByZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgfVxuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydC5hYm9ydCgpO1xuICB9XG59XG5jbGFzcyBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtLCBxdWV1ZWRDaHVua3MsIHByb2dyZXNzaXZlRG9uZSA9IGZhbHNlLCBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSA9IG51bGwpIHtcbiAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgdGhpcy5fZG9uZSA9IHByb2dyZXNzaXZlRG9uZSB8fCBmYWxzZTtcbiAgICB0aGlzLl9maWxlbmFtZSA9IGlzUGRmRmlsZShjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSkgPyBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSA6IG51bGw7XG4gICAgdGhpcy5fcXVldWVkQ2h1bmtzID0gcXVldWVkQ2h1bmtzIHx8IFtdO1xuICAgIHRoaXMuX2xvYWRlZCA9IDA7XG4gICAgZm9yIChjb25zdCBjaHVuayBvZiB0aGlzLl9xdWV1ZWRDaHVua3MpIHtcbiAgICAgIHRoaXMuX2xvYWRlZCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuX2hlYWRlcnNSZWFkeSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHN0cmVhbS5fZnVsbFJlcXVlc3RSZWFkZXIgPSB0aGlzO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cbiAgX2VucXVldWUoY2h1bmspIHtcbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSB0aGlzLl9yZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVua3MucHVzaChjaHVuayk7XG4gICAgfVxuICAgIHRoaXMuX2xvYWRlZCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICB9XG4gIGdldCBoZWFkZXJzUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNSZWFkeTtcbiAgfVxuICBnZXQgZmlsZW5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGVuYW1lO1xuICB9XG4gIGdldCBpc1JhbmdlU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJlYW0uX2lzUmFuZ2VTdXBwb3J0ZWQ7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJlYW0uX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG4gIGdldCBjb250ZW50TGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJlYW0uX2NvbnRlbnRMZW5ndGg7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBpZiAodGhpcy5fcXVldWVkQ2h1bmtzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcXVldWVkQ2h1bmtzLnNoaWZ0KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3RDYXBhYmlsaXR5KTtcbiAgICByZXR1cm4gcmVxdWVzdENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICB9XG4gIHByb2dyZXNzaXZlRG9uZSgpIHtcbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgfVxufVxuY2xhc3MgUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJhbmdlUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtLCBiZWdpbiwgZW5kKSB7XG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHRoaXMuX2JlZ2luID0gYmVnaW47XG4gICAgdGhpcy5fZW5kID0gZW5kO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rID0gbnVsbDtcbiAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG4gIF9lbnF1ZXVlKGNodW5rKSB7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBjaHVuaztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVxdWVzdHNDYXBhYmlsaXR5ID0gdGhpcy5fcmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgIHJlcXVlc3RzQ2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIHRoaXMuX3N0cmVhbS5fcmVtb3ZlUmFuZ2VSZWFkZXIodGhpcyk7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGlmICh0aGlzLl9xdWV1ZWRDaHVuaykge1xuICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9xdWV1ZWRDaHVuaztcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rID0gbnVsbDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuX3JlcXVlc3RzLnB1c2gocmVxdWVzdENhcGFiaWxpdHkpO1xuICAgIHJldHVybiByZXF1ZXN0Q2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fc3RyZWFtLl9yZW1vdmVSYW5nZVJlYWRlcih0aGlzKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9jb250ZW50X2Rpc3Bvc2l0aW9uLmpzXG5cbmZ1bmN0aW9uIGdldEZpbGVuYW1lRnJvbUNvbnRlbnREaXNwb3NpdGlvbkhlYWRlcihjb250ZW50RGlzcG9zaXRpb24pIHtcbiAgbGV0IG5lZWRzRW5jb2RpbmdGaXh1cCA9IHRydWU7XG4gIGxldCB0bXAgPSB0b1BhcmFtUmVnRXhwKFwiZmlsZW5hbWVcXFxcKlwiLCBcImlcIikuZXhlYyhjb250ZW50RGlzcG9zaXRpb24pO1xuICBpZiAodG1wKSB7XG4gICAgdG1wID0gdG1wWzFdO1xuICAgIGxldCBmaWxlbmFtZSA9IHJmYzI2MTZ1bnF1b3RlKHRtcCk7XG4gICAgZmlsZW5hbWUgPSB1bmVzY2FwZShmaWxlbmFtZSk7XG4gICAgZmlsZW5hbWUgPSByZmM1OTg3ZGVjb2RlKGZpbGVuYW1lKTtcbiAgICBmaWxlbmFtZSA9IHJmYzIwNDdkZWNvZGUoZmlsZW5hbWUpO1xuICAgIHJldHVybiBmaXh1cEVuY29kaW5nKGZpbGVuYW1lKTtcbiAgfVxuICB0bXAgPSByZmMyMjMxZ2V0cGFyYW0oY29udGVudERpc3Bvc2l0aW9uKTtcbiAgaWYgKHRtcCkge1xuICAgIGNvbnN0IGZpbGVuYW1lID0gcmZjMjA0N2RlY29kZSh0bXApO1xuICAgIHJldHVybiBmaXh1cEVuY29kaW5nKGZpbGVuYW1lKTtcbiAgfVxuICB0bXAgPSB0b1BhcmFtUmVnRXhwKFwiZmlsZW5hbWVcIiwgXCJpXCIpLmV4ZWMoY29udGVudERpc3Bvc2l0aW9uKTtcbiAgaWYgKHRtcCkge1xuICAgIHRtcCA9IHRtcFsxXTtcbiAgICBsZXQgZmlsZW5hbWUgPSByZmMyNjE2dW5xdW90ZSh0bXApO1xuICAgIGZpbGVuYW1lID0gcmZjMjA0N2RlY29kZShmaWxlbmFtZSk7XG4gICAgcmV0dXJuIGZpeHVwRW5jb2RpbmcoZmlsZW5hbWUpO1xuICB9XG4gIGZ1bmN0aW9uIHRvUGFyYW1SZWdFeHAoYXR0cmlidXRlUGF0dGVybiwgZmxhZ3MpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcIig/Ol58OylcXFxccypcIiArIGF0dHJpYnV0ZVBhdHRlcm4gKyBcIlxcXFxzKj1cXFxccypcIiArIFwiKFwiICsgJ1teXCI7XFxcXHNdW147XFxcXHNdKicgKyBcInxcIiArICdcIig/OlteXCJcXFxcXFxcXF18XFxcXFxcXFxcIj8pK1wiPycgKyBcIilcIiwgZmxhZ3MpO1xuICB9XG4gIGZ1bmN0aW9uIHRleHRkZWNvZGUoZW5jb2RpbmcsIHZhbHVlKSB7XG4gICAgaWYgKGVuY29kaW5nKSB7XG4gICAgICBpZiAoIS9eW1xceDAwLVxceEZGXSskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKGVuY29kaW5nLCB7XG4gICAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHN0cmluZ1RvQnl0ZXModmFsdWUpO1xuICAgICAgICB2YWx1ZSA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlcik7XG4gICAgICAgIG5lZWRzRW5jb2RpbmdGaXh1cCA9IGZhbHNlO1xuICAgICAgfSBjYXRjaCB7fVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gZml4dXBFbmNvZGluZyh2YWx1ZSkge1xuICAgIGlmIChuZWVkc0VuY29kaW5nRml4dXAgJiYgL1tcXHg4MC1cXHhmZl0vLnRlc3QodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHRleHRkZWNvZGUoXCJ1dGYtOFwiLCB2YWx1ZSk7XG4gICAgICBpZiAobmVlZHNFbmNvZGluZ0ZpeHVwKSB7XG4gICAgICAgIHZhbHVlID0gdGV4dGRlY29kZShcImlzby04ODU5LTFcIiwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gcmZjMjIzMWdldHBhcmFtKGNvbnRlbnREaXNwb3NpdGlvblN0cikge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBbXTtcbiAgICBsZXQgbWF0Y2g7XG4gICAgY29uc3QgaXRlciA9IHRvUGFyYW1SZWdFeHAoXCJmaWxlbmFtZVxcXFwqKCg/ITBcXFxcZClcXFxcZCspKFxcXFwqPylcIiwgXCJpZ1wiKTtcbiAgICB3aGlsZSAoKG1hdGNoID0gaXRlci5leGVjKGNvbnRlbnREaXNwb3NpdGlvblN0cikpICE9PSBudWxsKSB7XG4gICAgICBsZXQgWywgbiwgcXVvdCwgcGFydF0gPSBtYXRjaDtcbiAgICAgIG4gPSBwYXJzZUludChuLCAxMCk7XG4gICAgICBpZiAobiBpbiBtYXRjaGVzKSB7XG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBtYXRjaGVzW25dID0gW3F1b3QsIHBhcnRdO1xuICAgIH1cbiAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgbWF0Y2hlcy5sZW5ndGg7ICsrbikge1xuICAgICAgaWYgKCEobiBpbiBtYXRjaGVzKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGxldCBbcXVvdCwgcGFydF0gPSBtYXRjaGVzW25dO1xuICAgICAgcGFydCA9IHJmYzI2MTZ1bnF1b3RlKHBhcnQpO1xuICAgICAgaWYgKHF1b3QpIHtcbiAgICAgICAgcGFydCA9IHVuZXNjYXBlKHBhcnQpO1xuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgIHBhcnQgPSByZmM1OTg3ZGVjb2RlKHBhcnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwYXJ0cy5wdXNoKHBhcnQpO1xuICAgIH1cbiAgICByZXR1cm4gcGFydHMuam9pbihcIlwiKTtcbiAgfVxuICBmdW5jdGlvbiByZmMyNjE2dW5xdW90ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKCdcIicpKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IHZhbHVlLnNsaWNlKDEpLnNwbGl0KCdcXFxcXCInKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgcXVvdGluZGV4ID0gcGFydHNbaV0uaW5kZXhPZignXCInKTtcbiAgICAgICAgaWYgKHF1b3RpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICBwYXJ0c1tpXSA9IHBhcnRzW2ldLnNsaWNlKDAsIHF1b3RpbmRleCk7XG4gICAgICAgICAgcGFydHMubGVuZ3RoID0gaSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcGFydHNbaV0gPSBwYXJ0c1tpXS5yZXBsYWNlQWxsKC9cXFxcKC4pL2csIFwiJDFcIik7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHBhcnRzLmpvaW4oJ1wiJyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiByZmM1OTg3ZGVjb2RlKGV4dHZhbHVlKSB7XG4gICAgY29uc3QgZW5jb2RpbmdlbmQgPSBleHR2YWx1ZS5pbmRleE9mKFwiJ1wiKTtcbiAgICBpZiAoZW5jb2RpbmdlbmQgPT09IC0xKSB7XG4gICAgICByZXR1cm4gZXh0dmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IGVuY29kaW5nID0gZXh0dmFsdWUuc2xpY2UoMCwgZW5jb2RpbmdlbmQpO1xuICAgIGNvbnN0IGxhbmd2YWx1ZSA9IGV4dHZhbHVlLnNsaWNlKGVuY29kaW5nZW5kICsgMSk7XG4gICAgY29uc3QgdmFsdWUgPSBsYW5ndmFsdWUucmVwbGFjZSgvXlteJ10qJy8sIFwiXCIpO1xuICAgIHJldHVybiB0ZXh0ZGVjb2RlKGVuY29kaW5nLCB2YWx1ZSk7XG4gIH1cbiAgZnVuY3Rpb24gcmZjMjA0N2RlY29kZSh2YWx1ZSkge1xuICAgIGlmICghdmFsdWUuc3RhcnRzV2l0aChcIj0/XCIpIHx8IC9bXFx4MDAtXFx4MTlcXHg4MC1cXHhmZl0vLnRlc3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlQWxsKC89XFw/KFtcXHctXSopXFw/KFtRcUJiXSlcXD8oKD86W14/XXxcXD8oPyE9KSkqKVxcPz0vZywgZnVuY3Rpb24gKG1hdGNoZXMsIGNoYXJzZXQsIGVuY29kaW5nLCB0ZXh0KSB7XG4gICAgICBpZiAoZW5jb2RpbmcgPT09IFwicVwiIHx8IGVuY29kaW5nID09PSBcIlFcIikge1xuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlQWxsKFwiX1wiLCBcIiBcIik7XG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2VBbGwoLz0oWzAtOWEtZkEtRl17Mn0pL2csIGZ1bmN0aW9uIChtYXRjaCwgaGV4KSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoaGV4LCAxNikpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRleHRkZWNvZGUoY2hhcnNldCwgdGV4dCk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB0ZXh0ID0gYXRvYih0ZXh0KTtcbiAgICAgIH0gY2F0Y2gge31cbiAgICAgIHJldHVybiB0ZXh0ZGVjb2RlKGNoYXJzZXQsIHRleHQpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBcIlwiO1xufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9uZXR3b3JrX3V0aWxzLmpzXG5cblxuXG5mdW5jdGlvbiBjcmVhdGVIZWFkZXJzKGlzSHR0cCwgaHR0cEhlYWRlcnMpIHtcbiAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gIGlmICghaXNIdHRwIHx8ICFodHRwSGVhZGVycyB8fCB0eXBlb2YgaHR0cEhlYWRlcnMgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gaGVhZGVycztcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBodHRwSGVhZGVycykge1xuICAgIGNvbnN0IHZhbCA9IGh0dHBIZWFkZXJzW2tleV07XG4gICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBoZWFkZXJzO1xufVxuZnVuY3Rpb24gZ2V0UmVzcG9uc2VPcmlnaW4odXJsKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBVUkwodXJsKS5vcmlnaW47XG4gIH0gY2F0Y2gge31cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcyh7XG4gIHJlc3BvbnNlSGVhZGVycyxcbiAgaXNIdHRwLFxuICByYW5nZUNodW5rU2l6ZSxcbiAgZGlzYWJsZVJhbmdlXG59KSB7XG4gIGNvbnN0IHJldHVyblZhbHVlcyA9IHtcbiAgICBhbGxvd1JhbmdlUmVxdWVzdHM6IGZhbHNlLFxuICAgIHN1Z2dlc3RlZExlbmd0aDogdW5kZWZpbmVkXG4gIH07XG4gIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KHJlc3BvbnNlSGVhZGVycy5nZXQoXCJDb250ZW50LUxlbmd0aFwiKSwgMTApO1xuICBpZiAoIU51bWJlci5pc0ludGVnZXIobGVuZ3RoKSkge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cbiAgcmV0dXJuVmFsdWVzLnN1Z2dlc3RlZExlbmd0aCA9IGxlbmd0aDtcbiAgaWYgKGxlbmd0aCA8PSAyICogcmFuZ2VDaHVua1NpemUpIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICB9XG4gIGlmIChkaXNhYmxlUmFuZ2UgfHwgIWlzSHR0cCkge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cbiAgaWYgKHJlc3BvbnNlSGVhZGVycy5nZXQoXCJBY2NlcHQtUmFuZ2VzXCIpICE9PSBcImJ5dGVzXCIpIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICB9XG4gIGNvbnN0IGNvbnRlbnRFbmNvZGluZyA9IHJlc3BvbnNlSGVhZGVycy5nZXQoXCJDb250ZW50LUVuY29kaW5nXCIpIHx8IFwiaWRlbnRpdHlcIjtcbiAgaWYgKGNvbnRlbnRFbmNvZGluZyAhPT0gXCJpZGVudGl0eVwiKSB7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlcztcbiAgfVxuICByZXR1cm5WYWx1ZXMuYWxsb3dSYW5nZVJlcXVlc3RzID0gdHJ1ZTtcbiAgcmV0dXJuIHJldHVyblZhbHVlcztcbn1cbmZ1bmN0aW9uIGV4dHJhY3RGaWxlbmFtZUZyb21IZWFkZXIocmVzcG9uc2VIZWFkZXJzKSB7XG4gIGNvbnN0IGNvbnRlbnREaXNwb3NpdGlvbiA9IHJlc3BvbnNlSGVhZGVycy5nZXQoXCJDb250ZW50LURpc3Bvc2l0aW9uXCIpO1xuICBpZiAoY29udGVudERpc3Bvc2l0aW9uKSB7XG4gICAgbGV0IGZpbGVuYW1lID0gZ2V0RmlsZW5hbWVGcm9tQ29udGVudERpc3Bvc2l0aW9uSGVhZGVyKGNvbnRlbnREaXNwb3NpdGlvbik7XG4gICAgaWYgKGZpbGVuYW1lLmluY2x1ZGVzKFwiJVwiKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZmlsZW5hbWUgPSBkZWNvZGVVUklDb21wb25lbnQoZmlsZW5hbWUpO1xuICAgICAgfSBjYXRjaCB7fVxuICAgIH1cbiAgICBpZiAoaXNQZGZGaWxlKGZpbGVuYW1lKSkge1xuICAgICAgcmV0dXJuIGZpbGVuYW1lO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlc3BvbnNlU3RhdHVzRXJyb3Ioc3RhdHVzLCB1cmwpIHtcbiAgaWYgKHN0YXR1cyA9PT0gNDA0IHx8IHN0YXR1cyA9PT0gMCAmJiB1cmwuc3RhcnRzV2l0aChcImZpbGU6XCIpKSB7XG4gICAgcmV0dXJuIG5ldyBNaXNzaW5nUERGRXhjZXB0aW9uKCdNaXNzaW5nIFBERiBcIicgKyB1cmwgKyAnXCIuJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24oYFVuZXhwZWN0ZWQgc2VydmVyIHJlc3BvbnNlICgke3N0YXR1c30pIHdoaWxlIHJldHJpZXZpbmcgUERGIFwiJHt1cmx9XCIuYCwgc3RhdHVzKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUmVzcG9uc2VTdGF0dXMoc3RhdHVzKSB7XG4gIHJldHVybiBzdGF0dXMgPT09IDIwMCB8fCBzdGF0dXMgPT09IDIwNjtcbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZmV0Y2hfc3RyZWFtLmpzXG5cblxuZnVuY3Rpb24gY3JlYXRlRmV0Y2hPcHRpb25zKGhlYWRlcnMsIHdpdGhDcmVkZW50aWFscywgYWJvcnRDb250cm9sbGVyKSB7XG4gIHJldHVybiB7XG4gICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIGhlYWRlcnMsXG4gICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgIG1vZGU6IFwiY29yc1wiLFxuICAgIGNyZWRlbnRpYWxzOiB3aXRoQ3JlZGVudGlhbHMgPyBcImluY2x1ZGVcIiA6IFwic2FtZS1vcmlnaW5cIixcbiAgICByZWRpcmVjdDogXCJmb2xsb3dcIlxuICB9O1xufVxuZnVuY3Rpb24gZ2V0QXJyYXlCdWZmZXIodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIHZhbC5idWZmZXI7XG4gIH1cbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICB3YXJuKGBnZXRBcnJheUJ1ZmZlciAtIHVuZXhwZWN0ZWQgZGF0YSBmb3JtYXQ6ICR7dmFsfWApO1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodmFsKS5idWZmZXI7XG59XG5jbGFzcyBQREZGZXRjaFN0cmVhbSB7XG4gIF9yZXNwb25zZU9yaWdpbiA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMuaXNIdHRwID0gL15odHRwcz86L2kudGVzdChzb3VyY2UudXJsKTtcbiAgICB0aGlzLmhlYWRlcnMgPSBjcmVhdGVIZWFkZXJzKHRoaXMuaXNIdHRwLCBzb3VyY2UuaHR0cEhlYWRlcnMpO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzID0gW107XG4gIH1cbiAgZ2V0IF9wcm9ncmVzc2l2ZURhdGFMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5fbG9hZGVkID8/IDA7XG4gIH1cbiAgZ2V0RnVsbFJlYWRlcigpIHtcbiAgICBhc3NlcnQoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERkZldGNoU3RyZWFtLmdldEZ1bGxSZWFkZXIgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuXCIpO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbmV3IFBERkZldGNoU3RyZWFtUmVhZGVyKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcjtcbiAgfVxuICBnZXRSYW5nZVJlYWRlcihiZWdpbiwgZW5kKSB7XG4gICAgaWYgKGVuZCA8PSB0aGlzLl9wcm9ncmVzc2l2ZURhdGFMZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZWFkZXIgPSBuZXcgUERGRmV0Y2hTdHJlYW1SYW5nZVJlYWRlcih0aGlzLCBiZWdpbiwgZW5kKTtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnB1c2gocmVhZGVyKTtcbiAgICByZXR1cm4gcmVhZGVyO1xuICB9XG4gIGNhbmNlbEFsbFJlcXVlc3RzKHJlYXNvbikge1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5jYW5jZWwocmVhc29uKTtcbiAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnNsaWNlKDApKSB7XG4gICAgICByZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgfVxuICB9XG59XG5jbGFzcyBQREZGZXRjaFN0cmVhbVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgIHRoaXMuX3N0cmVhbSA9IHN0cmVhbTtcbiAgICB0aGlzLl9yZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX2xvYWRlZCA9IDA7XG4gICAgdGhpcy5fZmlsZW5hbWUgPSBudWxsO1xuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmVhbS5zb3VyY2U7XG4gICAgdGhpcy5fd2l0aENyZWRlbnRpYWxzID0gc291cmNlLndpdGhDcmVkZW50aWFscyB8fCBmYWxzZTtcbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHNvdXJjZS5kaXNhYmxlUmFuZ2UgfHwgZmFsc2U7XG4gICAgdGhpcy5fcmFuZ2VDaHVua1NpemUgPSBzb3VyY2UucmFuZ2VDaHVua1NpemU7XG4gICAgaWYgKCF0aGlzLl9yYW5nZUNodW5rU2l6ZSAmJiAhdGhpcy5fZGlzYWJsZVJhbmdlKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9hYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVTdHJlYW07XG4gICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVJhbmdlO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhzdHJlYW0uaGVhZGVycyk7XG4gICAgY29uc3QgdXJsID0gc291cmNlLnVybDtcbiAgICBmZXRjaCh1cmwsIGNyZWF0ZUZldGNoT3B0aW9ucyhoZWFkZXJzLCB0aGlzLl93aXRoQ3JlZGVudGlhbHMsIHRoaXMuX2Fib3J0Q29udHJvbGxlcikpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgc3RyZWFtLl9yZXNwb25zZU9yaWdpbiA9IGdldFJlc3BvbnNlT3JpZ2luKHJlc3BvbnNlLnVybCk7XG4gICAgICBpZiAoIXZhbGlkYXRlUmVzcG9uc2VTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgICAgICB0aHJvdyBjcmVhdGVSZXNwb25zZVN0YXR1c0Vycm9yKHJlc3BvbnNlLnN0YXR1cywgdXJsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSByZXNwb25zZS5oZWFkZXJzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBhbGxvd1JhbmdlUmVxdWVzdHMsXG4gICAgICAgIHN1Z2dlc3RlZExlbmd0aFxuICAgICAgfSA9IHZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzKHtcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICBpc0h0dHA6IHN0cmVhbS5pc0h0dHAsXG4gICAgICAgIHJhbmdlQ2h1bmtTaXplOiB0aGlzLl9yYW5nZUNodW5rU2l6ZSxcbiAgICAgICAgZGlzYWJsZVJhbmdlOiB0aGlzLl9kaXNhYmxlUmFuZ2VcbiAgICAgIH0pO1xuICAgICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9IGFsbG93UmFuZ2VSZXF1ZXN0cztcbiAgICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzdWdnZXN0ZWRMZW5ndGggfHwgdGhpcy5fY29udGVudExlbmd0aDtcbiAgICAgIHRoaXMuX2ZpbGVuYW1lID0gZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlcihyZXNwb25zZUhlYWRlcnMpO1xuICAgICAgaWYgKCF0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCAmJiB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsKG5ldyBBYm9ydEV4Y2VwdGlvbihcIlN0cmVhbWluZyBpcyBkaXNhYmxlZC5cIikpO1xuICAgICAgfVxuICAgIH0pLmNhdGNoKHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuICBnZXQgaGVhZGVyc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGdldCBmaWxlbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZW5hbWU7XG4gIH1cbiAgZ2V0IGNvbnRlbnRMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRlbnRMZW5ndGg7XG4gIH1cbiAgZ2V0IGlzUmFuZ2VTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQ7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGF3YWl0IHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgY29uc3Qge1xuICAgICAgdmFsdWUsXG4gICAgICBkb25lXG4gICAgfSA9IGF3YWl0IHRoaXMuX3JlYWRlci5yZWFkKCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkb25lXG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLl9sb2FkZWQgKz0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICBsb2FkZWQ6IHRoaXMuX2xvYWRlZCxcbiAgICAgIHRvdGFsOiB0aGlzLl9jb250ZW50TGVuZ3RoXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBnZXRBcnJheUJ1ZmZlcih2YWx1ZSksXG4gICAgICBkb25lOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIHRoaXMuX3JlYWRlcj8uY2FuY2VsKHJlYXNvbik7XG4gICAgdGhpcy5fYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gIH1cbn1cbmNsYXNzIFBERkZldGNoU3RyZWFtUmFuZ2VSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0sIGJlZ2luLCBlbmQpIHtcbiAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgdGhpcy5fcmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9sb2FkZWQgPSAwO1xuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmVhbS5zb3VyY2U7XG4gICAgdGhpcy5fd2l0aENyZWRlbnRpYWxzID0gc291cmNlLndpdGhDcmVkZW50aWFscyB8fCBmYWxzZTtcbiAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlU3RyZWFtO1xuICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoc3RyZWFtLmhlYWRlcnMpO1xuICAgIGhlYWRlcnMuYXBwZW5kKFwiUmFuZ2VcIiwgYGJ5dGVzPSR7YmVnaW59LSR7ZW5kIC0gMX1gKTtcbiAgICBjb25zdCB1cmwgPSBzb3VyY2UudXJsO1xuICAgIGZldGNoKHVybCwgY3JlYXRlRmV0Y2hPcHRpb25zKGhlYWRlcnMsIHRoaXMuX3dpdGhDcmVkZW50aWFscywgdGhpcy5fYWJvcnRDb250cm9sbGVyKSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICBjb25zdCByZXNwb25zZU9yaWdpbiA9IGdldFJlc3BvbnNlT3JpZ2luKHJlc3BvbnNlLnVybCk7XG4gICAgICBpZiAocmVzcG9uc2VPcmlnaW4gIT09IHN0cmVhbS5fcmVzcG9uc2VPcmlnaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCByYW5nZSByZXNwb25zZS1vcmlnaW4gXCIke3Jlc3BvbnNlT3JpZ2lufVwiIHRvIG1hdGNoIFwiJHtzdHJlYW0uX3Jlc3BvbnNlT3JpZ2lufVwiLmApO1xuICAgICAgfVxuICAgICAgaWYgKCF2YWxpZGF0ZVJlc3BvbnNlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlUmVzcG9uc2VTdGF0dXNFcnJvcihyZXNwb25zZS5zdGF0dXMsIHVybCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICB0aGlzLl9yZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgIH0pLmNhdGNoKHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5fcmVhZENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICBjb25zdCB7XG4gICAgICB2YWx1ZSxcbiAgICAgIGRvbmVcbiAgICB9ID0gYXdhaXQgdGhpcy5fcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAoZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRvbmVcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMuX2xvYWRlZCArPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgIHRoaXMub25Qcm9ncmVzcz8uKHtcbiAgICAgIGxvYWRlZDogdGhpcy5fbG9hZGVkXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBnZXRBcnJheUJ1ZmZlcih2YWx1ZSksXG4gICAgICBkb25lOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIHRoaXMuX3JlYWRlcj8uY2FuY2VsKHJlYXNvbik7XG4gICAgdGhpcy5fYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvbmV0d29yay5qc1xuXG5cbmNvbnN0IE9LX1JFU1BPTlNFID0gMjAwO1xuY29uc3QgUEFSVElBTF9DT05URU5UX1JFU1BPTlNFID0gMjA2O1xuZnVuY3Rpb24gbmV0d29ya19nZXRBcnJheUJ1ZmZlcih4aHIpIHtcbiAgY29uc3QgZGF0YSA9IHhoci5yZXNwb25zZTtcbiAgaWYgKHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgcmV0dXJuIHN0cmluZ1RvQnl0ZXMoZGF0YSkuYnVmZmVyO1xufVxuY2xhc3MgTmV0d29ya01hbmFnZXIge1xuICBfcmVzcG9uc2VPcmlnaW4gPSBudWxsO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdXJsLFxuICAgIGh0dHBIZWFkZXJzLFxuICAgIHdpdGhDcmVkZW50aWFsc1xuICB9KSB7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy5pc0h0dHAgPSAvXmh0dHBzPzovaS50ZXN0KHVybCk7XG4gICAgdGhpcy5oZWFkZXJzID0gY3JlYXRlSGVhZGVycyh0aGlzLmlzSHR0cCwgaHR0cEhlYWRlcnMpO1xuICAgIHRoaXMud2l0aENyZWRlbnRpYWxzID0gd2l0aENyZWRlbnRpYWxzIHx8IGZhbHNlO1xuICAgIHRoaXMuY3VyclhocklkID0gMDtcbiAgICB0aGlzLnBlbmRpbmdSZXF1ZXN0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgcmVxdWVzdFJhbmdlKGJlZ2luLCBlbmQsIGxpc3RlbmVycykge1xuICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICBiZWdpbixcbiAgICAgIGVuZFxuICAgIH07XG4gICAgZm9yIChjb25zdCBwcm9wIGluIGxpc3RlbmVycykge1xuICAgICAgYXJnc1twcm9wXSA9IGxpc3RlbmVyc1twcm9wXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChhcmdzKTtcbiAgfVxuICByZXF1ZXN0RnVsbChsaXN0ZW5lcnMpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGxpc3RlbmVycyk7XG4gIH1cbiAgcmVxdWVzdChhcmdzKSB7XG4gICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgY29uc3QgeGhySWQgPSB0aGlzLmN1cnJYaHJJZCsrO1xuICAgIGNvbnN0IHBlbmRpbmdSZXF1ZXN0ID0gdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdID0ge1xuICAgICAgeGhyXG4gICAgfTtcbiAgICB4aHIub3BlbihcIkdFVFwiLCB0aGlzLnVybCk7XG4gICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRoaXMud2l0aENyZWRlbnRpYWxzO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiB0aGlzLmhlYWRlcnMpIHtcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNIdHRwICYmIFwiYmVnaW5cIiBpbiBhcmdzICYmIFwiZW5kXCIgaW4gYXJncykge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJSYW5nZVwiLCBgYnl0ZXM9JHthcmdzLmJlZ2lufS0ke2FyZ3MuZW5kIC0gMX1gKTtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0LmV4cGVjdGVkU3RhdHVzID0gUEFSVElBTF9DT05URU5UX1JFU1BPTlNFO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5leHBlY3RlZFN0YXR1cyA9IE9LX1JFU1BPTlNFO1xuICAgIH1cbiAgICB4aHIucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xuICAgIGlmIChhcmdzLm9uRXJyb3IpIHtcbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBhcmdzLm9uRXJyb3IoeGhyLnN0YXR1cyk7XG4gICAgICB9O1xuICAgIH1cbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gdGhpcy5vblN0YXRlQ2hhbmdlLmJpbmQodGhpcywgeGhySWQpO1xuICAgIHhoci5vbnByb2dyZXNzID0gdGhpcy5vblByb2dyZXNzLmJpbmQodGhpcywgeGhySWQpO1xuICAgIHBlbmRpbmdSZXF1ZXN0Lm9uSGVhZGVyc1JlY2VpdmVkID0gYXJncy5vbkhlYWRlcnNSZWNlaXZlZDtcbiAgICBwZW5kaW5nUmVxdWVzdC5vbkRvbmUgPSBhcmdzLm9uRG9uZTtcbiAgICBwZW5kaW5nUmVxdWVzdC5vbkVycm9yID0gYXJncy5vbkVycm9yO1xuICAgIHBlbmRpbmdSZXF1ZXN0Lm9uUHJvZ3Jlc3MgPSBhcmdzLm9uUHJvZ3Jlc3M7XG4gICAgeGhyLnNlbmQobnVsbCk7XG4gICAgcmV0dXJuIHhocklkO1xuICB9XG4gIG9uUHJvZ3Jlc3MoeGhySWQsIGV2dCkge1xuICAgIGNvbnN0IHBlbmRpbmdSZXF1ZXN0ID0gdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdO1xuICAgIGlmICghcGVuZGluZ1JlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGVuZGluZ1JlcXVlc3Qub25Qcm9ncmVzcz8uKGV2dCk7XG4gIH1cbiAgb25TdGF0ZUNoYW5nZSh4aHJJZCwgZXZ0KSB7XG4gICAgY29uc3QgcGVuZGluZ1JlcXVlc3QgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF07XG4gICAgaWYgKCFwZW5kaW5nUmVxdWVzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB4aHIgPSBwZW5kaW5nUmVxdWVzdC54aHI7XG4gICAgaWYgKHhoci5yZWFkeVN0YXRlID49IDIgJiYgcGVuZGluZ1JlcXVlc3Qub25IZWFkZXJzUmVjZWl2ZWQpIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uSGVhZGVyc1JlY2VpdmVkKCk7XG4gICAgICBkZWxldGUgcGVuZGluZ1JlcXVlc3Qub25IZWFkZXJzUmVjZWl2ZWQ7XG4gICAgfVxuICAgIGlmICh4aHIucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoISh4aHJJZCBpbiB0aGlzLnBlbmRpbmdSZXF1ZXN0cykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXTtcbiAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMCAmJiB0aGlzLmlzSHR0cCkge1xuICAgICAgcGVuZGluZ1JlcXVlc3Qub25FcnJvcj8uKHhoci5zdGF0dXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB4aHJTdGF0dXMgPSB4aHIuc3RhdHVzIHx8IE9LX1JFU1BPTlNFO1xuICAgIGNvbnN0IG9rX3Jlc3BvbnNlX29uX3JhbmdlX3JlcXVlc3QgPSB4aHJTdGF0dXMgPT09IE9LX1JFU1BPTlNFICYmIHBlbmRpbmdSZXF1ZXN0LmV4cGVjdGVkU3RhdHVzID09PSBQQVJUSUFMX0NPTlRFTlRfUkVTUE9OU0U7XG4gICAgaWYgKCFva19yZXNwb25zZV9vbl9yYW5nZV9yZXF1ZXN0ICYmIHhoclN0YXR1cyAhPT0gcGVuZGluZ1JlcXVlc3QuZXhwZWN0ZWRTdGF0dXMpIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRXJyb3I/Lih4aHIuc3RhdHVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2h1bmsgPSBuZXR3b3JrX2dldEFycmF5QnVmZmVyKHhocik7XG4gICAgaWYgKHhoclN0YXR1cyA9PT0gUEFSVElBTF9DT05URU5UX1JFU1BPTlNFKSB7XG4gICAgICBjb25zdCByYW5nZUhlYWRlciA9IHhoci5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtUmFuZ2VcIik7XG4gICAgICBjb25zdCBtYXRjaGVzID0gL2J5dGVzIChcXGQrKS0oXFxkKylcXC8oXFxkKykvLmV4ZWMocmFuZ2VIZWFkZXIpO1xuICAgICAgcGVuZGluZ1JlcXVlc3Qub25Eb25lKHtcbiAgICAgICAgYmVnaW46IHBhcnNlSW50KG1hdGNoZXNbMV0sIDEwKSxcbiAgICAgICAgY2h1bmtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY2h1bmspIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRG9uZSh7XG4gICAgICAgIGJlZ2luOiAwLFxuICAgICAgICBjaHVua1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRXJyb3I/Lih4aHIuc3RhdHVzKTtcbiAgICB9XG4gIH1cbiAgZ2V0UmVxdWVzdFhocih4aHJJZCkge1xuICAgIHJldHVybiB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF0ueGhyO1xuICB9XG4gIGlzUGVuZGluZ1JlcXVlc3QoeGhySWQpIHtcbiAgICByZXR1cm4geGhySWQgaW4gdGhpcy5wZW5kaW5nUmVxdWVzdHM7XG4gIH1cbiAgYWJvcnRSZXF1ZXN0KHhocklkKSB7XG4gICAgY29uc3QgeGhyID0gdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdLnhocjtcbiAgICBkZWxldGUgdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdO1xuICAgIHhoci5hYm9ydCgpO1xuICB9XG59XG5jbGFzcyBQREZOZXR3b3JrU3RyZWFtIHtcbiAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgdGhpcy5fc291cmNlID0gc291cmNlO1xuICAgIHRoaXMuX21hbmFnZXIgPSBuZXcgTmV0d29ya01hbmFnZXIoc291cmNlKTtcbiAgICB0aGlzLl9yYW5nZUNodW5rU2l6ZSA9IHNvdXJjZS5yYW5nZUNodW5rU2l6ZTtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycyA9IFtdO1xuICB9XG4gIF9vblJhbmdlUmVxdWVzdFJlYWRlckNsb3NlZChyZWFkZXIpIHtcbiAgICBjb25zdCBpID0gdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5pbmRleE9mKHJlYWRlcik7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG4gIGdldEZ1bGxSZWFkZXIoKSB7XG4gICAgYXNzZXJ0KCF0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciwgXCJQREZOZXR3b3JrU3RyZWFtLmdldEZ1bGxSZWFkZXIgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuXCIpO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbmV3IFBERk5ldHdvcmtTdHJlYW1GdWxsUmVxdWVzdFJlYWRlcih0aGlzLl9tYW5hZ2VyLCB0aGlzLl9zb3VyY2UpO1xuICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcjtcbiAgfVxuICBnZXRSYW5nZVJlYWRlcihiZWdpbiwgZW5kKSB7XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IFBERk5ldHdvcmtTdHJlYW1SYW5nZVJlcXVlc3RSZWFkZXIodGhpcy5fbWFuYWdlciwgYmVnaW4sIGVuZCk7XG4gICAgcmVhZGVyLm9uQ2xvc2VkID0gdGhpcy5fb25SYW5nZVJlcXVlc3RSZWFkZXJDbG9zZWQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnB1c2gocmVhZGVyKTtcbiAgICByZXR1cm4gcmVhZGVyO1xuICB9XG4gIGNhbmNlbEFsbFJlcXVlc3RzKHJlYXNvbikge1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5jYW5jZWwocmVhc29uKTtcbiAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnNsaWNlKDApKSB7XG4gICAgICByZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgfVxuICB9XG59XG5jbGFzcyBQREZOZXR3b3JrU3RyZWFtRnVsbFJlcXVlc3RSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihtYW5hZ2VyLCBzb3VyY2UpIHtcbiAgICB0aGlzLl9tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgb25IZWFkZXJzUmVjZWl2ZWQ6IHRoaXMuX29uSGVhZGVyc1JlY2VpdmVkLmJpbmQodGhpcyksXG4gICAgICBvbkRvbmU6IHRoaXMuX29uRG9uZS5iaW5kKHRoaXMpLFxuICAgICAgb25FcnJvcjogdGhpcy5fb25FcnJvci5iaW5kKHRoaXMpLFxuICAgICAgb25Qcm9ncmVzczogdGhpcy5fb25Qcm9ncmVzcy5iaW5kKHRoaXMpXG4gICAgfTtcbiAgICB0aGlzLl91cmwgPSBzb3VyY2UudXJsO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0SWQgPSBtYW5hZ2VyLnJlcXVlc3RGdWxsKGFyZ3MpO1xuICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5fZGlzYWJsZVJhbmdlID0gc291cmNlLmRpc2FibGVSYW5nZSB8fCBmYWxzZTtcbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICB0aGlzLl9yYW5nZUNodW5rU2l6ZSA9IHNvdXJjZS5yYW5nZUNodW5rU2l6ZTtcbiAgICBpZiAoIXRoaXMuX3JhbmdlQ2h1bmtTaXplICYmICF0aGlzLl9kaXNhYmxlUmFuZ2UpIHtcbiAgICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2NhY2hlZENodW5rcyA9IFtdO1xuICAgIHRoaXMuX3JlcXVlc3RzID0gW107XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2ZpbGVuYW1lID0gbnVsbDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG4gIF9vbkhlYWRlcnNSZWNlaXZlZCgpIHtcbiAgICBjb25zdCBmdWxsUmVxdWVzdFhocklkID0gdGhpcy5fZnVsbFJlcXVlc3RJZDtcbiAgICBjb25zdCBmdWxsUmVxdWVzdFhociA9IHRoaXMuX21hbmFnZXIuZ2V0UmVxdWVzdFhocihmdWxsUmVxdWVzdFhocklkKTtcbiAgICB0aGlzLl9tYW5hZ2VyLl9yZXNwb25zZU9yaWdpbiA9IGdldFJlc3BvbnNlT3JpZ2luKGZ1bGxSZXF1ZXN0WGhyLnJlc3BvbnNlVVJMKTtcbiAgICBjb25zdCByYXdSZXNwb25zZUhlYWRlcnMgPSBmdWxsUmVxdWVzdFhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKTtcbiAgICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBuZXcgSGVhZGVycyhyYXdSZXNwb25zZUhlYWRlcnMgPyByYXdSZXNwb25zZUhlYWRlcnMudHJpbSgpLnNwbGl0KC9bXFxyXFxuXSsvKS5tYXAoeCA9PiB7XG4gICAgICBjb25zdCBba2V5LCAuLi52YWxdID0geC5zcGxpdChcIjogXCIpO1xuICAgICAgcmV0dXJuIFtrZXksIHZhbC5qb2luKFwiOiBcIildO1xuICAgIH0pIDogW10pO1xuICAgIGNvbnN0IHtcbiAgICAgIGFsbG93UmFuZ2VSZXF1ZXN0cyxcbiAgICAgIHN1Z2dlc3RlZExlbmd0aFxuICAgIH0gPSB2YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcyh7XG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICBpc0h0dHA6IHRoaXMuX21hbmFnZXIuaXNIdHRwLFxuICAgICAgcmFuZ2VDaHVua1NpemU6IHRoaXMuX3JhbmdlQ2h1bmtTaXplLFxuICAgICAgZGlzYWJsZVJhbmdlOiB0aGlzLl9kaXNhYmxlUmFuZ2VcbiAgICB9KTtcbiAgICBpZiAoYWxsb3dSYW5nZVJlcXVlc3RzKSB7XG4gICAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fY29udGVudExlbmd0aCA9IHN1Z2dlc3RlZExlbmd0aCB8fCB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICAgIHRoaXMuX2ZpbGVuYW1lID0gZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlcihyZXNwb25zZUhlYWRlcnMpO1xuICAgIGlmICh0aGlzLl9pc1JhbmdlU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLl9tYW5hZ2VyLmFib3J0UmVxdWVzdChmdWxsUmVxdWVzdFhocklkKTtcbiAgICB9XG4gICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG4gIF9vbkRvbmUoZGF0YSkge1xuICAgIGlmIChkYXRhKSB7XG4gICAgICBpZiAodGhpcy5fcmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IHRoaXMuX3JlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICAgIHZhbHVlOiBkYXRhLmNodW5rLFxuICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY2FjaGVkQ2h1bmtzLnB1c2goZGF0YS5jaHVuayk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIGlmICh0aGlzLl9jYWNoZWRDaHVua3MubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gIH1cbiAgX29uRXJyb3Ioc3RhdHVzKSB7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSBjcmVhdGVSZXNwb25zZVN0YXR1c0Vycm9yKHN0YXR1cywgdGhpcy5fdXJsKTtcbiAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZWplY3QodGhpcy5fc3RvcmVkRXJyb3IpO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlamVjdCh0aGlzLl9zdG9yZWRFcnJvcik7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fY2FjaGVkQ2h1bmtzLmxlbmd0aCA9IDA7XG4gIH1cbiAgX29uUHJvZ3Jlc3MoZXZ0KSB7XG4gICAgdGhpcy5vblByb2dyZXNzPy4oe1xuICAgICAgbG9hZGVkOiBldnQubG9hZGVkLFxuICAgICAgdG90YWw6IGV2dC5sZW5ndGhDb21wdXRhYmxlID8gZXZ0LnRvdGFsIDogdGhpcy5fY29udGVudExlbmd0aFxuICAgIH0pO1xuICB9XG4gIGdldCBmaWxlbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZW5hbWU7XG4gIH1cbiAgZ2V0IGlzUmFuZ2VTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQ7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBnZXQgY29udGVudExlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGVudExlbmd0aDtcbiAgfVxuICBnZXQgaGVhZGVyc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuX3N0b3JlZEVycm9yO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY2FjaGVkQ2h1bmtzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fY2FjaGVkQ2h1bmtzLnNoaWZ0KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3RDYXBhYmlsaXR5KTtcbiAgICByZXR1cm4gcmVxdWVzdENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVqZWN0KHJlYXNvbik7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIGlmICh0aGlzLl9tYW5hZ2VyLmlzUGVuZGluZ1JlcXVlc3QodGhpcy5fZnVsbFJlcXVlc3RJZCkpIHtcbiAgICAgIHRoaXMuX21hbmFnZXIuYWJvcnRSZXF1ZXN0KHRoaXMuX2Z1bGxSZXF1ZXN0SWQpO1xuICAgIH1cbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG51bGw7XG4gIH1cbn1cbmNsYXNzIFBERk5ldHdvcmtTdHJlYW1SYW5nZVJlcXVlc3RSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihtYW5hZ2VyLCBiZWdpbiwgZW5kKSB7XG4gICAgdGhpcy5fbWFuYWdlciA9IG1hbmFnZXI7XG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgIG9uSGVhZGVyc1JlY2VpdmVkOiB0aGlzLl9vbkhlYWRlcnNSZWNlaXZlZC5iaW5kKHRoaXMpLFxuICAgICAgb25Eb25lOiB0aGlzLl9vbkRvbmUuYmluZCh0aGlzKSxcbiAgICAgIG9uRXJyb3I6IHRoaXMuX29uRXJyb3IuYmluZCh0aGlzKSxcbiAgICAgIG9uUHJvZ3Jlc3M6IHRoaXMuX29uUHJvZ3Jlc3MuYmluZCh0aGlzKVxuICAgIH07XG4gICAgdGhpcy5fdXJsID0gbWFuYWdlci51cmw7XG4gICAgdGhpcy5fcmVxdWVzdElkID0gbWFuYWdlci5yZXF1ZXN0UmFuZ2UoYmVnaW4sIGVuZCwgYXJncyk7XG4gICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gICAgdGhpcy5vbkNsb3NlZCA9IG51bGw7XG4gIH1cbiAgX29uSGVhZGVyc1JlY2VpdmVkKCkge1xuICAgIGNvbnN0IHJlc3BvbnNlT3JpZ2luID0gZ2V0UmVzcG9uc2VPcmlnaW4odGhpcy5fbWFuYWdlci5nZXRSZXF1ZXN0WGhyKHRoaXMuX3JlcXVlc3RJZCk/LnJlc3BvbnNlVVJMKTtcbiAgICBpZiAocmVzcG9uc2VPcmlnaW4gIT09IHRoaXMuX21hbmFnZXIuX3Jlc3BvbnNlT3JpZ2luKSB7XG4gICAgICB0aGlzLl9zdG9yZWRFcnJvciA9IG5ldyBFcnJvcihgRXhwZWN0ZWQgcmFuZ2UgcmVzcG9uc2Utb3JpZ2luIFwiJHtyZXNwb25zZU9yaWdpbn1cIiB0byBtYXRjaCBcIiR7dGhpcy5fbWFuYWdlci5fcmVzcG9uc2VPcmlnaW59XCIuYCk7XG4gICAgICB0aGlzLl9vbkVycm9yKDApO1xuICAgIH1cbiAgfVxuICBfY2xvc2UoKSB7XG4gICAgdGhpcy5vbkNsb3NlZD8uKHRoaXMpO1xuICB9XG4gIF9vbkRvbmUoZGF0YSkge1xuICAgIGNvbnN0IGNodW5rID0gZGF0YS5jaHVuaztcbiAgICBpZiAodGhpcy5fcmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSB0aGlzLl9yZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IGNodW5rO1xuICAgIH1cbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fY2xvc2UoKTtcbiAgfVxuICBfb25FcnJvcihzdGF0dXMpIHtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA/Pz0gY3JlYXRlUmVzcG9uc2VTdGF0dXNFcnJvcihzdGF0dXMsIHRoaXMuX3VybCk7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVqZWN0KHRoaXMuX3N0b3JlZEVycm9yKTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gIH1cbiAgX29uUHJvZ3Jlc3MoZXZ0KSB7XG4gICAgaWYgKCF0aGlzLmlzU3RyZWFtaW5nU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuX3N0b3JlZEVycm9yO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcXVldWVkQ2h1bmsgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcXVldWVkQ2h1bms7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3RDYXBhYmlsaXR5KTtcbiAgICByZXR1cm4gcmVxdWVzdENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIGlmICh0aGlzLl9tYW5hZ2VyLmlzUGVuZGluZ1JlcXVlc3QodGhpcy5fcmVxdWVzdElkKSkge1xuICAgICAgdGhpcy5fbWFuYWdlci5hYm9ydFJlcXVlc3QodGhpcy5fcmVxdWVzdElkKTtcbiAgICB9XG4gICAgdGhpcy5fY2xvc2UoKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9ub2RlX3N0cmVhbS5qc1xuXG5jb25zdCB1cmxSZWdleCA9IC9eW2Etel1bYS16MC05XFwtKy5dKzovaTtcbmZ1bmN0aW9uIHBhcnNlVXJsT3JQYXRoKHNvdXJjZVVybCkge1xuICBpZiAodXJsUmVnZXgudGVzdChzb3VyY2VVcmwpKSB7XG4gICAgcmV0dXJuIG5ldyBVUkwoc291cmNlVXJsKTtcbiAgfVxuICBjb25zdCB1cmwgPSBwcm9jZXNzLmdldEJ1aWx0aW5Nb2R1bGUoXCJ1cmxcIik7XG4gIHJldHVybiBuZXcgVVJMKHVybC5wYXRoVG9GaWxlVVJMKHNvdXJjZVVybCkpO1xufVxuY2xhc3MgUERGTm9kZVN0cmVhbSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMudXJsID0gcGFyc2VVcmxPclBhdGgoc291cmNlLnVybCk7XG4gICAgYXNzZXJ0KHRoaXMudXJsLnByb3RvY29sID09PSBcImZpbGU6XCIsIFwiUERGTm9kZVN0cmVhbSBvbmx5IHN1cHBvcnRzIGZpbGU6Ly8gVVJMcy5cIik7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMgPSBbXTtcbiAgfVxuICBnZXQgX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/Ll9sb2FkZWQgPz8gMDtcbiAgfVxuICBnZXRGdWxsUmVhZGVyKCkge1xuICAgIGFzc2VydCghdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIsIFwiUERGTm9kZVN0cmVhbS5nZXRGdWxsUmVhZGVyIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLlwiKTtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG5ldyBQREZOb2RlU3RyZWFtRnNGdWxsUmVhZGVyKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcjtcbiAgfVxuICBnZXRSYW5nZVJlYWRlcihzdGFydCwgZW5kKSB7XG4gICAgaWYgKGVuZCA8PSB0aGlzLl9wcm9ncmVzc2l2ZURhdGFMZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByYW5nZVJlYWRlciA9IG5ldyBQREZOb2RlU3RyZWFtRnNSYW5nZVJlYWRlcih0aGlzLCBzdGFydCwgZW5kKTtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnB1c2gocmFuZ2VSZWFkZXIpO1xuICAgIHJldHVybiByYW5nZVJlYWRlcjtcbiAgfVxuICBjYW5jZWxBbGxSZXF1ZXN0cyhyZWFzb24pIHtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8uY2FuY2VsKHJlYXNvbik7XG4gICAgZm9yIChjb25zdCByZWFkZXIgb2YgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5zbGljZSgwKSkge1xuICAgICAgcmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgUERGTm9kZVN0cmVhbUZzRnVsbFJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgIHRoaXMuX3VybCA9IHN0cmVhbS51cmw7XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gbnVsbDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmVhbS5zb3VyY2U7XG4gICAgdGhpcy5fY29udGVudExlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgdGhpcy5fbG9hZGVkID0gMDtcbiAgICB0aGlzLl9maWxlbmFtZSA9IG51bGw7XG4gICAgdGhpcy5fZGlzYWJsZVJhbmdlID0gc291cmNlLmRpc2FibGVSYW5nZSB8fCBmYWxzZTtcbiAgICB0aGlzLl9yYW5nZUNodW5rU2l6ZSA9IHNvdXJjZS5yYW5nZUNodW5rU2l6ZTtcbiAgICBpZiAoIXRoaXMuX3JhbmdlQ2h1bmtTaXplICYmICF0aGlzLl9kaXNhYmxlUmFuZ2UpIHtcbiAgICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlU3RyZWFtO1xuICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVSYW5nZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbSA9IG51bGw7XG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIGNvbnN0IGZzID0gcHJvY2Vzcy5nZXRCdWlsdGluTW9kdWxlKFwiZnNcIik7XG4gICAgZnMucHJvbWlzZXMubHN0YXQodGhpcy5fdXJsKS50aGVuKHN0YXQgPT4ge1xuICAgICAgdGhpcy5fY29udGVudExlbmd0aCA9IHN0YXQuc2l6ZTtcbiAgICAgIHRoaXMuX3NldFJlYWRhYmxlU3RyZWFtKGZzLmNyZWF0ZVJlYWRTdHJlYW0odGhpcy5fdXJsKSk7XG4gICAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSwgZXJyb3IgPT4ge1xuICAgICAgaWYgKGVycm9yLmNvZGUgPT09IFwiRU5PRU5UXCIpIHtcbiAgICAgICAgZXJyb3IgPSBuZXcgTWlzc2luZ1BERkV4Y2VwdGlvbihgTWlzc2luZyBQREYgXCIke3RoaXMuX3VybH1cIi5gKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0b3JlZEVycm9yID0gZXJyb3I7XG4gICAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZWplY3QoZXJyb3IpO1xuICAgIH0pO1xuICB9XG4gIGdldCBoZWFkZXJzUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgZ2V0IGZpbGVuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlbmFtZTtcbiAgfVxuICBnZXQgY29udGVudExlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGVudExlbmd0aDtcbiAgfVxuICBnZXQgaXNSYW5nZVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNSYW5nZVN1cHBvcnRlZDtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5fcmVhZENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICB0aHJvdyB0aGlzLl9zdG9yZWRFcnJvcjtcbiAgICB9XG4gICAgY29uc3QgY2h1bmsgPSB0aGlzLl9yZWFkYWJsZVN0cmVhbS5yZWFkKCk7XG4gICAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgICAgcmV0dXJuIHRoaXMucmVhZCgpO1xuICAgIH1cbiAgICB0aGlzLl9sb2FkZWQgKz0gY2h1bmsubGVuZ3RoO1xuICAgIHRoaXMub25Qcm9ncmVzcz8uKHtcbiAgICAgIGxvYWRlZDogdGhpcy5fbG9hZGVkLFxuICAgICAgdG90YWw6IHRoaXMuX2NvbnRlbnRMZW5ndGhcbiAgICB9KTtcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShjaHVuaykuYnVmZmVyO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogYnVmZmVyLFxuICAgICAgZG9uZTogZmFsc2VcbiAgICB9O1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RyZWFtKSB7XG4gICAgICB0aGlzLl9lcnJvcihyZWFzb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbS5kZXN0cm95KHJlYXNvbik7XG4gIH1cbiAgX2Vycm9yKHJlYXNvbikge1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gcmVhc29uO1xuICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgfVxuICBfc2V0UmVhZGFibGVTdHJlYW0ocmVhZGFibGVTdHJlYW0pIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbSA9IHJlYWRhYmxlU3RyZWFtO1xuICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwicmVhZGFibGVcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0pO1xuICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwiZW5kXCIsICgpID0+IHtcbiAgICAgIHJlYWRhYmxlU3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0pO1xuICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwiZXJyb3JcIiwgcmVhc29uID0+IHtcbiAgICAgIHRoaXMuX2Vycm9yKHJlYXNvbik7XG4gICAgfSk7XG4gICAgaWYgKCF0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCAmJiB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLl9lcnJvcihuZXcgQWJvcnRFeGNlcHRpb24oXCJzdHJlYW1pbmcgaXMgZGlzYWJsZWRcIikpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtLmRlc3Ryb3kodGhpcy5fc3RvcmVkRXJyb3IpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgUERGTm9kZVN0cmVhbUZzUmFuZ2VSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0sIHN0YXJ0LCBlbmQpIHtcbiAgICB0aGlzLl91cmwgPSBzdHJlYW0udXJsO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IG51bGw7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgICB0aGlzLl9sb2FkZWQgPSAwO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtID0gbnVsbDtcbiAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmVhbS5zb3VyY2U7XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVTdHJlYW07XG4gICAgY29uc3QgZnMgPSBwcm9jZXNzLmdldEJ1aWx0aW5Nb2R1bGUoXCJmc1wiKTtcbiAgICB0aGlzLl9zZXRSZWFkYWJsZVN0cmVhbShmcy5jcmVhdGVSZWFkU3RyZWFtKHRoaXMuX3VybCwge1xuICAgICAgc3RhcnQsXG4gICAgICBlbmQ6IGVuZCAtIDFcbiAgICB9KSk7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGF3YWl0IHRoaXMuX3JlYWRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5fc3RvcmVkRXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcmVhZGFibGVTdHJlYW0ucmVhZCgpO1xuICAgIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICAgIHJldHVybiB0aGlzLnJlYWQoKTtcbiAgICB9XG4gICAgdGhpcy5fbG9hZGVkICs9IGNodW5rLmxlbmd0aDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICBsb2FkZWQ6IHRoaXMuX2xvYWRlZFxuICAgIH0pO1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGNodW5rKS5idWZmZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBidWZmZXIsXG4gICAgICBkb25lOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdHJlYW0pIHtcbiAgICAgIHRoaXMuX2Vycm9yKHJlYXNvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtLmRlc3Ryb3kocmVhc29uKTtcbiAgfVxuICBfZXJyb3IocmVhc29uKSB7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSByZWFzb247XG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG4gIF9zZXRSZWFkYWJsZVN0cmVhbShyZWFkYWJsZVN0cmVhbSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtID0gcmVhZGFibGVTdHJlYW07XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJyZWFkYWJsZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSk7XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJlbmRcIiwgKCkgPT4ge1xuICAgICAgcmVhZGFibGVTdHJlYW0uZGVzdHJveSgpO1xuICAgICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSk7XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJlcnJvclwiLCByZWFzb24gPT4ge1xuICAgICAgdGhpcy5fZXJyb3IocmVhc29uKTtcbiAgICB9KTtcbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtLmRlc3Ryb3kodGhpcy5fc3RvcmVkRXJyb3IpO1xuICAgIH1cbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS90ZXh0X2xheWVyLmpzXG5cblxuY29uc3QgTUFYX1RFWFRfRElWU19UT19SRU5ERVIgPSAxMDAwMDA7XG5jb25zdCBERUZBVUxUX0ZPTlRfU0laRSA9IDMwO1xuY29uc3QgREVGQVVMVF9GT05UX0FTQ0VOVCA9IDAuODtcbmNsYXNzIFRleHRMYXllciB7XG4gICNjYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICNjb250YWluZXIgPSBudWxsO1xuICAjZGlzYWJsZVByb2Nlc3NJdGVtcyA9IGZhbHNlO1xuICAjZm9udEluc3BlY3RvckVuYWJsZWQgPSAhIWdsb2JhbFRoaXMuRm9udEluc3BlY3Rvcj8uZW5hYmxlZDtcbiAgI2xhbmcgPSBudWxsO1xuICAjbGF5b3V0VGV4dFBhcmFtcyA9IG51bGw7XG4gICNwYWdlSGVpZ2h0ID0gMDtcbiAgI3BhZ2VXaWR0aCA9IDA7XG4gICNyZWFkZXIgPSBudWxsO1xuICAjcm9vdENvbnRhaW5lciA9IG51bGw7XG4gICNyb3RhdGlvbiA9IDA7XG4gICNzY2FsZSA9IDA7XG4gICNzdHlsZUNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgI3RleHRDb250ZW50SXRlbXNTdHIgPSBbXTtcbiAgI3RleHRDb250ZW50U291cmNlID0gbnVsbDtcbiAgI3RleHREaXZzID0gW107XG4gICN0ZXh0RGl2UHJvcGVydGllcyA9IG5ldyBXZWFrTWFwKCk7XG4gICN0cmFuc2Zvcm0gPSBudWxsO1xuICBzdGF0aWMgI2FzY2VudENhY2hlID0gbmV3IE1hcCgpO1xuICBzdGF0aWMgI2NhbnZhc0NvbnRleHRzID0gbmV3IE1hcCgpO1xuICBzdGF0aWMgI2NhbnZhc0N0eEZvbnRzID0gbmV3IFdlYWtNYXAoKTtcbiAgc3RhdGljICNtaW5Gb250U2l6ZSA9IG51bGw7XG4gIHN0YXRpYyAjcGVuZGluZ1RleHRMYXllcnMgPSBuZXcgU2V0KCk7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB0ZXh0Q29udGVudFNvdXJjZSxcbiAgICBjb250YWluZXIsXG4gICAgdmlld3BvcnRcbiAgfSkge1xuICAgIGlmICh0ZXh0Q29udGVudFNvdXJjZSBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtKSB7XG4gICAgICB0aGlzLiN0ZXh0Q29udGVudFNvdXJjZSA9IHRleHRDb250ZW50U291cmNlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRleHRDb250ZW50U291cmNlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aGlzLiN0ZXh0Q29udGVudFNvdXJjZSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodGV4dENvbnRlbnRTb3VyY2UpO1xuICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gXCJ0ZXh0Q29udGVudFNvdXJjZVwiIHBhcmFtZXRlciBzcGVjaWZpZWQuJyk7XG4gICAgfVxuICAgIHRoaXMuI2NvbnRhaW5lciA9IHRoaXMuI3Jvb3RDb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy4jc2NhbGUgPSB2aWV3cG9ydC5zY2FsZSAqIChnbG9iYWxUaGlzLmRldmljZVBpeGVsUmF0aW8gfHwgMSk7XG4gICAgdGhpcy4jcm90YXRpb24gPSB2aWV3cG9ydC5yb3RhdGlvbjtcbiAgICB0aGlzLiNsYXlvdXRUZXh0UGFyYW1zID0ge1xuICAgICAgZGl2OiBudWxsLFxuICAgICAgcHJvcGVydGllczogbnVsbCxcbiAgICAgIGN0eDogbnVsbFxuICAgIH07XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodCxcbiAgICAgIHBhZ2VYLFxuICAgICAgcGFnZVlcbiAgICB9ID0gdmlld3BvcnQucmF3RGltcztcbiAgICB0aGlzLiN0cmFuc2Zvcm0gPSBbMSwgMCwgMCwgLTEsIC1wYWdlWCwgcGFnZVkgKyBwYWdlSGVpZ2h0XTtcbiAgICB0aGlzLiNwYWdlV2lkdGggPSBwYWdlV2lkdGg7XG4gICAgdGhpcy4jcGFnZUhlaWdodCA9IHBhZ2VIZWlnaHQ7XG4gICAgVGV4dExheWVyLiNlbnN1cmVNaW5Gb250U2l6ZUNvbXB1dGVkKCk7XG4gICAgc2V0TGF5ZXJEaW1lbnNpb25zKGNvbnRhaW5lciwgdmlld3BvcnQpO1xuICAgIHRoaXMuI2NhcGFiaWxpdHkucHJvbWlzZS5maW5hbGx5KCgpID0+IHtcbiAgICAgIFRleHRMYXllci4jcGVuZGluZ1RleHRMYXllcnMuZGVsZXRlKHRoaXMpO1xuICAgICAgdGhpcy4jbGF5b3V0VGV4dFBhcmFtcyA9IG51bGw7XG4gICAgICB0aGlzLiNzdHlsZUNhY2hlID0gbnVsbDtcbiAgICB9KS5jYXRjaCgoKSA9PiB7fSk7XG4gIH1cbiAgc3RhdGljIGdldCBmb250RmFtaWx5TWFwKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzV2luZG93cyxcbiAgICAgIGlzRmlyZWZveFxuICAgIH0gPSB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJmb250RmFtaWx5TWFwXCIsIG5ldyBNYXAoW1tcInNhbnMtc2VyaWZcIiwgYCR7aXNXaW5kb3dzICYmIGlzRmlyZWZveCA/IFwiQ2FsaWJyaSwgXCIgOiBcIlwifXNhbnMtc2VyaWZgXSwgW1wibW9ub3NwYWNlXCIsIGAke2lzV2luZG93cyAmJiBpc0ZpcmVmb3ggPyBcIkx1Y2lkYSBDb25zb2xlLCBcIiA6IFwiXCJ9bW9ub3NwYWNlYF1dKSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHB1bXAgPSAoKSA9PiB7XG4gICAgICB0aGlzLiNyZWFkZXIucmVhZCgpLnRoZW4oKHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRvbmVcbiAgICAgIH0pID0+IHtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICB0aGlzLiNjYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbGFuZyA/Pz0gdmFsdWUubGFuZztcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLiNzdHlsZUNhY2hlLCB2YWx1ZS5zdHlsZXMpO1xuICAgICAgICB0aGlzLiNwcm9jZXNzSXRlbXModmFsdWUuaXRlbXMpO1xuICAgICAgICBwdW1wKCk7XG4gICAgICB9LCB0aGlzLiNjYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgfTtcbiAgICB0aGlzLiNyZWFkZXIgPSB0aGlzLiN0ZXh0Q29udGVudFNvdXJjZS5nZXRSZWFkZXIoKTtcbiAgICBUZXh0TGF5ZXIuI3BlbmRpbmdUZXh0TGF5ZXJzLmFkZCh0aGlzKTtcbiAgICBwdW1wKCk7XG4gICAgcmV0dXJuIHRoaXMuI2NhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICB1cGRhdGUoe1xuICAgIHZpZXdwb3J0LFxuICAgIG9uQmVmb3JlID0gbnVsbFxuICB9KSB7XG4gICAgY29uc3Qgc2NhbGUgPSB2aWV3cG9ydC5zY2FsZSAqIChnbG9iYWxUaGlzLmRldmljZVBpeGVsUmF0aW8gfHwgMSk7XG4gICAgY29uc3Qgcm90YXRpb24gPSB2aWV3cG9ydC5yb3RhdGlvbjtcbiAgICBpZiAocm90YXRpb24gIT09IHRoaXMuI3JvdGF0aW9uKSB7XG4gICAgICBvbkJlZm9yZT8uKCk7XG4gICAgICB0aGlzLiNyb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgICAgc2V0TGF5ZXJEaW1lbnNpb25zKHRoaXMuI3Jvb3RDb250YWluZXIsIHtcbiAgICAgICAgcm90YXRpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2NhbGUgIT09IHRoaXMuI3NjYWxlKSB7XG4gICAgICBvbkJlZm9yZT8uKCk7XG4gICAgICB0aGlzLiNzY2FsZSA9IHNjYWxlO1xuICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICBkaXY6IG51bGwsXG4gICAgICAgIHByb3BlcnRpZXM6IG51bGwsXG4gICAgICAgIGN0eDogVGV4dExheWVyLiNnZXRDdHgodGhpcy4jbGFuZylcbiAgICAgIH07XG4gICAgICBmb3IgKGNvbnN0IGRpdiBvZiB0aGlzLiN0ZXh0RGl2cykge1xuICAgICAgICBwYXJhbXMucHJvcGVydGllcyA9IHRoaXMuI3RleHREaXZQcm9wZXJ0aWVzLmdldChkaXYpO1xuICAgICAgICBwYXJhbXMuZGl2ID0gZGl2O1xuICAgICAgICB0aGlzLiNsYXlvdXQocGFyYW1zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2FuY2VsKCkge1xuICAgIGNvbnN0IGFib3J0RXggPSBuZXcgQWJvcnRFeGNlcHRpb24oXCJUZXh0TGF5ZXIgdGFzayBjYW5jZWxsZWQuXCIpO1xuICAgIHRoaXMuI3JlYWRlcj8uY2FuY2VsKGFib3J0RXgpLmNhdGNoKCgpID0+IHt9KTtcbiAgICB0aGlzLiNyZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuI2NhcGFiaWxpdHkucmVqZWN0KGFib3J0RXgpO1xuICB9XG4gIGdldCB0ZXh0RGl2cygpIHtcbiAgICByZXR1cm4gdGhpcy4jdGV4dERpdnM7XG4gIH1cbiAgZ2V0IHRleHRDb250ZW50SXRlbXNTdHIoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3RleHRDb250ZW50SXRlbXNTdHI7XG4gIH1cbiAgI3Byb2Nlc3NJdGVtcyhpdGVtcykge1xuICAgIGlmICh0aGlzLiNkaXNhYmxlUHJvY2Vzc0l0ZW1zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2xheW91dFRleHRQYXJhbXMuY3R4ID8/PSBUZXh0TGF5ZXIuI2dldEN0eCh0aGlzLiNsYW5nKTtcbiAgICBjb25zdCB0ZXh0RGl2cyA9IHRoaXMuI3RleHREaXZzLFxuICAgICAgdGV4dENvbnRlbnRJdGVtc1N0ciA9IHRoaXMuI3RleHRDb250ZW50SXRlbXNTdHI7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICBpZiAodGV4dERpdnMubGVuZ3RoID4gTUFYX1RFWFRfRElWU19UT19SRU5ERVIpIHtcbiAgICAgICAgd2FybihcIklnbm9yaW5nIGFkZGl0aW9uYWwgdGV4dERpdnMgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuXCIpO1xuICAgICAgICB0aGlzLiNkaXNhYmxlUHJvY2Vzc0l0ZW1zID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW0uc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gXCJiZWdpbk1hcmtlZENvbnRlbnRQcm9wc1wiIHx8IGl0ZW0udHlwZSA9PT0gXCJiZWdpbk1hcmtlZENvbnRlbnRcIikge1xuICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuI2NvbnRhaW5lcjtcbiAgICAgICAgICB0aGlzLiNjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICB0aGlzLiNjb250YWluZXIuY2xhc3NMaXN0LmFkZChcIm1hcmtlZENvbnRlbnRcIik7XG4gICAgICAgICAgaWYgKGl0ZW0uaWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuI2NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBgJHtpdGVtLmlkfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJlbnQuYXBwZW5kKHRoaXMuI2NvbnRhaW5lcik7XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbS50eXBlID09PSBcImVuZE1hcmtlZENvbnRlbnRcIikge1xuICAgICAgICAgIHRoaXMuI2NvbnRhaW5lciA9IHRoaXMuI2NvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGV4dENvbnRlbnRJdGVtc1N0ci5wdXNoKGl0ZW0uc3RyKTtcbiAgICAgIHRoaXMuI2FwcGVuZFRleHQoaXRlbSk7XG4gICAgfVxuICB9XG4gICNhcHBlbmRUZXh0KGdlb20pIHtcbiAgICBjb25zdCB0ZXh0RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgY29uc3QgdGV4dERpdlByb3BlcnRpZXMgPSB7XG4gICAgICBhbmdsZTogMCxcbiAgICAgIGNhbnZhc1dpZHRoOiAwLFxuICAgICAgaGFzVGV4dDogZ2VvbS5zdHIgIT09IFwiXCIsXG4gICAgICBoYXNFT0w6IGdlb20uaGFzRU9MLFxuICAgICAgZm9udFNpemU6IDBcbiAgICB9O1xuICAgIHRoaXMuI3RleHREaXZzLnB1c2godGV4dERpdik7XG4gICAgY29uc3QgdHggPSBVdGlsLnRyYW5zZm9ybSh0aGlzLiN0cmFuc2Zvcm0sIGdlb20udHJhbnNmb3JtKTtcbiAgICBsZXQgYW5nbGUgPSBNYXRoLmF0YW4yKHR4WzFdLCB0eFswXSk7XG4gICAgY29uc3Qgc3R5bGUgPSB0aGlzLiNzdHlsZUNhY2hlW2dlb20uZm9udE5hbWVdO1xuICAgIGlmIChzdHlsZS52ZXJ0aWNhbCkge1xuICAgICAgYW5nbGUgKz0gTWF0aC5QSSAvIDI7XG4gICAgfVxuICAgIGxldCBmb250RmFtaWx5ID0gdGhpcy4jZm9udEluc3BlY3RvckVuYWJsZWQgJiYgc3R5bGUuZm9udFN1YnN0aXR1dGlvbiB8fCBzdHlsZS5mb250RmFtaWx5O1xuICAgIGZvbnRGYW1pbHkgPSBUZXh0TGF5ZXIuZm9udEZhbWlseU1hcC5nZXQoZm9udEZhbWlseSkgfHwgZm9udEZhbWlseTtcbiAgICBjb25zdCBmb250SGVpZ2h0ID0gTWF0aC5oeXBvdCh0eFsyXSwgdHhbM10pO1xuICAgIGNvbnN0IGZvbnRBc2NlbnQgPSBmb250SGVpZ2h0ICogVGV4dExheWVyLiNnZXRBc2NlbnQoZm9udEZhbWlseSwgdGhpcy4jbGFuZyk7XG4gICAgbGV0IGxlZnQsIHRvcDtcbiAgICBpZiAoYW5nbGUgPT09IDApIHtcbiAgICAgIGxlZnQgPSB0eFs0XTtcbiAgICAgIHRvcCA9IHR4WzVdIC0gZm9udEFzY2VudDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVmdCA9IHR4WzRdICsgZm9udEFzY2VudCAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICAgIHRvcCA9IHR4WzVdIC0gZm9udEFzY2VudCAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICB9XG4gICAgY29uc3Qgc2NhbGVGYWN0b3JTdHIgPSBcImNhbGModmFyKC0tc2NhbGUtZmFjdG9yKSpcIjtcbiAgICBjb25zdCBkaXZTdHlsZSA9IHRleHREaXYuc3R5bGU7XG4gICAgaWYgKHRoaXMuI2NvbnRhaW5lciA9PT0gdGhpcy4jcm9vdENvbnRhaW5lcikge1xuICAgICAgZGl2U3R5bGUubGVmdCA9IGAkeygxMDAgKiBsZWZ0IC8gdGhpcy4jcGFnZVdpZHRoKS50b0ZpeGVkKDIpfSVgO1xuICAgICAgZGl2U3R5bGUudG9wID0gYCR7KDEwMCAqIHRvcCAvIHRoaXMuI3BhZ2VIZWlnaHQpLnRvRml4ZWQoMil9JWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpdlN0eWxlLmxlZnQgPSBgJHtzY2FsZUZhY3RvclN0cn0ke2xlZnQudG9GaXhlZCgyKX1weClgO1xuICAgICAgZGl2U3R5bGUudG9wID0gYCR7c2NhbGVGYWN0b3JTdHJ9JHt0b3AudG9GaXhlZCgyKX1weClgO1xuICAgIH1cbiAgICBkaXZTdHlsZS5mb250U2l6ZSA9IGAke3NjYWxlRmFjdG9yU3RyfSR7KFRleHRMYXllci4jbWluRm9udFNpemUgKiBmb250SGVpZ2h0KS50b0ZpeGVkKDIpfXB4KWA7XG4gICAgZGl2U3R5bGUuZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gICAgdGV4dERpdlByb3BlcnRpZXMuZm9udFNpemUgPSBmb250SGVpZ2h0O1xuICAgIHRleHREaXYuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInByZXNlbnRhdGlvblwiKTtcbiAgICB0ZXh0RGl2LnRleHRDb250ZW50ID0gZ2VvbS5zdHI7XG4gICAgdGV4dERpdi5kaXIgPSBnZW9tLmRpcjtcbiAgICBpZiAodGhpcy4jZm9udEluc3BlY3RvckVuYWJsZWQpIHtcbiAgICAgIHRleHREaXYuZGF0YXNldC5mb250TmFtZSA9IHN0eWxlLmZvbnRTdWJzdGl0dXRpb25Mb2FkZWROYW1lIHx8IGdlb20uZm9udE5hbWU7XG4gICAgfVxuICAgIGlmIChhbmdsZSAhPT0gMCkge1xuICAgICAgdGV4dERpdlByb3BlcnRpZXMuYW5nbGUgPSBhbmdsZSAqICgxODAgLyBNYXRoLlBJKTtcbiAgICB9XG4gICAgbGV0IHNob3VsZFNjYWxlVGV4dCA9IGZhbHNlO1xuICAgIGlmIChnZW9tLnN0ci5sZW5ndGggPiAxKSB7XG4gICAgICBzaG91bGRTY2FsZVRleHQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZ2VvbS5zdHIgIT09IFwiIFwiICYmIGdlb20udHJhbnNmb3JtWzBdICE9PSBnZW9tLnRyYW5zZm9ybVszXSkge1xuICAgICAgY29uc3QgYWJzU2NhbGVYID0gTWF0aC5hYnMoZ2VvbS50cmFuc2Zvcm1bMF0pLFxuICAgICAgICBhYnNTY2FsZVkgPSBNYXRoLmFicyhnZW9tLnRyYW5zZm9ybVszXSk7XG4gICAgICBpZiAoYWJzU2NhbGVYICE9PSBhYnNTY2FsZVkgJiYgTWF0aC5tYXgoYWJzU2NhbGVYLCBhYnNTY2FsZVkpIC8gTWF0aC5taW4oYWJzU2NhbGVYLCBhYnNTY2FsZVkpID4gMS41KSB7XG4gICAgICAgIHNob3VsZFNjYWxlVGV4dCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzaG91bGRTY2FsZVRleHQpIHtcbiAgICAgIHRleHREaXZQcm9wZXJ0aWVzLmNhbnZhc1dpZHRoID0gc3R5bGUudmVydGljYWwgPyBnZW9tLmhlaWdodCA6IGdlb20ud2lkdGg7XG4gICAgfVxuICAgIHRoaXMuI3RleHREaXZQcm9wZXJ0aWVzLnNldCh0ZXh0RGl2LCB0ZXh0RGl2UHJvcGVydGllcyk7XG4gICAgdGhpcy4jbGF5b3V0VGV4dFBhcmFtcy5kaXYgPSB0ZXh0RGl2O1xuICAgIHRoaXMuI2xheW91dFRleHRQYXJhbXMucHJvcGVydGllcyA9IHRleHREaXZQcm9wZXJ0aWVzO1xuICAgIHRoaXMuI2xheW91dCh0aGlzLiNsYXlvdXRUZXh0UGFyYW1zKTtcbiAgICBpZiAodGV4dERpdlByb3BlcnRpZXMuaGFzVGV4dCkge1xuICAgICAgdGhpcy4jY29udGFpbmVyLmFwcGVuZCh0ZXh0RGl2KTtcbiAgICB9XG4gICAgaWYgKHRleHREaXZQcm9wZXJ0aWVzLmhhc0VPTCkge1xuICAgICAgY29uc3QgYnIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIik7XG4gICAgICBici5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwicHJlc2VudGF0aW9uXCIpO1xuICAgICAgdGhpcy4jY29udGFpbmVyLmFwcGVuZChicik7XG4gICAgfVxuICB9XG4gICNsYXlvdXQocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGl2LFxuICAgICAgcHJvcGVydGllcyxcbiAgICAgIGN0eFxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gZGl2O1xuICAgIGxldCB0cmFuc2Zvcm0gPSBcIlwiO1xuICAgIGlmIChUZXh0TGF5ZXIuI21pbkZvbnRTaXplID4gMSkge1xuICAgICAgdHJhbnNmb3JtID0gYHNjYWxlKCR7MSAvIFRleHRMYXllci4jbWluRm9udFNpemV9KWA7XG4gICAgfVxuICAgIGlmIChwcm9wZXJ0aWVzLmNhbnZhc1dpZHRoICE9PSAwICYmIHByb3BlcnRpZXMuaGFzVGV4dCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBmb250RmFtaWx5XG4gICAgICB9ID0gc3R5bGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNhbnZhc1dpZHRoLFxuICAgICAgICBmb250U2l6ZVxuICAgICAgfSA9IHByb3BlcnRpZXM7XG4gICAgICBUZXh0TGF5ZXIuI2Vuc3VyZUN0eEZvbnQoY3R4LCBmb250U2l6ZSAqIHRoaXMuI3NjYWxlLCBmb250RmFtaWx5KTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd2lkdGhcbiAgICAgIH0gPSBjdHgubWVhc3VyZVRleHQoZGl2LnRleHRDb250ZW50KTtcbiAgICAgIGlmICh3aWR0aCA+IDApIHtcbiAgICAgICAgdHJhbnNmb3JtID0gYHNjYWxlWCgke2NhbnZhc1dpZHRoICogdGhpcy4jc2NhbGUgLyB3aWR0aH0pICR7dHJhbnNmb3JtfWA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wZXJ0aWVzLmFuZ2xlICE9PSAwKSB7XG4gICAgICB0cmFuc2Zvcm0gPSBgcm90YXRlKCR7cHJvcGVydGllcy5hbmdsZX1kZWcpICR7dHJhbnNmb3JtfWA7XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm0ubGVuZ3RoID4gMCkge1xuICAgICAgc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgY2xlYW51cCgpIHtcbiAgICBpZiAodGhpcy4jcGVuZGluZ1RleHRMYXllcnMuc2l6ZSA+IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYXNjZW50Q2FjaGUuY2xlYXIoKTtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIGNhbnZhc1xuICAgIH0gb2YgdGhpcy4jY2FudmFzQ29udGV4dHMudmFsdWVzKCkpIHtcbiAgICAgIGNhbnZhcy5yZW1vdmUoKTtcbiAgICB9XG4gICAgdGhpcy4jY2FudmFzQ29udGV4dHMuY2xlYXIoKTtcbiAgfVxuICBzdGF0aWMgI2dldEN0eChsYW5nID0gbnVsbCkge1xuICAgIGxldCBjdHggPSB0aGlzLiNjYW52YXNDb250ZXh0cy5nZXQobGFuZyB8fD0gXCJcIik7XG4gICAgaWYgKCFjdHgpIHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICBjYW52YXMuY2xhc3NOYW1lID0gXCJoaWRkZW5DYW52YXNFbGVtZW50XCI7XG4gICAgICBjYW52YXMubGFuZyA9IGxhbmc7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZChjYW52YXMpO1xuICAgICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICAgIGFscGhhOiBmYWxzZSxcbiAgICAgICAgd2lsbFJlYWRGcmVxdWVudGx5OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuI2NhbnZhc0NvbnRleHRzLnNldChsYW5nLCBjdHgpO1xuICAgICAgdGhpcy4jY2FudmFzQ3R4Rm9udHMuc2V0KGN0eCwge1xuICAgICAgICBzaXplOiAwLFxuICAgICAgICBmYW1pbHk6IFwiXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY3R4O1xuICB9XG4gIHN0YXRpYyAjZW5zdXJlQ3R4Rm9udChjdHgsIHNpemUsIGZhbWlseSkge1xuICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuI2NhbnZhc0N0eEZvbnRzLmdldChjdHgpO1xuICAgIGlmIChzaXplID09PSBjYWNoZWQuc2l6ZSAmJiBmYW1pbHkgPT09IGNhY2hlZC5mYW1pbHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3R4LmZvbnQgPSBgJHtzaXplfXB4ICR7ZmFtaWx5fWA7XG4gICAgY2FjaGVkLnNpemUgPSBzaXplO1xuICAgIGNhY2hlZC5mYW1pbHkgPSBmYW1pbHk7XG4gIH1cbiAgc3RhdGljICNlbnN1cmVNaW5Gb250U2l6ZUNvbXB1dGVkKCkge1xuICAgIGlmICh0aGlzLiNtaW5Gb250U2l6ZSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdi5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICBkaXYuc3R5bGUubGluZUhlaWdodCA9IDE7XG4gICAgZGl2LnN0eWxlLmZvbnRTaXplID0gXCIxcHhcIjtcbiAgICBkaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgZGl2LnRleHRDb250ZW50ID0gXCJYXCI7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmQoZGl2KTtcbiAgICB0aGlzLiNtaW5Gb250U2l6ZSA9IGRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgZGl2LnJlbW92ZSgpO1xuICB9XG4gIHN0YXRpYyAjZ2V0QXNjZW50KGZvbnRGYW1pbHksIGxhbmcpIHtcbiAgICBjb25zdCBjYWNoZWRBc2NlbnQgPSB0aGlzLiNhc2NlbnRDYWNoZS5nZXQoZm9udEZhbWlseSk7XG4gICAgaWYgKGNhY2hlZEFzY2VudCkge1xuICAgICAgcmV0dXJuIGNhY2hlZEFzY2VudDtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy4jZ2V0Q3R4KGxhbmcpO1xuICAgIGN0eC5jYW52YXMud2lkdGggPSBjdHguY2FudmFzLmhlaWdodCA9IERFRkFVTFRfRk9OVF9TSVpFO1xuICAgIHRoaXMuI2Vuc3VyZUN0eEZvbnQoY3R4LCBERUZBVUxUX0ZPTlRfU0laRSwgZm9udEZhbWlseSk7XG4gICAgY29uc3QgbWV0cmljcyA9IGN0eC5tZWFzdXJlVGV4dChcIlwiKTtcbiAgICBsZXQgYXNjZW50ID0gbWV0cmljcy5mb250Qm91bmRpbmdCb3hBc2NlbnQ7XG4gICAgbGV0IGRlc2NlbnQgPSBNYXRoLmFicyhtZXRyaWNzLmZvbnRCb3VuZGluZ0JveERlc2NlbnQpO1xuICAgIGlmIChhc2NlbnQpIHtcbiAgICAgIGNvbnN0IHJhdGlvID0gYXNjZW50IC8gKGFzY2VudCArIGRlc2NlbnQpO1xuICAgICAgdGhpcy4jYXNjZW50Q2FjaGUuc2V0KGZvbnRGYW1pbHksIHJhdGlvKTtcbiAgICAgIGN0eC5jYW52YXMud2lkdGggPSBjdHguY2FudmFzLmhlaWdodCA9IDA7XG4gICAgICByZXR1cm4gcmF0aW87XG4gICAgfVxuICAgIGN0eC5zdHJva2VTdHlsZSA9IFwicmVkXCI7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBERUZBVUxUX0ZPTlRfU0laRSwgREVGQVVMVF9GT05UX1NJWkUpO1xuICAgIGN0eC5zdHJva2VUZXh0KFwiZ1wiLCAwLCAwKTtcbiAgICBsZXQgcGl4ZWxzID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBERUZBVUxUX0ZPTlRfU0laRSwgREVGQVVMVF9GT05UX1NJWkUpLmRhdGE7XG4gICAgZGVzY2VudCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IHBpeGVscy5sZW5ndGggLSAxIC0gMzsgaSA+PSAwOyBpIC09IDQpIHtcbiAgICAgIGlmIChwaXhlbHNbaV0gPiAwKSB7XG4gICAgICAgIGRlc2NlbnQgPSBNYXRoLmNlaWwoaSAvIDQgLyBERUZBVUxUX0ZPTlRfU0laRSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIERFRkFVTFRfRk9OVF9TSVpFLCBERUZBVUxUX0ZPTlRfU0laRSk7XG4gICAgY3R4LnN0cm9rZVRleHQoXCJBXCIsIDAsIERFRkFVTFRfRk9OVF9TSVpFKTtcbiAgICBwaXhlbHMgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIERFRkFVTFRfRk9OVF9TSVpFLCBERUZBVUxUX0ZPTlRfU0laRSkuZGF0YTtcbiAgICBhc2NlbnQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBpeGVscy5sZW5ndGg7IGkgPCBpaTsgaSArPSA0KSB7XG4gICAgICBpZiAocGl4ZWxzW2ldID4gMCkge1xuICAgICAgICBhc2NlbnQgPSBERUZBVUxUX0ZPTlRfU0laRSAtIE1hdGguZmxvb3IoaSAvIDQgLyBERUZBVUxUX0ZPTlRfU0laRSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBjdHguY2FudmFzLndpZHRoID0gY3R4LmNhbnZhcy5oZWlnaHQgPSAwO1xuICAgIGNvbnN0IHJhdGlvID0gYXNjZW50ID8gYXNjZW50IC8gKGFzY2VudCArIGRlc2NlbnQpIDogREVGQVVMVF9GT05UX0FTQ0VOVDtcbiAgICB0aGlzLiNhc2NlbnRDYWNoZS5zZXQoZm9udEZhbWlseSwgcmF0aW8pO1xuICAgIHJldHVybiByYXRpbztcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS94ZmFfdGV4dC5qc1xuY2xhc3MgWGZhVGV4dCB7XG4gIHN0YXRpYyB0ZXh0Q29udGVudCh4ZmEpIHtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgIGl0ZW1zLFxuICAgICAgc3R5bGVzOiBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgfTtcbiAgICBmdW5jdGlvbiB3YWxrKG5vZGUpIHtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgc3RyID0gbnVsbDtcbiAgICAgIGNvbnN0IG5hbWUgPSBub2RlLm5hbWU7XG4gICAgICBpZiAobmFtZSA9PT0gXCIjdGV4dFwiKSB7XG4gICAgICAgIHN0ciA9IG5vZGUudmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKCFYZmFUZXh0LnNob3VsZEJ1aWxkVGV4dChuYW1lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKG5vZGU/LmF0dHJpYnV0ZXM/LnRleHRDb250ZW50KSB7XG4gICAgICAgIHN0ciA9IG5vZGUuYXR0cmlidXRlcy50ZXh0Q29udGVudDtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS52YWx1ZSkge1xuICAgICAgICBzdHIgPSBub2RlLnZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0ciAhPT0gbnVsbCkge1xuICAgICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgICBzdHJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIHdhbGsoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgICB3YWxrKHhmYSk7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuICBzdGF0aWMgc2hvdWxkQnVpbGRUZXh0KG5hbWUpIHtcbiAgICByZXR1cm4gIShuYW1lID09PSBcInRleHRhcmVhXCIgfHwgbmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwib3B0aW9uXCIgfHwgbmFtZSA9PT0gXCJzZWxlY3RcIik7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvYXBpLmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuY29uc3QgREVGQVVMVF9SQU5HRV9DSFVOS19TSVpFID0gNjU1MzY7XG5jb25zdCBSRU5ERVJJTkdfQ0FOQ0VMTEVEX1RJTUVPVVQgPSAxMDA7XG5jb25zdCBERUxBWUVEX0NMRUFOVVBfVElNRU9VVCA9IDUwMDA7XG5jb25zdCBEZWZhdWx0Q2FudmFzRmFjdG9yeSA9IGlzTm9kZUpTID8gTm9kZUNhbnZhc0ZhY3RvcnkgOiBET01DYW52YXNGYWN0b3J5O1xuY29uc3QgRGVmYXVsdENNYXBSZWFkZXJGYWN0b3J5ID0gaXNOb2RlSlMgPyBOb2RlQ01hcFJlYWRlckZhY3RvcnkgOiBET01DTWFwUmVhZGVyRmFjdG9yeTtcbmNvbnN0IERlZmF1bHRGaWx0ZXJGYWN0b3J5ID0gaXNOb2RlSlMgPyBOb2RlRmlsdGVyRmFjdG9yeSA6IERPTUZpbHRlckZhY3Rvcnk7XG5jb25zdCBEZWZhdWx0U3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBpc05vZGVKUyA/IE5vZGVTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA6IERPTVN0YW5kYXJkRm9udERhdGFGYWN0b3J5O1xuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoc3JjID0ge30pIHtcbiAgaWYgKHR5cGVvZiBzcmMgPT09IFwic3RyaW5nXCIgfHwgc3JjIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgc3JjID0ge1xuICAgICAgdXJsOiBzcmNcbiAgICB9O1xuICB9IGVsc2UgaWYgKHNyYyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyhzcmMpKSB7XG4gICAgc3JjID0ge1xuICAgICAgZGF0YTogc3JjXG4gICAgfTtcbiAgfVxuICBjb25zdCB0YXNrID0gbmV3IFBERkRvY3VtZW50TG9hZGluZ1Rhc2soKTtcbiAgY29uc3Qge1xuICAgIGRvY0lkXG4gIH0gPSB0YXNrO1xuICBjb25zdCB1cmwgPSBzcmMudXJsID8gZ2V0VXJsUHJvcChzcmMudXJsKSA6IG51bGw7XG4gIGNvbnN0IGRhdGEgPSBzcmMuZGF0YSA/IGdldERhdGFQcm9wKHNyYy5kYXRhKSA6IG51bGw7XG4gIGNvbnN0IGh0dHBIZWFkZXJzID0gc3JjLmh0dHBIZWFkZXJzIHx8IG51bGw7XG4gIGNvbnN0IHdpdGhDcmVkZW50aWFscyA9IHNyYy53aXRoQ3JlZGVudGlhbHMgPT09IHRydWU7XG4gIGNvbnN0IHBhc3N3b3JkID0gc3JjLnBhc3N3b3JkID8/IG51bGw7XG4gIGNvbnN0IHJhbmdlVHJhbnNwb3J0ID0gc3JjLnJhbmdlIGluc3RhbmNlb2YgUERGRGF0YVJhbmdlVHJhbnNwb3J0ID8gc3JjLnJhbmdlIDogbnVsbDtcbiAgY29uc3QgcmFuZ2VDaHVua1NpemUgPSBOdW1iZXIuaXNJbnRlZ2VyKHNyYy5yYW5nZUNodW5rU2l6ZSkgJiYgc3JjLnJhbmdlQ2h1bmtTaXplID4gMCA/IHNyYy5yYW5nZUNodW5rU2l6ZSA6IERFRkFVTFRfUkFOR0VfQ0hVTktfU0laRTtcbiAgbGV0IHdvcmtlciA9IHNyYy53b3JrZXIgaW5zdGFuY2VvZiBQREZXb3JrZXIgPyBzcmMud29ya2VyIDogbnVsbDtcbiAgY29uc3QgdmVyYm9zaXR5ID0gc3JjLnZlcmJvc2l0eTtcbiAgY29uc3QgZG9jQmFzZVVybCA9IHR5cGVvZiBzcmMuZG9jQmFzZVVybCA9PT0gXCJzdHJpbmdcIiAmJiAhaXNEYXRhU2NoZW1lKHNyYy5kb2NCYXNlVXJsKSA/IHNyYy5kb2NCYXNlVXJsIDogbnVsbDtcbiAgY29uc3QgY01hcFVybCA9IHR5cGVvZiBzcmMuY01hcFVybCA9PT0gXCJzdHJpbmdcIiA/IHNyYy5jTWFwVXJsIDogbnVsbDtcbiAgY29uc3QgY01hcFBhY2tlZCA9IHNyYy5jTWFwUGFja2VkICE9PSBmYWxzZTtcbiAgY29uc3QgQ01hcFJlYWRlckZhY3RvcnkgPSBzcmMuQ01hcFJlYWRlckZhY3RvcnkgfHwgRGVmYXVsdENNYXBSZWFkZXJGYWN0b3J5O1xuICBjb25zdCBzdGFuZGFyZEZvbnREYXRhVXJsID0gdHlwZW9mIHNyYy5zdGFuZGFyZEZvbnREYXRhVXJsID09PSBcInN0cmluZ1wiID8gc3JjLnN0YW5kYXJkRm9udERhdGFVcmwgOiBudWxsO1xuICBjb25zdCBTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IHNyYy5TdGFuZGFyZEZvbnREYXRhRmFjdG9yeSB8fCBEZWZhdWx0U3RhbmRhcmRGb250RGF0YUZhY3Rvcnk7XG4gIGNvbnN0IGlnbm9yZUVycm9ycyA9IHNyYy5zdG9wQXRFcnJvcnMgIT09IHRydWU7XG4gIGNvbnN0IG1heEltYWdlU2l6ZSA9IE51bWJlci5pc0ludGVnZXIoc3JjLm1heEltYWdlU2l6ZSkgJiYgc3JjLm1heEltYWdlU2l6ZSA+IC0xID8gc3JjLm1heEltYWdlU2l6ZSA6IC0xO1xuICBjb25zdCBpc0V2YWxTdXBwb3J0ZWQgPSBzcmMuaXNFdmFsU3VwcG9ydGVkICE9PSBmYWxzZTtcbiAgY29uc3QgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQgPSB0eXBlb2Ygc3JjLmlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkID09PSBcImJvb2xlYW5cIiA/IHNyYy5pc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCA6ICFpc05vZGVKUztcbiAgY29uc3QgaXNJbWFnZURlY29kZXJTdXBwb3J0ZWQgPSB0eXBlb2Ygc3JjLmlzSW1hZ2VEZWNvZGVyU3VwcG9ydGVkID09PSBcImJvb2xlYW5cIiA/IHNyYy5pc0ltYWdlRGVjb2RlclN1cHBvcnRlZCA6ICFpc05vZGVKUyAmJiAodXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybS5pc0ZpcmVmb3ggfHwgIWdsb2JhbFRoaXMuY2hyb21lKTtcbiAgY29uc3QgY2FudmFzTWF4QXJlYUluQnl0ZXMgPSBOdW1iZXIuaXNJbnRlZ2VyKHNyYy5jYW52YXNNYXhBcmVhSW5CeXRlcykgPyBzcmMuY2FudmFzTWF4QXJlYUluQnl0ZXMgOiAtMTtcbiAgY29uc3QgZGlzYWJsZUZvbnRGYWNlID0gdHlwZW9mIHNyYy5kaXNhYmxlRm9udEZhY2UgPT09IFwiYm9vbGVhblwiID8gc3JjLmRpc2FibGVGb250RmFjZSA6IGlzTm9kZUpTO1xuICBjb25zdCBmb250RXh0cmFQcm9wZXJ0aWVzID0gc3JjLmZvbnRFeHRyYVByb3BlcnRpZXMgPT09IHRydWU7XG4gIGNvbnN0IGVuYWJsZVhmYSA9IHNyYy5lbmFibGVYZmEgPT09IHRydWU7XG4gIGNvbnN0IG93bmVyRG9jdW1lbnQgPSBzcmMub3duZXJEb2N1bWVudCB8fCBnbG9iYWxUaGlzLmRvY3VtZW50O1xuICBjb25zdCBkaXNhYmxlUmFuZ2UgPSBzcmMuZGlzYWJsZVJhbmdlID09PSB0cnVlO1xuICBjb25zdCBkaXNhYmxlU3RyZWFtID0gc3JjLmRpc2FibGVTdHJlYW0gPT09IHRydWU7XG4gIGNvbnN0IGRpc2FibGVBdXRvRmV0Y2ggPSBzcmMuZGlzYWJsZUF1dG9GZXRjaCA9PT0gdHJ1ZTtcbiAgY29uc3QgcGRmQnVnID0gc3JjLnBkZkJ1ZyA9PT0gdHJ1ZTtcbiAgY29uc3QgQ2FudmFzRmFjdG9yeSA9IHNyYy5DYW52YXNGYWN0b3J5IHx8IERlZmF1bHRDYW52YXNGYWN0b3J5O1xuICBjb25zdCBGaWx0ZXJGYWN0b3J5ID0gc3JjLkZpbHRlckZhY3RvcnkgfHwgRGVmYXVsdEZpbHRlckZhY3Rvcnk7XG4gIGNvbnN0IGVuYWJsZUhXQSA9IHNyYy5lbmFibGVIV0EgPT09IHRydWU7XG4gIGNvbnN0IGxlbmd0aCA9IHJhbmdlVHJhbnNwb3J0ID8gcmFuZ2VUcmFuc3BvcnQubGVuZ3RoIDogc3JjLmxlbmd0aCA/PyBOYU47XG4gIGNvbnN0IHVzZVN5c3RlbUZvbnRzID0gdHlwZW9mIHNyYy51c2VTeXN0ZW1Gb250cyA9PT0gXCJib29sZWFuXCIgPyBzcmMudXNlU3lzdGVtRm9udHMgOiAhaXNOb2RlSlMgJiYgIWRpc2FibGVGb250RmFjZTtcbiAgY29uc3QgdXNlV29ya2VyRmV0Y2ggPSB0eXBlb2Ygc3JjLnVzZVdvcmtlckZldGNoID09PSBcImJvb2xlYW5cIiA/IHNyYy51c2VXb3JrZXJGZXRjaCA6IENNYXBSZWFkZXJGYWN0b3J5ID09PSBET01DTWFwUmVhZGVyRmFjdG9yeSAmJiBTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9PT0gRE9NU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgJiYgY01hcFVybCAmJiBzdGFuZGFyZEZvbnREYXRhVXJsICYmIGlzVmFsaWRGZXRjaFVybChjTWFwVXJsLCBkb2N1bWVudC5iYXNlVVJJKSAmJiBpc1ZhbGlkRmV0Y2hVcmwoc3RhbmRhcmRGb250RGF0YVVybCwgZG9jdW1lbnQuYmFzZVVSSSk7XG4gIGlmIChzcmMuY2FudmFzRmFjdG9yeSkge1xuICAgIGRlcHJlY2F0ZWQoXCJgY2FudmFzRmFjdG9yeWAtaW5zdGFuY2Ugb3B0aW9uLCBwbGVhc2UgdXNlIGBDYW52YXNGYWN0b3J5YCBpbnN0ZWFkLlwiKTtcbiAgfVxuICBpZiAoc3JjLmZpbHRlckZhY3RvcnkpIHtcbiAgICBkZXByZWNhdGVkKFwiYGZpbHRlckZhY3RvcnlgLWluc3RhbmNlIG9wdGlvbiwgcGxlYXNlIHVzZSBgRmlsdGVyRmFjdG9yeWAgaW5zdGVhZC5cIik7XG4gIH1cbiAgY29uc3Qgc3R5bGVFbGVtZW50ID0gbnVsbDtcbiAgc2V0VmVyYm9zaXR5TGV2ZWwodmVyYm9zaXR5KTtcbiAgY29uc3QgdHJhbnNwb3J0RmFjdG9yeSA9IHtcbiAgICBjYW52YXNGYWN0b3J5OiBuZXcgQ2FudmFzRmFjdG9yeSh7XG4gICAgICBvd25lckRvY3VtZW50LFxuICAgICAgZW5hYmxlSFdBXG4gICAgfSksXG4gICAgZmlsdGVyRmFjdG9yeTogbmV3IEZpbHRlckZhY3Rvcnkoe1xuICAgICAgZG9jSWQsXG4gICAgICBvd25lckRvY3VtZW50XG4gICAgfSksXG4gICAgY01hcFJlYWRlckZhY3Rvcnk6IHVzZVdvcmtlckZldGNoID8gbnVsbCA6IG5ldyBDTWFwUmVhZGVyRmFjdG9yeSh7XG4gICAgICBiYXNlVXJsOiBjTWFwVXJsLFxuICAgICAgaXNDb21wcmVzc2VkOiBjTWFwUGFja2VkXG4gICAgfSksXG4gICAgc3RhbmRhcmRGb250RGF0YUZhY3Rvcnk6IHVzZVdvcmtlckZldGNoID8gbnVsbCA6IG5ldyBTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSh7XG4gICAgICBiYXNlVXJsOiBzdGFuZGFyZEZvbnREYXRhVXJsXG4gICAgfSlcbiAgfTtcbiAgaWYgKCF3b3JrZXIpIHtcbiAgICBjb25zdCB3b3JrZXJQYXJhbXMgPSB7XG4gICAgICB2ZXJib3NpdHksXG4gICAgICBwb3J0OiBHbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclBvcnRcbiAgICB9O1xuICAgIHdvcmtlciA9IHdvcmtlclBhcmFtcy5wb3J0ID8gUERGV29ya2VyLmZyb21Qb3J0KHdvcmtlclBhcmFtcykgOiBuZXcgUERGV29ya2VyKHdvcmtlclBhcmFtcyk7XG4gICAgdGFzay5fd29ya2VyID0gd29ya2VyO1xuICB9XG4gIGNvbnN0IGRvY1BhcmFtcyA9IHtcbiAgICBkb2NJZCxcbiAgICBhcGlWZXJzaW9uOiBcIjQuOS4xNTVcIixcbiAgICBkYXRhLFxuICAgIHBhc3N3b3JkLFxuICAgIGRpc2FibGVBdXRvRmV0Y2gsXG4gICAgcmFuZ2VDaHVua1NpemUsXG4gICAgbGVuZ3RoLFxuICAgIGRvY0Jhc2VVcmwsXG4gICAgZW5hYmxlWGZhLFxuICAgIGV2YWx1YXRvck9wdGlvbnM6IHtcbiAgICAgIG1heEltYWdlU2l6ZSxcbiAgICAgIGRpc2FibGVGb250RmFjZSxcbiAgICAgIGlnbm9yZUVycm9ycyxcbiAgICAgIGlzRXZhbFN1cHBvcnRlZCxcbiAgICAgIGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkLFxuICAgICAgaXNJbWFnZURlY29kZXJTdXBwb3J0ZWQsXG4gICAgICBjYW52YXNNYXhBcmVhSW5CeXRlcyxcbiAgICAgIGZvbnRFeHRyYVByb3BlcnRpZXMsXG4gICAgICB1c2VTeXN0ZW1Gb250cyxcbiAgICAgIGNNYXBVcmw6IHVzZVdvcmtlckZldGNoID8gY01hcFVybCA6IG51bGwsXG4gICAgICBzdGFuZGFyZEZvbnREYXRhVXJsOiB1c2VXb3JrZXJGZXRjaCA/IHN0YW5kYXJkRm9udERhdGFVcmwgOiBudWxsXG4gICAgfVxuICB9O1xuICBjb25zdCB0cmFuc3BvcnRQYXJhbXMgPSB7XG4gICAgZGlzYWJsZUZvbnRGYWNlLFxuICAgIGZvbnRFeHRyYVByb3BlcnRpZXMsXG4gICAgb3duZXJEb2N1bWVudCxcbiAgICBwZGZCdWcsXG4gICAgc3R5bGVFbGVtZW50LFxuICAgIGxvYWRpbmdQYXJhbXM6IHtcbiAgICAgIGRpc2FibGVBdXRvRmV0Y2gsXG4gICAgICBlbmFibGVYZmFcbiAgICB9XG4gIH07XG4gIHdvcmtlci5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIGlmICh0YXNrLmRlc3Ryb3llZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTG9hZGluZyBhYm9ydGVkXCIpO1xuICAgIH1cbiAgICBpZiAod29ya2VyLmRlc3Ryb3llZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IHdvcmtlcklkUHJvbWlzZSA9IHdvcmtlci5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXREb2NSZXF1ZXN0XCIsIGRvY1BhcmFtcywgZGF0YSA/IFtkYXRhLmJ1ZmZlcl0gOiBudWxsKTtcbiAgICBsZXQgbmV0d29ya1N0cmVhbTtcbiAgICBpZiAocmFuZ2VUcmFuc3BvcnQpIHtcbiAgICAgIG5ldHdvcmtTdHJlYW0gPSBuZXcgUERGRGF0YVRyYW5zcG9ydFN0cmVhbShyYW5nZVRyYW5zcG9ydCwge1xuICAgICAgICBkaXNhYmxlUmFuZ2UsXG4gICAgICAgIGRpc2FibGVTdHJlYW1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoIWRhdGEpIHtcbiAgICAgIGlmICghdXJsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImdldERvY3VtZW50IC0gbm8gYHVybGAgcGFyYW1ldGVyIHByb3ZpZGVkLlwiKTtcbiAgICAgIH1cbiAgICAgIGxldCBOZXR3b3JrU3RyZWFtO1xuICAgICAgaWYgKGlzTm9kZUpTKSB7XG4gICAgICAgIGlmIChpc1ZhbGlkRmV0Y2hVcmwodXJsKSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgZmV0Y2ggPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIFJlc3BvbnNlID09PSBcInVuZGVmaW5lZFwiIHx8ICEoXCJib2R5XCIgaW4gUmVzcG9uc2UucHJvdG90eXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2V0RG9jdW1lbnQgLSB0aGUgRmV0Y2ggQVBJIHdhcyBkaXNhYmxlZCBpbiBOb2RlLmpzLCBzZWUgYC0tbm8tZXhwZXJpbWVudGFsLWZldGNoYC5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIE5ldHdvcmtTdHJlYW0gPSBQREZGZXRjaFN0cmVhbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBOZXR3b3JrU3RyZWFtID0gUERGTm9kZVN0cmVhbTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgTmV0d29ya1N0cmVhbSA9IGlzVmFsaWRGZXRjaFVybCh1cmwpID8gUERGRmV0Y2hTdHJlYW0gOiBQREZOZXR3b3JrU3RyZWFtO1xuICAgICAgfVxuICAgICAgbmV0d29ya1N0cmVhbSA9IG5ldyBOZXR3b3JrU3RyZWFtKHtcbiAgICAgICAgdXJsLFxuICAgICAgICBsZW5ndGgsXG4gICAgICAgIGh0dHBIZWFkZXJzLFxuICAgICAgICB3aXRoQ3JlZGVudGlhbHMsXG4gICAgICAgIHJhbmdlQ2h1bmtTaXplLFxuICAgICAgICBkaXNhYmxlUmFuZ2UsXG4gICAgICAgIGRpc2FibGVTdHJlYW1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gd29ya2VySWRQcm9taXNlLnRoZW4od29ya2VySWQgPT4ge1xuICAgICAgaWYgKHRhc2suZGVzdHJveWVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvYWRpbmcgYWJvcnRlZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh3b3JrZXIuZGVzdHJveWVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgbWVzc2FnZUhhbmRsZXIgPSBuZXcgTWVzc2FnZUhhbmRsZXIoZG9jSWQsIHdvcmtlcklkLCB3b3JrZXIucG9ydCk7XG4gICAgICBjb25zdCB0cmFuc3BvcnQgPSBuZXcgV29ya2VyVHJhbnNwb3J0KG1lc3NhZ2VIYW5kbGVyLCB0YXNrLCBuZXR3b3JrU3RyZWFtLCB0cmFuc3BvcnRQYXJhbXMsIHRyYW5zcG9ydEZhY3RvcnkpO1xuICAgICAgdGFzay5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgICAgbWVzc2FnZUhhbmRsZXIuc2VuZChcIlJlYWR5XCIsIG51bGwpO1xuICAgIH0pO1xuICB9KS5jYXRjaCh0YXNrLl9jYXBhYmlsaXR5LnJlamVjdCk7XG4gIHJldHVybiB0YXNrO1xufVxuZnVuY3Rpb24gZ2V0VXJsUHJvcCh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIFVSTCkge1xuICAgIHJldHVybiB2YWwuaHJlZjtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBuZXcgVVJMKHZhbCwgd2luZG93LmxvY2F0aW9uKS5ocmVmO1xuICB9IGNhdGNoIHtcbiAgICBpZiAoaXNOb2RlSlMgJiYgdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBQREYgdXJsIGRhdGE6IFwiICsgXCJlaXRoZXIgc3RyaW5nIG9yIFVSTC1vYmplY3QgaXMgZXhwZWN0ZWQgaW4gdGhlIHVybCBwcm9wZXJ0eS5cIik7XG59XG5mdW5jdGlvbiBnZXREYXRhUHJvcCh2YWwpIHtcbiAgaWYgKGlzTm9kZUpTICYmIHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgdmFsIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHByb3ZpZGUgYmluYXJ5IGRhdGEgYXMgYFVpbnQ4QXJyYXlgLCByYXRoZXIgdGhhbiBgQnVmZmVyYC5cIik7XG4gIH1cbiAgaWYgKHZhbCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgdmFsLmJ5dGVMZW5ndGggPT09IHZhbC5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gc3RyaW5nVG9CeXRlcyh2YWwpO1xuICB9XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKSB8fCB0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiICYmICFpc05hTih2YWw/Lmxlbmd0aCkpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFBERiBiaW5hcnkgZGF0YTogZWl0aGVyIFR5cGVkQXJyYXksIFwiICsgXCJzdHJpbmcsIG9yIGFycmF5LWxpa2Ugb2JqZWN0IGlzIGV4cGVjdGVkIGluIHRoZSBkYXRhIHByb3BlcnR5LlwiKTtcbn1cbmZ1bmN0aW9uIGlzUmVmUHJveHkocmVmKSB7XG4gIHJldHVybiB0eXBlb2YgcmVmID09PSBcIm9iamVjdFwiICYmIE51bWJlci5pc0ludGVnZXIocmVmPy5udW0pICYmIHJlZi5udW0gPj0gMCAmJiBOdW1iZXIuaXNJbnRlZ2VyKHJlZj8uZ2VuKSAmJiByZWYuZ2VuID49IDA7XG59XG5jbGFzcyBQREZEb2N1bWVudExvYWRpbmdUYXNrIHtcbiAgc3RhdGljICNkb2NJZCA9IDA7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2NhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSBudWxsO1xuICAgIHRoaXMuX3dvcmtlciA9IG51bGw7XG4gICAgdGhpcy5kb2NJZCA9IGBkJHtQREZEb2N1bWVudExvYWRpbmdUYXNrLiNkb2NJZCsrfWA7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLm9uUGFzc3dvcmQgPSBudWxsO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cbiAgZ2V0IHByb21pc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBhc3luYyBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuX3dvcmtlcj8ucG9ydCkge1xuICAgICAgICB0aGlzLl93b3JrZXIuX3BlbmRpbmdEZXN0cm95ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMuX3RyYW5zcG9ydD8uZGVzdHJveSgpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBpZiAodGhpcy5fd29ya2VyPy5wb3J0KSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl93b3JrZXIuX3BlbmRpbmdEZXN0cm95O1xuICAgICAgfVxuICAgICAgdGhyb3cgZXg7XG4gICAgfVxuICAgIHRoaXMuX3RyYW5zcG9ydCA9IG51bGw7XG4gICAgdGhpcy5fd29ya2VyPy5kZXN0cm95KCk7XG4gICAgdGhpcy5fd29ya2VyID0gbnVsbDtcbiAgfVxufVxuY2xhc3MgUERGRGF0YVJhbmdlVHJhbnNwb3J0IHtcbiAgY29uc3RydWN0b3IobGVuZ3RoLCBpbml0aWFsRGF0YSwgcHJvZ3Jlc3NpdmVEb25lID0gZmFsc2UsIGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lID0gbnVsbCkge1xuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIHRoaXMuaW5pdGlhbERhdGEgPSBpbml0aWFsRGF0YTtcbiAgICB0aGlzLnByb2dyZXNzaXZlRG9uZSA9IHByb2dyZXNzaXZlRG9uZTtcbiAgICB0aGlzLmNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lID0gY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWU7XG4gICAgdGhpcy5fcmFuZ2VMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9wcm9ncmVzc0xpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuX3Byb2dyZXNzaXZlUmVhZExpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuX3Byb2dyZXNzaXZlRG9uZUxpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICB9XG4gIGFkZFJhbmdlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICB0aGlzLl9yYW5nZUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuICBhZGRQcm9ncmVzc0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fcHJvZ3Jlc3NMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH1cbiAgYWRkUHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH1cbiAgYWRkUHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH1cbiAgb25EYXRhUmFuZ2UoYmVnaW4sIGNodW5rKSB7XG4gICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLl9yYW5nZUxpc3RlbmVycykge1xuICAgICAgbGlzdGVuZXIoYmVnaW4sIGNodW5rKTtcbiAgICB9XG4gIH1cbiAgb25EYXRhUHJvZ3Jlc3MobG9hZGVkLCB0b3RhbCkge1xuICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5wcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLl9wcm9ncmVzc0xpc3RlbmVycykge1xuICAgICAgICBsaXN0ZW5lcihsb2FkZWQsIHRvdGFsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBvbkRhdGFQcm9ncmVzc2l2ZVJlYWQoY2h1bmspIHtcbiAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5fcHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXJzKSB7XG4gICAgICAgIGxpc3RlbmVyKGNodW5rKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBvbkRhdGFQcm9ncmVzc2l2ZURvbmUoKSB7XG4gICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuX3Byb2dyZXNzaXZlRG9uZUxpc3RlbmVycykge1xuICAgICAgICBsaXN0ZW5lcigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHRyYW5zcG9ydFJlYWR5KCkge1xuICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gIH1cbiAgcmVxdWVzdERhdGFSYW5nZShiZWdpbiwgZW5kKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBtZXRob2QgUERGRGF0YVJhbmdlVHJhbnNwb3J0LnJlcXVlc3REYXRhUmFuZ2VcIik7XG4gIH1cbiAgYWJvcnQoKSB7fVxufVxuY2xhc3MgUERGRG9jdW1lbnRQcm94eSB7XG4gIGNvbnN0cnVjdG9yKHBkZkluZm8sIHRyYW5zcG9ydCkge1xuICAgIHRoaXMuX3BkZkluZm8gPSBwZGZJbmZvO1xuICAgIHRoaXMuX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgfVxuICBnZXQgYW5ub3RhdGlvblN0b3JhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgfVxuICBnZXQgY2FudmFzRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmNhbnZhc0ZhY3Rvcnk7XG4gIH1cbiAgZ2V0IGZpbHRlckZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5maWx0ZXJGYWN0b3J5O1xuICB9XG4gIGdldCBudW1QYWdlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGRmSW5mby5udW1QYWdlcztcbiAgfVxuICBnZXQgZmluZ2VycHJpbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9wZGZJbmZvLmZpbmdlcnByaW50cztcbiAgfVxuICBnZXQgaXNQdXJlWGZhKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc1B1cmVYZmFcIiwgISF0aGlzLl90cmFuc3BvcnQuX2h0bWxGb3JYZmEpO1xuICB9XG4gIGdldCBhbGxYZmFIdG1sKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuX2h0bWxGb3JYZmE7XG4gIH1cbiAgZ2V0UGFnZShwYWdlTnVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlKHBhZ2VOdW1iZXIpO1xuICB9XG4gIGdldFBhZ2VJbmRleChyZWYpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2VJbmRleChyZWYpO1xuICB9XG4gIGdldERlc3RpbmF0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldERlc3RpbmF0aW9ucygpO1xuICB9XG4gIGdldERlc3RpbmF0aW9uKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXREZXN0aW5hdGlvbihpZCk7XG4gIH1cbiAgZ2V0UGFnZUxhYmVscygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2VMYWJlbHMoKTtcbiAgfVxuICBnZXRQYWdlTGF5b3V0KCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZUxheW91dCgpO1xuICB9XG4gIGdldFBhZ2VNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZU1vZGUoKTtcbiAgfVxuICBnZXRWaWV3ZXJQcmVmZXJlbmNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFZpZXdlclByZWZlcmVuY2VzKCk7XG4gIH1cbiAgZ2V0T3BlbkFjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldE9wZW5BY3Rpb24oKTtcbiAgfVxuICBnZXRBdHRhY2htZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldEF0dGFjaG1lbnRzKCk7XG4gIH1cbiAgZ2V0SlNBY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0RG9jSlNBY3Rpb25zKCk7XG4gIH1cbiAgZ2V0T3V0bGluZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldE91dGxpbmUoKTtcbiAgfVxuICBnZXRPcHRpb25hbENvbnRlbnRDb25maWcoe1xuICAgIGludGVudCA9IFwiZGlzcGxheVwiXG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlbmRlcmluZ0ludGVudFxuICAgIH0gPSB0aGlzLl90cmFuc3BvcnQuZ2V0UmVuZGVyaW5nSW50ZW50KGludGVudCk7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRPcHRpb25hbENvbnRlbnRDb25maWcocmVuZGVyaW5nSW50ZW50KTtcbiAgfVxuICBnZXRQZXJtaXNzaW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBlcm1pc3Npb25zKCk7XG4gIH1cbiAgZ2V0TWV0YWRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRNZXRhZGF0YSgpO1xuICB9XG4gIGdldE1hcmtJbmZvKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0TWFya0luZm8oKTtcbiAgfVxuICBnZXREYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0RGF0YSgpO1xuICB9XG4gIHNhdmVEb2N1bWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LnNhdmVEb2N1bWVudCgpO1xuICB9XG4gIGdldERvd25sb2FkSW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmRvd25sb2FkSW5mb0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjbGVhbnVwKGtlZXBMb2FkZWRGb250cyA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5zdGFydENsZWFudXAoa2VlcExvYWRlZEZvbnRzIHx8IHRoaXMuaXNQdXJlWGZhKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHJldHVybiB0aGlzLmxvYWRpbmdUYXNrLmRlc3Ryb3koKTtcbiAgfVxuICBjYWNoZWRQYWdlTnVtYmVyKHJlZikge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuY2FjaGVkUGFnZU51bWJlcihyZWYpO1xuICB9XG4gIGdldCBsb2FkaW5nUGFyYW1zKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQubG9hZGluZ1BhcmFtcztcbiAgfVxuICBnZXQgbG9hZGluZ1Rhc2soKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5sb2FkaW5nVGFzaztcbiAgfVxuICBnZXRGaWVsZE9iamVjdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRGaWVsZE9iamVjdHMoKTtcbiAgfVxuICBoYXNKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5oYXNKU0FjdGlvbnMoKTtcbiAgfVxuICBnZXRDYWxjdWxhdGlvbk9yZGVySWRzKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0Q2FsY3VsYXRpb25PcmRlcklkcygpO1xuICB9XG59XG5jbGFzcyBQREZQYWdlUHJveHkge1xuICAjZGVsYXllZENsZWFudXBUaW1lb3V0ID0gbnVsbDtcbiAgI3BlbmRpbmdDbGVhbnVwID0gZmFsc2U7XG4gIGNvbnN0cnVjdG9yKHBhZ2VJbmRleCwgcGFnZUluZm8sIHRyYW5zcG9ydCwgcGRmQnVnID0gZmFsc2UpIHtcbiAgICB0aGlzLl9wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgdGhpcy5fcGFnZUluZm8gPSBwYWdlSW5mbztcbiAgICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgdGhpcy5fc3RhdHMgPSBwZGZCdWcgPyBuZXcgU3RhdFRpbWVyKCkgOiBudWxsO1xuICAgIHRoaXMuX3BkZkJ1ZyA9IHBkZkJ1ZztcbiAgICB0aGlzLmNvbW1vbk9ianMgPSB0cmFuc3BvcnQuY29tbW9uT2JqcztcbiAgICB0aGlzLm9ianMgPSBuZXcgUERGT2JqZWN0cygpO1xuICAgIHRoaXMuX21heWJlQ2xlYW51cEFmdGVyUmVuZGVyID0gZmFsc2U7XG4gICAgdGhpcy5faW50ZW50U3RhdGVzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gIH1cbiAgZ2V0IHBhZ2VOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmRleCArIDE7XG4gIH1cbiAgZ2V0IHJvdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUluZm8ucm90YXRlO1xuICB9XG4gIGdldCByZWYoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmZvLnJlZjtcbiAgfVxuICBnZXQgdXNlclVuaXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmZvLnVzZXJVbml0O1xuICB9XG4gIGdldCB2aWV3KCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlSW5mby52aWV3O1xuICB9XG4gIGdldFZpZXdwb3J0KHtcbiAgICBzY2FsZSxcbiAgICByb3RhdGlvbiA9IHRoaXMucm90YXRlLFxuICAgIG9mZnNldFggPSAwLFxuICAgIG9mZnNldFkgPSAwLFxuICAgIGRvbnRGbGlwID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBQYWdlVmlld3BvcnQoe1xuICAgICAgdmlld0JveDogdGhpcy52aWV3LFxuICAgICAgc2NhbGUsXG4gICAgICByb3RhdGlvbixcbiAgICAgIG9mZnNldFgsXG4gICAgICBvZmZzZXRZLFxuICAgICAgZG9udEZsaXBcbiAgICB9KTtcbiAgfVxuICBnZXRBbm5vdGF0aW9ucyh7XG4gICAgaW50ZW50ID0gXCJkaXNwbGF5XCJcbiAgfSA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVuZGVyaW5nSW50ZW50XG4gICAgfSA9IHRoaXMuX3RyYW5zcG9ydC5nZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50KTtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldEFubm90YXRpb25zKHRoaXMuX3BhZ2VJbmRleCwgcmVuZGVyaW5nSW50ZW50KTtcbiAgfVxuICBnZXRKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlSlNBY3Rpb25zKHRoaXMuX3BhZ2VJbmRleCk7XG4gIH1cbiAgZ2V0IGZpbHRlckZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5maWx0ZXJGYWN0b3J5O1xuICB9XG4gIGdldCBpc1B1cmVYZmEoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzUHVyZVhmYVwiLCAhIXRoaXMuX3RyYW5zcG9ydC5faHRtbEZvclhmYSk7XG4gIH1cbiAgYXN5bmMgZ2V0WGZhKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuX2h0bWxGb3JYZmE/LmNoaWxkcmVuW3RoaXMuX3BhZ2VJbmRleF0gfHwgbnVsbDtcbiAgfVxuICByZW5kZXIoe1xuICAgIGNhbnZhc0NvbnRleHQsXG4gICAgdmlld3BvcnQsXG4gICAgaW50ZW50ID0gXCJkaXNwbGF5XCIsXG4gICAgYW5ub3RhdGlvbk1vZGUgPSBBbm5vdGF0aW9uTW9kZS5FTkFCTEUsXG4gICAgdHJhbnNmb3JtID0gbnVsbCxcbiAgICBiYWNrZ3JvdW5kID0gbnVsbCxcbiAgICBvcHRpb25hbENvbnRlbnRDb25maWdQcm9taXNlID0gbnVsbCxcbiAgICBhbm5vdGF0aW9uQ2FudmFzTWFwID0gbnVsbCxcbiAgICBwYWdlQ29sb3JzID0gbnVsbCxcbiAgICBwcmludEFubm90YXRpb25TdG9yYWdlID0gbnVsbCxcbiAgICBpc0VkaXRpbmcgPSBmYWxzZVxuICB9KSB7XG4gICAgdGhpcy5fc3RhdHM/LnRpbWUoXCJPdmVyYWxsXCIpO1xuICAgIGNvbnN0IGludGVudEFyZ3MgPSB0aGlzLl90cmFuc3BvcnQuZ2V0UmVuZGVyaW5nSW50ZW50KGludGVudCwgYW5ub3RhdGlvbk1vZGUsIHByaW50QW5ub3RhdGlvblN0b3JhZ2UsIGlzRWRpdGluZyk7XG4gICAgY29uc3Qge1xuICAgICAgcmVuZGVyaW5nSW50ZW50LFxuICAgICAgY2FjaGVLZXlcbiAgICB9ID0gaW50ZW50QXJncztcbiAgICB0aGlzLiNwZW5kaW5nQ2xlYW51cCA9IGZhbHNlO1xuICAgIHRoaXMuI2Fib3J0RGVsYXllZENsZWFudXAoKTtcbiAgICBvcHRpb25hbENvbnRlbnRDb25maWdQcm9taXNlIHx8PSB0aGlzLl90cmFuc3BvcnQuZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnKHJlbmRlcmluZ0ludGVudCk7XG4gICAgbGV0IGludGVudFN0YXRlID0gdGhpcy5faW50ZW50U3RhdGVzLmdldChjYWNoZUtleSk7XG4gICAgaWYgKCFpbnRlbnRTdGF0ZSkge1xuICAgICAgaW50ZW50U3RhdGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5faW50ZW50U3RhdGVzLnNldChjYWNoZUtleSwgaW50ZW50U3RhdGUpO1xuICAgIH1cbiAgICBpZiAoaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQpO1xuICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGludGVudFByaW50ID0gISEocmVuZGVyaW5nSW50ZW50ICYgUmVuZGVyaW5nSW50ZW50RmxhZy5QUklOVCk7XG4gICAgaWYgKCFpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5KSB7XG4gICAgICBpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QgPSB7XG4gICAgICAgIGZuQXJyYXk6IFtdLFxuICAgICAgICBhcmdzQXJyYXk6IFtdLFxuICAgICAgICBsYXN0Q2h1bms6IGZhbHNlLFxuICAgICAgICBzZXBhcmF0ZUFubm90czogbnVsbFxuICAgICAgfTtcbiAgICAgIHRoaXMuX3N0YXRzPy50aW1lKFwiUGFnZSBSZXF1ZXN0XCIpO1xuICAgICAgdGhpcy5fcHVtcE9wZXJhdG9yTGlzdChpbnRlbnRBcmdzKTtcbiAgICB9XG4gICAgY29uc3QgY29tcGxldGUgPSBlcnJvciA9PiB7XG4gICAgICBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcy5kZWxldGUoaW50ZXJuYWxSZW5kZXJUYXNrKTtcbiAgICAgIGlmICh0aGlzLl9tYXliZUNsZWFudXBBZnRlclJlbmRlciB8fCBpbnRlbnRQcmludCkge1xuICAgICAgICB0aGlzLiNwZW5kaW5nQ2xlYW51cCA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLiN0cnlDbGVhbnVwKCFpbnRlbnRQcmludCk7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLmNhcGFiaWxpdHkucmVqZWN0KGVycm9yKTtcbiAgICAgICAgdGhpcy5fYWJvcnRPcGVyYXRvckxpc3Qoe1xuICAgICAgICAgIGludGVudFN0YXRlLFxuICAgICAgICAgIHJlYXNvbjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKGVycm9yKVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVybmFsUmVuZGVyVGFzay5jYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9zdGF0cykge1xuICAgICAgICB0aGlzLl9zdGF0cy50aW1lRW5kKFwiUmVuZGVyaW5nXCIpO1xuICAgICAgICB0aGlzLl9zdGF0cy50aW1lRW5kKFwiT3ZlcmFsbFwiKTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuU3RhdHM/LmVuYWJsZWQpIHtcbiAgICAgICAgICBnbG9iYWxUaGlzLlN0YXRzLmFkZCh0aGlzLnBhZ2VOdW1iZXIsIHRoaXMuX3N0YXRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaW50ZXJuYWxSZW5kZXJUYXNrID0gbmV3IEludGVybmFsUmVuZGVyVGFzayh7XG4gICAgICBjYWxsYmFjazogY29tcGxldGUsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgY2FudmFzQ29udGV4dCxcbiAgICAgICAgdmlld3BvcnQsXG4gICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgYmFja2dyb3VuZFxuICAgICAgfSxcbiAgICAgIG9ianM6IHRoaXMub2JqcyxcbiAgICAgIGNvbW1vbk9ianM6IHRoaXMuY29tbW9uT2JqcyxcbiAgICAgIGFubm90YXRpb25DYW52YXNNYXAsXG4gICAgICBvcGVyYXRvckxpc3Q6IGludGVudFN0YXRlLm9wZXJhdG9yTGlzdCxcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5fcGFnZUluZGV4LFxuICAgICAgY2FudmFzRmFjdG9yeTogdGhpcy5fdHJhbnNwb3J0LmNhbnZhc0ZhY3RvcnksXG4gICAgICBmaWx0ZXJGYWN0b3J5OiB0aGlzLl90cmFuc3BvcnQuZmlsdGVyRmFjdG9yeSxcbiAgICAgIHVzZVJlcXVlc3RBbmltYXRpb25GcmFtZTogIWludGVudFByaW50LFxuICAgICAgcGRmQnVnOiB0aGlzLl9wZGZCdWcsXG4gICAgICBwYWdlQ29sb3JzXG4gICAgfSk7XG4gICAgKGludGVudFN0YXRlLnJlbmRlclRhc2tzIHx8PSBuZXcgU2V0KCkpLmFkZChpbnRlcm5hbFJlbmRlclRhc2spO1xuICAgIGNvbnN0IHJlbmRlclRhc2sgPSBpbnRlcm5hbFJlbmRlclRhc2sudGFzaztcbiAgICBQcm9taXNlLmFsbChbaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eS5wcm9taXNlLCBvcHRpb25hbENvbnRlbnRDb25maWdQcm9taXNlXSkudGhlbigoW3RyYW5zcGFyZW5jeSwgb3B0aW9uYWxDb250ZW50Q29uZmlnXSkgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0YXRzPy50aW1lKFwiUmVuZGVyaW5nXCIpO1xuICAgICAgaWYgKCEob3B0aW9uYWxDb250ZW50Q29uZmlnLnJlbmRlcmluZ0ludGVudCAmIHJlbmRlcmluZ0ludGVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCB1c2UgdGhlIHNhbWUgYGludGVudGAtYXJndW1lbnQgd2hlbiBjYWxsaW5nIHRoZSBgUERGUGFnZVByb3h5LnJlbmRlcmAgXCIgKyBcImFuZCBgUERGRG9jdW1lbnRQcm94eS5nZXRPcHRpb25hbENvbnRlbnRDb25maWdgIG1ldGhvZHMuXCIpO1xuICAgICAgfVxuICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLmluaXRpYWxpemVHcmFwaGljcyh7XG4gICAgICAgIHRyYW5zcGFyZW5jeSxcbiAgICAgICAgb3B0aW9uYWxDb250ZW50Q29uZmlnXG4gICAgICB9KTtcbiAgICAgIGludGVybmFsUmVuZGVyVGFzay5vcGVyYXRvckxpc3RDaGFuZ2VkKCk7XG4gICAgfSkuY2F0Y2goY29tcGxldGUpO1xuICAgIHJldHVybiByZW5kZXJUYXNrO1xuICB9XG4gIGdldE9wZXJhdG9yTGlzdCh7XG4gICAgaW50ZW50ID0gXCJkaXNwbGF5XCIsXG4gICAgYW5ub3RhdGlvbk1vZGUgPSBBbm5vdGF0aW9uTW9kZS5FTkFCTEUsXG4gICAgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSA9IG51bGwsXG4gICAgaXNFZGl0aW5nID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgZnVuY3Rpb24gb3BlcmF0b3JMaXN0Q2hhbmdlZCgpIHtcbiAgICAgIGlmIChpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QubGFzdENodW5rKSB7XG4gICAgICAgIGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5LnJlc29sdmUoaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0KTtcbiAgICAgICAgaW50ZW50U3RhdGUucmVuZGVyVGFza3MuZGVsZXRlKG9wTGlzdFRhc2spO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpbnRlbnRBcmdzID0gdGhpcy5fdHJhbnNwb3J0LmdldFJlbmRlcmluZ0ludGVudChpbnRlbnQsIGFubm90YXRpb25Nb2RlLCBwcmludEFubm90YXRpb25TdG9yYWdlLCBpc0VkaXRpbmcsIHRydWUpO1xuICAgIGxldCBpbnRlbnRTdGF0ZSA9IHRoaXMuX2ludGVudFN0YXRlcy5nZXQoaW50ZW50QXJncy5jYWNoZUtleSk7XG4gICAgaWYgKCFpbnRlbnRTdGF0ZSkge1xuICAgICAgaW50ZW50U3RhdGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5faW50ZW50U3RhdGVzLnNldChpbnRlbnRBcmdzLmNhY2hlS2V5LCBpbnRlbnRTdGF0ZSk7XG4gICAgfVxuICAgIGxldCBvcExpc3RUYXNrO1xuICAgIGlmICghaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkpIHtcbiAgICAgIG9wTGlzdFRhc2sgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgb3BMaXN0VGFzay5vcGVyYXRvckxpc3RDaGFuZ2VkID0gb3BlcmF0b3JMaXN0Q2hhbmdlZDtcbiAgICAgIGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgICAoaW50ZW50U3RhdGUucmVuZGVyVGFza3MgfHw9IG5ldyBTZXQoKSkuYWRkKG9wTGlzdFRhc2spO1xuICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0ID0ge1xuICAgICAgICBmbkFycmF5OiBbXSxcbiAgICAgICAgYXJnc0FycmF5OiBbXSxcbiAgICAgICAgbGFzdENodW5rOiBmYWxzZSxcbiAgICAgICAgc2VwYXJhdGVBbm5vdHM6IG51bGxcbiAgICAgIH07XG4gICAgICB0aGlzLl9zdGF0cz8udGltZShcIlBhZ2UgUmVxdWVzdFwiKTtcbiAgICAgIHRoaXMuX3B1bXBPcGVyYXRvckxpc3QoaW50ZW50QXJncyk7XG4gICAgfVxuICAgIHJldHVybiBpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIHN0cmVhbVRleHRDb250ZW50KHtcbiAgICBpbmNsdWRlTWFya2VkQ29udGVudCA9IGZhbHNlLFxuICAgIGRpc2FibGVOb3JtYWxpemF0aW9uID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgY29uc3QgVEVYVF9DT05URU5UX0NIVU5LX1NJWkUgPSAxMDA7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFN0cmVhbShcIkdldFRleHRDb250ZW50XCIsIHtcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5fcGFnZUluZGV4LFxuICAgICAgaW5jbHVkZU1hcmtlZENvbnRlbnQ6IGluY2x1ZGVNYXJrZWRDb250ZW50ID09PSB0cnVlLFxuICAgICAgZGlzYWJsZU5vcm1hbGl6YXRpb246IGRpc2FibGVOb3JtYWxpemF0aW9uID09PSB0cnVlXG4gICAgfSwge1xuICAgICAgaGlnaFdhdGVyTWFyazogVEVYVF9DT05URU5UX0NIVU5LX1NJWkUsXG4gICAgICBzaXplKHRleHRDb250ZW50KSB7XG4gICAgICAgIHJldHVybiB0ZXh0Q29udGVudC5pdGVtcy5sZW5ndGg7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0VGV4dENvbnRlbnQocGFyYW1zID0ge30pIHtcbiAgICBpZiAodGhpcy5fdHJhbnNwb3J0Ll9odG1sRm9yWGZhKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRYZmEoKS50aGVuKHhmYSA9PiBYZmFUZXh0LnRleHRDb250ZW50KHhmYSkpO1xuICAgIH1cbiAgICBjb25zdCByZWFkYWJsZVN0cmVhbSA9IHRoaXMuc3RyZWFtVGV4dENvbnRlbnQocGFyYW1zKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZnVuY3Rpb24gcHVtcCgpIHtcbiAgICAgICAgcmVhZGVyLnJlYWQoKS50aGVuKGZ1bmN0aW9uICh7XG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgZG9uZVxuICAgICAgICB9KSB7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHJlc29sdmUodGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0ZXh0Q29udGVudC5sYW5nID8/PSB2YWx1ZS5sYW5nO1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24odGV4dENvbnRlbnQuc3R5bGVzLCB2YWx1ZS5zdHlsZXMpO1xuICAgICAgICAgIHRleHRDb250ZW50Lml0ZW1zLnB1c2goLi4udmFsdWUuaXRlbXMpO1xuICAgICAgICAgIHB1bXAoKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlYWRlciA9IHJlYWRhYmxlU3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgY29uc3QgdGV4dENvbnRlbnQgPSB7XG4gICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgc3R5bGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICBsYW5nOiBudWxsXG4gICAgICB9O1xuICAgICAgcHVtcCgpO1xuICAgIH0pO1xuICB9XG4gIGdldFN0cnVjdFRyZWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRTdHJ1Y3RUcmVlKHRoaXMuX3BhZ2VJbmRleCk7XG4gIH1cbiAgX2Rlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIGNvbnN0IHdhaXRPbiA9IFtdO1xuICAgIGZvciAoY29uc3QgaW50ZW50U3RhdGUgb2YgdGhpcy5faW50ZW50U3RhdGVzLnZhbHVlcygpKSB7XG4gICAgICB0aGlzLl9hYm9ydE9wZXJhdG9yTGlzdCh7XG4gICAgICAgIGludGVudFN0YXRlLFxuICAgICAgICByZWFzb246IG5ldyBFcnJvcihcIlBhZ2Ugd2FzIGRlc3Ryb3llZC5cIiksXG4gICAgICAgIGZvcmNlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGlmIChpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgaW50ZXJuYWxSZW5kZXJUYXNrIG9mIGludGVudFN0YXRlLnJlbmRlclRhc2tzKSB7XG4gICAgICAgIHdhaXRPbi5wdXNoKGludGVybmFsUmVuZGVyVGFzay5jb21wbGV0ZWQpO1xuICAgICAgICBpbnRlcm5hbFJlbmRlclRhc2suY2FuY2VsKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMub2Jqcy5jbGVhcigpO1xuICAgIHRoaXMuI3BlbmRpbmdDbGVhbnVwID0gZmFsc2U7XG4gICAgdGhpcy4jYWJvcnREZWxheWVkQ2xlYW51cCgpO1xuICAgIHJldHVybiBQcm9taXNlLmFsbCh3YWl0T24pO1xuICB9XG4gIGNsZWFudXAocmVzZXRTdGF0cyA9IGZhbHNlKSB7XG4gICAgdGhpcy4jcGVuZGluZ0NsZWFudXAgPSB0cnVlO1xuICAgIGNvbnN0IHN1Y2Nlc3MgPSB0aGlzLiN0cnlDbGVhbnVwKGZhbHNlKTtcbiAgICBpZiAocmVzZXRTdGF0cyAmJiBzdWNjZXNzKSB7XG4gICAgICB0aGlzLl9zdGF0cyAmJj0gbmV3IFN0YXRUaW1lcigpO1xuICAgIH1cbiAgICByZXR1cm4gc3VjY2VzcztcbiAgfVxuICAjdHJ5Q2xlYW51cChkZWxheWVkID0gZmFsc2UpIHtcbiAgICB0aGlzLiNhYm9ydERlbGF5ZWRDbGVhbnVwKCk7XG4gICAgaWYgKCF0aGlzLiNwZW5kaW5nQ2xlYW51cCB8fCB0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZGVsYXllZCkge1xuICAgICAgdGhpcy4jZGVsYXllZENsZWFudXBUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuI2RlbGF5ZWRDbGVhbnVwVGltZW91dCA9IG51bGw7XG4gICAgICAgIHRoaXMuI3RyeUNsZWFudXAoZmFsc2UpO1xuICAgICAgfSwgREVMQVlFRF9DTEVBTlVQX1RJTUVPVVQpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIHJlbmRlclRhc2tzLFxuICAgICAgb3BlcmF0b3JMaXN0XG4gICAgfSBvZiB0aGlzLl9pbnRlbnRTdGF0ZXMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChyZW5kZXJUYXNrcy5zaXplID4gMCB8fCAhb3BlcmF0b3JMaXN0Lmxhc3RDaHVuaykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2ludGVudFN0YXRlcy5jbGVhcigpO1xuICAgIHRoaXMub2Jqcy5jbGVhcigpO1xuICAgIHRoaXMuI3BlbmRpbmdDbGVhbnVwID0gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgI2Fib3J0RGVsYXllZENsZWFudXAoKSB7XG4gICAgaWYgKHRoaXMuI2RlbGF5ZWRDbGVhbnVwVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2RlbGF5ZWRDbGVhbnVwVGltZW91dCk7XG4gICAgICB0aGlzLiNkZWxheWVkQ2xlYW51cFRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgfVxuICBfc3RhcnRSZW5kZXJQYWdlKHRyYW5zcGFyZW5jeSwgY2FjaGVLZXkpIHtcbiAgICBjb25zdCBpbnRlbnRTdGF0ZSA9IHRoaXMuX2ludGVudFN0YXRlcy5nZXQoY2FjaGVLZXkpO1xuICAgIGlmICghaW50ZW50U3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fc3RhdHM/LnRpbWVFbmQoXCJQYWdlIFJlcXVlc3RcIik7XG4gICAgaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eT8ucmVzb2x2ZSh0cmFuc3BhcmVuY3kpO1xuICB9XG4gIF9yZW5kZXJQYWdlQ2h1bmsob3BlcmF0b3JMaXN0Q2h1bmssIGludGVudFN0YXRlKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gb3BlcmF0b3JMaXN0Q2h1bmsubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0LmZuQXJyYXkucHVzaChvcGVyYXRvckxpc3RDaHVuay5mbkFycmF5W2ldKTtcbiAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5hcmdzQXJyYXkucHVzaChvcGVyYXRvckxpc3RDaHVuay5hcmdzQXJyYXlbaV0pO1xuICAgIH1cbiAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QubGFzdENodW5rID0gb3BlcmF0b3JMaXN0Q2h1bmsubGFzdENodW5rO1xuICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5zZXBhcmF0ZUFubm90cyA9IG9wZXJhdG9yTGlzdENodW5rLnNlcGFyYXRlQW5ub3RzO1xuICAgIGZvciAoY29uc3QgaW50ZXJuYWxSZW5kZXJUYXNrIG9mIGludGVudFN0YXRlLnJlbmRlclRhc2tzKSB7XG4gICAgICBpbnRlcm5hbFJlbmRlclRhc2sub3BlcmF0b3JMaXN0Q2hhbmdlZCgpO1xuICAgIH1cbiAgICBpZiAob3BlcmF0b3JMaXN0Q2h1bmsubGFzdENodW5rKSB7XG4gICAgICB0aGlzLiN0cnlDbGVhbnVwKHRydWUpO1xuICAgIH1cbiAgfVxuICBfcHVtcE9wZXJhdG9yTGlzdCh7XG4gICAgcmVuZGVyaW5nSW50ZW50LFxuICAgIGNhY2hlS2V5LFxuICAgIGFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlLFxuICAgIG1vZGlmaWVkSWRzXG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICBtYXAsXG4gICAgICB0cmFuc2ZlclxuICAgIH0gPSBhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZTtcbiAgICBjb25zdCByZWFkYWJsZVN0cmVhbSA9IHRoaXMuX3RyYW5zcG9ydC5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFN0cmVhbShcIkdldE9wZXJhdG9yTGlzdFwiLCB7XG4gICAgICBwYWdlSW5kZXg6IHRoaXMuX3BhZ2VJbmRleCxcbiAgICAgIGludGVudDogcmVuZGVyaW5nSW50ZW50LFxuICAgICAgY2FjaGVLZXksXG4gICAgICBhbm5vdGF0aW9uU3RvcmFnZTogbWFwLFxuICAgICAgbW9kaWZpZWRJZHNcbiAgICB9LCB0cmFuc2Zlcik7XG4gICAgY29uc3QgcmVhZGVyID0gcmVhZGFibGVTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgY29uc3QgaW50ZW50U3RhdGUgPSB0aGlzLl9pbnRlbnRTdGF0ZXMuZ2V0KGNhY2hlS2V5KTtcbiAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIgPSByZWFkZXI7XG4gICAgY29uc3QgcHVtcCA9ICgpID0+IHtcbiAgICAgIHJlYWRlci5yZWFkKCkudGhlbigoe1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZG9uZVxuICAgICAgfSkgPT4ge1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlciA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl90cmFuc3BvcnQuZGVzdHJveWVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlbmRlclBhZ2VDaHVuayh2YWx1ZSwgaW50ZW50U3RhdGUpO1xuICAgICAgICBwdW1wKCk7XG4gICAgICB9LCByZWFzb24gPT4ge1xuICAgICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fdHJhbnNwb3J0LmRlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0KSB7XG4gICAgICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0Lmxhc3RDaHVuayA9IHRydWU7XG4gICAgICAgICAgZm9yIChjb25zdCBpbnRlcm5hbFJlbmRlclRhc2sgb2YgaW50ZW50U3RhdGUucmVuZGVyVGFza3MpIHtcbiAgICAgICAgICAgIGludGVybmFsUmVuZGVyVGFzay5vcGVyYXRvckxpc3RDaGFuZ2VkKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuI3RyeUNsZWFudXAodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkpIHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5LnJlamVjdChyZWFzb24pO1xuICAgICAgICB9IGVsc2UgaWYgKGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5KSB7XG4gICAgICAgICAgaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkucmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgcmVhc29uO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHB1bXAoKTtcbiAgfVxuICBfYWJvcnRPcGVyYXRvckxpc3Qoe1xuICAgIGludGVudFN0YXRlLFxuICAgIHJlYXNvbixcbiAgICBmb3JjZSA9IGZhbHNlXG4gIH0pIHtcbiAgICBpZiAoIWludGVudFN0YXRlLnN0cmVhbVJlYWRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQpO1xuICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIGlmICghZm9yY2UpIHtcbiAgICAgIGlmIChpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcy5zaXplID4gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocmVhc29uIGluc3RhbmNlb2YgUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uKSB7XG4gICAgICAgIGxldCBkZWxheSA9IFJFTkRFUklOR19DQU5DRUxMRURfVElNRU9VVDtcbiAgICAgICAgaWYgKHJlYXNvbi5leHRyYURlbGF5ID4gMCAmJiByZWFzb24uZXh0cmFEZWxheSA8IDEwMDApIHtcbiAgICAgICAgICBkZWxheSArPSByZWFzb24uZXh0cmFEZWxheTtcbiAgICAgICAgfVxuICAgICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fYWJvcnRPcGVyYXRvckxpc3Qoe1xuICAgICAgICAgICAgaW50ZW50U3RhdGUsXG4gICAgICAgICAgICByZWFzb24sXG4gICAgICAgICAgICBmb3JjZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyLmNhbmNlbChuZXcgQWJvcnRFeGNlcHRpb24ocmVhc29uLm1lc3NhZ2UpKS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyID0gbnVsbDtcbiAgICBpZiAodGhpcy5fdHJhbnNwb3J0LmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtjdXJDYWNoZUtleSwgY3VySW50ZW50U3RhdGVdIG9mIHRoaXMuX2ludGVudFN0YXRlcykge1xuICAgICAgaWYgKGN1ckludGVudFN0YXRlID09PSBpbnRlbnRTdGF0ZSkge1xuICAgICAgICB0aGlzLl9pbnRlbnRTdGF0ZXMuZGVsZXRlKGN1ckNhY2hlS2V5KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY2xlYW51cCgpO1xuICB9XG4gIGdldCBzdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdHM7XG4gIH1cbn1cbmNsYXNzIExvb3BiYWNrUG9ydCB7XG4gICNsaXN0ZW5lcnMgPSBuZXcgTWFwKCk7XG4gICNkZWZlcnJlZCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICBwb3N0TWVzc2FnZShvYmosIHRyYW5zZmVyKSB7XG4gICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICBkYXRhOiBzdHJ1Y3R1cmVkQ2xvbmUob2JqLCB0cmFuc2ZlciA/IHtcbiAgICAgICAgdHJhbnNmZXJcbiAgICAgIH0gOiBudWxsKVxuICAgIH07XG4gICAgdGhpcy4jZGVmZXJyZWQudGhlbigoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IFtsaXN0ZW5lcl0gb2YgdGhpcy4jbGlzdGVuZXJzKSB7XG4gICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFkZEV2ZW50TGlzdGVuZXIobmFtZSwgbGlzdGVuZXIsIG9wdGlvbnMgPSBudWxsKSB7XG4gICAgbGV0IHJtQWJvcnQgPSBudWxsO1xuICAgIGlmIChvcHRpb25zPy5zaWduYWwgaW5zdGFuY2VvZiBBYm9ydFNpZ25hbCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHdhcm4oXCJMb29wYmFja1BvcnQgLSBjYW5ub3QgdXNlIGFuIGBhYm9ydGVkYCBzaWduYWwuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBvbkFib3J0ID0gKCkgPT4gdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGxpc3RlbmVyKTtcbiAgICAgIHJtQWJvcnQgPSAoKSA9PiBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQWJvcnQpO1xuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgICB9XG4gICAgdGhpcy4jbGlzdGVuZXJzLnNldChsaXN0ZW5lciwgcm1BYm9ydCk7XG4gIH1cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IHJtQWJvcnQgPSB0aGlzLiNsaXN0ZW5lcnMuZ2V0KGxpc3RlbmVyKTtcbiAgICBybUFib3J0Py4oKTtcbiAgICB0aGlzLiNsaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgfVxuICB0ZXJtaW5hdGUoKSB7XG4gICAgZm9yIChjb25zdCBbLCBybUFib3J0XSBvZiB0aGlzLiNsaXN0ZW5lcnMpIHtcbiAgICAgIHJtQWJvcnQ/LigpO1xuICAgIH1cbiAgICB0aGlzLiNsaXN0ZW5lcnMuY2xlYXIoKTtcbiAgfVxufVxuY2xhc3MgUERGV29ya2VyIHtcbiAgc3RhdGljICNmYWtlV29ya2VySWQgPSAwO1xuICBzdGF0aWMgI2lzV29ya2VyRGlzYWJsZWQgPSBmYWxzZTtcbiAgc3RhdGljICN3b3JrZXJQb3J0cztcbiAgc3RhdGljIHtcbiAgICBpZiAoaXNOb2RlSlMpIHtcbiAgICAgIHRoaXMuI2lzV29ya2VyRGlzYWJsZWQgPSB0cnVlO1xuICAgICAgR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmMgfHw9IFwiLi9wZGYud29ya2VyLm1qc1wiO1xuICAgIH1cbiAgICB0aGlzLl9pc1NhbWVPcmlnaW4gPSAoYmFzZVVybCwgb3RoZXJVcmwpID0+IHtcbiAgICAgIGxldCBiYXNlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYmFzZSA9IG5ldyBVUkwoYmFzZVVybCk7XG4gICAgICAgIGlmICghYmFzZS5vcmlnaW4gfHwgYmFzZS5vcmlnaW4gPT09IFwibnVsbFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3RoZXIgPSBuZXcgVVJMKG90aGVyVXJsLCBiYXNlKTtcbiAgICAgIHJldHVybiBiYXNlLm9yaWdpbiA9PT0gb3RoZXIub3JpZ2luO1xuICAgIH07XG4gICAgdGhpcy5fY3JlYXRlQ0ROV3JhcHBlciA9IHVybCA9PiB7XG4gICAgICBjb25zdCB3cmFwcGVyID0gYGF3YWl0IGltcG9ydChcIiR7dXJsfVwiKTtgO1xuICAgICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW3dyYXBwZXJdLCB7XG4gICAgICAgIHR5cGU6IFwidGV4dC9qYXZhc2NyaXB0XCJcbiAgICAgIH0pKTtcbiAgICB9O1xuICB9XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBuYW1lID0gbnVsbCxcbiAgICBwb3J0ID0gbnVsbCxcbiAgICB2ZXJib3NpdHkgPSBnZXRWZXJib3NpdHlMZXZlbCgpXG4gIH0gPSB7fSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnZlcmJvc2l0eSA9IHZlcmJvc2l0eTtcbiAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLl9wb3J0ID0gbnVsbDtcbiAgICB0aGlzLl93ZWJXb3JrZXIgPSBudWxsO1xuICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbnVsbDtcbiAgICBpZiAocG9ydCkge1xuICAgICAgaWYgKFBERldvcmtlci4jd29ya2VyUG9ydHM/Lmhhcyhwb3J0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXNlIG1vcmUgdGhhbiBvbmUgUERGV29ya2VyIHBlciBwb3J0LlwiKTtcbiAgICAgIH1cbiAgICAgIChQREZXb3JrZXIuI3dvcmtlclBvcnRzIHx8PSBuZXcgV2Vha01hcCgpKS5zZXQocG9ydCwgdGhpcyk7XG4gICAgICB0aGlzLl9pbml0aWFsaXplRnJvbVBvcnQocG9ydCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2luaXRpYWxpemUoKTtcbiAgfVxuICBnZXQgcHJvbWlzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgI3Jlc29sdmUoKSB7XG4gICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB0aGlzLl9tZXNzYWdlSGFuZGxlci5zZW5kKFwiY29uZmlndXJlXCIsIHtcbiAgICAgIHZlcmJvc2l0eTogdGhpcy52ZXJib3NpdHlcbiAgICB9KTtcbiAgfVxuICBnZXQgcG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9ydDtcbiAgfVxuICBnZXQgbWVzc2FnZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lc3NhZ2VIYW5kbGVyO1xuICB9XG4gIF9pbml0aWFsaXplRnJvbVBvcnQocG9ydCkge1xuICAgIHRoaXMuX3BvcnQgPSBwb3J0O1xuICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbmV3IE1lc3NhZ2VIYW5kbGVyKFwibWFpblwiLCBcIndvcmtlclwiLCBwb3J0KTtcbiAgICB0aGlzLl9tZXNzYWdlSGFuZGxlci5vbihcInJlYWR5XCIsIGZ1bmN0aW9uICgpIHt9KTtcbiAgICB0aGlzLiNyZXNvbHZlKCk7XG4gIH1cbiAgX2luaXRpYWxpemUoKSB7XG4gICAgaWYgKFBERldvcmtlci4jaXNXb3JrZXJEaXNhYmxlZCB8fCBQREZXb3JrZXIuI21haW5UaHJlYWRXb3JrZXJNZXNzYWdlSGFuZGxlcikge1xuICAgICAgdGhpcy5fc2V0dXBGYWtlV29ya2VyKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB7XG4gICAgICB3b3JrZXJTcmNcbiAgICB9ID0gUERGV29ya2VyO1xuICAgIHRyeSB7XG4gICAgICBpZiAoIVBERldvcmtlci5faXNTYW1lT3JpZ2luKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCB3b3JrZXJTcmMpKSB7XG4gICAgICAgIHdvcmtlclNyYyA9IFBERldvcmtlci5fY3JlYXRlQ0ROV3JhcHBlcihuZXcgVVJMKHdvcmtlclNyYywgd2luZG93LmxvY2F0aW9uKS5ocmVmKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyU3JjLCB7XG4gICAgICAgIHR5cGU6IFwibW9kdWxlXCJcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbWVzc2FnZUhhbmRsZXIgPSBuZXcgTWVzc2FnZUhhbmRsZXIoXCJtYWluXCIsIFwid29ya2VyXCIsIHdvcmtlcik7XG4gICAgICBjb25zdCB0ZXJtaW5hdGVFYXJseSA9ICgpID0+IHtcbiAgICAgICAgYWMuYWJvcnQoKTtcbiAgICAgICAgbWVzc2FnZUhhbmRsZXIuZGVzdHJveSgpO1xuICAgICAgICB3b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5yZWplY3QobmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWRcIikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3NldHVwRmFrZVdvcmtlcigpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsICgpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLl93ZWJXb3JrZXIpIHtcbiAgICAgICAgICB0ZXJtaW5hdGVFYXJseSgpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIHNpZ25hbDogYWMuc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwidGVzdFwiLCBkYXRhID0+IHtcbiAgICAgICAgYWMuYWJvcnQoKTtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkIHx8ICFkYXRhKSB7XG4gICAgICAgICAgdGVybWluYXRlRWFybHkoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIgPSBtZXNzYWdlSGFuZGxlcjtcbiAgICAgICAgdGhpcy5fcG9ydCA9IHdvcmtlcjtcbiAgICAgICAgdGhpcy5fd2ViV29ya2VyID0gd29ya2VyO1xuICAgICAgICB0aGlzLiNyZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwicmVhZHlcIiwgZGF0YSA9PiB7XG4gICAgICAgIGFjLmFib3J0KCk7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgIHRlcm1pbmF0ZUVhcmx5KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2VuZFRlc3QoKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgdGhpcy5fc2V0dXBGYWtlV29ya2VyKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3Qgc2VuZFRlc3QgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRlc3RPYmogPSBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlSGFuZGxlci5zZW5kKFwidGVzdFwiLCB0ZXN0T2JqLCBbdGVzdE9iai5idWZmZXJdKTtcbiAgICAgIH07XG4gICAgICBzZW5kVGVzdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gY2F0Y2gge1xuICAgICAgaW5mbyhcIlRoZSB3b3JrZXIgaGFzIGJlZW4gZGlzYWJsZWQuXCIpO1xuICAgIH1cbiAgICB0aGlzLl9zZXR1cEZha2VXb3JrZXIoKTtcbiAgfVxuICBfc2V0dXBGYWtlV29ya2VyKCkge1xuICAgIGlmICghUERGV29ya2VyLiNpc1dvcmtlckRpc2FibGVkKSB7XG4gICAgICB3YXJuKFwiU2V0dGluZyB1cCBmYWtlIHdvcmtlci5cIik7XG4gICAgICBQREZXb3JrZXIuI2lzV29ya2VyRGlzYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBQREZXb3JrZXIuX3NldHVwRmFrZVdvcmtlckdsb2JhbC50aGVuKFdvcmtlck1lc3NhZ2VIYW5kbGVyID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucmVqZWN0KG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkXCIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcG9ydCA9IG5ldyBMb29wYmFja1BvcnQoKTtcbiAgICAgIHRoaXMuX3BvcnQgPSBwb3J0O1xuICAgICAgY29uc3QgaWQgPSBgZmFrZSR7UERGV29ya2VyLiNmYWtlV29ya2VySWQrK31gO1xuICAgICAgY29uc3Qgd29ya2VySGFuZGxlciA9IG5ldyBNZXNzYWdlSGFuZGxlcihpZCArIFwiX3dvcmtlclwiLCBpZCwgcG9ydCk7XG4gICAgICBXb3JrZXJNZXNzYWdlSGFuZGxlci5zZXR1cCh3b3JrZXJIYW5kbGVyLCBwb3J0KTtcbiAgICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbmV3IE1lc3NhZ2VIYW5kbGVyKGlkLCBpZCArIFwiX3dvcmtlclwiLCBwb3J0KTtcbiAgICAgIHRoaXMuI3Jlc29sdmUoKTtcbiAgICB9KS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnJlamVjdChuZXcgRXJyb3IoYFNldHRpbmcgdXAgZmFrZSB3b3JrZXIgZmFpbGVkOiBcIiR7cmVhc29uLm1lc3NhZ2V9XCIuYCkpO1xuICAgIH0pO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHRoaXMuX3dlYldvcmtlcj8udGVybWluYXRlKCk7XG4gICAgdGhpcy5fd2ViV29ya2VyID0gbnVsbDtcbiAgICBQREZXb3JrZXIuI3dvcmtlclBvcnRzPy5kZWxldGUodGhpcy5fcG9ydCk7XG4gICAgdGhpcy5fcG9ydCA9IG51bGw7XG4gICAgdGhpcy5fbWVzc2FnZUhhbmRsZXI/LmRlc3Ryb3koKTtcbiAgICB0aGlzLl9tZXNzYWdlSGFuZGxlciA9IG51bGw7XG4gIH1cbiAgc3RhdGljIGZyb21Qb3J0KHBhcmFtcykge1xuICAgIGlmICghcGFyYW1zPy5wb3J0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQREZXb3JrZXIuZnJvbVBvcnQgLSBpbnZhbGlkIG1ldGhvZCBzaWduYXR1cmUuXCIpO1xuICAgIH1cbiAgICBjb25zdCBjYWNoZWRQb3J0ID0gdGhpcy4jd29ya2VyUG9ydHM/LmdldChwYXJhbXMucG9ydCk7XG4gICAgaWYgKGNhY2hlZFBvcnQpIHtcbiAgICAgIGlmIChjYWNoZWRQb3J0Ll9wZW5kaW5nRGVzdHJveSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQREZXb3JrZXIuZnJvbVBvcnQgLSB0aGUgd29ya2VyIGlzIGJlaW5nIGRlc3Ryb3llZC5cXG5cIiArIFwiUGxlYXNlIHJlbWVtYmVyIHRvIGF3YWl0IGBQREZEb2N1bWVudExvYWRpbmdUYXNrLmRlc3Ryb3koKWAtY2FsbHMuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhY2hlZFBvcnQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUERGV29ya2VyKHBhcmFtcyk7XG4gIH1cbiAgc3RhdGljIGdldCB3b3JrZXJTcmMoKSB7XG4gICAgaWYgKEdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjKSB7XG4gICAgICByZXR1cm4gR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmM7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignTm8gXCJHbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyY1wiIHNwZWNpZmllZC4nKTtcbiAgfVxuICBzdGF0aWMgZ2V0ICNtYWluVGhyZWFkV29ya2VyTWVzc2FnZUhhbmRsZXIoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBnbG9iYWxUaGlzLnBkZmpzV29ya2VyPy5Xb3JrZXJNZXNzYWdlSGFuZGxlciB8fCBudWxsO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXQgX3NldHVwRmFrZVdvcmtlckdsb2JhbCgpIHtcbiAgICBjb25zdCBsb2FkZXIgPSBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAodGhpcy4jbWFpblRocmVhZFdvcmtlck1lc3NhZ2VIYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNtYWluVGhyZWFkV29ya2VyTWVzc2FnZUhhbmRsZXI7XG4gICAgICB9XG4gICAgICBjb25zdCB3b3JrZXIgPSBhd2FpdCBpbXBvcnQoLyp3ZWJwYWNrSWdub3JlOiB0cnVlKi90aGlzLndvcmtlclNyYyk7XG4gICAgICByZXR1cm4gd29ya2VyLldvcmtlck1lc3NhZ2VIYW5kbGVyO1xuICAgIH07XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9zZXR1cEZha2VXb3JrZXJHbG9iYWxcIiwgbG9hZGVyKCkpO1xuICB9XG59XG5jbGFzcyBXb3JrZXJUcmFuc3BvcnQge1xuICAjbWV0aG9kUHJvbWlzZXMgPSBuZXcgTWFwKCk7XG4gICNwYWdlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICNwYWdlUHJvbWlzZXMgPSBuZXcgTWFwKCk7XG4gICNwYWdlUmVmQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICNwYXNzd29yZENhcGFiaWxpdHkgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlSGFuZGxlciwgbG9hZGluZ1Rhc2ssIG5ldHdvcmtTdHJlYW0sIHBhcmFtcywgZmFjdG9yeSkge1xuICAgIHRoaXMubWVzc2FnZUhhbmRsZXIgPSBtZXNzYWdlSGFuZGxlcjtcbiAgICB0aGlzLmxvYWRpbmdUYXNrID0gbG9hZGluZ1Rhc2s7XG4gICAgdGhpcy5jb21tb25PYmpzID0gbmV3IFBERk9iamVjdHMoKTtcbiAgICB0aGlzLmZvbnRMb2FkZXIgPSBuZXcgRm9udExvYWRlcih7XG4gICAgICBvd25lckRvY3VtZW50OiBwYXJhbXMub3duZXJEb2N1bWVudCxcbiAgICAgIHN0eWxlRWxlbWVudDogcGFyYW1zLnN0eWxlRWxlbWVudFxuICAgIH0pO1xuICAgIHRoaXMubG9hZGluZ1BhcmFtcyA9IHBhcmFtcy5sb2FkaW5nUGFyYW1zO1xuICAgIHRoaXMuX3BhcmFtcyA9IHBhcmFtcztcbiAgICB0aGlzLmNhbnZhc0ZhY3RvcnkgPSBmYWN0b3J5LmNhbnZhc0ZhY3Rvcnk7XG4gICAgdGhpcy5maWx0ZXJGYWN0b3J5ID0gZmFjdG9yeS5maWx0ZXJGYWN0b3J5O1xuICAgIHRoaXMuY01hcFJlYWRlckZhY3RvcnkgPSBmYWN0b3J5LmNNYXBSZWFkZXJGYWN0b3J5O1xuICAgIHRoaXMuc3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBmYWN0b3J5LnN0YW5kYXJkRm9udERhdGFGYWN0b3J5O1xuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5kZXN0cm95Q2FwYWJpbGl0eSA9IG51bGw7XG4gICAgdGhpcy5fbmV0d29ya1N0cmVhbSA9IG5ldHdvcmtTdHJlYW07XG4gICAgdGhpcy5fZnVsbFJlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fbGFzdFByb2dyZXNzID0gbnVsbDtcbiAgICB0aGlzLmRvd25sb2FkSW5mb0NhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLnNldHVwTWVzc2FnZUhhbmRsZXIoKTtcbiAgfVxuICAjY2FjaGVTaW1wbGVNZXRob2QobmFtZSwgZGF0YSA9IG51bGwpIHtcbiAgICBjb25zdCBjYWNoZWRQcm9taXNlID0gdGhpcy4jbWV0aG9kUHJvbWlzZXMuZ2V0KG5hbWUpO1xuICAgIGlmIChjYWNoZWRQcm9taXNlKSB7XG4gICAgICByZXR1cm4gY2FjaGVkUHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKG5hbWUsIGRhdGEpO1xuICAgIHRoaXMuI21ldGhvZFByb21pc2VzLnNldChuYW1lLCBwcm9taXNlKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBnZXQgYW5ub3RhdGlvblN0b3JhZ2UoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImFubm90YXRpb25TdG9yYWdlXCIsIG5ldyBBbm5vdGF0aW9uU3RvcmFnZSgpKTtcbiAgfVxuICBnZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50LCBhbm5vdGF0aW9uTW9kZSA9IEFubm90YXRpb25Nb2RlLkVOQUJMRSwgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSA9IG51bGwsIGlzRWRpdGluZyA9IGZhbHNlLCBpc09wTGlzdCA9IGZhbHNlKSB7XG4gICAgbGV0IHJlbmRlcmluZ0ludGVudCA9IFJlbmRlcmluZ0ludGVudEZsYWcuRElTUExBWTtcbiAgICBsZXQgYW5ub3RhdGlvblN0b3JhZ2VTZXJpYWxpemFibGUgPSBTZXJpYWxpemFibGVFbXB0eTtcbiAgICBzd2l0Y2ggKGludGVudCkge1xuICAgICAgY2FzZSBcImFueVwiOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgPSBSZW5kZXJpbmdJbnRlbnRGbGFnLkFOWTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZGlzcGxheVwiOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwcmludFwiOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgPSBSZW5kZXJpbmdJbnRlbnRGbGFnLlBSSU5UO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHdhcm4oYGdldFJlbmRlcmluZ0ludGVudCAtIGludmFsaWQgaW50ZW50OiAke2ludGVudH1gKTtcbiAgICB9XG4gICAgY29uc3QgYW5ub3RhdGlvblN0b3JhZ2UgPSByZW5kZXJpbmdJbnRlbnQgJiBSZW5kZXJpbmdJbnRlbnRGbGFnLlBSSU5UICYmIHByaW50QW5ub3RhdGlvblN0b3JhZ2UgaW5zdGFuY2VvZiBQcmludEFubm90YXRpb25TdG9yYWdlID8gcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSA6IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgc3dpdGNoIChhbm5vdGF0aW9uTW9kZSkge1xuICAgICAgY2FzZSBBbm5vdGF0aW9uTW9kZS5ESVNBQkxFOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgKz0gUmVuZGVyaW5nSW50ZW50RmxhZy5BTk5PVEFUSU9OU19ESVNBQkxFO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQW5ub3RhdGlvbk1vZGUuRU5BQkxFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQW5ub3RhdGlvbk1vZGUuRU5BQkxFX0ZPUk1TOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgKz0gUmVuZGVyaW5nSW50ZW50RmxhZy5BTk5PVEFUSU9OU19GT1JNUztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25Nb2RlLkVOQUJMRV9TVE9SQUdFOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgKz0gUmVuZGVyaW5nSW50ZW50RmxhZy5BTk5PVEFUSU9OU19TVE9SQUdFO1xuICAgICAgICBhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZSA9IGFubm90YXRpb25TdG9yYWdlLnNlcmlhbGl6YWJsZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB3YXJuKGBnZXRSZW5kZXJpbmdJbnRlbnQgLSBpbnZhbGlkIGFubm90YXRpb25Nb2RlOiAke2Fubm90YXRpb25Nb2RlfWApO1xuICAgIH1cbiAgICBpZiAoaXNFZGl0aW5nKSB7XG4gICAgICByZW5kZXJpbmdJbnRlbnQgKz0gUmVuZGVyaW5nSW50ZW50RmxhZy5JU19FRElUSU5HO1xuICAgIH1cbiAgICBpZiAoaXNPcExpc3QpIHtcbiAgICAgIHJlbmRlcmluZ0ludGVudCArPSBSZW5kZXJpbmdJbnRlbnRGbGFnLk9QTElTVDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgaWRzOiBtb2RpZmllZElkcyxcbiAgICAgIGhhc2g6IG1vZGlmaWVkSWRzSGFzaFxuICAgIH0gPSBhbm5vdGF0aW9uU3RvcmFnZS5tb2RpZmllZElkcztcbiAgICBjb25zdCBjYWNoZUtleUJ1ZiA9IFtyZW5kZXJpbmdJbnRlbnQsIGFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlLmhhc2gsIG1vZGlmaWVkSWRzSGFzaF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbmRlcmluZ0ludGVudCxcbiAgICAgIGNhY2hlS2V5OiBjYWNoZUtleUJ1Zi5qb2luKFwiX1wiKSxcbiAgICAgIGFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlLFxuICAgICAgbW9kaWZpZWRJZHNcbiAgICB9O1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveUNhcGFiaWxpdHkpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgfVxuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5Py5yZWplY3QobmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWQgZHVyaW5nIG9uUGFzc3dvcmQgY2FsbGJhY2tcIikpO1xuICAgIGNvbnN0IHdhaXRPbiA9IFtdO1xuICAgIGZvciAoY29uc3QgcGFnZSBvZiB0aGlzLiNwYWdlQ2FjaGUudmFsdWVzKCkpIHtcbiAgICAgIHdhaXRPbi5wdXNoKHBhZ2UuX2Rlc3Ryb3koKSk7XG4gICAgfVxuICAgIHRoaXMuI3BhZ2VDYWNoZS5jbGVhcigpO1xuICAgIHRoaXMuI3BhZ2VQcm9taXNlcy5jbGVhcigpO1xuICAgIHRoaXMuI3BhZ2VSZWZDYWNoZS5jbGVhcigpO1xuICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KFwiYW5ub3RhdGlvblN0b3JhZ2VcIikpIHtcbiAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2UucmVzZXRNb2RpZmllZCgpO1xuICAgIH1cbiAgICBjb25zdCB0ZXJtaW5hdGVkID0gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJUZXJtaW5hdGVcIiwgbnVsbCk7XG4gICAgd2FpdE9uLnB1c2godGVybWluYXRlZCk7XG4gICAgUHJvbWlzZS5hbGwod2FpdE9uKS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMuY29tbW9uT2Jqcy5jbGVhcigpO1xuICAgICAgdGhpcy5mb250TG9hZGVyLmNsZWFyKCk7XG4gICAgICB0aGlzLiNtZXRob2RQcm9taXNlcy5jbGVhcigpO1xuICAgICAgdGhpcy5maWx0ZXJGYWN0b3J5LmRlc3Ryb3koKTtcbiAgICAgIFRleHRMYXllci5jbGVhbnVwKCk7XG4gICAgICB0aGlzLl9uZXR3b3JrU3RyZWFtPy5jYW5jZWxBbGxSZXF1ZXN0cyhuZXcgQWJvcnRFeGNlcHRpb24oXCJXb3JrZXIgd2FzIHRlcm1pbmF0ZWQuXCIpKTtcbiAgICAgIHRoaXMubWVzc2FnZUhhbmRsZXI/LmRlc3Ryb3koKTtcbiAgICAgIHRoaXMubWVzc2FnZUhhbmRsZXIgPSBudWxsO1xuICAgICAgdGhpcy5kZXN0cm95Q2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSwgdGhpcy5kZXN0cm95Q2FwYWJpbGl0eS5yZWplY3QpO1xuICAgIHJldHVybiB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgc2V0dXBNZXNzYWdlSGFuZGxlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZXNzYWdlSGFuZGxlcixcbiAgICAgIGxvYWRpbmdUYXNrXG4gICAgfSA9IHRoaXM7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJHZXRSZWFkZXJcIiwgKGRhdGEsIHNpbmspID0+IHtcbiAgICAgIGFzc2VydCh0aGlzLl9uZXR3b3JrU3RyZWFtLCBcIkdldFJlYWRlciAtIG5vIGBJUERGU3RyZWFtYCBpbnN0YW5jZSBhdmFpbGFibGUuXCIpO1xuICAgICAgdGhpcy5fZnVsbFJlYWRlciA9IHRoaXMuX25ldHdvcmtTdHJlYW0uZ2V0RnVsbFJlYWRlcigpO1xuICAgICAgdGhpcy5fZnVsbFJlYWRlci5vblByb2dyZXNzID0gZXZ0ID0+IHtcbiAgICAgICAgdGhpcy5fbGFzdFByb2dyZXNzID0ge1xuICAgICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZCxcbiAgICAgICAgICB0b3RhbDogZXZ0LnRvdGFsXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgc2luay5vblB1bGwgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2Z1bGxSZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBkb25lXG4gICAgICAgIH0pIHtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgc2luay5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhc3NlcnQodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciwgXCJHZXRSZWFkZXIgLSBleHBlY3RlZCBhbiBBcnJheUJ1ZmZlci5cIik7XG4gICAgICAgICAgc2luay5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KHZhbHVlKSwgMSwgW3ZhbHVlXSk7XG4gICAgICAgIH0pLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICAgICAgc2luay5lcnJvcihyZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBzaW5rLm9uQ2FuY2VsID0gcmVhc29uID0+IHtcbiAgICAgICAgdGhpcy5fZnVsbFJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICAgICAgc2luay5yZWFkeS5jYXRjaChyZWFkeVJlYXNvbiA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IHJlYWR5UmVhc29uO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJSZWFkZXJIZWFkZXJzUmVhZHlcIiwgYXN5bmMgZGF0YSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLl9mdWxsUmVhZGVyLmhlYWRlcnNSZWFkeTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaXNTdHJlYW1pbmdTdXBwb3J0ZWQsXG4gICAgICAgIGlzUmFuZ2VTdXBwb3J0ZWQsXG4gICAgICAgIGNvbnRlbnRMZW5ndGhcbiAgICAgIH0gPSB0aGlzLl9mdWxsUmVhZGVyO1xuICAgICAgaWYgKCFpc1N0cmVhbWluZ1N1cHBvcnRlZCB8fCAhaXNSYW5nZVN1cHBvcnRlZCkge1xuICAgICAgICBpZiAodGhpcy5fbGFzdFByb2dyZXNzKSB7XG4gICAgICAgICAgbG9hZGluZ1Rhc2sub25Qcm9ncmVzcz8uKHRoaXMuX2xhc3RQcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZnVsbFJlYWRlci5vblByb2dyZXNzID0gZXZ0ID0+IHtcbiAgICAgICAgICBsb2FkaW5nVGFzay5vblByb2dyZXNzPy4oe1xuICAgICAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkLFxuICAgICAgICAgICAgdG90YWw6IGV2dC50b3RhbFxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNTdHJlYW1pbmdTdXBwb3J0ZWQsXG4gICAgICAgIGlzUmFuZ2VTdXBwb3J0ZWQsXG4gICAgICAgIGNvbnRlbnRMZW5ndGhcbiAgICAgIH07XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJHZXRSYW5nZVJlYWRlclwiLCAoZGF0YSwgc2luaykgPT4ge1xuICAgICAgYXNzZXJ0KHRoaXMuX25ldHdvcmtTdHJlYW0sIFwiR2V0UmFuZ2VSZWFkZXIgLSBubyBgSVBERlN0cmVhbWAgaW5zdGFuY2UgYXZhaWxhYmxlLlwiKTtcbiAgICAgIGNvbnN0IHJhbmdlUmVhZGVyID0gdGhpcy5fbmV0d29ya1N0cmVhbS5nZXRSYW5nZVJlYWRlcihkYXRhLmJlZ2luLCBkYXRhLmVuZCk7XG4gICAgICBpZiAoIXJhbmdlUmVhZGVyKSB7XG4gICAgICAgIHNpbmsuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2luay5vblB1bGwgPSAoKSA9PiB7XG4gICAgICAgIHJhbmdlUmVhZGVyLnJlYWQoKS50aGVuKGZ1bmN0aW9uICh7XG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgZG9uZVxuICAgICAgICB9KSB7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHNpbmsuY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXNzZXJ0KHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIsIFwiR2V0UmFuZ2VSZWFkZXIgLSBleHBlY3RlZCBhbiBBcnJheUJ1ZmZlci5cIik7XG4gICAgICAgICAgc2luay5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KHZhbHVlKSwgMSwgW3ZhbHVlXSk7XG4gICAgICAgIH0pLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICAgICAgc2luay5lcnJvcihyZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBzaW5rLm9uQ2FuY2VsID0gcmVhc29uID0+IHtcbiAgICAgICAgcmFuZ2VSZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgICAgIHNpbmsucmVhZHkuY2F0Y2gocmVhZHlSZWFzb24gPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyByZWFkeVJlYXNvbjtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiR2V0RG9jXCIsICh7XG4gICAgICBwZGZJbmZvXG4gICAgfSkgPT4ge1xuICAgICAgdGhpcy5fbnVtUGFnZXMgPSBwZGZJbmZvLm51bVBhZ2VzO1xuICAgICAgdGhpcy5faHRtbEZvclhmYSA9IHBkZkluZm8uaHRtbEZvclhmYTtcbiAgICAgIGRlbGV0ZSBwZGZJbmZvLmh0bWxGb3JYZmE7XG4gICAgICBsb2FkaW5nVGFzay5fY2FwYWJpbGl0eS5yZXNvbHZlKG5ldyBQREZEb2N1bWVudFByb3h5KHBkZkluZm8sIHRoaXMpKTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkRvY0V4Y2VwdGlvblwiLCBmdW5jdGlvbiAoZXgpIHtcbiAgICAgIGxldCByZWFzb247XG4gICAgICBzd2l0Y2ggKGV4Lm5hbWUpIHtcbiAgICAgICAgY2FzZSBcIlBhc3N3b3JkRXhjZXB0aW9uXCI6XG4gICAgICAgICAgcmVhc29uID0gbmV3IFBhc3N3b3JkRXhjZXB0aW9uKGV4Lm1lc3NhZ2UsIGV4LmNvZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiSW52YWxpZFBERkV4Y2VwdGlvblwiOlxuICAgICAgICAgIHJlYXNvbiA9IG5ldyBJbnZhbGlkUERGRXhjZXB0aW9uKGV4Lm1lc3NhZ2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTWlzc2luZ1BERkV4Y2VwdGlvblwiOlxuICAgICAgICAgIHJlYXNvbiA9IG5ldyBNaXNzaW5nUERGRXhjZXB0aW9uKGV4Lm1lc3NhZ2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uXCI6XG4gICAgICAgICAgcmVhc29uID0gbmV3IFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbihleC5tZXNzYWdlLCBleC5zdGF0dXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiVW5rbm93bkVycm9yRXhjZXB0aW9uXCI6XG4gICAgICAgICAgcmVhc29uID0gbmV3IFVua25vd25FcnJvckV4Y2VwdGlvbihleC5tZXNzYWdlLCBleC5kZXRhaWxzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB1bnJlYWNoYWJsZShcIkRvY0V4Y2VwdGlvbiAtIGV4cGVjdGVkIGEgdmFsaWQgRXJyb3IuXCIpO1xuICAgICAgfVxuICAgICAgbG9hZGluZ1Rhc2suX2NhcGFiaWxpdHkucmVqZWN0KHJlYXNvbik7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJQYXNzd29yZFJlcXVlc3RcIiwgZXhjZXB0aW9uID0+IHtcbiAgICAgIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgICAgaWYgKGxvYWRpbmdUYXNrLm9uUGFzc3dvcmQpIHtcbiAgICAgICAgY29uc3QgdXBkYXRlUGFzc3dvcmQgPSBwYXNzd29yZCA9PiB7XG4gICAgICAgICAgaWYgKHBhc3N3b3JkIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eS5yZWplY3QocGFzc3dvcmQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNwYXNzd29yZENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgICAgICAgIHBhc3N3b3JkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbG9hZGluZ1Rhc2sub25QYXNzd29yZCh1cGRhdGVQYXNzd29yZCwgZXhjZXB0aW9uLmNvZGUpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eS5yZWplY3QoZXgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiNwYXNzd29yZENhcGFiaWxpdHkucmVqZWN0KG5ldyBQYXNzd29yZEV4Y2VwdGlvbihleGNlcHRpb24ubWVzc2FnZSwgZXhjZXB0aW9uLmNvZGUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLiNwYXNzd29yZENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkRhdGFMb2FkZWRcIiwgZGF0YSA9PiB7XG4gICAgICBsb2FkaW5nVGFzay5vblByb2dyZXNzPy4oe1xuICAgICAgICBsb2FkZWQ6IGRhdGEubGVuZ3RoLFxuICAgICAgICB0b3RhbDogZGF0YS5sZW5ndGhcbiAgICAgIH0pO1xuICAgICAgdGhpcy5kb3dubG9hZEluZm9DYXBhYmlsaXR5LnJlc29sdmUoZGF0YSk7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJTdGFydFJlbmRlclBhZ2VcIiwgZGF0YSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFnZSA9IHRoaXMuI3BhZ2VDYWNoZS5nZXQoZGF0YS5wYWdlSW5kZXgpO1xuICAgICAgcGFnZS5fc3RhcnRSZW5kZXJQYWdlKGRhdGEudHJhbnNwYXJlbmN5LCBkYXRhLmNhY2hlS2V5KTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcImNvbW1vbm9ialwiLCAoW2lkLCB0eXBlLCBleHBvcnRlZERhdGFdKSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb21tb25PYmpzLmhhcyhpZCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcIkZvbnRcIjpcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBkaXNhYmxlRm9udEZhY2UsXG4gICAgICAgICAgICBmb250RXh0cmFQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgcGRmQnVnXG4gICAgICAgICAgfSA9IHRoaXMuX3BhcmFtcztcbiAgICAgICAgICBpZiAoXCJlcnJvclwiIGluIGV4cG9ydGVkRGF0YSkge1xuICAgICAgICAgICAgY29uc3QgZXhwb3J0ZWRFcnJvciA9IGV4cG9ydGVkRGF0YS5lcnJvcjtcbiAgICAgICAgICAgIHdhcm4oYEVycm9yIGR1cmluZyBmb250IGxvYWRpbmc6ICR7ZXhwb3J0ZWRFcnJvcn1gKTtcbiAgICAgICAgICAgIHRoaXMuY29tbW9uT2Jqcy5yZXNvbHZlKGlkLCBleHBvcnRlZEVycm9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpbnNwZWN0Rm9udCA9IHBkZkJ1ZyAmJiBnbG9iYWxUaGlzLkZvbnRJbnNwZWN0b3I/LmVuYWJsZWQgPyAoZm9udCwgdXJsKSA9PiBnbG9iYWxUaGlzLkZvbnRJbnNwZWN0b3IuZm9udEFkZGVkKGZvbnQsIHVybCkgOiBudWxsO1xuICAgICAgICAgIGNvbnN0IGZvbnQgPSBuZXcgRm9udEZhY2VPYmplY3QoZXhwb3J0ZWREYXRhLCB7XG4gICAgICAgICAgICBkaXNhYmxlRm9udEZhY2UsXG4gICAgICAgICAgICBpbnNwZWN0Rm9udFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuZm9udExvYWRlci5iaW5kKGZvbnQpLmNhdGNoKCgpID0+IG1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkZvbnRGYWxsYmFja1wiLCB7XG4gICAgICAgICAgICBpZFxuICAgICAgICAgIH0pKS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgIGlmICghZm9udEV4dHJhUHJvcGVydGllcyAmJiBmb250LmRhdGEpIHtcbiAgICAgICAgICAgICAgZm9udC5kYXRhID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29tbW9uT2Jqcy5yZXNvbHZlKGlkLCBmb250KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkNvcHlMb2NhbEltYWdlXCI6XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgaW1hZ2VSZWZcbiAgICAgICAgICB9ID0gZXhwb3J0ZWREYXRhO1xuICAgICAgICAgIGFzc2VydChpbWFnZVJlZiwgXCJUaGUgaW1hZ2VSZWYgbXVzdCBiZSBkZWZpbmVkLlwiKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHBhZ2VQcm94eSBvZiB0aGlzLiNwYWdlQ2FjaGUudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgWywgZGF0YV0gb2YgcGFnZVByb3h5Lm9ianMpIHtcbiAgICAgICAgICAgICAgaWYgKGRhdGE/LnJlZiAhPT0gaW1hZ2VSZWYpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWRhdGEuZGF0YUxlbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuY29tbW9uT2Jqcy5yZXNvbHZlKGlkLCBzdHJ1Y3R1cmVkQ2xvbmUoZGF0YSkpO1xuICAgICAgICAgICAgICByZXR1cm4gZGF0YS5kYXRhTGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkZvbnRQYXRoXCI6XG4gICAgICAgIGNhc2UgXCJJbWFnZVwiOlxuICAgICAgICBjYXNlIFwiUGF0dGVyblwiOlxuICAgICAgICAgIHRoaXMuY29tbW9uT2Jqcy5yZXNvbHZlKGlkLCBleHBvcnRlZERhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgR290IHVua25vd24gY29tbW9uIG9iamVjdCB0eXBlICR7dHlwZX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwib2JqXCIsIChbaWQsIHBhZ2VJbmRleCwgdHlwZSwgaW1hZ2VEYXRhXSkgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhZ2VQcm94eSA9IHRoaXMuI3BhZ2VDYWNoZS5nZXQocGFnZUluZGV4KTtcbiAgICAgIGlmIChwYWdlUHJveHkub2Jqcy5oYXMoaWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChwYWdlUHJveHkuX2ludGVudFN0YXRlcy5zaXplID09PSAwKSB7XG4gICAgICAgIGltYWdlRGF0YT8uYml0bWFwPy5jbG9zZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcIkltYWdlXCI6XG4gICAgICAgICAgcGFnZVByb3h5Lm9ianMucmVzb2x2ZShpZCwgaW1hZ2VEYXRhKTtcbiAgICAgICAgICBpZiAoaW1hZ2VEYXRhPy5kYXRhTGVuID4gTUFYX0lNQUdFX1NJWkVfVE9fQ0FDSEUpIHtcbiAgICAgICAgICAgIHBhZ2VQcm94eS5fbWF5YmVDbGVhbnVwQWZ0ZXJSZW5kZXIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlBhdHRlcm5cIjpcbiAgICAgICAgICBwYWdlUHJveHkub2Jqcy5yZXNvbHZlKGlkLCBpbWFnZURhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgR290IHVua25vd24gb2JqZWN0IHR5cGUgJHt0eXBlfWApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiRG9jUHJvZ3Jlc3NcIiwgZGF0YSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbG9hZGluZ1Rhc2sub25Qcm9ncmVzcz8uKHtcbiAgICAgICAgbG9hZGVkOiBkYXRhLmxvYWRlZCxcbiAgICAgICAgdG90YWw6IGRhdGEudG90YWxcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiRmV0Y2hCdWlsdEluQ01hcFwiLCBhc3luYyBkYXRhID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZC5cIik7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuY01hcFJlYWRlckZhY3RvcnkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ01hcFJlYWRlckZhY3Rvcnkgbm90IGluaXRpYWxpemVkLCBzZWUgdGhlIGB1c2VXb3JrZXJGZXRjaGAgcGFyYW1ldGVyLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNNYXBSZWFkZXJGYWN0b3J5LmZldGNoKGRhdGEpO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiRmV0Y2hTdGFuZGFyZEZvbnREYXRhXCIsIGFzeW5jIGRhdGEgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkLlwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5zdGFuZGFyZEZvbnREYXRhRmFjdG9yeSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSBub3QgaW5pdGlhbGl6ZWQsIHNlZSB0aGUgYHVzZVdvcmtlckZldGNoYCBwYXJhbWV0ZXIuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc3RhbmRhcmRGb250RGF0YUZhY3RvcnkuZmV0Y2goZGF0YSk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXREYXRhXCIsIG51bGwpO1xuICB9XG4gIHNhdmVEb2N1bWVudCgpIHtcbiAgICBpZiAodGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zaXplIDw9IDApIHtcbiAgICAgIHdhcm4oXCJzYXZlRG9jdW1lbnQgY2FsbGVkIHdoaWxlIGBhbm5vdGF0aW9uU3RvcmFnZWAgaXMgZW1wdHksIFwiICsgXCJwbGVhc2UgdXNlIHRoZSBnZXREYXRhLW1ldGhvZCBpbnN0ZWFkLlwiKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgbWFwLFxuICAgICAgdHJhbnNmZXJcbiAgICB9ID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zZXJpYWxpemFibGU7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiU2F2ZURvY3VtZW50XCIsIHtcbiAgICAgIGlzUHVyZVhmYTogISF0aGlzLl9odG1sRm9yWGZhLFxuICAgICAgbnVtUGFnZXM6IHRoaXMuX251bVBhZ2VzLFxuICAgICAgYW5ub3RhdGlvblN0b3JhZ2U6IG1hcCxcbiAgICAgIGZpbGVuYW1lOiB0aGlzLl9mdWxsUmVhZGVyPy5maWxlbmFtZSA/PyBudWxsXG4gICAgfSwgdHJhbnNmZXIpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5yZXNldE1vZGlmaWVkKCk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0UGFnZShwYWdlTnVtYmVyKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHBhZ2VOdW1iZXIpIHx8IHBhZ2VOdW1iZXIgPD0gMCB8fCBwYWdlTnVtYmVyID4gdGhpcy5fbnVtUGFnZXMpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJJbnZhbGlkIHBhZ2UgcmVxdWVzdC5cIikpO1xuICAgIH1cbiAgICBjb25zdCBwYWdlSW5kZXggPSBwYWdlTnVtYmVyIC0gMSxcbiAgICAgIGNhY2hlZFByb21pc2UgPSB0aGlzLiNwYWdlUHJvbWlzZXMuZ2V0KHBhZ2VJbmRleCk7XG4gICAgaWYgKGNhY2hlZFByb21pc2UpIHtcbiAgICAgIHJldHVybiBjYWNoZWRQcm9taXNlO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlXCIsIHtcbiAgICAgIHBhZ2VJbmRleFxuICAgIH0pLnRoZW4ocGFnZUluZm8gPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zcG9ydCBkZXN0cm95ZWRcIik7XG4gICAgICB9XG4gICAgICBpZiAocGFnZUluZm8ucmVmU3RyKSB7XG4gICAgICAgIHRoaXMuI3BhZ2VSZWZDYWNoZS5zZXQocGFnZUluZm8ucmVmU3RyLCBwYWdlTnVtYmVyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhZ2UgPSBuZXcgUERGUGFnZVByb3h5KHBhZ2VJbmRleCwgcGFnZUluZm8sIHRoaXMsIHRoaXMuX3BhcmFtcy5wZGZCdWcpO1xuICAgICAgdGhpcy4jcGFnZUNhY2hlLnNldChwYWdlSW5kZXgsIHBhZ2UpO1xuICAgICAgcmV0dXJuIHBhZ2U7XG4gICAgfSk7XG4gICAgdGhpcy4jcGFnZVByb21pc2VzLnNldChwYWdlSW5kZXgsIHByb21pc2UpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIGdldFBhZ2VJbmRleChyZWYpIHtcbiAgICBpZiAoIWlzUmVmUHJveHkocmVmKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkludmFsaWQgcGFnZUluZGV4IHJlcXVlc3QuXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZUluZGV4XCIsIHtcbiAgICAgIG51bTogcmVmLm51bSxcbiAgICAgIGdlbjogcmVmLmdlblxuICAgIH0pO1xuICB9XG4gIGdldEFubm90YXRpb25zKHBhZ2VJbmRleCwgaW50ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0QW5ub3RhdGlvbnNcIiwge1xuICAgICAgcGFnZUluZGV4LFxuICAgICAgaW50ZW50XG4gICAgfSk7XG4gIH1cbiAgZ2V0RmllbGRPYmplY3RzKCkge1xuICAgIHJldHVybiB0aGlzLiNjYWNoZVNpbXBsZU1ldGhvZChcIkdldEZpZWxkT2JqZWN0c1wiKTtcbiAgfVxuICBoYXNKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlU2ltcGxlTWV0aG9kKFwiSGFzSlNBY3Rpb25zXCIpO1xuICB9XG4gIGdldENhbGN1bGF0aW9uT3JkZXJJZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0Q2FsY3VsYXRpb25PcmRlcklkc1wiLCBudWxsKTtcbiAgfVxuICBnZXREZXN0aW5hdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0RGVzdGluYXRpb25zXCIsIG51bGwpO1xuICB9XG4gIGdldERlc3RpbmF0aW9uKGlkKSB7XG4gICAgaWYgKHR5cGVvZiBpZCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkludmFsaWQgZGVzdGluYXRpb24gcmVxdWVzdC5cIikpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXREZXN0aW5hdGlvblwiLCB7XG4gICAgICBpZFxuICAgIH0pO1xuICB9XG4gIGdldFBhZ2VMYWJlbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZUxhYmVsc1wiLCBudWxsKTtcbiAgfVxuICBnZXRQYWdlTGF5b3V0KCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBhZ2VMYXlvdXRcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0UGFnZU1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZU1vZGVcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0Vmlld2VyUHJlZmVyZW5jZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0Vmlld2VyUHJlZmVyZW5jZXNcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0T3BlbkFjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRPcGVuQWN0aW9uXCIsIG51bGwpO1xuICB9XG4gIGdldEF0dGFjaG1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldEF0dGFjaG1lbnRzXCIsIG51bGwpO1xuICB9XG4gIGdldERvY0pTQWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy4jY2FjaGVTaW1wbGVNZXRob2QoXCJHZXREb2NKU0FjdGlvbnNcIik7XG4gIH1cbiAgZ2V0UGFnZUpTQWN0aW9ucyhwYWdlSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlSlNBY3Rpb25zXCIsIHtcbiAgICAgIHBhZ2VJbmRleFxuICAgIH0pO1xuICB9XG4gIGdldFN0cnVjdFRyZWUocGFnZUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0U3RydWN0VHJlZVwiLCB7XG4gICAgICBwYWdlSW5kZXhcbiAgICB9KTtcbiAgfVxuICBnZXRPdXRsaW5lKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldE91dGxpbmVcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnKHJlbmRlcmluZ0ludGVudCkge1xuICAgIHJldHVybiB0aGlzLiNjYWNoZVNpbXBsZU1ldGhvZChcIkdldE9wdGlvbmFsQ29udGVudENvbmZpZ1wiKS50aGVuKGRhdGEgPT4gbmV3IE9wdGlvbmFsQ29udGVudENvbmZpZyhkYXRhLCByZW5kZXJpbmdJbnRlbnQpKTtcbiAgfVxuICBnZXRQZXJtaXNzaW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQZXJtaXNzaW9uc1wiLCBudWxsKTtcbiAgfVxuICBnZXRNZXRhZGF0YSgpIHtcbiAgICBjb25zdCBuYW1lID0gXCJHZXRNZXRhZGF0YVwiLFxuICAgICAgY2FjaGVkUHJvbWlzZSA9IHRoaXMuI21ldGhvZFByb21pc2VzLmdldChuYW1lKTtcbiAgICBpZiAoY2FjaGVkUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIGNhY2hlZFByb21pc2U7XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShuYW1lLCBudWxsKS50aGVuKHJlc3VsdHMgPT4gKHtcbiAgICAgIGluZm86IHJlc3VsdHNbMF0sXG4gICAgICBtZXRhZGF0YTogcmVzdWx0c1sxXSA/IG5ldyBNZXRhZGF0YShyZXN1bHRzWzFdKSA6IG51bGwsXG4gICAgICBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZTogdGhpcy5fZnVsbFJlYWRlcj8uZmlsZW5hbWUgPz8gbnVsbCxcbiAgICAgIGNvbnRlbnRMZW5ndGg6IHRoaXMuX2Z1bGxSZWFkZXI/LmNvbnRlbnRMZW5ndGggPz8gbnVsbFxuICAgIH0pKTtcbiAgICB0aGlzLiNtZXRob2RQcm9taXNlcy5zZXQobmFtZSwgcHJvbWlzZSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgZ2V0TWFya0luZm8oKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0TWFya0luZm9cIiwgbnVsbCk7XG4gIH1cbiAgYXN5bmMgc3RhcnRDbGVhbnVwKGtlZXBMb2FkZWRGb250cyA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGF3YWl0IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiQ2xlYW51cFwiLCBudWxsKTtcbiAgICBmb3IgKGNvbnN0IHBhZ2Ugb2YgdGhpcy4jcGFnZUNhY2hlLnZhbHVlcygpKSB7XG4gICAgICBjb25zdCBjbGVhbnVwU3VjY2Vzc2Z1bCA9IHBhZ2UuY2xlYW51cCgpO1xuICAgICAgaWYgKCFjbGVhbnVwU3VjY2Vzc2Z1bCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHN0YXJ0Q2xlYW51cDogUGFnZSAke3BhZ2UucGFnZU51bWJlcn0gaXMgY3VycmVudGx5IHJlbmRlcmluZy5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb21tb25PYmpzLmNsZWFyKCk7XG4gICAgaWYgKCFrZWVwTG9hZGVkRm9udHMpIHtcbiAgICAgIHRoaXMuZm9udExvYWRlci5jbGVhcigpO1xuICAgIH1cbiAgICB0aGlzLiNtZXRob2RQcm9taXNlcy5jbGVhcigpO1xuICAgIHRoaXMuZmlsdGVyRmFjdG9yeS5kZXN0cm95KHRydWUpO1xuICAgIFRleHRMYXllci5jbGVhbnVwKCk7XG4gIH1cbiAgY2FjaGVkUGFnZU51bWJlcihyZWYpIHtcbiAgICBpZiAoIWlzUmVmUHJveHkocmVmKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlZlN0ciA9IHJlZi5nZW4gPT09IDAgPyBgJHtyZWYubnVtfVJgIDogYCR7cmVmLm51bX1SJHtyZWYuZ2VufWA7XG4gICAgcmV0dXJuIHRoaXMuI3BhZ2VSZWZDYWNoZS5nZXQocmVmU3RyKSA/PyBudWxsO1xuICB9XG59XG5jb25zdCBJTklUSUFMX0RBVEEgPSBTeW1ib2woXCJJTklUSUFMX0RBVEFcIik7XG5jbGFzcyBQREZPYmplY3RzIHtcbiAgI29ianMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAjZW5zdXJlT2JqKG9iaklkKSB7XG4gICAgcmV0dXJuIHRoaXMuI29ianNbb2JqSWRdIHx8PSB7XG4gICAgICAuLi5Qcm9taXNlLndpdGhSZXNvbHZlcnMoKSxcbiAgICAgIGRhdGE6IElOSVRJQUxfREFUQVxuICAgIH07XG4gIH1cbiAgZ2V0KG9iaklkLCBjYWxsYmFjayA9IG51bGwpIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IG9iaiA9IHRoaXMuI2Vuc3VyZU9iaihvYmpJZCk7XG4gICAgICBvYmoucHJvbWlzZS50aGVuKCgpID0+IGNhbGxiYWNrKG9iai5kYXRhKSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgb2JqID0gdGhpcy4jb2Jqc1tvYmpJZF07XG4gICAgaWYgKCFvYmogfHwgb2JqLmRhdGEgPT09IElOSVRJQUxfREFUQSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXF1ZXN0aW5nIG9iamVjdCB0aGF0IGlzbid0IHJlc29sdmVkIHlldCAke29iaklkfS5gKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iai5kYXRhO1xuICB9XG4gIGhhcyhvYmpJZCkge1xuICAgIGNvbnN0IG9iaiA9IHRoaXMuI29ianNbb2JqSWRdO1xuICAgIHJldHVybiAhIW9iaiAmJiBvYmouZGF0YSAhPT0gSU5JVElBTF9EQVRBO1xuICB9XG4gIHJlc29sdmUob2JqSWQsIGRhdGEgPSBudWxsKSB7XG4gICAgY29uc3Qgb2JqID0gdGhpcy4jZW5zdXJlT2JqKG9iaklkKTtcbiAgICBvYmouZGF0YSA9IGRhdGE7XG4gICAgb2JqLnJlc29sdmUoKTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICBmb3IgKGNvbnN0IG9iaklkIGluIHRoaXMuI29ianMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YVxuICAgICAgfSA9IHRoaXMuI29ianNbb2JqSWRdO1xuICAgICAgZGF0YT8uYml0bWFwPy5jbG9zZSgpO1xuICAgIH1cbiAgICB0aGlzLiNvYmpzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgZm9yIChjb25zdCBvYmpJZCBpbiB0aGlzLiNvYmpzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGFcbiAgICAgIH0gPSB0aGlzLiNvYmpzW29iaklkXTtcbiAgICAgIGlmIChkYXRhID09PSBJTklUSUFMX0RBVEEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB5aWVsZCBbb2JqSWQsIGRhdGFdO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgUmVuZGVyVGFzayB7XG4gICNpbnRlcm5hbFJlbmRlclRhc2sgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihpbnRlcm5hbFJlbmRlclRhc2spIHtcbiAgICB0aGlzLiNpbnRlcm5hbFJlbmRlclRhc2sgPSBpbnRlcm5hbFJlbmRlclRhc2s7XG4gICAgdGhpcy5vbkNvbnRpbnVlID0gbnVsbDtcbiAgfVxuICBnZXQgcHJvbWlzZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaW50ZXJuYWxSZW5kZXJUYXNrLmNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjYW5jZWwoZXh0cmFEZWxheSA9IDApIHtcbiAgICB0aGlzLiNpbnRlcm5hbFJlbmRlclRhc2suY2FuY2VsKG51bGwsIGV4dHJhRGVsYXkpO1xuICB9XG4gIGdldCBzZXBhcmF0ZUFubm90cygpIHtcbiAgICBjb25zdCB7XG4gICAgICBzZXBhcmF0ZUFubm90c1xuICAgIH0gPSB0aGlzLiNpbnRlcm5hbFJlbmRlclRhc2sub3BlcmF0b3JMaXN0O1xuICAgIGlmICghc2VwYXJhdGVBbm5vdHMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYW5ub3RhdGlvbkNhbnZhc01hcFxuICAgIH0gPSB0aGlzLiNpbnRlcm5hbFJlbmRlclRhc2s7XG4gICAgcmV0dXJuIHNlcGFyYXRlQW5ub3RzLmZvcm0gfHwgc2VwYXJhdGVBbm5vdHMuY2FudmFzICYmIGFubm90YXRpb25DYW52YXNNYXA/LnNpemUgPiAwO1xuICB9XG59XG5jbGFzcyBJbnRlcm5hbFJlbmRlclRhc2sge1xuICAjckFGID0gbnVsbDtcbiAgc3RhdGljICNjYW52YXNJblVzZSA9IG5ldyBXZWFrU2V0KCk7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjYWxsYmFjayxcbiAgICBwYXJhbXMsXG4gICAgb2JqcyxcbiAgICBjb21tb25PYmpzLFxuICAgIGFubm90YXRpb25DYW52YXNNYXAsXG4gICAgb3BlcmF0b3JMaXN0LFxuICAgIHBhZ2VJbmRleCxcbiAgICBjYW52YXNGYWN0b3J5LFxuICAgIGZpbHRlckZhY3RvcnksXG4gICAgdXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZmFsc2UsXG4gICAgcGRmQnVnID0gZmFsc2UsXG4gICAgcGFnZUNvbG9ycyA9IG51bGxcbiAgfSkge1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICB0aGlzLm9ianMgPSBvYmpzO1xuICAgIHRoaXMuY29tbW9uT2JqcyA9IGNvbW1vbk9ianM7XG4gICAgdGhpcy5hbm5vdGF0aW9uQ2FudmFzTWFwID0gYW5ub3RhdGlvbkNhbnZhc01hcDtcbiAgICB0aGlzLm9wZXJhdG9yTGlzdElkeCA9IG51bGw7XG4gICAgdGhpcy5vcGVyYXRvckxpc3QgPSBvcGVyYXRvckxpc3Q7XG4gICAgdGhpcy5fcGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgIHRoaXMuY2FudmFzRmFjdG9yeSA9IGNhbnZhc0ZhY3Rvcnk7XG4gICAgdGhpcy5maWx0ZXJGYWN0b3J5ID0gZmlsdGVyRmFjdG9yeTtcbiAgICB0aGlzLl9wZGZCdWcgPSBwZGZCdWc7XG4gICAgdGhpcy5wYWdlQ29sb3JzID0gcGFnZUNvbG9ycztcbiAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLmdyYXBoaWNzUmVhZHlDYWxsYmFjayA9IG51bGw7XG4gICAgdGhpcy5ncmFwaGljc1JlYWR5ID0gZmFsc2U7XG4gICAgdGhpcy5fdXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gdXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSB0cnVlICYmIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG4gICAgdGhpcy5jYW5jZWxsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLnRhc2sgPSBuZXcgUmVuZGVyVGFzayh0aGlzKTtcbiAgICB0aGlzLl9jYW5jZWxCb3VuZCA9IHRoaXMuY2FuY2VsLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fY29udGludWVCb3VuZCA9IHRoaXMuX2NvbnRpbnVlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fc2NoZWR1bGVOZXh0Qm91bmQgPSB0aGlzLl9zY2hlZHVsZU5leHQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9uZXh0Qm91bmQgPSB0aGlzLl9uZXh0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fY2FudmFzID0gcGFyYW1zLmNhbnZhc0NvbnRleHQuY2FudmFzO1xuICB9XG4gIGdldCBjb21wbGV0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FwYWJpbGl0eS5wcm9taXNlLmNhdGNoKGZ1bmN0aW9uICgpIHt9KTtcbiAgfVxuICBpbml0aWFsaXplR3JhcGhpY3Moe1xuICAgIHRyYW5zcGFyZW5jeSA9IGZhbHNlLFxuICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1xuICB9KSB7XG4gICAgaWYgKHRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9jYW52YXMpIHtcbiAgICAgIGlmIChJbnRlcm5hbFJlbmRlclRhc2suI2NhbnZhc0luVXNlLmhhcyh0aGlzLl9jYW52YXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgdGhlIHNhbWUgY2FudmFzIGR1cmluZyBtdWx0aXBsZSByZW5kZXIoKSBvcGVyYXRpb25zLiBcIiArIFwiVXNlIGRpZmZlcmVudCBjYW52YXMgb3IgZW5zdXJlIHByZXZpb3VzIG9wZXJhdGlvbnMgd2VyZSBcIiArIFwiY2FuY2VsbGVkIG9yIGNvbXBsZXRlZC5cIik7XG4gICAgICB9XG4gICAgICBJbnRlcm5hbFJlbmRlclRhc2suI2NhbnZhc0luVXNlLmFkZCh0aGlzLl9jYW52YXMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcGRmQnVnICYmIGdsb2JhbFRoaXMuU3RlcHBlck1hbmFnZXI/LmVuYWJsZWQpIHtcbiAgICAgIHRoaXMuc3RlcHBlciA9IGdsb2JhbFRoaXMuU3RlcHBlck1hbmFnZXIuY3JlYXRlKHRoaXMuX3BhZ2VJbmRleCk7XG4gICAgICB0aGlzLnN0ZXBwZXIuaW5pdCh0aGlzLm9wZXJhdG9yTGlzdCk7XG4gICAgICB0aGlzLnN0ZXBwZXIubmV4dEJyZWFrUG9pbnQgPSB0aGlzLnN0ZXBwZXIuZ2V0TmV4dEJyZWFrUG9pbnQoKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY2FudmFzQ29udGV4dCxcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgdHJhbnNmb3JtLFxuICAgICAgYmFja2dyb3VuZFxuICAgIH0gPSB0aGlzLnBhcmFtcztcbiAgICB0aGlzLmdmeCA9IG5ldyBDYW52YXNHcmFwaGljcyhjYW52YXNDb250ZXh0LCB0aGlzLmNvbW1vbk9ianMsIHRoaXMub2JqcywgdGhpcy5jYW52YXNGYWN0b3J5LCB0aGlzLmZpbHRlckZhY3RvcnksIHtcbiAgICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1xuICAgIH0sIHRoaXMuYW5ub3RhdGlvbkNhbnZhc01hcCwgdGhpcy5wYWdlQ29sb3JzKTtcbiAgICB0aGlzLmdmeC5iZWdpbkRyYXdpbmcoe1xuICAgICAgdHJhbnNmb3JtLFxuICAgICAgdmlld3BvcnQsXG4gICAgICB0cmFuc3BhcmVuY3ksXG4gICAgICBiYWNrZ3JvdW5kXG4gICAgfSk7XG4gICAgdGhpcy5vcGVyYXRvckxpc3RJZHggPSAwO1xuICAgIHRoaXMuZ3JhcGhpY3NSZWFkeSA9IHRydWU7XG4gICAgdGhpcy5ncmFwaGljc1JlYWR5Q2FsbGJhY2s/LigpO1xuICB9XG4gIGNhbmNlbChlcnJvciA9IG51bGwsIGV4dHJhRGVsYXkgPSAwKSB7XG4gICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIHRoaXMuZ2Z4Py5lbmREcmF3aW5nKCk7XG4gICAgaWYgKHRoaXMuI3JBRikge1xuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuI3JBRik7XG4gICAgICB0aGlzLiNyQUYgPSBudWxsO1xuICAgIH1cbiAgICBJbnRlcm5hbFJlbmRlclRhc2suI2NhbnZhc0luVXNlLmRlbGV0ZSh0aGlzLl9jYW52YXMpO1xuICAgIHRoaXMuY2FsbGJhY2soZXJyb3IgfHwgbmV3IFJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbihgUmVuZGVyaW5nIGNhbmNlbGxlZCwgcGFnZSAke3RoaXMuX3BhZ2VJbmRleCArIDF9YCwgZXh0cmFEZWxheSkpO1xuICB9XG4gIG9wZXJhdG9yTGlzdENoYW5nZWQoKSB7XG4gICAgaWYgKCF0aGlzLmdyYXBoaWNzUmVhZHkpIHtcbiAgICAgIHRoaXMuZ3JhcGhpY3NSZWFkeUNhbGxiYWNrIHx8PSB0aGlzLl9jb250aW51ZUJvdW5kO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnN0ZXBwZXI/LnVwZGF0ZU9wZXJhdG9yTGlzdCh0aGlzLm9wZXJhdG9yTGlzdCk7XG4gICAgaWYgKHRoaXMucnVubmluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jb250aW51ZSgpO1xuICB9XG4gIF9jb250aW51ZSgpIHtcbiAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuICAgIGlmICh0aGlzLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy50YXNrLm9uQ29udGludWUpIHtcbiAgICAgIHRoaXMudGFzay5vbkNvbnRpbnVlKHRoaXMuX3NjaGVkdWxlTmV4dEJvdW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2NoZWR1bGVOZXh0KCk7XG4gICAgfVxuICB9XG4gIF9zY2hlZHVsZU5leHQoKSB7XG4gICAgaWYgKHRoaXMuX3VzZVJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgdGhpcy4jckFGID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuI3JBRiA9IG51bGw7XG4gICAgICAgIHRoaXMuX25leHRCb3VuZCgpLmNhdGNoKHRoaXMuX2NhbmNlbEJvdW5kKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKHRoaXMuX25leHRCb3VuZCkuY2F0Y2godGhpcy5fY2FuY2VsQm91bmQpO1xuICAgIH1cbiAgfVxuICBhc3luYyBfbmV4dCgpIHtcbiAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5vcGVyYXRvckxpc3RJZHggPSB0aGlzLmdmeC5leGVjdXRlT3BlcmF0b3JMaXN0KHRoaXMub3BlcmF0b3JMaXN0LCB0aGlzLm9wZXJhdG9yTGlzdElkeCwgdGhpcy5fY29udGludWVCb3VuZCwgdGhpcy5zdGVwcGVyKTtcbiAgICBpZiAodGhpcy5vcGVyYXRvckxpc3RJZHggPT09IHRoaXMub3BlcmF0b3JMaXN0LmFyZ3NBcnJheS5sZW5ndGgpIHtcbiAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMub3BlcmF0b3JMaXN0Lmxhc3RDaHVuaykge1xuICAgICAgICB0aGlzLmdmeC5lbmREcmF3aW5nKCk7XG4gICAgICAgIEludGVybmFsUmVuZGVyVGFzay4jY2FudmFzSW5Vc2UuZGVsZXRlKHRoaXMuX2NhbnZhcyk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmNvbnN0IHZlcnNpb24gPSBcIjQuOS4xNTVcIjtcbmNvbnN0IGJ1aWxkID0gXCJhNGViODQwN2NcIjtcblxuOy8vIC4vc3JjL3NoYXJlZC9zY3JpcHRpbmdfdXRpbHMuanNcbmZ1bmN0aW9uIG1ha2VDb2xvckNvbXAobikge1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBuKSkgKiAyNTUpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIik7XG59XG5mdW5jdGlvbiBzY2FsZUFuZENsYW1wKHgpIHtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgMjU1ICogeCkpO1xufVxuY2xhc3MgQ29sb3JDb252ZXJ0ZXJzIHtcbiAgc3RhdGljIENNWUtfRyhbYywgeSwgbSwga10pIHtcbiAgICByZXR1cm4gW1wiR1wiLCAxIC0gTWF0aC5taW4oMSwgMC4zICogYyArIDAuNTkgKiBtICsgMC4xMSAqIHkgKyBrKV07XG4gIH1cbiAgc3RhdGljIEdfQ01ZSyhbZ10pIHtcbiAgICByZXR1cm4gW1wiQ01ZS1wiLCAwLCAwLCAwLCAxIC0gZ107XG4gIH1cbiAgc3RhdGljIEdfUkdCKFtnXSkge1xuICAgIHJldHVybiBbXCJSR0JcIiwgZywgZywgZ107XG4gIH1cbiAgc3RhdGljIEdfcmdiKFtnXSkge1xuICAgIGcgPSBzY2FsZUFuZENsYW1wKGcpO1xuICAgIHJldHVybiBbZywgZywgZ107XG4gIH1cbiAgc3RhdGljIEdfSFRNTChbZ10pIHtcbiAgICBjb25zdCBHID0gbWFrZUNvbG9yQ29tcChnKTtcbiAgICByZXR1cm4gYCMke0d9JHtHfSR7R31gO1xuICB9XG4gIHN0YXRpYyBSR0JfRyhbciwgZywgYl0pIHtcbiAgICByZXR1cm4gW1wiR1wiLCAwLjMgKiByICsgMC41OSAqIGcgKyAwLjExICogYl07XG4gIH1cbiAgc3RhdGljIFJHQl9yZ2IoY29sb3IpIHtcbiAgICByZXR1cm4gY29sb3IubWFwKHNjYWxlQW5kQ2xhbXApO1xuICB9XG4gIHN0YXRpYyBSR0JfSFRNTChjb2xvcikge1xuICAgIHJldHVybiBgIyR7Y29sb3IubWFwKG1ha2VDb2xvckNvbXApLmpvaW4oXCJcIil9YDtcbiAgfVxuICBzdGF0aWMgVF9IVE1MKCkge1xuICAgIHJldHVybiBcIiMwMDAwMDAwMFwiO1xuICB9XG4gIHN0YXRpYyBUX3JnYigpIHtcbiAgICByZXR1cm4gW251bGxdO1xuICB9XG4gIHN0YXRpYyBDTVlLX1JHQihbYywgeSwgbSwga10pIHtcbiAgICByZXR1cm4gW1wiUkdCXCIsIDEgLSBNYXRoLm1pbigxLCBjICsgayksIDEgLSBNYXRoLm1pbigxLCBtICsgayksIDEgLSBNYXRoLm1pbigxLCB5ICsgayldO1xuICB9XG4gIHN0YXRpYyBDTVlLX3JnYihbYywgeSwgbSwga10pIHtcbiAgICByZXR1cm4gW3NjYWxlQW5kQ2xhbXAoMSAtIE1hdGgubWluKDEsIGMgKyBrKSksIHNjYWxlQW5kQ2xhbXAoMSAtIE1hdGgubWluKDEsIG0gKyBrKSksIHNjYWxlQW5kQ2xhbXAoMSAtIE1hdGgubWluKDEsIHkgKyBrKSldO1xuICB9XG4gIHN0YXRpYyBDTVlLX0hUTUwoY29tcG9uZW50cykge1xuICAgIGNvbnN0IHJnYiA9IHRoaXMuQ01ZS19SR0IoY29tcG9uZW50cykuc2xpY2UoMSk7XG4gICAgcmV0dXJuIHRoaXMuUkdCX0hUTUwocmdiKTtcbiAgfVxuICBzdGF0aWMgUkdCX0NNWUsoW3IsIGcsIGJdKSB7XG4gICAgY29uc3QgYyA9IDEgLSByO1xuICAgIGNvbnN0IG0gPSAxIC0gZztcbiAgICBjb25zdCB5ID0gMSAtIGI7XG4gICAgY29uc3QgayA9IE1hdGgubWluKGMsIG0sIHkpO1xuICAgIHJldHVybiBbXCJDTVlLXCIsIGMsIG0sIHksIGtdO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L3N2Z19mYWN0b3J5LmpzXG5cblxuY2xhc3MgQmFzZVNWR0ZhY3Rvcnkge1xuICBjcmVhdGUod2lkdGgsIGhlaWdodCwgc2tpcERpbWVuc2lvbnMgPSBmYWxzZSkge1xuICAgIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFNWRyBkaW1lbnNpb25zXCIpO1xuICAgIH1cbiAgICBjb25zdCBzdmcgPSB0aGlzLl9jcmVhdGVTVkcoXCJzdmc6c3ZnXCIpO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ2ZXJzaW9uXCIsIFwiMS4xXCIpO1xuICAgIGlmICghc2tpcERpbWVuc2lvbnMpIHtcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBgJHt3aWR0aH1weGApO1xuICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBgJHtoZWlnaHR9cHhgKTtcbiAgICB9XG4gICAgc3ZnLnNldEF0dHJpYnV0ZShcInByZXNlcnZlQXNwZWN0UmF0aW9cIiwgXCJub25lXCIpO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ2aWV3Qm94XCIsIGAwIDAgJHt3aWR0aH0gJHtoZWlnaHR9YCk7XG4gICAgcmV0dXJuIHN2ZztcbiAgfVxuICBjcmVhdGVFbGVtZW50KHR5cGUpIHtcbiAgICBpZiAodHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgU1ZHIGVsZW1lbnQgdHlwZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZVNWRyh0eXBlKTtcbiAgfVxuICBfY3JlYXRlU1ZHKHR5cGUpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IG1ldGhvZCBgX2NyZWF0ZVNWR2AgY2FsbGVkLlwiKTtcbiAgfVxufVxuY2xhc3MgRE9NU1ZHRmFjdG9yeSBleHRlbmRzIEJhc2VTVkdGYWN0b3J5IHtcbiAgX2NyZWF0ZVNWRyh0eXBlKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIHR5cGUpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L3hmYV9sYXllci5qc1xuXG5jbGFzcyBYZmFMYXllciB7XG4gIHN0YXRpYyBzZXR1cFN0b3JhZ2UoaHRtbCwgaWQsIGVsZW1lbnQsIHN0b3JhZ2UsIGludGVudCkge1xuICAgIGNvbnN0IHN0b3JlZERhdGEgPSBzdG9yYWdlLmdldFZhbHVlKGlkLCB7XG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH0pO1xuICAgIHN3aXRjaCAoZWxlbWVudC5uYW1lKSB7XG4gICAgICBjYXNlIFwidGV4dGFyZWFcIjpcbiAgICAgICAgaWYgKHN0b3JlZERhdGEudmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICBodG1sLnRleHRDb250ZW50ID0gc3RvcmVkRGF0YS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZW50ID09PSBcInByaW50XCIpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBldmVudCA9PiB7XG4gICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaW5wdXRcIjpcbiAgICAgICAgaWYgKGVsZW1lbnQuYXR0cmlidXRlcy50eXBlID09PSBcInJhZGlvXCIgfHwgZWxlbWVudC5hdHRyaWJ1dGVzLnR5cGUgPT09IFwiY2hlY2tib3hcIikge1xuICAgICAgICAgIGlmIChzdG9yZWREYXRhLnZhbHVlID09PSBlbGVtZW50LmF0dHJpYnV0ZXMueGZhT24pIHtcbiAgICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0b3JlZERhdGEudmFsdWUgPT09IGVsZW1lbnQuYXR0cmlidXRlcy54ZmFPZmYpIHtcbiAgICAgICAgICAgIGh0bWwucmVtb3ZlQXR0cmlidXRlKFwiY2hlY2tlZFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGludGVudCA9PT0gXCJwcmludFwiKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC5jaGVja2VkID8gZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZShcInhmYU9uXCIpIDogZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZShcInhmYU9mZlwiKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHN0b3JlZERhdGEudmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgc3RvcmVkRGF0YS52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbnRlbnQgPT09IFwicHJpbnRcIikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgICAgIGlmIChzdG9yZWREYXRhLnZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgaHRtbC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCBzdG9yZWREYXRhLnZhbHVlKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBlbGVtZW50LmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9uLmF0dHJpYnV0ZXMudmFsdWUgPT09IHN0b3JlZERhdGEudmFsdWUpIHtcbiAgICAgICAgICAgICAgb3B0aW9uLmF0dHJpYnV0ZXMuc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb24uYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShcInNlbGVjdGVkXCIpKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb24uYXR0cmlidXRlcy5zZWxlY3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBldmVudC50YXJnZXQub3B0aW9ucztcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9wdGlvbnMuc2VsZWN0ZWRJbmRleCA9PT0gLTEgPyBcIlwiIDogb3B0aW9uc1tvcHRpb25zLnNlbGVjdGVkSW5kZXhdLnZhbHVlO1xuICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhdGljIHNldEF0dHJpYnV0ZXMoe1xuICAgIGh0bWwsXG4gICAgZWxlbWVudCxcbiAgICBzdG9yYWdlID0gbnVsbCxcbiAgICBpbnRlbnQsXG4gICAgbGlua1NlcnZpY2VcbiAgfSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGF0dHJpYnV0ZXNcbiAgICB9ID0gZWxlbWVudDtcbiAgICBjb25zdCBpc0hUTUxBbmNob3JFbGVtZW50ID0gaHRtbCBpbnN0YW5jZW9mIEhUTUxBbmNob3JFbGVtZW50O1xuICAgIGlmIChhdHRyaWJ1dGVzLnR5cGUgPT09IFwicmFkaW9cIikge1xuICAgICAgYXR0cmlidXRlcy5uYW1lID0gYCR7YXR0cmlidXRlcy5uYW1lfS0ke2ludGVudH1gO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKSkge1xuICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICBjYXNlIFwiY2xhc3NcIjpcbiAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkYXRhSWRcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImlkXCI6XG4gICAgICAgICAgaHRtbC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGh0bWwuc3R5bGUsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRleHRDb250ZW50XCI6XG4gICAgICAgICAgaHRtbC50ZXh0Q29udGVudCA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghaXNIVE1MQW5jaG9yRWxlbWVudCB8fCBrZXkgIT09IFwiaHJlZlwiICYmIGtleSAhPT0gXCJuZXdXaW5kb3dcIikge1xuICAgICAgICAgICAgaHRtbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNIVE1MQW5jaG9yRWxlbWVudCkge1xuICAgICAgbGlua1NlcnZpY2UuYWRkTGlua0F0dHJpYnV0ZXMoaHRtbCwgYXR0cmlidXRlcy5ocmVmLCBhdHRyaWJ1dGVzLm5ld1dpbmRvdyk7XG4gICAgfVxuICAgIGlmIChzdG9yYWdlICYmIGF0dHJpYnV0ZXMuZGF0YUlkKSB7XG4gICAgICB0aGlzLnNldHVwU3RvcmFnZShodG1sLCBhdHRyaWJ1dGVzLmRhdGFJZCwgZWxlbWVudCwgc3RvcmFnZSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyByZW5kZXIocGFyYW1ldGVycykge1xuICAgIGNvbnN0IHN0b3JhZ2UgPSBwYXJhbWV0ZXJzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGxpbmtTZXJ2aWNlID0gcGFyYW1ldGVycy5saW5rU2VydmljZTtcbiAgICBjb25zdCByb290ID0gcGFyYW1ldGVycy54ZmFIdG1sO1xuICAgIGNvbnN0IGludGVudCA9IHBhcmFtZXRlcnMuaW50ZW50IHx8IFwiZGlzcGxheVwiO1xuICAgIGNvbnN0IHJvb3RIdG1sID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChyb290Lm5hbWUpO1xuICAgIGlmIChyb290LmF0dHJpYnV0ZXMpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlcyh7XG4gICAgICAgIGh0bWw6IHJvb3RIdG1sLFxuICAgICAgICBlbGVtZW50OiByb290LFxuICAgICAgICBpbnRlbnQsXG4gICAgICAgIGxpbmtTZXJ2aWNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgaXNOb3RGb3JSaWNoVGV4dCA9IGludGVudCAhPT0gXCJyaWNoVGV4dFwiO1xuICAgIGNvbnN0IHJvb3REaXYgPSBwYXJhbWV0ZXJzLmRpdjtcbiAgICByb290RGl2LmFwcGVuZChyb290SHRtbCk7XG4gICAgaWYgKHBhcmFtZXRlcnMudmlld3BvcnQpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGBtYXRyaXgoJHtwYXJhbWV0ZXJzLnZpZXdwb3J0LnRyYW5zZm9ybS5qb2luKFwiLFwiKX0pYDtcbiAgICAgIHJvb3REaXYuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIH1cbiAgICBpZiAoaXNOb3RGb3JSaWNoVGV4dCkge1xuICAgICAgcm9vdERpdi5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcInhmYUxheWVyIHhmYUZvbnRcIik7XG4gICAgfVxuICAgIGNvbnN0IHRleHREaXZzID0gW107XG4gICAgaWYgKHJvb3QuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAocm9vdC52YWx1ZSkge1xuICAgICAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocm9vdC52YWx1ZSk7XG4gICAgICAgIHJvb3RIdG1sLmFwcGVuZChub2RlKTtcbiAgICAgICAgaWYgKGlzTm90Rm9yUmljaFRleHQgJiYgWGZhVGV4dC5zaG91bGRCdWlsZFRleHQocm9vdC5uYW1lKSkge1xuICAgICAgICAgIHRleHREaXZzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRleHREaXZzXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBzdGFjayA9IFtbcm9vdCwgLTEsIHJvb3RIdG1sXV07XG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IFtwYXJlbnQsIGksIGh0bWxdID0gc3RhY2suYXQoLTEpO1xuICAgICAgaWYgKGkgKyAxID09PSBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoaWxkID0gcGFyZW50LmNoaWxkcmVuWysrc3RhY2suYXQoLTEpWzFdXTtcbiAgICAgIGlmIChjaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmFtZVxuICAgICAgfSA9IGNoaWxkO1xuICAgICAgaWYgKG5hbWUgPT09IFwiI3RleHRcIikge1xuICAgICAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY2hpbGQudmFsdWUpO1xuICAgICAgICB0ZXh0RGl2cy5wdXNoKG5vZGUpO1xuICAgICAgICBodG1sLmFwcGVuZChub2RlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGlsZEh0bWwgPSBjaGlsZD8uYXR0cmlidXRlcz8ueG1sbnMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoY2hpbGQuYXR0cmlidXRlcy54bWxucywgbmFtZSkgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpO1xuICAgICAgaHRtbC5hcHBlbmQoY2hpbGRIdG1sKTtcbiAgICAgIGlmIChjaGlsZC5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgaHRtbDogY2hpbGRIdG1sLFxuICAgICAgICAgIGVsZW1lbnQ6IGNoaWxkLFxuICAgICAgICAgIHN0b3JhZ2UsXG4gICAgICAgICAgaW50ZW50LFxuICAgICAgICAgIGxpbmtTZXJ2aWNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkLmNoaWxkcmVuPy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHN0YWNrLnB1c2goW2NoaWxkLCAtMSwgY2hpbGRIdG1sXSk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkLnZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjaGlsZC52YWx1ZSk7XG4gICAgICAgIGlmIChpc05vdEZvclJpY2hUZXh0ICYmIFhmYVRleHQuc2hvdWxkQnVpbGRUZXh0KG5hbWUpKSB7XG4gICAgICAgICAgdGV4dERpdnMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZEh0bWwuYXBwZW5kKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVsIG9mIHJvb3REaXYucXVlcnlTZWxlY3RvckFsbChcIi54ZmFOb25JbnRlcmFjdGl2ZSBpbnB1dCwgLnhmYU5vbkludGVyYWN0aXZlIHRleHRhcmVhXCIpKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJyZWFkT25seVwiLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHREaXZzXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgdXBkYXRlKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBgbWF0cml4KCR7cGFyYW1ldGVycy52aWV3cG9ydC50cmFuc2Zvcm0uam9pbihcIixcIil9KWA7XG4gICAgcGFyYW1ldGVycy5kaXYuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIHBhcmFtZXRlcnMuZGl2LmhpZGRlbiA9IGZhbHNlO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2Fubm90YXRpb25fbGF5ZXIuanNcblxuXG5cblxuXG5cbmNvbnN0IERFRkFVTFRfVEFCX0lOREVYID0gMTAwMDtcbmNvbnN0IGFubm90YXRpb25fbGF5ZXJfREVGQVVMVF9GT05UX1NJWkUgPSA5O1xuY29uc3QgR2V0RWxlbWVudHNCeU5hbWVTZXQgPSBuZXcgV2Vha1NldCgpO1xuZnVuY3Rpb24gZ2V0UmVjdERpbXMocmVjdCkge1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiByZWN0WzJdIC0gcmVjdFswXSxcbiAgICBoZWlnaHQ6IHJlY3RbM10gLSByZWN0WzFdXG4gIH07XG59XG5jbGFzcyBBbm5vdGF0aW9uRWxlbWVudEZhY3Rvcnkge1xuICBzdGF0aWMgY3JlYXRlKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBzdWJ0eXBlID0gcGFyYW1ldGVycy5kYXRhLmFubm90YXRpb25UeXBlO1xuICAgIHN3aXRjaCAoc3VidHlwZSkge1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5MSU5LOlxuICAgICAgICByZXR1cm4gbmV3IExpbmtBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuVEVYVDpcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLldJREdFVDpcbiAgICAgICAgY29uc3QgZmllbGRUeXBlID0gcGFyYW1ldGVycy5kYXRhLmZpZWxkVHlwZTtcbiAgICAgICAgc3dpdGNoIChmaWVsZFR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiVHhcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dFdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgIGNhc2UgXCJCdG5cIjpcbiAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJzLmRhdGEucmFkaW9CdXR0b24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSYWRpb0J1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbWV0ZXJzLmRhdGEuY2hlY2tCb3gpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGVja2JveFdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQdXNoQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICAgICAgY2FzZSBcIkNoXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IENob2ljZVdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgIGNhc2UgXCJTaWdcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuUE9QVVA6XG4gICAgICAgIHJldHVybiBuZXcgUG9wdXBBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuRlJFRVRFWFQ6XG4gICAgICAgIHJldHVybiBuZXcgRnJlZVRleHRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuTElORTpcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLlNRVUFSRTpcbiAgICAgICAgcmV0dXJuIG5ldyBTcXVhcmVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuQ0lSQ0xFOlxuICAgICAgICByZXR1cm4gbmV3IENpcmNsZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5QT0xZTElORTpcbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5bGluZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5DQVJFVDpcbiAgICAgICAgcmV0dXJuIG5ldyBDYXJldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5JTks6XG4gICAgICAgIHJldHVybiBuZXcgSW5rQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLlBPTFlHT046XG4gICAgICAgIHJldHVybiBuZXcgUG9seWdvbkFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5ISUdITElHSFQ6XG4gICAgICAgIHJldHVybiBuZXcgSGlnaGxpZ2h0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLlVOREVSTElORTpcbiAgICAgICAgcmV0dXJuIG5ldyBVbmRlcmxpbmVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuU1FVSUdHTFk6XG4gICAgICAgIHJldHVybiBuZXcgU3F1aWdnbHlBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuU1RSSUtFT1VUOlxuICAgICAgICByZXR1cm4gbmV3IFN0cmlrZU91dEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5TVEFNUDpcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFtcEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5GSUxFQVRUQUNITUVOVDpcbiAgICAgICAgcmV0dXJuIG5ldyBGaWxlQXR0YWNobWVudEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG5ldyBBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI3VwZGF0ZXMgPSBudWxsO1xuICAjaGFzQm9yZGVyID0gZmFsc2U7XG4gICNwb3B1cEVsZW1lbnQgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzLCB7XG4gICAgaXNSZW5kZXJhYmxlID0gZmFsc2UsXG4gICAgaWdub3JlQm9yZGVyID0gZmFsc2UsXG4gICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHMgPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICB0aGlzLmlzUmVuZGVyYWJsZSA9IGlzUmVuZGVyYWJsZTtcbiAgICB0aGlzLmRhdGEgPSBwYXJhbWV0ZXJzLmRhdGE7XG4gICAgdGhpcy5sYXllciA9IHBhcmFtZXRlcnMubGF5ZXI7XG4gICAgdGhpcy5saW5rU2VydmljZSA9IHBhcmFtZXRlcnMubGlua1NlcnZpY2U7XG4gICAgdGhpcy5kb3dubG9hZE1hbmFnZXIgPSBwYXJhbWV0ZXJzLmRvd25sb2FkTWFuYWdlcjtcbiAgICB0aGlzLmltYWdlUmVzb3VyY2VzUGF0aCA9IHBhcmFtZXRlcnMuaW1hZ2VSZXNvdXJjZXNQYXRoO1xuICAgIHRoaXMucmVuZGVyRm9ybXMgPSBwYXJhbWV0ZXJzLnJlbmRlckZvcm1zO1xuICAgIHRoaXMuc3ZnRmFjdG9yeSA9IHBhcmFtZXRlcnMuc3ZnRmFjdG9yeTtcbiAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlID0gcGFyYW1ldGVycy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICB0aGlzLmVuYWJsZVNjcmlwdGluZyA9IHBhcmFtZXRlcnMuZW5hYmxlU2NyaXB0aW5nO1xuICAgIHRoaXMuaGFzSlNBY3Rpb25zID0gcGFyYW1ldGVycy5oYXNKU0FjdGlvbnM7XG4gICAgdGhpcy5fZmllbGRPYmplY3RzID0gcGFyYW1ldGVycy5maWVsZE9iamVjdHM7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJhbWV0ZXJzLnBhcmVudDtcbiAgICBpZiAoaXNSZW5kZXJhYmxlKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMuX2NyZWF0ZUNvbnRhaW5lcihpZ25vcmVCb3JkZXIpO1xuICAgIH1cbiAgICBpZiAoY3JlYXRlUXVhZHJpbGF0ZXJhbHMpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVF1YWRyaWxhdGVyYWxzKCk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBfaGFzUG9wdXBEYXRhKHtcbiAgICB0aXRsZU9iaixcbiAgICBjb250ZW50c09iaixcbiAgICByaWNoVGV4dFxuICB9KSB7XG4gICAgcmV0dXJuICEhKHRpdGxlT2JqPy5zdHIgfHwgY29udGVudHNPYmo/LnN0ciB8fCByaWNoVGV4dD8uc3RyKTtcbiAgfVxuICBnZXQgX2lzRWRpdGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5pc0VkaXRhYmxlO1xuICB9XG4gIGdldCBoYXNQb3B1cERhdGEoKSB7XG4gICAgcmV0dXJuIEFubm90YXRpb25FbGVtZW50Ll9oYXNQb3B1cERhdGEodGhpcy5kYXRhKTtcbiAgfVxuICB1cGRhdGVFZGl0ZWQocGFyYW1zKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiN1cGRhdGVzIHx8PSB7XG4gICAgICByZWN0OiB0aGlzLmRhdGEucmVjdC5zbGljZSgwKVxuICAgIH07XG4gICAgY29uc3Qge1xuICAgICAgcmVjdFxuICAgIH0gPSBwYXJhbXM7XG4gICAgaWYgKHJlY3QpIHtcbiAgICAgIHRoaXMuI3NldFJlY3RFZGl0ZWQocmVjdCk7XG4gICAgfVxuICAgIHRoaXMuI3BvcHVwRWxlbWVudD8ucG9wdXAudXBkYXRlRWRpdGVkKHBhcmFtcyk7XG4gIH1cbiAgcmVzZXRFZGl0ZWQoKSB7XG4gICAgaWYgKCF0aGlzLiN1cGRhdGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3NldFJlY3RFZGl0ZWQodGhpcy4jdXBkYXRlcy5yZWN0KTtcbiAgICB0aGlzLiNwb3B1cEVsZW1lbnQ/LnBvcHVwLnJlc2V0RWRpdGVkKCk7XG4gICAgdGhpcy4jdXBkYXRlcyA9IG51bGw7XG4gIH1cbiAgI3NldFJlY3RFZGl0ZWQocmVjdCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRhaW5lcjoge1xuICAgICAgICBzdHlsZVxuICAgICAgfSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcmVjdDogY3VycmVudFJlY3QsXG4gICAgICAgIHJvdGF0aW9uXG4gICAgICB9LFxuICAgICAgcGFyZW50OiB7XG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgcmF3RGltczoge1xuICAgICAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICAgICAgcGFnZUhlaWdodCxcbiAgICAgICAgICAgIHBhZ2VYLFxuICAgICAgICAgICAgcGFnZVlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBjdXJyZW50UmVjdD8uc3BsaWNlKDAsIDQsIC4uLnJlY3QpO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGdldFJlY3REaW1zKHJlY3QpO1xuICAgIHN0eWxlLmxlZnQgPSBgJHsxMDAgKiAocmVjdFswXSAtIHBhZ2VYKSAvIHBhZ2VXaWR0aH0lYDtcbiAgICBzdHlsZS50b3AgPSBgJHsxMDAgKiAocGFnZUhlaWdodCAtIHJlY3RbM10gKyBwYWdlWSkgLyBwYWdlSGVpZ2h0fSVgO1xuICAgIGlmIChyb3RhdGlvbiA9PT0gMCkge1xuICAgICAgc3R5bGUud2lkdGggPSBgJHsxMDAgKiB3aWR0aCAvIHBhZ2VXaWR0aH0lYDtcbiAgICAgIHN0eWxlLmhlaWdodCA9IGAkezEwMCAqIGhlaWdodCAvIHBhZ2VIZWlnaHR9JWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0Um90YXRpb24ocm90YXRpb24pO1xuICAgIH1cbiAgfVxuICBfY3JlYXRlQ29udGFpbmVyKGlnbm9yZUJvcmRlcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICBwYXJlbnQ6IHtcbiAgICAgICAgcGFnZSxcbiAgICAgICAgdmlld3BvcnRcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiKTtcbiAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKFwiZGF0YS1hbm5vdGF0aW9uLWlkXCIsIGRhdGEuaWQpO1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCkpIHtcbiAgICAgIGNvbnRhaW5lci50YWJJbmRleCA9IERFRkFVTFRfVEFCX0lOREVYO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSBjb250YWluZXI7XG4gICAgc3R5bGUuekluZGV4ID0gdGhpcy5wYXJlbnQuekluZGV4Kys7XG4gICAgaWYgKGRhdGEuYWx0ZXJuYXRpdmVUZXh0KSB7XG4gICAgICBjb250YWluZXIudGl0bGUgPSBkYXRhLmFsdGVybmF0aXZlVGV4dDtcbiAgICB9XG4gICAgaWYgKGRhdGEubm9Sb3RhdGUpIHtcbiAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwibm9yb3RhdGVcIik7XG4gICAgfVxuICAgIGlmICghZGF0YS5yZWN0IHx8IHRoaXMgaW5zdGFuY2VvZiBQb3B1cEFubm90YXRpb25FbGVtZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJvdGF0aW9uXG4gICAgICB9ID0gZGF0YTtcbiAgICAgIGlmICghZGF0YS5oYXNPd25DYW52YXMgJiYgcm90YXRpb24gIT09IDApIHtcbiAgICAgICAgdGhpcy5zZXRSb3RhdGlvbihyb3RhdGlvbiwgY29udGFpbmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGdldFJlY3REaW1zKGRhdGEucmVjdCk7XG4gICAgaWYgKCFpZ25vcmVCb3JkZXIgJiYgZGF0YS5ib3JkZXJTdHlsZS53aWR0aCA+IDApIHtcbiAgICAgIHN0eWxlLmJvcmRlcldpZHRoID0gYCR7ZGF0YS5ib3JkZXJTdHlsZS53aWR0aH1weGA7XG4gICAgICBjb25zdCBob3Jpem9udGFsUmFkaXVzID0gZGF0YS5ib3JkZXJTdHlsZS5ob3Jpem9udGFsQ29ybmVyUmFkaXVzO1xuICAgICAgY29uc3QgdmVydGljYWxSYWRpdXMgPSBkYXRhLmJvcmRlclN0eWxlLnZlcnRpY2FsQ29ybmVyUmFkaXVzO1xuICAgICAgaWYgKGhvcml6b250YWxSYWRpdXMgPiAwIHx8IHZlcnRpY2FsUmFkaXVzID4gMCkge1xuICAgICAgICBjb25zdCByYWRpdXMgPSBgY2FsYygke2hvcml6b250YWxSYWRpdXN9cHggKiB2YXIoLS1zY2FsZS1mYWN0b3IpKSAvIGNhbGMoJHt2ZXJ0aWNhbFJhZGl1c31weCAqIHZhcigtLXNjYWxlLWZhY3RvcikpYDtcbiAgICAgICAgc3R5bGUuYm9yZGVyUmFkaXVzID0gcmFkaXVzO1xuICAgICAgfSBlbHNlIGlmICh0aGlzIGluc3RhbmNlb2YgUmFkaW9CdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCkge1xuICAgICAgICBjb25zdCByYWRpdXMgPSBgY2FsYygke3dpZHRofXB4ICogdmFyKC0tc2NhbGUtZmFjdG9yKSkgLyBjYWxjKCR7aGVpZ2h0fXB4ICogdmFyKC0tc2NhbGUtZmFjdG9yKSlgO1xuICAgICAgICBzdHlsZS5ib3JkZXJSYWRpdXMgPSByYWRpdXM7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGRhdGEuYm9yZGVyU3R5bGUuc3R5bGUpIHtcbiAgICAgICAgY2FzZSBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLlNPTElEOlxuICAgICAgICAgIHN0eWxlLmJvcmRlclN0eWxlID0gXCJzb2xpZFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuREFTSEVEOlxuICAgICAgICAgIHN0eWxlLmJvcmRlclN0eWxlID0gXCJkYXNoZWRcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLkJFVkVMRUQ6XG4gICAgICAgICAgd2FybihcIlVuaW1wbGVtZW50ZWQgYm9yZGVyIHN0eWxlOiBiZXZlbGVkXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuSU5TRVQ6XG4gICAgICAgICAgd2FybihcIlVuaW1wbGVtZW50ZWQgYm9yZGVyIHN0eWxlOiBpbnNldFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLlVOREVSTElORTpcbiAgICAgICAgICBzdHlsZS5ib3JkZXJCb3R0b21TdHlsZSA9IFwic29saWRcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJvcmRlckNvbG9yID0gZGF0YS5ib3JkZXJDb2xvciB8fCBudWxsO1xuICAgICAgaWYgKGJvcmRlckNvbG9yKSB7XG4gICAgICAgIHRoaXMuI2hhc0JvcmRlciA9IHRydWU7XG4gICAgICAgIHN0eWxlLmJvcmRlckNvbG9yID0gVXRpbC5tYWtlSGV4Q29sb3IoYm9yZGVyQ29sb3JbMF0gfCAwLCBib3JkZXJDb2xvclsxXSB8IDAsIGJvcmRlckNvbG9yWzJdIHwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZS5ib3JkZXJXaWR0aCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlY3QgPSBVdGlsLm5vcm1hbGl6ZVJlY3QoW2RhdGEucmVjdFswXSwgcGFnZS52aWV3WzNdIC0gZGF0YS5yZWN0WzFdICsgcGFnZS52aWV3WzFdLCBkYXRhLnJlY3RbMl0sIHBhZ2Uudmlld1szXSAtIGRhdGEucmVjdFszXSArIHBhZ2Uudmlld1sxXV0pO1xuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VXaWR0aCxcbiAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICBwYWdlWCxcbiAgICAgIHBhZ2VZXG4gICAgfSA9IHZpZXdwb3J0LnJhd0RpbXM7XG4gICAgc3R5bGUubGVmdCA9IGAkezEwMCAqIChyZWN0WzBdIC0gcGFnZVgpIC8gcGFnZVdpZHRofSVgO1xuICAgIHN0eWxlLnRvcCA9IGAkezEwMCAqIChyZWN0WzFdIC0gcGFnZVkpIC8gcGFnZUhlaWdodH0lYDtcbiAgICBjb25zdCB7XG4gICAgICByb3RhdGlvblxuICAgIH0gPSBkYXRhO1xuICAgIGlmIChkYXRhLmhhc093bkNhbnZhcyB8fCByb3RhdGlvbiA9PT0gMCkge1xuICAgICAgc3R5bGUud2lkdGggPSBgJHsxMDAgKiB3aWR0aCAvIHBhZ2VXaWR0aH0lYDtcbiAgICAgIHN0eWxlLmhlaWdodCA9IGAkezEwMCAqIGhlaWdodCAvIHBhZ2VIZWlnaHR9JWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0Um90YXRpb24ocm90YXRpb24sIGNvbnRhaW5lcik7XG4gICAgfVxuICAgIHJldHVybiBjb250YWluZXI7XG4gIH1cbiAgc2V0Um90YXRpb24oYW5nbGUsIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEucmVjdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0XG4gICAgfSA9IHRoaXMucGFyZW50LnZpZXdwb3J0LnJhd0RpbXM7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gZ2V0UmVjdERpbXModGhpcy5kYXRhLnJlY3QpO1xuICAgIGxldCBlbGVtZW50V2lkdGgsIGVsZW1lbnRIZWlnaHQ7XG4gICAgaWYgKGFuZ2xlICUgMTgwID09PSAwKSB7XG4gICAgICBlbGVtZW50V2lkdGggPSAxMDAgKiB3aWR0aCAvIHBhZ2VXaWR0aDtcbiAgICAgIGVsZW1lbnRIZWlnaHQgPSAxMDAgKiBoZWlnaHQgLyBwYWdlSGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50V2lkdGggPSAxMDAgKiBoZWlnaHQgLyBwYWdlV2lkdGg7XG4gICAgICBlbGVtZW50SGVpZ2h0ID0gMTAwICogd2lkdGggLyBwYWdlSGVpZ2h0O1xuICAgIH1cbiAgICBjb250YWluZXIuc3R5bGUud2lkdGggPSBgJHtlbGVtZW50V2lkdGh9JWA7XG4gICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGAke2VsZW1lbnRIZWlnaHR9JWA7XG4gICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImRhdGEtbWFpbi1yb3RhdGlvblwiLCAoMzYwIC0gYW5nbGUpICUgMzYwKTtcbiAgfVxuICBnZXQgX2NvbW1vbkFjdGlvbnMoKSB7XG4gICAgY29uc3Qgc2V0Q29sb3IgPSAoanNOYW1lLCBzdHlsZU5hbWUsIGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBjb2xvciA9IGV2ZW50LmRldGFpbFtqc05hbWVdO1xuICAgICAgY29uc3QgY29sb3JUeXBlID0gY29sb3JbMF07XG4gICAgICBjb25zdCBjb2xvckFycmF5ID0gY29sb3Iuc2xpY2UoMSk7XG4gICAgICBldmVudC50YXJnZXQuc3R5bGVbc3R5bGVOYW1lXSA9IENvbG9yQ29udmVydGVyc1tgJHtjb2xvclR5cGV9X0hUTUxgXShjb2xvckFycmF5KTtcbiAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgIFtzdHlsZU5hbWVdOiBDb2xvckNvbnZlcnRlcnNbYCR7Y29sb3JUeXBlfV9yZ2JgXShjb2xvckFycmF5KVxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2NvbW1vbkFjdGlvbnNcIiwge1xuICAgICAgZGlzcGxheTogZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZGlzcGxheVxuICAgICAgICB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICBjb25zdCBoaWRkZW4gPSBkaXNwbGF5ICUgMiA9PT0gMTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9IGhpZGRlbiA/IFwiaGlkZGVuXCIgOiBcInZpc2libGVcIjtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zZXRWYWx1ZSh0aGlzLmRhdGEuaWQsIHtcbiAgICAgICAgICBub1ZpZXc6IGhpZGRlbixcbiAgICAgICAgICBub1ByaW50OiBkaXNwbGF5ID09PSAxIHx8IGRpc3BsYXkgPT09IDJcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgcHJpbnQ6IGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zZXRWYWx1ZSh0aGlzLmRhdGEuaWQsIHtcbiAgICAgICAgICBub1ByaW50OiAhZXZlbnQuZGV0YWlsLnByaW50XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGhpZGRlbjogZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaGlkZGVuXG4gICAgICAgIH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSBoaWRkZW4gPyBcImhpZGRlblwiIDogXCJ2aXNpYmxlXCI7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgICAgbm9QcmludDogaGlkZGVuLFxuICAgICAgICAgIG5vVmlldzogaGlkZGVuXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGZvY3VzOiBldmVudCA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gZXZlbnQudGFyZ2V0LmZvY3VzKHtcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiBmYWxzZVxuICAgICAgICB9KSwgMCk7XG4gICAgICB9LFxuICAgICAgdXNlck5hbWU6IGV2ZW50ID0+IHtcbiAgICAgICAgZXZlbnQudGFyZ2V0LnRpdGxlID0gZXZlbnQuZGV0YWlsLnVzZXJOYW1lO1xuICAgICAgfSxcbiAgICAgIHJlYWRvbmx5OiBldmVudCA9PiB7XG4gICAgICAgIGV2ZW50LnRhcmdldC5kaXNhYmxlZCA9IGV2ZW50LmRldGFpbC5yZWFkb25seTtcbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDogZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLl9zZXRSZXF1aXJlZChldmVudC50YXJnZXQsIGV2ZW50LmRldGFpbC5yZXF1aXJlZCk7XG4gICAgICB9LFxuICAgICAgYmdDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcImJnQ29sb3JcIiwgXCJiYWNrZ3JvdW5kQ29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIGZpbGxDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcImZpbGxDb2xvclwiLCBcImJhY2tncm91bmRDb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgZmdDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcImZnQ29sb3JcIiwgXCJjb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgdGV4dENvbG9yOiBldmVudCA9PiB7XG4gICAgICAgIHNldENvbG9yKFwidGV4dENvbG9yXCIsIFwiY29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIGJvcmRlckNvbG9yOiBldmVudCA9PiB7XG4gICAgICAgIHNldENvbG9yKFwiYm9yZGVyQ29sb3JcIiwgXCJib3JkZXJDb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgc3Ryb2tlQ29sb3I6IGV2ZW50ID0+IHtcbiAgICAgICAgc2V0Q29sb3IoXCJzdHJva2VDb2xvclwiLCBcImJvcmRlckNvbG9yXCIsIGV2ZW50KTtcbiAgICAgIH0sXG4gICAgICByb3RhdGlvbjogZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBhbmdsZSA9IGV2ZW50LmRldGFpbC5yb3RhdGlvbjtcbiAgICAgICAgdGhpcy5zZXRSb3RhdGlvbihhbmdsZSk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgICAgcm90YXRpb246IGFuZ2xlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goYWN0aW9ucywganNFdmVudCkge1xuICAgIGNvbnN0IGNvbW1vbkFjdGlvbnMgPSB0aGlzLl9jb21tb25BY3Rpb25zO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhqc0V2ZW50LmRldGFpbCkpIHtcbiAgICAgIGNvbnN0IGFjdGlvbiA9IGFjdGlvbnNbbmFtZV0gfHwgY29tbW9uQWN0aW9uc1tuYW1lXTtcbiAgICAgIGFjdGlvbj8uKGpzRXZlbnQpO1xuICAgIH1cbiAgfVxuICBfc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoZWxlbWVudCkge1xuICAgIGlmICghdGhpcy5lbmFibGVTY3JpcHRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RvcmVkRGF0YSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2UuZ2V0UmF3VmFsdWUodGhpcy5kYXRhLmlkKTtcbiAgICBpZiAoIXN0b3JlZERhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29tbW9uQWN0aW9ucyA9IHRoaXMuX2NvbW1vbkFjdGlvbnM7XG4gICAgZm9yIChjb25zdCBbYWN0aW9uTmFtZSwgZGV0YWlsXSBvZiBPYmplY3QuZW50cmllcyhzdG9yZWREYXRhKSkge1xuICAgICAgY29uc3QgYWN0aW9uID0gY29tbW9uQWN0aW9uc1thY3Rpb25OYW1lXTtcbiAgICAgIGlmIChhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgZXZlbnRQcm94eSA9IHtcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIFthY3Rpb25OYW1lXTogZGV0YWlsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0YXJnZXQ6IGVsZW1lbnRcbiAgICAgICAgfTtcbiAgICAgICAgYWN0aW9uKGV2ZW50UHJveHkpO1xuICAgICAgICBkZWxldGUgc3RvcmVkRGF0YVthY3Rpb25OYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2NyZWF0ZVF1YWRyaWxhdGVyYWxzKCkge1xuICAgIGlmICghdGhpcy5jb250YWluZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcXVhZFBvaW50c1xuICAgIH0gPSB0aGlzLmRhdGE7XG4gICAgaWYgKCFxdWFkUG9pbnRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IFtyZWN0QmxYLCByZWN0QmxZLCByZWN0VHJYLCByZWN0VHJZXSA9IHRoaXMuZGF0YS5yZWN0Lm1hcCh4ID0+IE1hdGguZnJvdW5kKHgpKTtcbiAgICBpZiAocXVhZFBvaW50cy5sZW5ndGggPT09IDgpIHtcbiAgICAgIGNvbnN0IFt0clgsIHRyWSwgYmxYLCBibFldID0gcXVhZFBvaW50cy5zdWJhcnJheSgyLCA2KTtcbiAgICAgIGlmIChyZWN0VHJYID09PSB0clggJiYgcmVjdFRyWSA9PT0gdHJZICYmIHJlY3RCbFggPT09IGJsWCAmJiByZWN0QmxZID09PSBibFkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSB0aGlzLmNvbnRhaW5lcjtcbiAgICBsZXQgc3ZnQnVmZmVyO1xuICAgIGlmICh0aGlzLiNoYXNCb3JkZXIpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYm9yZGVyQ29sb3IsXG4gICAgICAgIGJvcmRlcldpZHRoXG4gICAgICB9ID0gc3R5bGU7XG4gICAgICBzdHlsZS5ib3JkZXJXaWR0aCA9IDA7XG4gICAgICBzdmdCdWZmZXIgPSBbXCJ1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LFwiLCBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJgLCBgIHByZXNlcnZlQXNwZWN0UmF0aW89XCJub25lXCIgdmlld0JveD1cIjAgMCAxIDFcIj5gLCBgPGcgZmlsbD1cInRyYW5zcGFyZW50XCIgc3Ryb2tlPVwiJHtib3JkZXJDb2xvcn1cIiBzdHJva2Utd2lkdGg9XCIke2JvcmRlcldpZHRofVwiPmBdO1xuICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhhc0JvcmRlclwiKTtcbiAgICB9XG4gICAgY29uc3Qgd2lkdGggPSByZWN0VHJYIC0gcmVjdEJsWDtcbiAgICBjb25zdCBoZWlnaHQgPSByZWN0VHJZIC0gcmVjdEJsWTtcbiAgICBjb25zdCB7XG4gICAgICBzdmdGYWN0b3J5XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc3ZnID0gc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnXCIpO1xuICAgIHN2Zy5jbGFzc0xpc3QuYWRkKFwicXVhZHJpbGF0ZXJhbHNDb250YWluZXJcIik7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIDApO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgMCk7XG4gICAgY29uc3QgZGVmcyA9IHN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcImRlZnNcIik7XG4gICAgc3ZnLmFwcGVuZChkZWZzKTtcbiAgICBjb25zdCBjbGlwUGF0aCA9IHN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcImNsaXBQYXRoXCIpO1xuICAgIGNvbnN0IGlkID0gYGNsaXBwYXRoXyR7dGhpcy5kYXRhLmlkfWA7XG4gICAgY2xpcFBhdGguc2V0QXR0cmlidXRlKFwiaWRcIiwgaWQpO1xuICAgIGNsaXBQYXRoLnNldEF0dHJpYnV0ZShcImNsaXBQYXRoVW5pdHNcIiwgXCJvYmplY3RCb3VuZGluZ0JveFwiKTtcbiAgICBkZWZzLmFwcGVuZChjbGlwUGF0aCk7XG4gICAgZm9yIChsZXQgaSA9IDIsIGlpID0gcXVhZFBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSA4KSB7XG4gICAgICBjb25zdCB0clggPSBxdWFkUG9pbnRzW2ldO1xuICAgICAgY29uc3QgdHJZID0gcXVhZFBvaW50c1tpICsgMV07XG4gICAgICBjb25zdCBibFggPSBxdWFkUG9pbnRzW2kgKyAyXTtcbiAgICAgIGNvbnN0IGJsWSA9IHF1YWRQb2ludHNbaSArIDNdO1xuICAgICAgY29uc3QgcmVjdCA9IHN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInJlY3RcIik7XG4gICAgICBjb25zdCB4ID0gKGJsWCAtIHJlY3RCbFgpIC8gd2lkdGg7XG4gICAgICBjb25zdCB5ID0gKHJlY3RUclkgLSB0clkpIC8gaGVpZ2h0O1xuICAgICAgY29uc3QgcmVjdFdpZHRoID0gKHRyWCAtIGJsWCkgLyB3aWR0aDtcbiAgICAgIGNvbnN0IHJlY3RIZWlnaHQgPSAodHJZIC0gYmxZKSAvIGhlaWdodDtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKFwieFwiLCB4KTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKFwieVwiLCB5KTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgcmVjdFdpZHRoKTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIHJlY3RIZWlnaHQpO1xuICAgICAgY2xpcFBhdGguYXBwZW5kKHJlY3QpO1xuICAgICAgc3ZnQnVmZmVyPy5wdXNoKGA8cmVjdCB2ZWN0b3ItZWZmZWN0PVwibm9uLXNjYWxpbmctc3Ryb2tlXCIgeD1cIiR7eH1cIiB5PVwiJHt5fVwiIHdpZHRoPVwiJHtyZWN0V2lkdGh9XCIgaGVpZ2h0PVwiJHtyZWN0SGVpZ2h0fVwiLz5gKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2hhc0JvcmRlcikge1xuICAgICAgc3ZnQnVmZmVyLnB1c2goYDwvZz48L3N2Zz4nKWApO1xuICAgICAgc3R5bGUuYmFja2dyb3VuZEltYWdlID0gc3ZnQnVmZmVyLmpvaW4oXCJcIik7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmNsaXBQYXRoID0gYHVybCgjJHtpZH0pYDtcbiAgfVxuICBfY3JlYXRlUG9wdXAoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHBvcHVwID0gdGhpcy4jcG9wdXBFbGVtZW50ID0gbmV3IFBvcHVwQW5ub3RhdGlvbkVsZW1lbnQoe1xuICAgICAgZGF0YToge1xuICAgICAgICBjb2xvcjogZGF0YS5jb2xvcixcbiAgICAgICAgdGl0bGVPYmo6IGRhdGEudGl0bGVPYmosXG4gICAgICAgIG1vZGlmaWNhdGlvbkRhdGU6IGRhdGEubW9kaWZpY2F0aW9uRGF0ZSxcbiAgICAgICAgY29udGVudHNPYmo6IGRhdGEuY29udGVudHNPYmosXG4gICAgICAgIHJpY2hUZXh0OiBkYXRhLnJpY2hUZXh0LFxuICAgICAgICBwYXJlbnRSZWN0OiBkYXRhLnJlY3QsXG4gICAgICAgIGJvcmRlclN0eWxlOiAwLFxuICAgICAgICBpZDogYHBvcHVwXyR7ZGF0YS5pZH1gLFxuICAgICAgICByb3RhdGlvbjogZGF0YS5yb3RhdGlvblxuICAgICAgfSxcbiAgICAgIHBhcmVudDogdGhpcy5wYXJlbnQsXG4gICAgICBlbGVtZW50czogW3RoaXNdXG4gICAgfSk7XG4gICAgdGhpcy5wYXJlbnQuZGl2LmFwcGVuZChwb3B1cC5yZW5kZXIoKSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIGBBbm5vdGF0aW9uRWxlbWVudC5yZW5kZXJgIGNhbGxlZFwiKTtcbiAgfVxuICBfZ2V0RWxlbWVudHNCeU5hbWUobmFtZSwgc2tpcElkID0gbnVsbCkge1xuICAgIGNvbnN0IGZpZWxkcyA9IFtdO1xuICAgIGlmICh0aGlzLl9maWVsZE9iamVjdHMpIHtcbiAgICAgIGNvbnN0IGZpZWxkT2JqID0gdGhpcy5fZmllbGRPYmplY3RzW25hbWVdO1xuICAgICAgaWYgKGZpZWxkT2JqKSB7XG4gICAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICAgIHBhZ2UsXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgZXhwb3J0VmFsdWVzXG4gICAgICAgIH0gb2YgZmllbGRPYmopIHtcbiAgICAgICAgICBpZiAocGFnZSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaWQgPT09IHNraXBJZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGV4cG9ydFZhbHVlID0gdHlwZW9mIGV4cG9ydFZhbHVlcyA9PT0gXCJzdHJpbmdcIiA/IGV4cG9ydFZhbHVlcyA6IG51bGw7XG4gICAgICAgICAgY29uc3QgZG9tRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWVsZW1lbnQtaWQ9XCIke2lkfVwiXWApO1xuICAgICAgICAgIGlmIChkb21FbGVtZW50ICYmICFHZXRFbGVtZW50c0J5TmFtZVNldC5oYXMoZG9tRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHdhcm4oYF9nZXRFbGVtZW50c0J5TmFtZSAtIGVsZW1lbnQgbm90IGFsbG93ZWQ6ICR7aWR9YCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmllbGRzLnB1c2goe1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBleHBvcnRWYWx1ZSxcbiAgICAgICAgICAgIGRvbUVsZW1lbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZpZWxkcztcbiAgICB9XG4gICAgZm9yIChjb25zdCBkb21FbGVtZW50IG9mIGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKG5hbWUpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGV4cG9ydFZhbHVlXG4gICAgICB9ID0gZG9tRWxlbWVudDtcbiAgICAgIGNvbnN0IGlkID0gZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIik7XG4gICAgICBpZiAoaWQgPT09IHNraXBJZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghR2V0RWxlbWVudHNCeU5hbWVTZXQuaGFzKGRvbUVsZW1lbnQpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZmllbGRzLnB1c2goe1xuICAgICAgICBpZCxcbiAgICAgICAgZXhwb3J0VmFsdWUsXG4gICAgICAgIGRvbUVsZW1lbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZmllbGRzO1xuICB9XG4gIHNob3coKSB7XG4gICAgaWYgKHRoaXMuY29udGFpbmVyKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5oaWRkZW4gPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5wb3B1cD8ubWF5YmVTaG93KCk7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAodGhpcy5jb250YWluZXIpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmhpZGRlbiA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMucG9wdXA/LmZvcmNlSGlkZSgpO1xuICB9XG4gIGdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgY29uc3QgdHJpZ2dlcnMgPSB0aGlzLmdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmlnZ2VycykpIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0cmlnZ2Vycykge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cmlnZ2Vycy5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgICB9XG4gIH1cbiAgX2VkaXRPbkRvdWJsZUNsaWNrKCkge1xuICAgIGlmICghdGhpcy5faXNFZGl0YWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhbm5vdGF0aW9uRWRpdG9yVHlwZTogbW9kZSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgaWQ6IGVkaXRJZFxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJkYmxjbGlja1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcInN3aXRjaGFubm90YXRpb25lZGl0b3Jtb2RlXCIsIHtcbiAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICBtb2RlLFxuICAgICAgICBlZGl0SWRcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBMaW5rQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMsIG9wdGlvbnMgPSBudWxsKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiAhIW9wdGlvbnM/Lmlnbm9yZUJvcmRlcixcbiAgICAgIGNyZWF0ZVF1YWRyaWxhdGVyYWxzOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5pc1Rvb2x0aXBPbmx5ID0gcGFyYW1ldGVycy5kYXRhLmlzVG9vbHRpcE9ubHk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICBsaW5rU2VydmljZVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICBsaW5rLnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCBkYXRhLmlkKTtcbiAgICBsZXQgaXNCb3VuZCA9IGZhbHNlO1xuICAgIGlmIChkYXRhLnVybCkge1xuICAgICAgbGlua1NlcnZpY2UuYWRkTGlua0F0dHJpYnV0ZXMobGluaywgZGF0YS51cmwsIGRhdGEubmV3V2luZG93KTtcbiAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5hY3Rpb24pIHtcbiAgICAgIHRoaXMuX2JpbmROYW1lZEFjdGlvbihsaW5rLCBkYXRhLmFjdGlvbik7XG4gICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuYXR0YWNobWVudCkge1xuICAgICAgdGhpcy4jYmluZEF0dGFjaG1lbnQobGluaywgZGF0YS5hdHRhY2htZW50LCBkYXRhLmF0dGFjaG1lbnREZXN0KTtcbiAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5zZXRPQ0dTdGF0ZSkge1xuICAgICAgdGhpcy4jYmluZFNldE9DR1N0YXRlKGxpbmssIGRhdGEuc2V0T0NHU3RhdGUpO1xuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChkYXRhLmRlc3QpIHtcbiAgICAgIHRoaXMuX2JpbmRMaW5rKGxpbmssIGRhdGEuZGVzdCk7XG4gICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRhdGEuYWN0aW9ucyAmJiAoZGF0YS5hY3Rpb25zLkFjdGlvbiB8fCBkYXRhLmFjdGlvbnNbXCJNb3VzZSBVcFwiXSB8fCBkYXRhLmFjdGlvbnNbXCJNb3VzZSBEb3duXCJdKSAmJiB0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucykge1xuICAgICAgICB0aGlzLl9iaW5kSlNBY3Rpb24obGluaywgZGF0YSk7XG4gICAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEucmVzZXRGb3JtKSB7XG4gICAgICAgIHRoaXMuX2JpbmRSZXNldEZvcm1BY3Rpb24obGluaywgZGF0YS5yZXNldEZvcm0pO1xuICAgICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1Rvb2x0aXBPbmx5ICYmICFpc0JvdW5kKSB7XG4gICAgICAgIHRoaXMuX2JpbmRMaW5rKGxpbmssIFwiXCIpO1xuICAgICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImxpbmtBbm5vdGF0aW9uXCIpO1xuICAgIGlmIChpc0JvdW5kKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQobGluayk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICAjc2V0SW50ZXJuYWxMaW5rKCkge1xuICAgIHRoaXMuY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImRhdGEtaW50ZXJuYWwtbGlua1wiLCBcIlwiKTtcbiAgfVxuICBfYmluZExpbmsobGluaywgZGVzdGluYXRpb24pIHtcbiAgICBsaW5rLmhyZWYgPSB0aGlzLmxpbmtTZXJ2aWNlLmdldERlc3RpbmF0aW9uSGFzaChkZXN0aW5hdGlvbik7XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgaWYgKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZ29Ub0Rlc3RpbmF0aW9uKGRlc3RpbmF0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGlmIChkZXN0aW5hdGlvbiB8fCBkZXN0aW5hdGlvbiA9PT0gXCJcIikge1xuICAgICAgdGhpcy4jc2V0SW50ZXJuYWxMaW5rKCk7XG4gICAgfVxuICB9XG4gIF9iaW5kTmFtZWRBY3Rpb24obGluaywgYWN0aW9uKSB7XG4gICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXRBbmNob3JVcmwoXCJcIik7XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy5saW5rU2VydmljZS5leGVjdXRlTmFtZWRBY3Rpb24oYWN0aW9uKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICB9XG4gICNiaW5kQXR0YWNobWVudChsaW5rLCBhdHRhY2htZW50LCBkZXN0ID0gbnVsbCkge1xuICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0QW5jaG9yVXJsKFwiXCIpO1xuICAgIGlmIChhdHRhY2htZW50LmRlc2NyaXB0aW9uKSB7XG4gICAgICBsaW5rLnRpdGxlID0gYXR0YWNobWVudC5kZXNjcmlwdGlvbjtcbiAgICB9XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy5kb3dubG9hZE1hbmFnZXI/Lm9wZW5PckRvd25sb2FkRGF0YShhdHRhY2htZW50LmNvbnRlbnQsIGF0dGFjaG1lbnQuZmlsZW5hbWUsIGRlc3QpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgdGhpcy4jc2V0SW50ZXJuYWxMaW5rKCk7XG4gIH1cbiAgI2JpbmRTZXRPQ0dTdGF0ZShsaW5rLCBhY3Rpb24pIHtcbiAgICBsaW5rLmhyZWYgPSB0aGlzLmxpbmtTZXJ2aWNlLmdldEFuY2hvclVybChcIlwiKTtcbiAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV4ZWN1dGVTZXRPQ0dTdGF0ZShhY3Rpb24pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgdGhpcy4jc2V0SW50ZXJuYWxMaW5rKCk7XG4gIH1cbiAgX2JpbmRKU0FjdGlvbihsaW5rLCBkYXRhKSB7XG4gICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXRBbmNob3JVcmwoXCJcIik7XG4gICAgY29uc3QgbWFwID0gbmV3IE1hcChbW1wiQWN0aW9uXCIsIFwib25jbGlja1wiXSwgW1wiTW91c2UgVXBcIiwgXCJvbm1vdXNldXBcIl0sIFtcIk1vdXNlIERvd25cIiwgXCJvbm1vdXNlZG93blwiXV0pO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhkYXRhLmFjdGlvbnMpKSB7XG4gICAgICBjb25zdCBqc05hbWUgPSBtYXAuZ2V0KG5hbWUpO1xuICAgICAgaWYgKCFqc05hbWUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsaW5rW2pzTmFtZV0gPSAoKSA9PiB7XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgaWQ6IGRhdGEuaWQsXG4gICAgICAgICAgICBuYW1lXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFsaW5rLm9uY2xpY2spIHtcbiAgICAgIGxpbmsub25jbGljayA9ICgpID0+IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLiNzZXRJbnRlcm5hbExpbmsoKTtcbiAgfVxuICBfYmluZFJlc2V0Rm9ybUFjdGlvbihsaW5rLCByZXNldEZvcm0pIHtcbiAgICBjb25zdCBvdGhlckNsaWNrQWN0aW9uID0gbGluay5vbmNsaWNrO1xuICAgIGlmICghb3RoZXJDbGlja0FjdGlvbikge1xuICAgICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXRBbmNob3JVcmwoXCJcIik7XG4gICAgfVxuICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICAgIGlmICghdGhpcy5fZmllbGRPYmplY3RzKSB7XG4gICAgICB3YXJuKGBfYmluZFJlc2V0Rm9ybUFjdGlvbiAtIFwicmVzZXRGb3JtXCIgYWN0aW9uIG5vdCBzdXBwb3J0ZWQsIGAgKyBcImVuc3VyZSB0aGF0IHRoZSBgZmllbGRPYmplY3RzYCBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQuXCIpO1xuICAgICAgaWYgKCFvdGhlckNsaWNrQWN0aW9uKSB7XG4gICAgICAgIGxpbmsub25jbGljayA9ICgpID0+IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICBvdGhlckNsaWNrQWN0aW9uPy4oKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZmllbGRzOiByZXNldEZvcm1GaWVsZHMsXG4gICAgICAgIHJlZnM6IHJlc2V0Rm9ybVJlZnMsXG4gICAgICAgIGluY2x1ZGVcbiAgICAgIH0gPSByZXNldEZvcm07XG4gICAgICBjb25zdCBhbGxGaWVsZHMgPSBbXTtcbiAgICAgIGlmIChyZXNldEZvcm1GaWVsZHMubGVuZ3RoICE9PSAwIHx8IHJlc2V0Rm9ybVJlZnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkSWRzID0gbmV3IFNldChyZXNldEZvcm1SZWZzKTtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZE5hbWUgb2YgcmVzZXRGb3JtRmllbGRzKSB7XG4gICAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy5fZmllbGRPYmplY3RzW2ZpZWxkTmFtZV0gfHwgW107XG4gICAgICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgICAgICBpZFxuICAgICAgICAgIH0gb2YgZmllbGRzKSB7XG4gICAgICAgICAgICBmaWVsZElkcy5hZGQoaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkcyBvZiBPYmplY3QudmFsdWVzKHRoaXMuX2ZpZWxkT2JqZWN0cykpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgICAgICAgICAgaWYgKGZpZWxkSWRzLmhhcyhmaWVsZC5pZCkgPT09IGluY2x1ZGUpIHtcbiAgICAgICAgICAgICAgYWxsRmllbGRzLnB1c2goZmllbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZHMgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLl9maWVsZE9iamVjdHMpKSB7XG4gICAgICAgICAgYWxsRmllbGRzLnB1c2goLi4uZmllbGRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgICBjb25zdCBhbGxJZHMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgYWxsRmllbGRzKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBpZFxuICAgICAgICB9ID0gZmllbGQ7XG4gICAgICAgIGFsbElkcy5wdXNoKGlkKTtcbiAgICAgICAgc3dpdGNoIChmaWVsZC50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBmaWVsZC5kZWZhdWx0VmFsdWUgfHwgXCJcIjtcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiY2hlY2tib3hcIjpcbiAgICAgICAgICBjYXNlIFwicmFkaW9idXR0b25cIjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBmaWVsZC5kZWZhdWx0VmFsdWUgPT09IGZpZWxkLmV4cG9ydFZhbHVlcztcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiY29tYm9ib3hcIjpcbiAgICAgICAgICBjYXNlIFwibGlzdGJveFwiOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGZpZWxkLmRlZmF1bHRWYWx1ZSB8fCBcIlwiO1xuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkb21FbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtZWxlbWVudC1pZD1cIiR7aWR9XCJdYCk7XG4gICAgICAgIGlmICghZG9tRWxlbWVudCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKCFHZXRFbGVtZW50c0J5TmFtZVNldC5oYXMoZG9tRWxlbWVudCkpIHtcbiAgICAgICAgICB3YXJuKGBfYmluZFJlc2V0Rm9ybUFjdGlvbiAtIGVsZW1lbnQgbm90IGFsbG93ZWQ6ICR7aWR9YCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZG9tRWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInJlc2V0Zm9ybVwiKSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5lbmFibGVTY3JpcHRpbmcpIHtcbiAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBpZDogXCJhcHBcIixcbiAgICAgICAgICAgIGlkczogYWxsSWRzLFxuICAgICAgICAgICAgbmFtZTogXCJSZXNldEZvcm1cIlxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgfVxufVxuY2xhc3MgVGV4dEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJ0ZXh0QW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCBpbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgaW1hZ2Uuc3JjID0gdGhpcy5pbWFnZVJlc291cmNlc1BhdGggKyBcImFubm90YXRpb24tXCIgKyB0aGlzLmRhdGEubmFtZS50b0xvd2VyQ2FzZSgpICsgXCIuc3ZnXCI7XG4gICAgaW1hZ2Uuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtdGV4dC1hbm5vdGF0aW9uLXR5cGVcIik7XG4gICAgaW1hZ2Uuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWFyZ3NcIiwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgdHlwZTogdGhpcy5kYXRhLm5hbWVcbiAgICB9KSk7XG4gICAgaWYgKCF0aGlzLmRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChpbWFnZSk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBzaG93RWxlbWVudEFuZEhpZGVDYW52YXMoZWxlbWVudCkge1xuICAgIGlmICh0aGlzLmRhdGEuaGFzT3duQ2FudmFzKSB7XG4gICAgICBpZiAoZWxlbWVudC5wcmV2aW91c1NpYmxpbmc/Lm5vZGVOYW1lID09PSBcIkNBTlZBU1wiKSB7XG4gICAgICAgIGVsZW1lbnQucHJldmlvdXNTaWJsaW5nLmhpZGRlbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBlbGVtZW50LmhpZGRlbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBfZ2V0S2V5TW9kaWZpZXIoZXZlbnQpIHtcbiAgICByZXR1cm4gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybS5pc01hYyA/IGV2ZW50Lm1ldGFLZXkgOiBldmVudC5jdHJsS2V5O1xuICB9XG4gIF9zZXRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBiYXNlTmFtZSwgZXZlbnROYW1lLCB2YWx1ZUdldHRlcikge1xuICAgIGlmIChiYXNlTmFtZS5pbmNsdWRlcyhcIm1vdXNlXCIpKSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoYmFzZU5hbWUsIGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBpZDogdGhpcy5kYXRhLmlkLFxuICAgICAgICAgICAgbmFtZTogZXZlbnROYW1lLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlR2V0dGVyKGV2ZW50KSxcbiAgICAgICAgICAgIHNoaWZ0OiBldmVudC5zaGlmdEtleSxcbiAgICAgICAgICAgIG1vZGlmaWVyOiB0aGlzLl9nZXRLZXlNb2RpZmllcihldmVudClcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihiYXNlTmFtZSwgZXZlbnQgPT4ge1xuICAgICAgICBpZiAoYmFzZU5hbWUgPT09IFwiYmx1clwiKSB7XG4gICAgICAgICAgaWYgKCFlbGVtZW50RGF0YS5mb2N1c2VkIHx8ICFldmVudC5yZWxhdGVkVGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnREYXRhLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChiYXNlTmFtZSA9PT0gXCJmb2N1c1wiKSB7XG4gICAgICAgICAgaWYgKGVsZW1lbnREYXRhLmZvY3VzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudERhdGEuZm9jdXNlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2YWx1ZUdldHRlcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmRhdGEuaWQsXG4gICAgICAgICAgICBuYW1lOiBldmVudE5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVHZXR0ZXIoZXZlbnQpXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBfc2V0RXZlbnRMaXN0ZW5lcnMoZWxlbWVudCwgZWxlbWVudERhdGEsIG5hbWVzLCBnZXR0ZXIpIHtcbiAgICBmb3IgKGNvbnN0IFtiYXNlTmFtZSwgZXZlbnROYW1lXSBvZiBuYW1lcykge1xuICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gXCJBY3Rpb25cIiB8fCB0aGlzLmRhdGEuYWN0aW9ucz8uW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gXCJGb2N1c1wiIHx8IGV2ZW50TmFtZSA9PT0gXCJCbHVyXCIpIHtcbiAgICAgICAgICBlbGVtZW50RGF0YSB8fD0ge1xuICAgICAgICAgICAgZm9jdXNlZDogZmFsc2VcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZWxlbWVudERhdGEsIGJhc2VOYW1lLCBldmVudE5hbWUsIGdldHRlcik7XG4gICAgICAgIGlmIChldmVudE5hbWUgPT09IFwiRm9jdXNcIiAmJiAhdGhpcy5kYXRhLmFjdGlvbnM/LkJsdXIpIHtcbiAgICAgICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBcImJsdXJcIiwgXCJCbHVyXCIsIG51bGwpO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gXCJCbHVyXCIgJiYgIXRoaXMuZGF0YS5hY3Rpb25zPy5Gb2N1cykge1xuICAgICAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZWxlbWVudERhdGEsIFwiZm9jdXNcIiwgXCJGb2N1c1wiLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBfc2V0QmFja2dyb3VuZENvbG9yKGVsZW1lbnQpIHtcbiAgICBjb25zdCBjb2xvciA9IHRoaXMuZGF0YS5iYWNrZ3JvdW5kQ29sb3IgfHwgbnVsbDtcbiAgICBlbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yID09PSBudWxsID8gXCJ0cmFuc3BhcmVudFwiIDogVXRpbC5tYWtlSGV4Q29sb3IoY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSk7XG4gIH1cbiAgX3NldFRleHRTdHlsZShlbGVtZW50KSB7XG4gICAgY29uc3QgVEVYVF9BTElHTk1FTlQgPSBbXCJsZWZ0XCIsIFwiY2VudGVyXCIsIFwicmlnaHRcIl07XG4gICAgY29uc3Qge1xuICAgICAgZm9udENvbG9yXG4gICAgfSA9IHRoaXMuZGF0YS5kZWZhdWx0QXBwZWFyYW5jZURhdGE7XG4gICAgY29uc3QgZm9udFNpemUgPSB0aGlzLmRhdGEuZGVmYXVsdEFwcGVhcmFuY2VEYXRhLmZvbnRTaXplIHx8IGFubm90YXRpb25fbGF5ZXJfREVGQVVMVF9GT05UX1NJWkU7XG4gICAgY29uc3Qgc3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuICAgIGxldCBjb21wdXRlZEZvbnRTaXplO1xuICAgIGNvbnN0IEJPUkRFUl9TSVpFID0gMjtcbiAgICBjb25zdCByb3VuZFRvT25lRGVjaW1hbCA9IHggPT4gTWF0aC5yb3VuZCgxMCAqIHgpIC8gMTA7XG4gICAgaWYgKHRoaXMuZGF0YS5tdWx0aUxpbmUpIHtcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGguYWJzKHRoaXMuZGF0YS5yZWN0WzNdIC0gdGhpcy5kYXRhLnJlY3RbMV0gLSBCT1JERVJfU0laRSk7XG4gICAgICBjb25zdCBudW1iZXJPZkxpbmVzID0gTWF0aC5yb3VuZChoZWlnaHQgLyAoTElORV9GQUNUT1IgKiBmb250U2l6ZSkpIHx8IDE7XG4gICAgICBjb25zdCBsaW5lSGVpZ2h0ID0gaGVpZ2h0IC8gbnVtYmVyT2ZMaW5lcztcbiAgICAgIGNvbXB1dGVkRm9udFNpemUgPSBNYXRoLm1pbihmb250U2l6ZSwgcm91bmRUb09uZURlY2ltYWwobGluZUhlaWdodCAvIExJTkVfRkFDVE9SKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGguYWJzKHRoaXMuZGF0YS5yZWN0WzNdIC0gdGhpcy5kYXRhLnJlY3RbMV0gLSBCT1JERVJfU0laRSk7XG4gICAgICBjb21wdXRlZEZvbnRTaXplID0gTWF0aC5taW4oZm9udFNpemUsIHJvdW5kVG9PbmVEZWNpbWFsKGhlaWdodCAvIExJTkVfRkFDVE9SKSk7XG4gICAgfVxuICAgIHN0eWxlLmZvbnRTaXplID0gYGNhbGMoJHtjb21wdXRlZEZvbnRTaXplfXB4ICogdmFyKC0tc2NhbGUtZmFjdG9yKSlgO1xuICAgIHN0eWxlLmNvbG9yID0gVXRpbC5tYWtlSGV4Q29sb3IoZm9udENvbG9yWzBdLCBmb250Q29sb3JbMV0sIGZvbnRDb2xvclsyXSk7XG4gICAgaWYgKHRoaXMuZGF0YS50ZXh0QWxpZ25tZW50ICE9PSBudWxsKSB7XG4gICAgICBzdHlsZS50ZXh0QWxpZ24gPSBURVhUX0FMSUdOTUVOVFt0aGlzLmRhdGEudGV4dEFsaWdubWVudF07XG4gICAgfVxuICB9XG4gIF9zZXRSZXF1aXJlZChlbGVtZW50LCBpc1JlcXVpcmVkKSB7XG4gICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwicmVxdWlyZWRcIiwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwicmVxdWlyZWRcIik7XG4gICAgfVxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1yZXF1aXJlZFwiLCBpc1JlcXVpcmVkKTtcbiAgfVxufVxuY2xhc3MgVGV4dFdpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgaXNSZW5kZXJhYmxlID0gcGFyYW1ldGVycy5yZW5kZXJGb3JtcyB8fCBwYXJhbWV0ZXJzLmRhdGEuaGFzT3duQ2FudmFzIHx8ICFwYXJhbWV0ZXJzLmRhdGEuaGFzQXBwZWFyYW5jZSAmJiAhIXBhcmFtZXRlcnMuZGF0YS5maWVsZFZhbHVlO1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZVxuICAgIH0pO1xuICB9XG4gIHNldFByb3BlcnR5T25TaWJsaW5ncyhiYXNlLCBrZXksIHZhbHVlLCBrZXlJblN0b3JhZ2UpIHtcbiAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy5fZ2V0RWxlbWVudHNCeU5hbWUoYmFzZS5uYW1lLCBiYXNlLmlkKSkge1xuICAgICAgaWYgKGVsZW1lbnQuZG9tRWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LmRvbUVsZW1lbnRba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShlbGVtZW50LmlkLCB7XG4gICAgICAgIFtrZXlJblN0b3JhZ2VdOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBjb25zdCBpZCA9IHRoaXMuZGF0YS5pZDtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwidGV4dFdpZGdldEFubm90YXRpb25cIik7XG4gICAgbGV0IGVsZW1lbnQgPSBudWxsO1xuICAgIGlmICh0aGlzLnJlbmRlckZvcm1zKSB7XG4gICAgICBjb25zdCBzdG9yZWREYXRhID0gc3RvcmFnZS5nZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZTogdGhpcy5kYXRhLmZpZWxkVmFsdWVcbiAgICAgIH0pO1xuICAgICAgbGV0IHRleHRDb250ZW50ID0gc3RvcmVkRGF0YS52YWx1ZSB8fCBcIlwiO1xuICAgICAgY29uc3QgbWF4TGVuID0gc3RvcmFnZS5nZXRWYWx1ZShpZCwge1xuICAgICAgICBjaGFyTGltaXQ6IHRoaXMuZGF0YS5tYXhMZW5cbiAgICAgIH0pLmNoYXJMaW1pdDtcbiAgICAgIGlmIChtYXhMZW4gJiYgdGV4dENvbnRlbnQubGVuZ3RoID4gbWF4TGVuKSB7XG4gICAgICAgIHRleHRDb250ZW50ID0gdGV4dENvbnRlbnQuc2xpY2UoMCwgbWF4TGVuKTtcbiAgICAgIH1cbiAgICAgIGxldCBmaWVsZEZvcm1hdHRlZFZhbHVlcyA9IHN0b3JlZERhdGEuZm9ybWF0dGVkVmFsdWUgfHwgdGhpcy5kYXRhLnRleHRDb250ZW50Py5qb2luKFwiXFxuXCIpIHx8IG51bGw7XG4gICAgICBpZiAoZmllbGRGb3JtYXR0ZWRWYWx1ZXMgJiYgdGhpcy5kYXRhLmNvbWIpIHtcbiAgICAgICAgZmllbGRGb3JtYXR0ZWRWYWx1ZXMgPSBmaWVsZEZvcm1hdHRlZFZhbHVlcy5yZXBsYWNlQWxsKC9cXHMrL2csIFwiXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgZWxlbWVudERhdGEgPSB7XG4gICAgICAgIHVzZXJWYWx1ZTogdGV4dENvbnRlbnQsXG4gICAgICAgIGZvcm1hdHRlZFZhbHVlOiBmaWVsZEZvcm1hdHRlZFZhbHVlcyxcbiAgICAgICAgbGFzdENvbW1pdHRlZFZhbHVlOiBudWxsLFxuICAgICAgICBjb21taXRLZXk6IDEsXG4gICAgICAgIGZvY3VzZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuZGF0YS5tdWx0aUxpbmUpIHtcbiAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKTtcbiAgICAgICAgZWxlbWVudC50ZXh0Q29udGVudCA9IGZpZWxkRm9ybWF0dGVkVmFsdWVzID8/IHRleHRDb250ZW50O1xuICAgICAgICBpZiAodGhpcy5kYXRhLmRvTm90U2Nyb2xsKSB7XG4gICAgICAgICAgZWxlbWVudC5zdHlsZS5vdmVyZmxvd1kgPSBcImhpZGRlblwiO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICBlbGVtZW50LnR5cGUgPSBcInRleHRcIjtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCBmaWVsZEZvcm1hdHRlZFZhbHVlcyA/PyB0ZXh0Q29udGVudCk7XG4gICAgICAgIGlmICh0aGlzLmRhdGEuZG9Ob3RTY3JvbGwpIHtcbiAgICAgICAgICBlbGVtZW50LnN0eWxlLm92ZXJmbG93WCA9IFwiaGlkZGVuXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRhdGEuaGFzT3duQ2FudmFzKSB7XG4gICAgICAgIGVsZW1lbnQuaGlkZGVuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIEdldEVsZW1lbnRzQnlOYW1lU2V0LmFkZChlbGVtZW50KTtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIsIGlkKTtcbiAgICAgIGVsZW1lbnQuZGlzYWJsZWQgPSB0aGlzLmRhdGEucmVhZE9ubHk7XG4gICAgICBlbGVtZW50Lm5hbWUgPSB0aGlzLmRhdGEuZmllbGROYW1lO1xuICAgICAgZWxlbWVudC50YWJJbmRleCA9IERFRkFVTFRfVEFCX0lOREVYO1xuICAgICAgdGhpcy5fc2V0UmVxdWlyZWQoZWxlbWVudCwgdGhpcy5kYXRhLnJlcXVpcmVkKTtcbiAgICAgIGlmIChtYXhMZW4pIHtcbiAgICAgICAgZWxlbWVudC5tYXhMZW5ndGggPSBtYXhMZW47XG4gICAgICB9XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBldmVudCA9PiB7XG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICB2YWx1ZTogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldFByb3BlcnR5T25TaWJsaW5ncyhlbGVtZW50LCBcInZhbHVlXCIsIGV2ZW50LnRhcmdldC52YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgZWxlbWVudERhdGEuZm9ybWF0dGVkVmFsdWUgPSBudWxsO1xuICAgICAgfSk7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNldGZvcm1cIiwgZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSB0aGlzLmRhdGEuZGVmYXVsdEZpZWxkVmFsdWUgPz8gXCJcIjtcbiAgICAgICAgZWxlbWVudC52YWx1ZSA9IGVsZW1lbnREYXRhLnVzZXJWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgZWxlbWVudERhdGEuZm9ybWF0dGVkVmFsdWUgPSBudWxsO1xuICAgICAgfSk7XG4gICAgICBsZXQgYmx1ckxpc3RlbmVyID0gZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZm9ybWF0dGVkVmFsdWVcbiAgICAgICAgfSA9IGVsZW1lbnREYXRhO1xuICAgICAgICBpZiAoZm9ybWF0dGVkVmFsdWUgIT09IG51bGwgJiYgZm9ybWF0dGVkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IGZvcm1hdHRlZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnRhcmdldC5zY3JvbGxMZWZ0ID0gMDtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5lbmFibGVTY3JpcHRpbmcgJiYgdGhpcy5oYXNKU0FjdGlvbnMpIHtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgIGlmIChlbGVtZW50RGF0YS5mb2N1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHRhcmdldFxuICAgICAgICAgIH0gPSBldmVudDtcbiAgICAgICAgICBpZiAoZWxlbWVudERhdGEudXNlclZhbHVlKSB7XG4gICAgICAgICAgICB0YXJnZXQudmFsdWUgPSBlbGVtZW50RGF0YS51c2VyVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSA9IHRhcmdldC52YWx1ZTtcbiAgICAgICAgICBlbGVtZW50RGF0YS5jb21taXRLZXkgPSAxO1xuICAgICAgICAgIGlmICghdGhpcy5kYXRhLmFjdGlvbnM/LkZvY3VzKSB7XG4gICAgICAgICAgICBlbGVtZW50RGF0YS5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBqc0V2ZW50ID0+IHtcbiAgICAgICAgICB0aGlzLnNob3dFbGVtZW50QW5kSGlkZUNhbnZhcyhqc0V2ZW50LnRhcmdldCk7XG4gICAgICAgICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgICAgICAgIHZhbHVlKGV2ZW50KSB7XG4gICAgICAgICAgICAgIGVsZW1lbnREYXRhLnVzZXJWYWx1ZSA9IGV2ZW50LmRldGFpbC52YWx1ZSA/PyBcIlwiO1xuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGVsZW1lbnREYXRhLnVzZXJWYWx1ZS50b1N0cmluZygpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSBlbGVtZW50RGF0YS51c2VyVmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWUoZXZlbnQpIHtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlXG4gICAgICAgICAgICAgIH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgICAgICAgIGVsZW1lbnREYXRhLmZvcm1hdHRlZFZhbHVlID0gZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgICAgICAgIGlmIChmb3JtYXR0ZWRWYWx1ZSAhPT0gbnVsbCAmJiBmb3JtYXR0ZWRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIGV2ZW50LnRhcmdldCAhPT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IGZvcm1hdHRlZFZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWxSYW5nZShldmVudCkge1xuICAgICAgICAgICAgICBldmVudC50YXJnZXQuc2V0U2VsZWN0aW9uUmFuZ2UoLi4uZXZlbnQuZGV0YWlsLnNlbFJhbmdlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaGFyTGltaXQ6IGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGNoYXJMaW1pdFxuICAgICAgICAgICAgICB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICAgICAgIH0gPSBldmVudDtcbiAgICAgICAgICAgICAgaWYgKGNoYXJMaW1pdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJtYXhMZW5ndGhcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJtYXhMZW5ndGhcIiwgY2hhckxpbWl0KTtcbiAgICAgICAgICAgICAgbGV0IHZhbHVlID0gZWxlbWVudERhdGEudXNlclZhbHVlO1xuICAgICAgICAgICAgICBpZiAoIXZhbHVlIHx8IHZhbHVlLmxlbmd0aCA8PSBjaGFyTGltaXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCBjaGFyTGltaXQpO1xuICAgICAgICAgICAgICB0YXJnZXQudmFsdWUgPSBlbGVtZW50RGF0YS51c2VyVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgd2lsbENvbW1pdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdEtleTogMSxcbiAgICAgICAgICAgICAgICAgIHNlbFN0YXJ0OiB0YXJnZXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgICAgICBzZWxFbmQ6IHRhcmdldC5zZWxlY3Rpb25FbmRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudEZyb21TYW5kYm94KGFjdGlvbnMsIGpzRXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBldmVudCA9PiB7XG4gICAgICAgICAgZWxlbWVudERhdGEuY29tbWl0S2V5ID0gMTtcbiAgICAgICAgICBsZXQgY29tbWl0S2V5ID0gLTE7XG4gICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCJFc2NhcGVcIikge1xuICAgICAgICAgICAgY29tbWl0S2V5ID0gMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gXCJFbnRlclwiICYmICF0aGlzLmRhdGEubXVsdGlMaW5lKSB7XG4gICAgICAgICAgICBjb21taXRLZXkgPSAyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5ID09PSBcIlRhYlwiKSB7XG4gICAgICAgICAgICBlbGVtZW50RGF0YS5jb21taXRLZXkgPSAzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29tbWl0S2V5ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0gPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgaWYgKGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudERhdGEubGFzdENvbW1pdHRlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgZWxlbWVudERhdGEudXNlclZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIHdpbGxDb21taXQ6IHRydWUsXG4gICAgICAgICAgICAgIGNvbW1pdEtleSxcbiAgICAgICAgICAgICAgc2VsU3RhcnQ6IGV2ZW50LnRhcmdldC5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgICAgc2VsRW5kOiBldmVudC50YXJnZXQuc2VsZWN0aW9uRW5kXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBfYmx1ckxpc3RlbmVyID0gYmx1ckxpc3RlbmVyO1xuICAgICAgICBibHVyTGlzdGVuZXIgPSBudWxsO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICBpZiAoIWVsZW1lbnREYXRhLmZvY3VzZWQgfHwgIWV2ZW50LnJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLmRhdGEuYWN0aW9ucz8uQmx1cikge1xuICAgICAgICAgICAgZWxlbWVudERhdGEuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0gPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgZWxlbWVudERhdGEudXNlclZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgaWYgKGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB3aWxsQ29tbWl0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbW1pdEtleTogZWxlbWVudERhdGEuY29tbWl0S2V5LFxuICAgICAgICAgICAgICAgIHNlbFN0YXJ0OiBldmVudC50YXJnZXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgICAgc2VsRW5kOiBldmVudC50YXJnZXQuc2VsZWN0aW9uRW5kXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfYmx1ckxpc3RlbmVyKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmRhdGEuYWN0aW9ucz8uS2V5c3Ryb2tlKSB7XG4gICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JlaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgICAgZWxlbWVudERhdGEubGFzdENvbW1pdHRlZFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICAgICB9ID0gZXZlbnQ7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICBzZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgICAgc2VsZWN0aW9uRW5kXG4gICAgICAgICAgICB9ID0gdGFyZ2V0O1xuICAgICAgICAgICAgbGV0IHNlbFN0YXJ0ID0gc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgIHNlbEVuZCA9IHNlbGVjdGlvbkVuZDtcbiAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQuaW5wdXRUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJkZWxldGVXb3JkQmFja3dhcmRcIjpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IHZhbHVlLnN1YnN0cmluZygwLCBzZWxlY3Rpb25TdGFydCkubWF0Y2goL1xcdypbXlxcd10qJC8pO1xuICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbFN0YXJ0IC09IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSBcImRlbGV0ZVdvcmRGb3J3YXJkXCI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB2YWx1ZS5zdWJzdHJpbmcoc2VsZWN0aW9uU3RhcnQpLm1hdGNoKC9eW15cXHddKlxcdyovKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxFbmQgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIFwiZGVsZXRlQ29udGVudEJhY2t3YXJkXCI6XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0ID09PSBzZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgICAgICAgICAgIHNlbFN0YXJ0IC09IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiZGVsZXRlQ29udGVudEZvcndhcmRcIjpcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgPT09IHNlbGVjdGlvbkVuZCkge1xuICAgICAgICAgICAgICAgICAgc2VsRW5kICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBjaGFuZ2U6IGRhdGEgfHwgXCJcIixcbiAgICAgICAgICAgICAgICB3aWxsQ29tbWl0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzZWxTdGFydCxcbiAgICAgICAgICAgICAgICBzZWxFbmRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcnMoZWxlbWVudCwgZWxlbWVudERhdGEsIFtbXCJmb2N1c1wiLCBcIkZvY3VzXCJdLCBbXCJibHVyXCIsIFwiQmx1clwiXSwgW1wibW91c2Vkb3duXCIsIFwiTW91c2UgRG93blwiXSwgW1wibW91c2VlbnRlclwiLCBcIk1vdXNlIEVudGVyXCJdLCBbXCJtb3VzZWxlYXZlXCIsIFwiTW91c2UgRXhpdFwiXSwgW1wibW91c2V1cFwiLCBcIk1vdXNlIFVwXCJdXSwgZXZlbnQgPT4gZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChibHVyTGlzdGVuZXIpIHtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBibHVyTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZGF0YS5jb21iKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkV2lkdGggPSB0aGlzLmRhdGEucmVjdFsyXSAtIHRoaXMuZGF0YS5yZWN0WzBdO1xuICAgICAgICBjb25zdCBjb21iV2lkdGggPSBmaWVsZFdpZHRoIC8gbWF4TGVuO1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJjb21iXCIpO1xuICAgICAgICBlbGVtZW50LnN0eWxlLmxldHRlclNwYWNpbmcgPSBgY2FsYygke2NvbWJXaWR0aH1weCAqIHZhcigtLXNjYWxlLWZhY3RvcikgLSAxY2gpYDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBlbGVtZW50LnRleHRDb250ZW50ID0gdGhpcy5kYXRhLmZpZWxkVmFsdWU7XG4gICAgICBlbGVtZW50LnN0eWxlLnZlcnRpY2FsQWxpZ24gPSBcIm1pZGRsZVwiO1xuICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJ0YWJsZS1jZWxsXCI7XG4gICAgICBpZiAodGhpcy5kYXRhLmhhc093bkNhbnZhcykge1xuICAgICAgICBlbGVtZW50LmhpZGRlbiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3NldFRleHRTdHlsZShlbGVtZW50KTtcbiAgICB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3IoZWxlbWVudCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoZWxlbWVudCk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGVsZW1lbnQpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgU2lnbmF0dXJlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6ICEhcGFyYW1ldGVycy5kYXRhLmhhc093bkNhbnZhc1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBDaGVja2JveFdpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiBwYXJhbWV0ZXJzLnJlbmRlckZvcm1zXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3QgaWQgPSBkYXRhLmlkO1xuICAgIGxldCB2YWx1ZSA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgIHZhbHVlOiBkYXRhLmV4cG9ydFZhbHVlID09PSBkYXRhLmZpZWxkVmFsdWVcbiAgICB9KS52YWx1ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlICE9PSBcIk9mZlwiO1xuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJidXR0b25XaWRnZXRBbm5vdGF0aW9uXCIsIFwiY2hlY2tCb3hcIik7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBHZXRFbGVtZW50c0J5TmFtZVNldC5hZGQoZWxlbWVudCk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIiwgaWQpO1xuICAgIGVsZW1lbnQuZGlzYWJsZWQgPSBkYXRhLnJlYWRPbmx5O1xuICAgIHRoaXMuX3NldFJlcXVpcmVkKGVsZW1lbnQsIHRoaXMuZGF0YS5yZXF1aXJlZCk7XG4gICAgZWxlbWVudC50eXBlID0gXCJjaGVja2JveFwiO1xuICAgIGVsZW1lbnQubmFtZSA9IGRhdGEuZmllbGROYW1lO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIsIHRydWUpO1xuICAgIH1cbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImV4cG9ydFZhbHVlXCIsIGRhdGEuZXhwb3J0VmFsdWUpO1xuICAgIGVsZW1lbnQudGFiSW5kZXggPSBERUZBVUxUX1RBQl9JTkRFWDtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgZXZlbnQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBuYW1lLFxuICAgICAgICBjaGVja2VkXG4gICAgICB9ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgZm9yIChjb25zdCBjaGVja2JveCBvZiB0aGlzLl9nZXRFbGVtZW50c0J5TmFtZShuYW1lLCBpZCkpIHtcbiAgICAgICAgY29uc3QgY3VyQ2hlY2tlZCA9IGNoZWNrZWQgJiYgY2hlY2tib3guZXhwb3J0VmFsdWUgPT09IGRhdGEuZXhwb3J0VmFsdWU7XG4gICAgICAgIGlmIChjaGVja2JveC5kb21FbGVtZW50KSB7XG4gICAgICAgICAgY2hlY2tib3guZG9tRWxlbWVudC5jaGVja2VkID0gY3VyQ2hlY2tlZDtcbiAgICAgICAgfVxuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGNoZWNrYm94LmlkLCB7XG4gICAgICAgICAgdmFsdWU6IGN1ckNoZWNrZWRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgIHZhbHVlOiBjaGVja2VkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNldGZvcm1cIiwgZXZlbnQgPT4ge1xuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gZGF0YS5kZWZhdWx0RmllbGRWYWx1ZSB8fCBcIk9mZlwiO1xuICAgICAgZXZlbnQudGFyZ2V0LmNoZWNrZWQgPSBkZWZhdWx0VmFsdWUgPT09IGRhdGEuZXhwb3J0VmFsdWU7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zKSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBqc0V2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgICAgICB2YWx1ZShldmVudCkge1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmNoZWNrZWQgPSBldmVudC5kZXRhaWwudmFsdWUgIT09IFwiT2ZmXCI7XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQuY2hlY2tlZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goYWN0aW9ucywganNFdmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXJzKGVsZW1lbnQsIG51bGwsIFtbXCJjaGFuZ2VcIiwgXCJWYWxpZGF0ZVwiXSwgW1wiY2hhbmdlXCIsIFwiQWN0aW9uXCJdLCBbXCJmb2N1c1wiLCBcIkZvY3VzXCJdLCBbXCJibHVyXCIsIFwiQmx1clwiXSwgW1wibW91c2Vkb3duXCIsIFwiTW91c2UgRG93blwiXSwgW1wibW91c2VlbnRlclwiLCBcIk1vdXNlIEVudGVyXCJdLCBbXCJtb3VzZWxlYXZlXCIsIFwiTW91c2UgRXhpdFwiXSwgW1wibW91c2V1cFwiLCBcIk1vdXNlIFVwXCJdXSwgZXZlbnQgPT4gZXZlbnQudGFyZ2V0LmNoZWNrZWQpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3IoZWxlbWVudCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoZWxlbWVudCk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGVsZW1lbnQpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgUmFkaW9CdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIFdpZGdldEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogcGFyYW1ldGVycy5yZW5kZXJGb3Jtc1xuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiYnV0dG9uV2lkZ2V0QW5ub3RhdGlvblwiLCBcInJhZGlvQnV0dG9uXCIpO1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3QgaWQgPSBkYXRhLmlkO1xuICAgIGxldCB2YWx1ZSA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgIHZhbHVlOiBkYXRhLmZpZWxkVmFsdWUgPT09IGRhdGEuYnV0dG9uVmFsdWVcbiAgICB9KS52YWx1ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlICE9PSBkYXRhLmJ1dHRvblZhbHVlO1xuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZm9yIChjb25zdCByYWRpbyBvZiB0aGlzLl9nZXRFbGVtZW50c0J5TmFtZShkYXRhLmZpZWxkTmFtZSwgaWQpKSB7XG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUocmFkaW8uaWQsIHtcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgR2V0RWxlbWVudHNCeU5hbWVTZXQuYWRkKGVsZW1lbnQpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIsIGlkKTtcbiAgICBlbGVtZW50LmRpc2FibGVkID0gZGF0YS5yZWFkT25seTtcbiAgICB0aGlzLl9zZXRSZXF1aXJlZChlbGVtZW50LCB0aGlzLmRhdGEucmVxdWlyZWQpO1xuICAgIGVsZW1lbnQudHlwZSA9IFwicmFkaW9cIjtcbiAgICBlbGVtZW50Lm5hbWUgPSBkYXRhLmZpZWxkTmFtZTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiLCB0cnVlKTtcbiAgICB9XG4gICAgZWxlbWVudC50YWJJbmRleCA9IERFRkFVTFRfVEFCX0lOREVYO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBldmVudCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGNoZWNrZWRcbiAgICAgIH0gPSBldmVudC50YXJnZXQ7XG4gICAgICBmb3IgKGNvbnN0IHJhZGlvIG9mIHRoaXMuX2dldEVsZW1lbnRzQnlOYW1lKG5hbWUsIGlkKSkge1xuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKHJhZGlvLmlkLCB7XG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZTogY2hlY2tlZFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVzZXRmb3JtXCIsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IGRhdGEuZGVmYXVsdEZpZWxkVmFsdWU7XG4gICAgICBldmVudC50YXJnZXQuY2hlY2tlZCA9IGRlZmF1bHRWYWx1ZSAhPT0gbnVsbCAmJiBkZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0VmFsdWUgPT09IGRhdGEuYnV0dG9uVmFsdWU7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zKSB7XG4gICAgICBjb25zdCBwZGZCdXR0b25WYWx1ZSA9IGRhdGEuYnV0dG9uVmFsdWU7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBqc0V2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgICAgICB2YWx1ZTogZXZlbnQgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hlY2tlZCA9IHBkZkJ1dHRvblZhbHVlID09PSBldmVudC5kZXRhaWwudmFsdWU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJhZGlvIG9mIHRoaXMuX2dldEVsZW1lbnRzQnlOYW1lKGV2ZW50LnRhcmdldC5uYW1lKSkge1xuICAgICAgICAgICAgICBjb25zdCBjdXJDaGVja2VkID0gY2hlY2tlZCAmJiByYWRpby5pZCA9PT0gaWQ7XG4gICAgICAgICAgICAgIGlmIChyYWRpby5kb21FbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmFkaW8uZG9tRWxlbWVudC5jaGVja2VkID0gY3VyQ2hlY2tlZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKHJhZGlvLmlkLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGN1ckNoZWNrZWRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goYWN0aW9ucywganNFdmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXJzKGVsZW1lbnQsIG51bGwsIFtbXCJjaGFuZ2VcIiwgXCJWYWxpZGF0ZVwiXSwgW1wiY2hhbmdlXCIsIFwiQWN0aW9uXCJdLCBbXCJmb2N1c1wiLCBcIkZvY3VzXCJdLCBbXCJibHVyXCIsIFwiQmx1clwiXSwgW1wibW91c2Vkb3duXCIsIFwiTW91c2UgRG93blwiXSwgW1wibW91c2VlbnRlclwiLCBcIk1vdXNlIEVudGVyXCJdLCBbXCJtb3VzZWxlYXZlXCIsIFwiTW91c2UgRXhpdFwiXSwgW1wibW91c2V1cFwiLCBcIk1vdXNlIFVwXCJdXSwgZXZlbnQgPT4gZXZlbnQudGFyZ2V0LmNoZWNrZWQpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3IoZWxlbWVudCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoZWxlbWVudCk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGVsZW1lbnQpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgUHVzaEJ1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgTGlua0Fubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlnbm9yZUJvcmRlcjogcGFyYW1ldGVycy5kYXRhLmhhc0FwcGVhcmFuY2VcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gc3VwZXIucmVuZGVyKCk7XG4gICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJidXR0b25XaWRnZXRBbm5vdGF0aW9uXCIsIFwicHVzaEJ1dHRvblwiKTtcbiAgICBjb25zdCBsaW5rRWxlbWVudCA9IGNvbnRhaW5lci5sYXN0Q2hpbGQ7XG4gICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zICYmIGxpbmtFbGVtZW50KSB7XG4gICAgICB0aGlzLl9zZXREZWZhdWx0UHJvcGVydGllc0Zyb21KUyhsaW5rRWxlbWVudCk7XG4gICAgICBsaW5rRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZnJvbXNhbmRib3hcIiwganNFdmVudCA9PiB7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveCh7fSwganNFdmVudCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgQ2hvaWNlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHBhcmFtZXRlcnMucmVuZGVyRm9ybXNcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImNob2ljZVdpZGdldEFubm90YXRpb25cIik7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgY29uc3QgaWQgPSB0aGlzLmRhdGEuaWQ7XG4gICAgY29uc3Qgc3RvcmVkRGF0YSA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgIHZhbHVlOiB0aGlzLmRhdGEuZmllbGRWYWx1ZVxuICAgIH0pO1xuICAgIGNvbnN0IHNlbGVjdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpO1xuICAgIEdldEVsZW1lbnRzQnlOYW1lU2V0LmFkZChzZWxlY3RFbGVtZW50KTtcbiAgICBzZWxlY3RFbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCBpZCk7XG4gICAgc2VsZWN0RWxlbWVudC5kaXNhYmxlZCA9IHRoaXMuZGF0YS5yZWFkT25seTtcbiAgICB0aGlzLl9zZXRSZXF1aXJlZChzZWxlY3RFbGVtZW50LCB0aGlzLmRhdGEucmVxdWlyZWQpO1xuICAgIHNlbGVjdEVsZW1lbnQubmFtZSA9IHRoaXMuZGF0YS5maWVsZE5hbWU7XG4gICAgc2VsZWN0RWxlbWVudC50YWJJbmRleCA9IERFRkFVTFRfVEFCX0lOREVYO1xuICAgIGxldCBhZGRBbkVtcHR5RW50cnkgPSB0aGlzLmRhdGEuY29tYm8gJiYgdGhpcy5kYXRhLm9wdGlvbnMubGVuZ3RoID4gMDtcbiAgICBpZiAoIXRoaXMuZGF0YS5jb21ibykge1xuICAgICAgc2VsZWN0RWxlbWVudC5zaXplID0gdGhpcy5kYXRhLm9wdGlvbnMubGVuZ3RoO1xuICAgICAgaWYgKHRoaXMuZGF0YS5tdWx0aVNlbGVjdCkge1xuICAgICAgICBzZWxlY3RFbGVtZW50Lm11bHRpcGxlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVzZXRmb3JtXCIsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IHRoaXMuZGF0YS5kZWZhdWx0RmllbGRWYWx1ZTtcbiAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIHNlbGVjdEVsZW1lbnQub3B0aW9ucykge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBvcHRpb24udmFsdWUgPT09IGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiB0aGlzLmRhdGEub3B0aW9ucykge1xuICAgICAgY29uc3Qgb3B0aW9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICBvcHRpb25FbGVtZW50LnRleHRDb250ZW50ID0gb3B0aW9uLmRpc3BsYXlWYWx1ZTtcbiAgICAgIG9wdGlvbkVsZW1lbnQudmFsdWUgPSBvcHRpb24uZXhwb3J0VmFsdWU7XG4gICAgICBpZiAoc3RvcmVkRGF0YS52YWx1ZS5pbmNsdWRlcyhvcHRpb24uZXhwb3J0VmFsdWUpKSB7XG4gICAgICAgIG9wdGlvbkVsZW1lbnQuc2V0QXR0cmlidXRlKFwic2VsZWN0ZWRcIiwgdHJ1ZSk7XG4gICAgICAgIGFkZEFuRW1wdHlFbnRyeSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgc2VsZWN0RWxlbWVudC5hcHBlbmQob3B0aW9uRWxlbWVudCk7XG4gICAgfVxuICAgIGxldCByZW1vdmVFbXB0eUVudHJ5ID0gbnVsbDtcbiAgICBpZiAoYWRkQW5FbXB0eUVudHJ5KSB7XG4gICAgICBjb25zdCBub25lT3B0aW9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICBub25lT3B0aW9uRWxlbWVudC52YWx1ZSA9IFwiIFwiO1xuICAgICAgbm9uZU9wdGlvbkVsZW1lbnQuc2V0QXR0cmlidXRlKFwiaGlkZGVuXCIsIHRydWUpO1xuICAgICAgbm9uZU9wdGlvbkVsZW1lbnQuc2V0QXR0cmlidXRlKFwic2VsZWN0ZWRcIiwgdHJ1ZSk7XG4gICAgICBzZWxlY3RFbGVtZW50LnByZXBlbmQobm9uZU9wdGlvbkVsZW1lbnQpO1xuICAgICAgcmVtb3ZlRW1wdHlFbnRyeSA9ICgpID0+IHtcbiAgICAgICAgbm9uZU9wdGlvbkVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgIHNlbGVjdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHJlbW92ZUVtcHR5RW50cnkpO1xuICAgICAgICByZW1vdmVFbXB0eUVudHJ5ID0gbnVsbDtcbiAgICAgIH07XG4gICAgICBzZWxlY3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCByZW1vdmVFbXB0eUVudHJ5KTtcbiAgICB9XG4gICAgY29uc3QgZ2V0VmFsdWUgPSBpc0V4cG9ydCA9PiB7XG4gICAgICBjb25zdCBuYW1lID0gaXNFeHBvcnQgPyBcInZhbHVlXCIgOiBcInRleHRDb250ZW50XCI7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIG11bHRpcGxlXG4gICAgICB9ID0gc2VsZWN0RWxlbWVudDtcbiAgICAgIGlmICghbXVsdGlwbGUpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuc2VsZWN0ZWRJbmRleCA9PT0gLTEgPyBudWxsIDogb3B0aW9uc1tvcHRpb25zLnNlbGVjdGVkSW5kZXhdW25hbWVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChvcHRpb25zLCBvcHRpb24gPT4gb3B0aW9uLnNlbGVjdGVkKS5tYXAob3B0aW9uID0+IG9wdGlvbltuYW1lXSk7XG4gICAgfTtcbiAgICBsZXQgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgY29uc3QgZ2V0SXRlbXMgPSBldmVudCA9PiB7XG4gICAgICBjb25zdCBvcHRpb25zID0gZXZlbnQudGFyZ2V0Lm9wdGlvbnM7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKG9wdGlvbnMsIG9wdGlvbiA9PiAoe1xuICAgICAgICBkaXNwbGF5VmFsdWU6IG9wdGlvbi50ZXh0Q29udGVudCxcbiAgICAgICAgZXhwb3J0VmFsdWU6IG9wdGlvbi52YWx1ZVxuICAgICAgfSkpO1xuICAgIH07XG4gICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zKSB7XG4gICAgICBzZWxlY3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBqc0V2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgICAgICB2YWx1ZShldmVudCkge1xuICAgICAgICAgICAgcmVtb3ZlRW1wdHlFbnRyeT8uKCk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGV2ZW50LmRldGFpbC52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IG5ldyBTZXQoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV0pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2Ygc2VsZWN0RWxlbWVudC5vcHRpb25zKSB7XG4gICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHZhbHVlcy5oYXMob3B0aW9uLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbXVsdGlwbGVTZWxlY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQubXVsdGlwbGUgPSB0cnVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVtb3ZlKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gc2VsZWN0RWxlbWVudC5vcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBldmVudC5kZXRhaWwucmVtb3ZlO1xuICAgICAgICAgICAgb3B0aW9uc1tpbmRleF0uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQucmVtb3ZlKGluZGV4KTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgaSA9IEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXguY2FsbChvcHRpb25zLCBvcHRpb24gPT4gb3B0aW9uLnNlbGVjdGVkKTtcbiAgICAgICAgICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1swXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpLFxuICAgICAgICAgICAgICBpdGVtczogZ2V0SXRlbXMoZXZlbnQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2xlYXIoZXZlbnQpIHtcbiAgICAgICAgICAgIHdoaWxlIChzZWxlY3RFbGVtZW50Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgIGl0ZW1zOiBbXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlcyA9IGdldFZhbHVlKGZhbHNlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGluc2VydChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgZGlzcGxheVZhbHVlLFxuICAgICAgICAgICAgICBleHBvcnRWYWx1ZVxuICAgICAgICAgICAgfSA9IGV2ZW50LmRldGFpbC5pbnNlcnQ7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RDaGlsZCA9IHNlbGVjdEVsZW1lbnQuY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgICAgICBvcHRpb25FbGVtZW50LnRleHRDb250ZW50ID0gZGlzcGxheVZhbHVlO1xuICAgICAgICAgICAgb3B0aW9uRWxlbWVudC52YWx1ZSA9IGV4cG9ydFZhbHVlO1xuICAgICAgICAgICAgaWYgKHNlbGVjdENoaWxkKSB7XG4gICAgICAgICAgICAgIHNlbGVjdENoaWxkLmJlZm9yZShvcHRpb25FbGVtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQuYXBwZW5kKG9wdGlvbkVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUodHJ1ZSksXG4gICAgICAgICAgICAgIGl0ZW1zOiBnZXRJdGVtcyhldmVudClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpdGVtcyhldmVudCkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBpdGVtc1xuICAgICAgICAgICAgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgICAgIHdoaWxlIChzZWxlY3RFbGVtZW50Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgZGlzcGxheVZhbHVlLFxuICAgICAgICAgICAgICAgIGV4cG9ydFZhbHVlXG4gICAgICAgICAgICAgIH0gPSBpdGVtO1xuICAgICAgICAgICAgICBjb25zdCBvcHRpb25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgICAgICAgICAgb3B0aW9uRWxlbWVudC50ZXh0Q29udGVudCA9IGRpc3BsYXlWYWx1ZTtcbiAgICAgICAgICAgICAgb3B0aW9uRWxlbWVudC52YWx1ZSA9IGV4cG9ydFZhbHVlO1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LmFwcGVuZChvcHRpb25FbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3RFbGVtZW50Lm9wdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50Lm9wdGlvbnNbMF0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUodHJ1ZSksXG4gICAgICAgICAgICAgIGl0ZW1zOiBnZXRJdGVtcyhldmVudClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbmRpY2VzKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBpbmRpY2VzID0gbmV3IFNldChldmVudC5kZXRhaWwuaW5kaWNlcyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBldmVudC50YXJnZXQub3B0aW9ucykge1xuICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBpbmRpY2VzLmhhcyhvcHRpb24uaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUodHJ1ZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlZGl0YWJsZShldmVudCkge1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmRpc2FibGVkID0gIWV2ZW50LmRldGFpbC5lZGl0YWJsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveChhY3Rpb25zLCBqc0V2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgc2VsZWN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBleHBvcnRWYWx1ZSA9IGdldFZhbHVlKHRydWUpO1xuICAgICAgICBjb25zdCBjaGFuZ2UgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICB2YWx1ZTogZXhwb3J0VmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBuYW1lOiBcIktleXN0cm9rZVwiLFxuICAgICAgICAgICAgdmFsdWU6IHNlbGVjdGVkVmFsdWVzLFxuICAgICAgICAgICAgY2hhbmdlLFxuICAgICAgICAgICAgY2hhbmdlRXg6IGV4cG9ydFZhbHVlLFxuICAgICAgICAgICAgd2lsbENvbW1pdDogZmFsc2UsXG4gICAgICAgICAgICBjb21taXRLZXk6IDEsXG4gICAgICAgICAgICBrZXlEb3duOiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXJzKHNlbGVjdEVsZW1lbnQsIG51bGwsIFtbXCJmb2N1c1wiLCBcIkZvY3VzXCJdLCBbXCJibHVyXCIsIFwiQmx1clwiXSwgW1wibW91c2Vkb3duXCIsIFwiTW91c2UgRG93blwiXSwgW1wibW91c2VlbnRlclwiLCBcIk1vdXNlIEVudGVyXCJdLCBbXCJtb3VzZWxlYXZlXCIsIFwiTW91c2UgRXhpdFwiXSwgW1wibW91c2V1cFwiLCBcIk1vdXNlIFVwXCJdLCBbXCJpbnB1dFwiLCBcIkFjdGlvblwiXSwgW1wiaW5wdXRcIiwgXCJWYWxpZGF0ZVwiXV0sIGV2ZW50ID0+IGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmRhdGEuY29tYm8pIHtcbiAgICAgIHRoaXMuX3NldFRleHRTdHlsZShzZWxlY3RFbGVtZW50KTtcbiAgICB9IGVsc2Uge31cbiAgICB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3Ioc2VsZWN0RWxlbWVudCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoc2VsZWN0RWxlbWVudCk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHNlbGVjdEVsZW1lbnQpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgUG9wdXBBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICBlbGVtZW50c1xuICAgIH0gPSBwYXJhbWV0ZXJzO1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogQW5ub3RhdGlvbkVsZW1lbnQuX2hhc1BvcHVwRGF0YShkYXRhKVxuICAgIH0pO1xuICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICB0aGlzLnBvcHVwID0gbnVsbDtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInBvcHVwQW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCBwb3B1cCA9IHRoaXMucG9wdXAgPSBuZXcgUG9wdXBFbGVtZW50KHtcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5jb250YWluZXIsXG4gICAgICBjb2xvcjogdGhpcy5kYXRhLmNvbG9yLFxuICAgICAgdGl0bGVPYmo6IHRoaXMuZGF0YS50aXRsZU9iaixcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGU6IHRoaXMuZGF0YS5tb2RpZmljYXRpb25EYXRlLFxuICAgICAgY29udGVudHNPYmo6IHRoaXMuZGF0YS5jb250ZW50c09iaixcbiAgICAgIHJpY2hUZXh0OiB0aGlzLmRhdGEucmljaFRleHQsXG4gICAgICByZWN0OiB0aGlzLmRhdGEucmVjdCxcbiAgICAgIHBhcmVudFJlY3Q6IHRoaXMuZGF0YS5wYXJlbnRSZWN0IHx8IG51bGwsXG4gICAgICBwYXJlbnQ6IHRoaXMucGFyZW50LFxuICAgICAgZWxlbWVudHM6IHRoaXMuZWxlbWVudHMsXG4gICAgICBvcGVuOiB0aGlzLmRhdGEub3BlblxuICAgIH0pO1xuICAgIGNvbnN0IGVsZW1lbnRJZHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy5lbGVtZW50cykge1xuICAgICAgZWxlbWVudC5wb3B1cCA9IHBvcHVwO1xuICAgICAgZWxlbWVudC5jb250YWluZXIuYXJpYUhhc1BvcHVwID0gXCJkaWFsb2dcIjtcbiAgICAgIGVsZW1lbnRJZHMucHVzaChlbGVtZW50LmRhdGEuaWQpO1xuICAgICAgZWxlbWVudC5hZGRIaWdobGlnaHRBcmVhKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImFyaWEtY29udHJvbHNcIiwgZWxlbWVudElkcy5tYXAoaWQgPT4gYCR7QW5ub3RhdGlvblByZWZpeH0ke2lkfWApLmpvaW4oXCIsXCIpKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFBvcHVwRWxlbWVudCB7XG4gICNib3VuZEtleURvd24gPSB0aGlzLiNrZXlEb3duLmJpbmQodGhpcyk7XG4gICNib3VuZEhpZGUgPSB0aGlzLiNoaWRlLmJpbmQodGhpcyk7XG4gICNib3VuZFNob3cgPSB0aGlzLiNzaG93LmJpbmQodGhpcyk7XG4gICNib3VuZFRvZ2dsZSA9IHRoaXMuI3RvZ2dsZS5iaW5kKHRoaXMpO1xuICAjY29sb3IgPSBudWxsO1xuICAjY29udGFpbmVyID0gbnVsbDtcbiAgI2NvbnRlbnRzT2JqID0gbnVsbDtcbiAgI2RhdGVPYmogPSBudWxsO1xuICAjZWxlbWVudHMgPSBudWxsO1xuICAjcGFyZW50ID0gbnVsbDtcbiAgI3BhcmVudFJlY3QgPSBudWxsO1xuICAjcGlubmVkID0gZmFsc2U7XG4gICNwb3B1cCA9IG51bGw7XG4gICNwb3NpdGlvbiA9IG51bGw7XG4gICNyZWN0ID0gbnVsbDtcbiAgI3JpY2hUZXh0ID0gbnVsbDtcbiAgI3RpdGxlT2JqID0gbnVsbDtcbiAgI3VwZGF0ZXMgPSBudWxsO1xuICAjd2FzVmlzaWJsZSA9IGZhbHNlO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY29udGFpbmVyLFxuICAgIGNvbG9yLFxuICAgIGVsZW1lbnRzLFxuICAgIHRpdGxlT2JqLFxuICAgIG1vZGlmaWNhdGlvbkRhdGUsXG4gICAgY29udGVudHNPYmosXG4gICAgcmljaFRleHQsXG4gICAgcGFyZW50LFxuICAgIHJlY3QsXG4gICAgcGFyZW50UmVjdCxcbiAgICBvcGVuXG4gIH0pIHtcbiAgICB0aGlzLiNjb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy4jdGl0bGVPYmogPSB0aXRsZU9iajtcbiAgICB0aGlzLiNjb250ZW50c09iaiA9IGNvbnRlbnRzT2JqO1xuICAgIHRoaXMuI3JpY2hUZXh0ID0gcmljaFRleHQ7XG4gICAgdGhpcy4jcGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuI2NvbG9yID0gY29sb3I7XG4gICAgdGhpcy4jcmVjdCA9IHJlY3Q7XG4gICAgdGhpcy4jcGFyZW50UmVjdCA9IHBhcmVudFJlY3Q7XG4gICAgdGhpcy4jZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICB0aGlzLiNkYXRlT2JqID0gUERGRGF0ZVN0cmluZy50b0RhdGVPYmplY3QobW9kaWZpY2F0aW9uRGF0ZSk7XG4gICAgdGhpcy50cmlnZ2VyID0gZWxlbWVudHMuZmxhdE1hcChlID0+IGUuZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpKTtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy50cmlnZ2VyKSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLiNib3VuZFRvZ2dsZSk7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsIHRoaXMuI2JvdW5kU2hvdyk7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHRoaXMuI2JvdW5kSGlkZSk7XG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJwb3B1cFRyaWdnZXJBcmVhXCIpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgIGVsZW1lbnQuY29udGFpbmVyPy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNib3VuZEtleURvd24pO1xuICAgIH1cbiAgICB0aGlzLiNjb250YWluZXIuaGlkZGVuID0gdHJ1ZTtcbiAgICBpZiAob3Blbikge1xuICAgICAgdGhpcy4jdG9nZ2xlKCk7XG4gICAgfVxuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy4jcG9wdXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcG9wdXAgPSB0aGlzLiNwb3B1cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgcG9wdXAuY2xhc3NOYW1lID0gXCJwb3B1cFwiO1xuICAgIGlmICh0aGlzLiNjb2xvcikge1xuICAgICAgY29uc3QgYmFzZUNvbG9yID0gcG9wdXAuc3R5bGUub3V0bGluZUNvbG9yID0gVXRpbC5tYWtlSGV4Q29sb3IoLi4udGhpcy4jY29sb3IpO1xuICAgICAgaWYgKENTUy5zdXBwb3J0cyhcImJhY2tncm91bmQtY29sb3JcIiwgXCJjb2xvci1taXgoaW4gc3JnYiwgcmVkIDMwJSwgd2hpdGUpXCIpKSB7XG4gICAgICAgIHBvcHVwLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGBjb2xvci1taXgoaW4gc3JnYiwgJHtiYXNlQ29sb3J9IDMwJSwgd2hpdGUpYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IEJBQ0tHUk9VTkRfRU5MSUdIVCA9IDAuNztcbiAgICAgICAgcG9wdXAuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gVXRpbC5tYWtlSGV4Q29sb3IoLi4udGhpcy4jY29sb3IubWFwKGMgPT4gTWF0aC5mbG9vcihCQUNLR1JPVU5EX0VOTElHSFQgKiAoMjU1IC0gYykgKyBjKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBoZWFkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBoZWFkZXIuY2xhc3NOYW1lID0gXCJoZWFkZXJcIjtcbiAgICBjb25zdCB0aXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJoMVwiKTtcbiAgICBoZWFkZXIuYXBwZW5kKHRpdGxlKTtcbiAgICAoe1xuICAgICAgZGlyOiB0aXRsZS5kaXIsXG4gICAgICBzdHI6IHRpdGxlLnRleHRDb250ZW50XG4gICAgfSA9IHRoaXMuI3RpdGxlT2JqKTtcbiAgICBwb3B1cC5hcHBlbmQoaGVhZGVyKTtcbiAgICBpZiAodGhpcy4jZGF0ZU9iaikge1xuICAgICAgY29uc3QgbW9kaWZpY2F0aW9uRGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgbW9kaWZpY2F0aW9uRGF0ZS5jbGFzc0xpc3QuYWRkKFwicG9wdXBEYXRlXCIpO1xuICAgICAgbW9kaWZpY2F0aW9uRGF0ZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1hbm5vdGF0aW9uLWRhdGUtdGltZS1zdHJpbmdcIik7XG4gICAgICBtb2RpZmljYXRpb25EYXRlLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1hcmdzXCIsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgZGF0ZU9iajogdGhpcy4jZGF0ZU9iai52YWx1ZU9mKClcbiAgICAgIH0pKTtcbiAgICAgIGhlYWRlci5hcHBlbmQobW9kaWZpY2F0aW9uRGF0ZSk7XG4gICAgfVxuICAgIGNvbnN0IGh0bWwgPSB0aGlzLiNodG1sO1xuICAgIGlmIChodG1sKSB7XG4gICAgICBYZmFMYXllci5yZW5kZXIoe1xuICAgICAgICB4ZmFIdG1sOiBodG1sLFxuICAgICAgICBpbnRlbnQ6IFwicmljaFRleHRcIixcbiAgICAgICAgZGl2OiBwb3B1cFxuICAgICAgfSk7XG4gICAgICBwb3B1cC5sYXN0Q2hpbGQuY2xhc3NMaXN0LmFkZChcInJpY2hUZXh0XCIsIFwicG9wdXBDb250ZW50XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb250ZW50cyA9IHRoaXMuX2Zvcm1hdENvbnRlbnRzKHRoaXMuI2NvbnRlbnRzT2JqKTtcbiAgICAgIHBvcHVwLmFwcGVuZChjb250ZW50cyk7XG4gICAgfVxuICAgIHRoaXMuI2NvbnRhaW5lci5hcHBlbmQocG9wdXApO1xuICB9XG4gIGdldCAjaHRtbCgpIHtcbiAgICBjb25zdCByaWNoVGV4dCA9IHRoaXMuI3JpY2hUZXh0O1xuICAgIGNvbnN0IGNvbnRlbnRzT2JqID0gdGhpcy4jY29udGVudHNPYmo7XG4gICAgaWYgKHJpY2hUZXh0Py5zdHIgJiYgKCFjb250ZW50c09iaj8uc3RyIHx8IGNvbnRlbnRzT2JqLnN0ciA9PT0gcmljaFRleHQuc3RyKSkge1xuICAgICAgcmV0dXJuIHRoaXMuI3JpY2hUZXh0Lmh0bWwgfHwgbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0ICNmb250U2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaHRtbD8uYXR0cmlidXRlcz8uc3R5bGU/LmZvbnRTaXplIHx8IDA7XG4gIH1cbiAgZ2V0ICNmb250Q29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2h0bWw/LmF0dHJpYnV0ZXM/LnN0eWxlPy5jb2xvciB8fCBudWxsO1xuICB9XG4gICNtYWtlUG9wdXBDb250ZW50KHRleHQpIHtcbiAgICBjb25zdCBwb3B1cExpbmVzID0gW107XG4gICAgY29uc3QgcG9wdXBDb250ZW50ID0ge1xuICAgICAgc3RyOiB0ZXh0LFxuICAgICAgaHRtbDoge1xuICAgICAgICBuYW1lOiBcImRpdlwiLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgZGlyOiBcImF1dG9cIlxuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICBuYW1lOiBcInBcIixcbiAgICAgICAgICBjaGlsZHJlbjogcG9wdXBMaW5lc1xuICAgICAgICB9XVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbGluZUF0dHJpYnV0ZXMgPSB7XG4gICAgICBzdHlsZToge1xuICAgICAgICBjb2xvcjogdGhpcy4jZm9udENvbG9yLFxuICAgICAgICBmb250U2l6ZTogdGhpcy4jZm9udFNpemUgPyBgY2FsYygke3RoaXMuI2ZvbnRTaXplfXB4ICogdmFyKC0tc2NhbGUtZmFjdG9yKSlgIDogXCJcIlxuICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCBsaW5lIG9mIHRleHQuc3BsaXQoXCJcXG5cIikpIHtcbiAgICAgIHBvcHVwTGluZXMucHVzaCh7XG4gICAgICAgIG5hbWU6IFwic3BhblwiLFxuICAgICAgICB2YWx1ZTogbGluZSxcbiAgICAgICAgYXR0cmlidXRlczogbGluZUF0dHJpYnV0ZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcG9wdXBDb250ZW50O1xuICB9XG4gIF9mb3JtYXRDb250ZW50cyh7XG4gICAgc3RyLFxuICAgIGRpclxuICB9KSB7XG4gICAgY29uc3QgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwXCIpO1xuICAgIHAuY2xhc3NMaXN0LmFkZChcInBvcHVwQ29udGVudFwiKTtcbiAgICBwLmRpciA9IGRpcjtcbiAgICBjb25zdCBsaW5lcyA9IHN0ci5zcGxpdCgvKD86XFxyXFxuP3xcXG4pLyk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gbGluZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgcC5hcHBlbmQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGluZSkpO1xuICAgICAgaWYgKGkgPCBpaSAtIDEpIHtcbiAgICAgICAgcC5hcHBlbmQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH1cbiAgI2tleURvd24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuYWx0S2V5IHx8IGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQua2V5ID09PSBcIkVudGVyXCIgfHwgZXZlbnQua2V5ID09PSBcIkVzY2FwZVwiICYmIHRoaXMuI3Bpbm5lZCkge1xuICAgICAgdGhpcy4jdG9nZ2xlKCk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZUVkaXRlZCh7XG4gICAgcmVjdCxcbiAgICBwb3B1cENvbnRlbnRcbiAgfSkge1xuICAgIHRoaXMuI3VwZGF0ZXMgfHw9IHtcbiAgICAgIGNvbnRlbnRzT2JqOiB0aGlzLiNjb250ZW50c09iaixcbiAgICAgIHJpY2hUZXh0OiB0aGlzLiNyaWNoVGV4dFxuICAgIH07XG4gICAgaWYgKHJlY3QpIHtcbiAgICAgIHRoaXMuI3Bvc2l0aW9uID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHBvcHVwQ29udGVudCkge1xuICAgICAgdGhpcy4jcmljaFRleHQgPSB0aGlzLiNtYWtlUG9wdXBDb250ZW50KHBvcHVwQ29udGVudCk7XG4gICAgICB0aGlzLiNjb250ZW50c09iaiA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuI3BvcHVwPy5yZW1vdmUoKTtcbiAgICB0aGlzLiNwb3B1cCA9IG51bGw7XG4gIH1cbiAgcmVzZXRFZGl0ZWQoKSB7XG4gICAgaWYgKCF0aGlzLiN1cGRhdGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICh7XG4gICAgICBjb250ZW50c09iajogdGhpcy4jY29udGVudHNPYmosXG4gICAgICByaWNoVGV4dDogdGhpcy4jcmljaFRleHRcbiAgICB9ID0gdGhpcy4jdXBkYXRlcyk7XG4gICAgdGhpcy4jdXBkYXRlcyA9IG51bGw7XG4gICAgdGhpcy4jcG9wdXA/LnJlbW92ZSgpO1xuICAgIHRoaXMuI3BvcHVwID0gbnVsbDtcbiAgICB0aGlzLiNwb3NpdGlvbiA9IG51bGw7XG4gIH1cbiAgI3NldFBvc2l0aW9uKCkge1xuICAgIGlmICh0aGlzLiNwb3NpdGlvbiAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBwYWdlOiB7XG4gICAgICAgIHZpZXdcbiAgICAgIH0sXG4gICAgICB2aWV3cG9ydDoge1xuICAgICAgICByYXdEaW1zOiB7XG4gICAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICAgICAgcGFnZVgsXG4gICAgICAgICAgcGFnZVlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gPSB0aGlzLiNwYXJlbnQ7XG4gICAgbGV0IHVzZVBhcmVudFJlY3QgPSAhIXRoaXMuI3BhcmVudFJlY3Q7XG4gICAgbGV0IHJlY3QgPSB1c2VQYXJlbnRSZWN0ID8gdGhpcy4jcGFyZW50UmVjdCA6IHRoaXMuI3JlY3Q7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMuI2VsZW1lbnRzKSB7XG4gICAgICBpZiAoIXJlY3QgfHwgVXRpbC5pbnRlcnNlY3QoZWxlbWVudC5kYXRhLnJlY3QsIHJlY3QpICE9PSBudWxsKSB7XG4gICAgICAgIHJlY3QgPSBlbGVtZW50LmRhdGEucmVjdDtcbiAgICAgICAgdXNlUGFyZW50UmVjdCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBub3JtYWxpemVkUmVjdCA9IFV0aWwubm9ybWFsaXplUmVjdChbcmVjdFswXSwgdmlld1szXSAtIHJlY3RbMV0gKyB2aWV3WzFdLCByZWN0WzJdLCB2aWV3WzNdIC0gcmVjdFszXSArIHZpZXdbMV1dKTtcbiAgICBjb25zdCBIT1JJWk9OVEFMX1NQQUNFX0FGVEVSX0FOTk9UQVRJT04gPSA1O1xuICAgIGNvbnN0IHBhcmVudFdpZHRoID0gdXNlUGFyZW50UmVjdCA/IHJlY3RbMl0gLSByZWN0WzBdICsgSE9SSVpPTlRBTF9TUEFDRV9BRlRFUl9BTk5PVEFUSU9OIDogMDtcbiAgICBjb25zdCBwb3B1cExlZnQgPSBub3JtYWxpemVkUmVjdFswXSArIHBhcmVudFdpZHRoO1xuICAgIGNvbnN0IHBvcHVwVG9wID0gbm9ybWFsaXplZFJlY3RbMV07XG4gICAgdGhpcy4jcG9zaXRpb24gPSBbMTAwICogKHBvcHVwTGVmdCAtIHBhZ2VYKSAvIHBhZ2VXaWR0aCwgMTAwICogKHBvcHVwVG9wIC0gcGFnZVkpIC8gcGFnZUhlaWdodF07XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy4jY29udGFpbmVyO1xuICAgIHN0eWxlLmxlZnQgPSBgJHt0aGlzLiNwb3NpdGlvblswXX0lYDtcbiAgICBzdHlsZS50b3AgPSBgJHt0aGlzLiNwb3NpdGlvblsxXX0lYDtcbiAgfVxuICAjdG9nZ2xlKCkge1xuICAgIHRoaXMuI3Bpbm5lZCA9ICF0aGlzLiNwaW5uZWQ7XG4gICAgaWYgKHRoaXMuI3Bpbm5lZCkge1xuICAgICAgdGhpcy4jc2hvdygpO1xuICAgICAgdGhpcy4jY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLiNib3VuZFRvZ2dsZSk7XG4gICAgICB0aGlzLiNjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4jYm91bmRLZXlEb3duKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jaGlkZSgpO1xuICAgICAgdGhpcy4jY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLiNib3VuZFRvZ2dsZSk7XG4gICAgICB0aGlzLiNjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4jYm91bmRLZXlEb3duKTtcbiAgICB9XG4gIH1cbiAgI3Nob3coKSB7XG4gICAgaWYgKCF0aGlzLiNwb3B1cCkge1xuICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgdGhpcy4jc2V0UG9zaXRpb24oKTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5zdHlsZS56SW5kZXggPSBwYXJzZUludCh0aGlzLiNjb250YWluZXIuc3R5bGUuekluZGV4KSArIDEwMDA7XG4gICAgfSBlbHNlIGlmICh0aGlzLiNwaW5uZWQpIHtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiZm9jdXNlZFwiKTtcbiAgICB9XG4gIH1cbiAgI2hpZGUoKSB7XG4gICAgdGhpcy4jY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoXCJmb2N1c2VkXCIpO1xuICAgIGlmICh0aGlzLiNwaW5uZWQgfHwgIXRoaXMuaXNWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPSB0cnVlO1xuICAgIHRoaXMuI2NvbnRhaW5lci5zdHlsZS56SW5kZXggPSBwYXJzZUludCh0aGlzLiNjb250YWluZXIuc3R5bGUuekluZGV4KSAtIDEwMDA7XG4gIH1cbiAgZm9yY2VIaWRlKCkge1xuICAgIHRoaXMuI3dhc1Zpc2libGUgPSB0aGlzLmlzVmlzaWJsZTtcbiAgICBpZiAoIXRoaXMuI3dhc1Zpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY29udGFpbmVyLmhpZGRlbiA9IHRydWU7XG4gIH1cbiAgbWF5YmVTaG93KCkge1xuICAgIGlmICghdGhpcy4jd2FzVmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI3BvcHVwKSB7XG4gICAgICB0aGlzLiNzaG93KCk7XG4gICAgfVxuICAgIHRoaXMuI3dhc1Zpc2libGUgPSBmYWxzZTtcbiAgICB0aGlzLiNjb250YWluZXIuaGlkZGVuID0gZmFsc2U7XG4gIH1cbiAgZ2V0IGlzVmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jY29udGFpbmVyLmhpZGRlbiA9PT0gZmFsc2U7XG4gIH1cbn1cbmNsYXNzIEZyZWVUZXh0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gcGFyYW1ldGVycy5kYXRhLnRleHRDb250ZW50O1xuICAgIHRoaXMudGV4dFBvc2l0aW9uID0gcGFyYW1ldGVycy5kYXRhLnRleHRQb3NpdGlvbjtcbiAgICB0aGlzLmFubm90YXRpb25FZGl0b3JUeXBlID0gQW5ub3RhdGlvbkVkaXRvclR5cGUuRlJFRVRFWFQ7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJmcmVlVGV4dEFubm90YXRpb25cIik7XG4gICAgaWYgKHRoaXMudGV4dENvbnRlbnQpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgY29udGVudC5jbGFzc0xpc3QuYWRkKFwiYW5ub3RhdGlvblRleHRDb250ZW50XCIpO1xuICAgICAgY29udGVudC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiY29tbWVudFwiKTtcbiAgICAgIGZvciAoY29uc3QgbGluZSBvZiB0aGlzLnRleHRDb250ZW50KSB7XG4gICAgICAgIGNvbnN0IGxpbmVTcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIGxpbmVTcGFuLnRleHRDb250ZW50ID0gbGluZTtcbiAgICAgICAgY29udGVudC5hcHBlbmQobGluZVNwYW4pO1xuICAgICAgfVxuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGNvbnRlbnQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5fZWRpdE9uRG91YmxlQ2xpY2soKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIExpbmVBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI2xpbmUgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJsaW5lQW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGdldFJlY3REaW1zKGRhdGEucmVjdCk7XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcbiAgICBjb25zdCBsaW5lID0gdGhpcy4jbGluZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmxpbmVcIik7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJ4MVwiLCBkYXRhLnJlY3RbMl0gLSBkYXRhLmxpbmVDb29yZGluYXRlc1swXSk7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJ5MVwiLCBkYXRhLnJlY3RbM10gLSBkYXRhLmxpbmVDb29yZGluYXRlc1sxXSk7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJ4MlwiLCBkYXRhLnJlY3RbMl0gLSBkYXRhLmxpbmVDb29yZGluYXRlc1syXSk7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJ5MlwiLCBkYXRhLnJlY3RbM10gLSBkYXRhLmxpbmVDb29yZGluYXRlc1szXSk7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgZGF0YS5ib3JkZXJTdHlsZS53aWR0aCB8fCAxKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIHN2Zy5hcHBlbmQobGluZSk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG4gICAgaWYgKCFkYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy4jbGluZTtcbiAgfVxuICBhZGRIaWdobGlnaHRBcmVhKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICB9XG59XG5jbGFzcyBTcXVhcmVBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI3NxdWFyZSA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInNxdWFyZUFubm90YXRpb25cIik7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBnZXRSZWN0RGltcyhkYXRhLnJlY3QpO1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG4gICAgY29uc3QgYm9yZGVyV2lkdGggPSBkYXRhLmJvcmRlclN0eWxlLndpZHRoO1xuICAgIGNvbnN0IHNxdWFyZSA9IHRoaXMuI3NxdWFyZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnJlY3RcIik7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcInhcIiwgYm9yZGVyV2lkdGggLyAyKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwieVwiLCBib3JkZXJXaWR0aCAvIDIpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB3aWR0aCAtIGJvcmRlcldpZHRoKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGhlaWdodCAtIGJvcmRlcldpZHRoKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGJvcmRlcldpZHRoIHx8IDEpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIHN2Zy5hcHBlbmQoc3F1YXJlKTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcbiAgICBpZiAoIWRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiNzcXVhcmU7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgfVxufVxuY2xhc3MgQ2lyY2xlQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICNjaXJjbGUgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJjaXJjbGVBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gZ2V0UmVjdERpbXMoZGF0YS5yZWN0KTtcbiAgICBjb25zdCBzdmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuICAgIGNvbnN0IGJvcmRlcldpZHRoID0gZGF0YS5ib3JkZXJTdHlsZS53aWR0aDtcbiAgICBjb25zdCBjaXJjbGUgPSB0aGlzLiNjaXJjbGUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzplbGxpcHNlXCIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJjeFwiLCB3aWR0aCAvIDIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJjeVwiLCBoZWlnaHQgLyAyKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwicnhcIiwgd2lkdGggLyAyIC0gYm9yZGVyV2lkdGggLyAyKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwicnlcIiwgaGVpZ2h0IC8gMiAtIGJvcmRlcldpZHRoIC8gMik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBib3JkZXJXaWR0aCB8fCAxKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBzdmcuYXBwZW5kKGNpcmNsZSk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG4gICAgaWYgKCFkYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy4jY2lyY2xlO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbn1cbmNsYXNzIFBvbHlsaW5lQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICNwb2x5bGluZSA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmNvbnRhaW5lckNsYXNzTmFtZSA9IFwicG9seWxpbmVBbm5vdGF0aW9uXCI7XG4gICAgdGhpcy5zdmdFbGVtZW50TmFtZSA9IFwic3ZnOnBvbHlsaW5lXCI7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQodGhpcy5jb250YWluZXJDbGFzc05hbWUpO1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcmVjdCxcbiAgICAgICAgdmVydGljZXMsXG4gICAgICAgIGJvcmRlclN0eWxlLFxuICAgICAgICBwb3B1cFJlZlxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghdmVydGljZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gZ2V0UmVjdERpbXMocmVjdCk7XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcbiAgICBsZXQgcG9pbnRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gdmVydGljZXMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgY29uc3QgeCA9IHZlcnRpY2VzW2ldIC0gcmVjdFswXTtcbiAgICAgIGNvbnN0IHkgPSByZWN0WzNdIC0gdmVydGljZXNbaSArIDFdO1xuICAgICAgcG9pbnRzLnB1c2goYCR7eH0sJHt5fWApO1xuICAgIH1cbiAgICBwb2ludHMgPSBwb2ludHMuam9pbihcIiBcIik7XG4gICAgY29uc3QgcG9seWxpbmUgPSB0aGlzLiNwb2x5bGluZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KHRoaXMuc3ZnRWxlbWVudE5hbWUpO1xuICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcInBvaW50c1wiLCBwb2ludHMpO1xuICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBib3JkZXJTdHlsZS53aWR0aCB8fCAxKTtcbiAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgc3ZnLmFwcGVuZChwb2x5bGluZSk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG4gICAgaWYgKCFwb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIGdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3BvbHlsaW5lO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbn1cbmNsYXNzIFBvbHlnb25Bbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIFBvbHlsaW5lQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycyk7XG4gICAgdGhpcy5jb250YWluZXJDbGFzc05hbWUgPSBcInBvbHlnb25Bbm5vdGF0aW9uXCI7XG4gICAgdGhpcy5zdmdFbGVtZW50TmFtZSA9IFwic3ZnOnBvbHlnb25cIjtcbiAgfVxufVxuY2xhc3MgQ2FyZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiY2FyZXRBbm5vdGF0aW9uXCIpO1xuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIElua0Fubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICAjcG9seWxpbmVzR3JvdXBFbGVtZW50ID0gbnVsbDtcbiAgI3BvbHlsaW5lcyA9IFtdO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5jb250YWluZXJDbGFzc05hbWUgPSBcImlua0Fubm90YXRpb25cIjtcbiAgICB0aGlzLnN2Z0VsZW1lbnROYW1lID0gXCJzdmc6cG9seWxpbmVcIjtcbiAgICB0aGlzLmFubm90YXRpb25FZGl0b3JUeXBlID0gdGhpcy5kYXRhLml0ID09PSBcIklua0hpZ2hsaWdodFwiID8gQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUIDogQW5ub3RhdGlvbkVkaXRvclR5cGUuSU5LO1xuICB9XG4gICNnZXRUcmFuc2Zvcm0ocm90YXRpb24sIHJlY3QpIHtcbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZSg5MCkgdHJhbnNsYXRlKCR7LXJlY3RbMF19LCR7cmVjdFsxXX0pIHNjYWxlKDEsLTEpYCxcbiAgICAgICAgICB3aWR0aDogcmVjdFszXSAtIHJlY3RbMV0sXG4gICAgICAgICAgaGVpZ2h0OiByZWN0WzJdIC0gcmVjdFswXVxuICAgICAgICB9O1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlKDE4MCkgdHJhbnNsYXRlKCR7LXJlY3RbMl19LCR7cmVjdFsxXX0pIHNjYWxlKDEsLTEpYCxcbiAgICAgICAgICB3aWR0aDogcmVjdFsyXSAtIHJlY3RbMF0sXG4gICAgICAgICAgaGVpZ2h0OiByZWN0WzNdIC0gcmVjdFsxXVxuICAgICAgICB9O1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlKDI3MCkgdHJhbnNsYXRlKCR7LXJlY3RbMl19LCR7cmVjdFszXX0pIHNjYWxlKDEsLTEpYCxcbiAgICAgICAgICB3aWR0aDogcmVjdFszXSAtIHJlY3RbMV0sXG4gICAgICAgICAgaGVpZ2h0OiByZWN0WzJdIC0gcmVjdFswXVxuICAgICAgICB9O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHstcmVjdFswXX0sJHtyZWN0WzNdfSkgc2NhbGUoMSwtMSlgLFxuICAgICAgICAgIHdpZHRoOiByZWN0WzJdIC0gcmVjdFswXSxcbiAgICAgICAgICBoZWlnaHQ6IHJlY3RbM10gLSByZWN0WzFdXG4gICAgICAgIH07XG4gICAgfVxuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKHRoaXMuY29udGFpbmVyQ2xhc3NOYW1lKTtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIHJlY3QsXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICBpbmtMaXN0cyxcbiAgICAgICAgYm9yZGVyU3R5bGUsXG4gICAgICAgIHBvcHVwUmVmXG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgdHJhbnNmb3JtLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcy4jZ2V0VHJhbnNmb3JtKHJvdGF0aW9uLCByZWN0KTtcbiAgICBjb25zdCBzdmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuICAgIGNvbnN0IGcgPSB0aGlzLiNwb2x5bGluZXNHcm91cEVsZW1lbnQgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpnXCIpO1xuICAgIHN2Zy5hcHBlbmQoZyk7XG4gICAgZy5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgYm9yZGVyU3R5bGUud2lkdGggfHwgMSk7XG4gICAgZy5zZXRBdHRyaWJ1dGUoXCJzdHJva2UtbGluZWNhcFwiLCBcInJvdW5kXCIpO1xuICAgIGcuc2V0QXR0cmlidXRlKFwic3Ryb2tlLWxpbmVqb2luXCIsIFwicm91bmRcIik7XG4gICAgZy5zZXRBdHRyaWJ1dGUoXCJzdHJva2UtbWl0ZXJsaW1pdFwiLCAxMCk7XG4gICAgZy5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBnLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBnLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0pO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGlua0xpc3RzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGNvbnN0IHBvbHlsaW5lID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQodGhpcy5zdmdFbGVtZW50TmFtZSk7XG4gICAgICB0aGlzLiNwb2x5bGluZXMucHVzaChwb2x5bGluZSk7XG4gICAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJwb2ludHNcIiwgaW5rTGlzdHNbaV0uam9pbihcIixcIikpO1xuICAgICAgZy5hcHBlbmQocG9seWxpbmUpO1xuICAgIH1cbiAgICBpZiAoIXBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcbiAgICB0aGlzLl9lZGl0T25Eb3VibGVDbGljaygpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICB1cGRhdGVFZGl0ZWQocGFyYW1zKSB7XG4gICAgc3VwZXIudXBkYXRlRWRpdGVkKHBhcmFtcyk7XG4gICAgY29uc3Qge1xuICAgICAgdGhpY2tuZXNzLFxuICAgICAgcG9pbnRzLFxuICAgICAgcmVjdFxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgZyA9IHRoaXMuI3BvbHlsaW5lc0dyb3VwRWxlbWVudDtcbiAgICBpZiAodGhpY2tuZXNzID49IDApIHtcbiAgICAgIGcuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIHRoaWNrbmVzcyB8fCAxKTtcbiAgICB9XG4gICAgaWYgKHBvaW50cykge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gdGhpcy4jcG9seWxpbmVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgdGhpcy4jcG9seWxpbmVzW2ldLnNldEF0dHJpYnV0ZShcInBvaW50c1wiLCBwb2ludHNbaV0uam9pbihcIixcIikpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVjdCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB0cmFuc2Zvcm0sXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0gPSB0aGlzLiNnZXRUcmFuc2Zvcm0odGhpcy5kYXRhLnJvdGF0aW9uLCByZWN0KTtcbiAgICAgIGNvbnN0IHJvb3QgPSBnLnBhcmVudEVsZW1lbnQ7XG4gICAgICByb290LnNldEF0dHJpYnV0ZShcInZpZXdCb3hcIiwgYDAgMCAke3dpZHRofSAke2hlaWdodH1gKTtcbiAgICAgIGcuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSk7XG4gICAgfVxuICB9XG4gIGdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3BvbHlsaW5lcztcbiAgfVxuICBhZGRIaWdobGlnaHRBcmVhKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICB9XG59XG5jbGFzcyBIaWdobGlnaHRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZSxcbiAgICAgIGNyZWF0ZVF1YWRyaWxhdGVyYWxzOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5hbm5vdGF0aW9uRWRpdG9yVHlwZSA9IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVDtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBbm5vdGF0aW9uXCIpO1xuICAgIHRoaXMuX2VkaXRPbkRvdWJsZUNsaWNrKCk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBVbmRlcmxpbmVBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZSxcbiAgICAgIGNyZWF0ZVF1YWRyaWxhdGVyYWxzOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwidW5kZXJsaW5lQW5ub3RhdGlvblwiKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFNxdWlnZ2x5QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWUsXG4gICAgICBjcmVhdGVRdWFkcmlsYXRlcmFsczogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInNxdWlnZ2x5QW5ub3RhdGlvblwiKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFN0cmlrZU91dEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHM6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJzdHJpa2VvdXRBbm5vdGF0aW9uXCIpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgU3RhbXBBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuYW5ub3RhdGlvbkVkaXRvclR5cGUgPSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5TVEFNUDtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInN0YW1wQW5ub3RhdGlvblwiKTtcbiAgICB0aGlzLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiaW1nXCIpO1xuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLl9lZGl0T25Eb3VibGVDbGljaygpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgRmlsZUF0dGFjaG1lbnRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI3RyaWdnZXIgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgY29uc3Qge1xuICAgICAgZmlsZVxuICAgIH0gPSB0aGlzLmRhdGE7XG4gICAgdGhpcy5maWxlbmFtZSA9IGZpbGUuZmlsZW5hbWU7XG4gICAgdGhpcy5jb250ZW50ID0gZmlsZS5jb250ZW50O1xuICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZmlsZWF0dGFjaG1lbnRhbm5vdGF0aW9uXCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIC4uLmZpbGVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImZpbGVBdHRhY2htZW50QW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCB7XG4gICAgICBjb250YWluZXIsXG4gICAgICBkYXRhXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHRyaWdnZXI7XG4gICAgaWYgKGRhdGEuaGFzQXBwZWFyYW5jZSB8fCBkYXRhLmZpbGxBbHBoYSA9PT0gMCkge1xuICAgICAgdHJpZ2dlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyaWdnZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgdHJpZ2dlci5zcmMgPSBgJHt0aGlzLmltYWdlUmVzb3VyY2VzUGF0aH1hbm5vdGF0aW9uLSR7L3BhcGVyY2xpcC9pLnRlc3QoZGF0YS5uYW1lKSA/IFwicGFwZXJjbGlwXCIgOiBcInB1c2hwaW5cIn0uc3ZnYDtcbiAgICAgIGlmIChkYXRhLmZpbGxBbHBoYSAmJiBkYXRhLmZpbGxBbHBoYSA8IDEpIHtcbiAgICAgICAgdHJpZ2dlci5zdHlsZSA9IGBmaWx0ZXI6IG9wYWNpdHkoJHtNYXRoLnJvdW5kKGRhdGEuZmlsbEFscGhhICogMTAwKX0lKTtgO1xuICAgICAgfVxuICAgIH1cbiAgICB0cmlnZ2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJkYmxjbGlja1wiLCB0aGlzLiNkb3dubG9hZC5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLiN0cmlnZ2VyID0gdHJpZ2dlcjtcbiAgICBjb25zdCB7XG4gICAgICBpc01hY1xuICAgIH0gPSB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBldnQgPT4ge1xuICAgICAgaWYgKGV2dC5rZXkgPT09IFwiRW50ZXJcIiAmJiAoaXNNYWMgPyBldnQubWV0YUtleSA6IGV2dC5jdHJsS2V5KSkge1xuICAgICAgICB0aGlzLiNkb3dubG9hZCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJpZ2dlci5jbGFzc0xpc3QuYWRkKFwicG9wdXBUcmlnZ2VyQXJlYVwiKTtcbiAgICB9XG4gICAgY29udGFpbmVyLmFwcGVuZCh0cmlnZ2VyKTtcbiAgICByZXR1cm4gY29udGFpbmVyO1xuICB9XG4gIGdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3RyaWdnZXI7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgfVxuICAjZG93bmxvYWQoKSB7XG4gICAgdGhpcy5kb3dubG9hZE1hbmFnZXI/Lm9wZW5PckRvd25sb2FkRGF0YSh0aGlzLmNvbnRlbnQsIHRoaXMuZmlsZW5hbWUpO1xuICB9XG59XG5jbGFzcyBBbm5vdGF0aW9uTGF5ZXIge1xuICAjYWNjZXNzaWJpbGl0eU1hbmFnZXIgPSBudWxsO1xuICAjYW5ub3RhdGlvbkNhbnZhc01hcCA9IG51bGw7XG4gICNlZGl0YWJsZUFubm90YXRpb25zID0gbmV3IE1hcCgpO1xuICAjc3RydWN0VHJlZUxheWVyID0gbnVsbDtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGRpdixcbiAgICBhY2Nlc3NpYmlsaXR5TWFuYWdlcixcbiAgICBhbm5vdGF0aW9uQ2FudmFzTWFwLFxuICAgIGFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIsXG4gICAgcGFnZSxcbiAgICB2aWV3cG9ydCxcbiAgICBzdHJ1Y3RUcmVlTGF5ZXJcbiAgfSkge1xuICAgIHRoaXMuZGl2ID0gZGl2O1xuICAgIHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyID0gYWNjZXNzaWJpbGl0eU1hbmFnZXI7XG4gICAgdGhpcy4jYW5ub3RhdGlvbkNhbnZhc01hcCA9IGFubm90YXRpb25DYW52YXNNYXA7XG4gICAgdGhpcy4jc3RydWN0VHJlZUxheWVyID0gc3RydWN0VHJlZUxheWVyIHx8IG51bGw7XG4gICAgdGhpcy5wYWdlID0gcGFnZTtcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgdGhpcy56SW5kZXggPSAwO1xuICAgIHRoaXMuX2Fubm90YXRpb25FZGl0b3JVSU1hbmFnZXIgPSBhbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyO1xuICB9XG4gIGhhc0VkaXRhYmxlQW5ub3RhdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2VkaXRhYmxlQW5ub3RhdGlvbnMuc2l6ZSA+IDA7XG4gIH1cbiAgYXN5bmMgI2FwcGVuZEVsZW1lbnQoZWxlbWVudCwgaWQpIHtcbiAgICBjb25zdCBjb250ZW50RWxlbWVudCA9IGVsZW1lbnQuZmlyc3RDaGlsZCB8fCBlbGVtZW50O1xuICAgIGNvbnN0IGFubm90YXRpb25JZCA9IGNvbnRlbnRFbGVtZW50LmlkID0gYCR7QW5ub3RhdGlvblByZWZpeH0ke2lkfWA7XG4gICAgY29uc3QgYXJpYUF0dHJpYnV0ZXMgPSBhd2FpdCB0aGlzLiNzdHJ1Y3RUcmVlTGF5ZXI/LmdldEFyaWFBdHRyaWJ1dGVzKGFubm90YXRpb25JZCk7XG4gICAgaWYgKGFyaWFBdHRyaWJ1dGVzKSB7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBhcmlhQXR0cmlidXRlcykge1xuICAgICAgICBjb250ZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZGl2LmFwcGVuZChlbGVtZW50KTtcbiAgICB0aGlzLiNhY2Nlc3NpYmlsaXR5TWFuYWdlcj8ubW92ZUVsZW1lbnRJbkRPTSh0aGlzLmRpdiwgZWxlbWVudCwgY29udGVudEVsZW1lbnQsIGZhbHNlKTtcbiAgfVxuICBhc3luYyByZW5kZXIocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgYW5ub3RhdGlvbnNcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy5kaXY7XG4gICAgc2V0TGF5ZXJEaW1lbnNpb25zKGxheWVyLCB0aGlzLnZpZXdwb3J0KTtcbiAgICBjb25zdCBwb3B1cFRvRWxlbWVudHMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZWxlbWVudFBhcmFtcyA9IHtcbiAgICAgIGRhdGE6IG51bGwsXG4gICAgICBsYXllcixcbiAgICAgIGxpbmtTZXJ2aWNlOiBwYXJhbXMubGlua1NlcnZpY2UsXG4gICAgICBkb3dubG9hZE1hbmFnZXI6IHBhcmFtcy5kb3dubG9hZE1hbmFnZXIsXG4gICAgICBpbWFnZVJlc291cmNlc1BhdGg6IHBhcmFtcy5pbWFnZVJlc291cmNlc1BhdGggfHwgXCJcIixcbiAgICAgIHJlbmRlckZvcm1zOiBwYXJhbXMucmVuZGVyRm9ybXMgIT09IGZhbHNlLFxuICAgICAgc3ZnRmFjdG9yeTogbmV3IERPTVNWR0ZhY3RvcnkoKSxcbiAgICAgIGFubm90YXRpb25TdG9yYWdlOiBwYXJhbXMuYW5ub3RhdGlvblN0b3JhZ2UgfHwgbmV3IEFubm90YXRpb25TdG9yYWdlKCksXG4gICAgICBlbmFibGVTY3JpcHRpbmc6IHBhcmFtcy5lbmFibGVTY3JpcHRpbmcgPT09IHRydWUsXG4gICAgICBoYXNKU0FjdGlvbnM6IHBhcmFtcy5oYXNKU0FjdGlvbnMsXG4gICAgICBmaWVsZE9iamVjdHM6IHBhcmFtcy5maWVsZE9iamVjdHMsXG4gICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICBlbGVtZW50czogbnVsbFxuICAgIH07XG4gICAgZm9yIChjb25zdCBkYXRhIG9mIGFubm90YXRpb25zKSB7XG4gICAgICBpZiAoZGF0YS5ub0hUTUwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBpc1BvcHVwQW5ub3RhdGlvbiA9IGRhdGEuYW5ub3RhdGlvblR5cGUgPT09IEFubm90YXRpb25UeXBlLlBPUFVQO1xuICAgICAgaWYgKCFpc1BvcHVwQW5ub3RhdGlvbikge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0XG4gICAgICAgIH0gPSBnZXRSZWN0RGltcyhkYXRhLnJlY3QpO1xuICAgICAgICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IHBvcHVwVG9FbGVtZW50cy5nZXQoZGF0YS5pZCk7XG4gICAgICAgIGlmICghZWxlbWVudHMpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50UGFyYW1zLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgICB9XG4gICAgICBlbGVtZW50UGFyYW1zLmRhdGEgPSBkYXRhO1xuICAgICAgY29uc3QgZWxlbWVudCA9IEFubm90YXRpb25FbGVtZW50RmFjdG9yeS5jcmVhdGUoZWxlbWVudFBhcmFtcyk7XG4gICAgICBpZiAoIWVsZW1lbnQuaXNSZW5kZXJhYmxlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFpc1BvcHVwQW5ub3RhdGlvbiAmJiBkYXRhLnBvcHVwUmVmKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gcG9wdXBUb0VsZW1lbnRzLmdldChkYXRhLnBvcHVwUmVmKTtcbiAgICAgICAgaWYgKCFlbGVtZW50cykge1xuICAgICAgICAgIHBvcHVwVG9FbGVtZW50cy5zZXQoZGF0YS5wb3B1cFJlZiwgW2VsZW1lbnRdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCByZW5kZXJlZCA9IGVsZW1lbnQucmVuZGVyKCk7XG4gICAgICBpZiAoZGF0YS5oaWRkZW4pIHtcbiAgICAgICAgcmVuZGVyZWQuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLiNhcHBlbmRFbGVtZW50KHJlbmRlcmVkLCBkYXRhLmlkKTtcbiAgICAgIGlmIChlbGVtZW50Ll9pc0VkaXRhYmxlKSB7XG4gICAgICAgIHRoaXMuI2VkaXRhYmxlQW5ub3RhdGlvbnMuc2V0KGVsZW1lbnQuZGF0YS5pZCwgZWxlbWVudCk7XG4gICAgICAgIHRoaXMuX2Fubm90YXRpb25FZGl0b3JVSU1hbmFnZXI/LnJlbmRlckFubm90YXRpb25FbGVtZW50KGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNzZXRBbm5vdGF0aW9uQ2FudmFzTWFwKCk7XG4gIH1cbiAgdXBkYXRlKHtcbiAgICB2aWV3cG9ydFxuICB9KSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmRpdjtcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgc2V0TGF5ZXJEaW1lbnNpb25zKGxheWVyLCB7XG4gICAgICByb3RhdGlvbjogdmlld3BvcnQucm90YXRpb25cbiAgICB9KTtcbiAgICB0aGlzLiNzZXRBbm5vdGF0aW9uQ2FudmFzTWFwKCk7XG4gICAgbGF5ZXIuaGlkZGVuID0gZmFsc2U7XG4gIH1cbiAgI3NldEFubm90YXRpb25DYW52YXNNYXAoKSB7XG4gICAgaWYgKCF0aGlzLiNhbm5vdGF0aW9uQ2FudmFzTWFwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5kaXY7XG4gICAgZm9yIChjb25zdCBbaWQsIGNhbnZhc10gb2YgdGhpcy4jYW5ub3RhdGlvbkNhbnZhc01hcCkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGxheWVyLnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWFubm90YXRpb24taWQ9XCIke2lkfVwiXWApO1xuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY2FudmFzLmNsYXNzTmFtZSA9IFwiYW5ub3RhdGlvbkNvbnRlbnRcIjtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZmlyc3RDaGlsZFxuICAgICAgfSA9IGVsZW1lbnQ7XG4gICAgICBpZiAoIWZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZWxlbWVudC5hcHBlbmQoY2FudmFzKTtcbiAgICAgIH0gZWxzZSBpZiAoZmlyc3RDaGlsZC5ub2RlTmFtZSA9PT0gXCJDQU5WQVNcIikge1xuICAgICAgICBmaXJzdENoaWxkLnJlcGxhY2VXaXRoKGNhbnZhcyk7XG4gICAgICB9IGVsc2UgaWYgKCFmaXJzdENoaWxkLmNsYXNzTGlzdC5jb250YWlucyhcImFubm90YXRpb25Db250ZW50XCIpKSB7XG4gICAgICAgIGZpcnN0Q2hpbGQuYmVmb3JlKGNhbnZhcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXJzdENoaWxkLmFmdGVyKGNhbnZhcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2Fubm90YXRpb25DYW52YXNNYXAuY2xlYXIoKTtcbiAgfVxuICBnZXRFZGl0YWJsZUFubm90YXRpb25zKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuI2VkaXRhYmxlQW5ub3RhdGlvbnMudmFsdWVzKCkpO1xuICB9XG4gIGdldEVkaXRhYmxlQW5ub3RhdGlvbihpZCkge1xuICAgIHJldHVybiB0aGlzLiNlZGl0YWJsZUFubm90YXRpb25zLmdldChpZCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2ZyZWV0ZXh0LmpzXG5cblxuXG5cbmNvbnN0IEVPTF9QQVRURVJOID0gL1xcclxcbj98XFxuL2c7XG5jbGFzcyBGcmVlVGV4dEVkaXRvciBleHRlbmRzIEFubm90YXRpb25FZGl0b3Ige1xuICAjY29sb3I7XG4gICNjb250ZW50ID0gXCJcIjtcbiAgI2VkaXRvckRpdklkID0gYCR7dGhpcy5pZH0tZWRpdG9yYDtcbiAgI2VkaXRNb2RlQUMgPSBudWxsO1xuICAjZm9udFNpemU7XG4gIHN0YXRpYyBfZnJlZVRleHREZWZhdWx0Q29udGVudCA9IFwiXCI7XG4gIHN0YXRpYyBfaW50ZXJuYWxQYWRkaW5nID0gMDtcbiAgc3RhdGljIF9kZWZhdWx0Q29sb3IgPSBudWxsO1xuICBzdGF0aWMgX2RlZmF1bHRGb250U2l6ZSA9IDEwO1xuICBzdGF0aWMgZ2V0IF9rZXlib2FyZE1hbmFnZXIoKSB7XG4gICAgY29uc3QgcHJvdG8gPSBGcmVlVGV4dEVkaXRvci5wcm90b3R5cGU7XG4gICAgY29uc3QgYXJyb3dDaGVja2VyID0gc2VsZiA9PiBzZWxmLmlzRW1wdHkoKTtcbiAgICBjb25zdCBzbWFsbCA9IEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIuVFJBTlNMQVRFX1NNQUxMO1xuICAgIGNvbnN0IGJpZyA9IEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIuVFJBTlNMQVRFX0JJRztcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2tleWJvYXJkTWFuYWdlclwiLCBuZXcgS2V5Ym9hcmRNYW5hZ2VyKFtbW1wiY3RybCtzXCIsIFwibWFjK21ldGErc1wiLCBcImN0cmwrcFwiLCBcIm1hYyttZXRhK3BcIl0sIHByb3RvLmNvbW1pdE9yUmVtb3ZlLCB7XG4gICAgICBidWJibGVzOiB0cnVlXG4gICAgfV0sIFtbXCJjdHJsK0VudGVyXCIsIFwibWFjK21ldGErRW50ZXJcIiwgXCJFc2NhcGVcIiwgXCJtYWMrRXNjYXBlXCJdLCBwcm90by5jb21taXRPclJlbW92ZV0sIFtbXCJBcnJvd0xlZnRcIiwgXCJtYWMrQXJyb3dMZWZ0XCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFstc21hbGwsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93TGVmdFwiLCBcIm1hYytzaGlmdCtBcnJvd0xlZnRcIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogWy1iaWcsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJBcnJvd1JpZ2h0XCIsIFwibWFjK0Fycm93UmlnaHRcIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogW3NtYWxsLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd1JpZ2h0XCIsIFwibWFjK3NoaWZ0K0Fycm93UmlnaHRcIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogW2JpZywgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93VXBcIiwgXCJtYWMrQXJyb3dVcFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbMCwgLXNtYWxsXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd1VwXCIsIFwibWFjK3NoaWZ0K0Fycm93VXBcIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogWzAsIC1iaWddLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJBcnJvd0Rvd25cIiwgXCJtYWMrQXJyb3dEb3duXCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFswLCBzbWFsbF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dEb3duXCIsIFwibWFjK3NoaWZ0K0Fycm93RG93blwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbMCwgYmlnXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dXSkpO1xuICB9XG4gIHN0YXRpYyBfdHlwZSA9IFwiZnJlZXRleHRcIjtcbiAgc3RhdGljIF9lZGl0b3JUeXBlID0gQW5ub3RhdGlvbkVkaXRvclR5cGUuRlJFRVRFWFQ7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLnBhcmFtcyxcbiAgICAgIG5hbWU6IFwiZnJlZVRleHRFZGl0b3JcIlxuICAgIH0pO1xuICAgIHRoaXMuI2NvbG9yID0gcGFyYW1zLmNvbG9yIHx8IEZyZWVUZXh0RWRpdG9yLl9kZWZhdWx0Q29sb3IgfHwgQW5ub3RhdGlvbkVkaXRvci5fZGVmYXVsdExpbmVDb2xvcjtcbiAgICB0aGlzLiNmb250U2l6ZSA9IHBhcmFtcy5mb250U2l6ZSB8fCBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdEZvbnRTaXplO1xuICB9XG4gIHN0YXRpYyBpbml0aWFsaXplKGwxMG4sIHVpTWFuYWdlcikge1xuICAgIEFubm90YXRpb25FZGl0b3IuaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpO1xuICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuICAgIHRoaXMuX2ludGVybmFsUGFkZGluZyA9IHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcIi0tZnJlZXRleHQtcGFkZGluZ1wiKSk7XG4gIH1cbiAgc3RhdGljIHVwZGF0ZURlZmF1bHRQYXJhbXModHlwZSwgdmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfU0laRTpcbiAgICAgICAgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRGb250U2l6ZSA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfQ09MT1I6XG4gICAgICAgIEZyZWVUZXh0RWRpdG9yLl9kZWZhdWx0Q29sb3IgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9TSVpFOlxuICAgICAgICB0aGlzLiN1cGRhdGVGb250U2l6ZSh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9DT0xPUjpcbiAgICAgICAgdGhpcy4jdXBkYXRlQ29sb3IodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldCBkZWZhdWx0UHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIHJldHVybiBbW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX1NJWkUsIEZyZWVUZXh0RWRpdG9yLl9kZWZhdWx0Rm9udFNpemVdLCBbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfQ09MT1IsIEZyZWVUZXh0RWRpdG9yLl9kZWZhdWx0Q29sb3IgfHwgQW5ub3RhdGlvbkVkaXRvci5fZGVmYXVsdExpbmVDb2xvcl1dO1xuICB9XG4gIGdldCBwcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfU0laRSwgdGhpcy4jZm9udFNpemVdLCBbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfQ09MT1IsIHRoaXMuI2NvbG9yXV07XG4gIH1cbiAgI3VwZGF0ZUZvbnRTaXplKGZvbnRTaXplKSB7XG4gICAgY29uc3Qgc2V0Rm9udHNpemUgPSBzaXplID0+IHtcbiAgICAgIHRoaXMuZWRpdG9yRGl2LnN0eWxlLmZvbnRTaXplID0gYGNhbGMoJHtzaXplfXB4ICogdmFyKC0tc2NhbGUtZmFjdG9yKSlgO1xuICAgICAgdGhpcy50cmFuc2xhdGUoMCwgLShzaXplIC0gdGhpcy4jZm9udFNpemUpICogdGhpcy5wYXJlbnRTY2FsZSk7XG4gICAgICB0aGlzLiNmb250U2l6ZSA9IHNpemU7XG4gICAgICB0aGlzLiNzZXRFZGl0b3JEaW1lbnNpb25zKCk7XG4gICAgfTtcbiAgICBjb25zdCBzYXZlZEZvbnRzaXplID0gdGhpcy4jZm9udFNpemU7XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6IHNldEZvbnRzaXplLmJpbmQodGhpcywgZm9udFNpemUpLFxuICAgICAgdW5kbzogc2V0Rm9udHNpemUuYmluZCh0aGlzLCBzYXZlZEZvbnRzaXplKSxcbiAgICAgIHBvc3Q6IHRoaXMuX3VpTWFuYWdlci51cGRhdGVVSS5iaW5kKHRoaXMuX3VpTWFuYWdlciwgdGhpcyksXG4gICAgICBtdXN0RXhlYzogdHJ1ZSxcbiAgICAgIHR5cGU6IEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX1NJWkUsXG4gICAgICBvdmVyd3JpdGVJZlNhbWVUeXBlOiB0cnVlLFxuICAgICAga2VlcFVuZG86IHRydWVcbiAgICB9KTtcbiAgfVxuICAjdXBkYXRlQ29sb3IoY29sb3IpIHtcbiAgICBjb25zdCBzZXRDb2xvciA9IGNvbCA9PiB7XG4gICAgICB0aGlzLiNjb2xvciA9IHRoaXMuZWRpdG9yRGl2LnN0eWxlLmNvbG9yID0gY29sO1xuICAgIH07XG4gICAgY29uc3Qgc2F2ZWRDb2xvciA9IHRoaXMuI2NvbG9yO1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiBzZXRDb2xvci5iaW5kKHRoaXMsIGNvbG9yKSxcbiAgICAgIHVuZG86IHNldENvbG9yLmJpbmQodGhpcywgc2F2ZWRDb2xvciksXG4gICAgICBwb3N0OiB0aGlzLl91aU1hbmFnZXIudXBkYXRlVUkuYmluZCh0aGlzLl91aU1hbmFnZXIsIHRoaXMpLFxuICAgICAgbXVzdEV4ZWM6IHRydWUsXG4gICAgICB0eXBlOiBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9DT0xPUixcbiAgICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGU6IHRydWUsXG4gICAgICBrZWVwVW5kbzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIF90cmFuc2xhdGVFbXB0eSh4LCB5KSB7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycyh4LCB5LCB0cnVlKTtcbiAgfVxuICBnZXRJbml0aWFsVHJhbnNsYXRpb24oKSB7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLnBhcmVudFNjYWxlO1xuICAgIHJldHVybiBbLUZyZWVUZXh0RWRpdG9yLl9pbnRlcm5hbFBhZGRpbmcgKiBzY2FsZSwgLShGcmVlVGV4dEVkaXRvci5faW50ZXJuYWxQYWRkaW5nICsgdGhpcy4jZm9udFNpemUpICogc2NhbGVdO1xuICB9XG4gIHJlYnVpbGQoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5yZWJ1aWxkKCk7XG4gICAgaWYgKHRoaXMuZGl2ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHRoaXMucGFyZW50LmFkZCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgZW5hYmxlRWRpdE1vZGUoKSB7XG4gICAgaWYgKHRoaXMuaXNJbkVkaXRNb2RlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQuc2V0RWRpdGluZ1N0YXRlKGZhbHNlKTtcbiAgICB0aGlzLnBhcmVudC51cGRhdGVUb29sYmFyKEFubm90YXRpb25FZGl0b3JUeXBlLkZSRUVURVhUKTtcbiAgICBzdXBlci5lbmFibGVFZGl0TW9kZSgpO1xuICAgIHRoaXMub3ZlcmxheURpdi5jbGFzc0xpc3QucmVtb3ZlKFwiZW5hYmxlZFwiKTtcbiAgICB0aGlzLmVkaXRvckRpdi5jb250ZW50RWRpdGFibGUgPSB0cnVlO1xuICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5kaXYucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIpO1xuICAgIHRoaXMuI2VkaXRNb2RlQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5fdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKHRoaXMuI2VkaXRNb2RlQUMpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuZWRpdG9yRGl2S2V5ZG93bi5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLmVkaXRvckRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy5lZGl0b3JEaXZGb2N1cy5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLmVkaXRvckRpdi5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLmVkaXRvckRpdkJsdXIuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy5lZGl0b3JEaXYuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHRoaXMuZWRpdG9yRGl2SW5wdXQuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy5lZGl0b3JEaXYuYWRkRXZlbnRMaXN0ZW5lcihcInBhc3RlXCIsIHRoaXMuZWRpdG9yRGl2UGFzdGUuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgZGlzYWJsZUVkaXRNb2RlKCkge1xuICAgIGlmICghdGhpcy5pc0luRWRpdE1vZGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudC5zZXRFZGl0aW5nU3RhdGUodHJ1ZSk7XG4gICAgc3VwZXIuZGlzYWJsZUVkaXRNb2RlKCk7XG4gICAgdGhpcy5vdmVybGF5RGl2LmNsYXNzTGlzdC5hZGQoXCJlbmFibGVkXCIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmNvbnRlbnRFZGl0YWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiLCB0aGlzLiNlZGl0b3JEaXZJZCk7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSB0cnVlO1xuICAgIHRoaXMuI2VkaXRNb2RlQUM/LmFib3J0KCk7XG4gICAgdGhpcy4jZWRpdE1vZGVBQyA9IG51bGw7XG4gICAgdGhpcy5kaXYuZm9jdXMoe1xuICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuaXNFZGl0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5wYXJlbnQuZGl2LmNsYXNzTGlzdC5hZGQoXCJmcmVldGV4dEVkaXRpbmdcIik7XG4gIH1cbiAgZm9jdXNpbihldmVudCkge1xuICAgIGlmICghdGhpcy5fZm9jdXNFdmVudHNBbGxvd2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLmZvY3VzaW4oZXZlbnQpO1xuICAgIGlmIChldmVudC50YXJnZXQgIT09IHRoaXMuZWRpdG9yRGl2KSB7XG4gICAgICB0aGlzLmVkaXRvckRpdi5mb2N1cygpO1xuICAgIH1cbiAgfVxuICBvbmNlQWRkZWQoKSB7XG4gICAgaWYgKHRoaXMud2lkdGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmZvY3VzKCk7XG4gICAgaWYgKHRoaXMuX2luaXRpYWxPcHRpb25zPy5pc0NlbnRlcmVkKSB7XG4gICAgICB0aGlzLmNlbnRlcigpO1xuICAgIH1cbiAgICB0aGlzLl9pbml0aWFsT3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gIXRoaXMuZWRpdG9yRGl2IHx8IHRoaXMuZWRpdG9yRGl2LmlubmVyVGV4dC50cmltKCkgPT09IFwiXCI7XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIHRoaXMuaXNFZGl0aW5nID0gZmFsc2U7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudC5zZXRFZGl0aW5nU3RhdGUodHJ1ZSk7XG4gICAgICB0aGlzLnBhcmVudC5kaXYuY2xhc3NMaXN0LmFkZChcImZyZWV0ZXh0RWRpdGluZ1wiKTtcbiAgICB9XG4gICAgc3VwZXIucmVtb3ZlKCk7XG4gIH1cbiAgI2V4dHJhY3RUZXh0KCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IFtdO1xuICAgIHRoaXMuZWRpdG9yRGl2Lm5vcm1hbGl6ZSgpO1xuICAgIGxldCBwcmV2Q2hpbGQgPSBudWxsO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5lZGl0b3JEaXYuY2hpbGROb2Rlcykge1xuICAgICAgaWYgKHByZXZDaGlsZD8ubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFICYmIGNoaWxkLm5vZGVOYW1lID09PSBcIkJSXCIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBidWZmZXIucHVzaChGcmVlVGV4dEVkaXRvci4jZ2V0Tm9kZUNvbnRlbnQoY2hpbGQpKTtcbiAgICAgIHByZXZDaGlsZCA9IGNoaWxkO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oXCJcXG5cIik7XG4gIH1cbiAgI3NldEVkaXRvckRpbWVuc2lvbnMoKSB7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIGxldCByZWN0O1xuICAgIGlmICh0aGlzLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgcmVjdCA9IHRoaXMuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGN1cnJlbnRMYXllcixcbiAgICAgICAgZGl2XG4gICAgICB9ID0gdGhpcztcbiAgICAgIGNvbnN0IHNhdmVkRGlzcGxheSA9IGRpdi5zdHlsZS5kaXNwbGF5O1xuICAgICAgY29uc3Qgc2F2ZWRWaXNpYmlsaXR5ID0gZGl2LmNsYXNzTGlzdC5jb250YWlucyhcImhpZGRlblwiKTtcbiAgICAgIGRpdi5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZGVuXCIpO1xuICAgICAgZGl2LnN0eWxlLmRpc3BsYXkgPSBcImhpZGRlblwiO1xuICAgICAgY3VycmVudExheWVyLmRpdi5hcHBlbmQodGhpcy5kaXYpO1xuICAgICAgcmVjdCA9IGRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGRpdi5yZW1vdmUoKTtcbiAgICAgIGRpdi5zdHlsZS5kaXNwbGF5ID0gc2F2ZWREaXNwbGF5O1xuICAgICAgZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJoaWRkZW5cIiwgc2F2ZWRWaXNpYmlsaXR5KTtcbiAgICB9XG4gICAgaWYgKHRoaXMucm90YXRpb24gJSAxODAgPT09IHRoaXMucGFyZW50Um90YXRpb24gJSAxODApIHtcbiAgICAgIHRoaXMud2lkdGggPSByZWN0LndpZHRoIC8gcGFyZW50V2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHJlY3QuaGVpZ2h0IC8gcGFyZW50SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndpZHRoID0gcmVjdC5oZWlnaHQgLyBwYXJlbnRXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gcmVjdC53aWR0aCAvIHBhcmVudEhlaWdodDtcbiAgICB9XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICB9XG4gIGNvbW1pdCgpIHtcbiAgICBpZiAoIXRoaXMuaXNJbkVkaXRNb2RlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIuY29tbWl0KCk7XG4gICAgdGhpcy5kaXNhYmxlRWRpdE1vZGUoKTtcbiAgICBjb25zdCBzYXZlZFRleHQgPSB0aGlzLiNjb250ZW50O1xuICAgIGNvbnN0IG5ld1RleHQgPSB0aGlzLiNjb250ZW50ID0gdGhpcy4jZXh0cmFjdFRleHQoKS50cmltRW5kKCk7XG4gICAgaWYgKHNhdmVkVGV4dCA9PT0gbmV3VGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZXRUZXh0ID0gdGV4dCA9PiB7XG4gICAgICB0aGlzLiNjb250ZW50ID0gdGV4dDtcbiAgICAgIGlmICghdGV4dCkge1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLiNzZXRDb250ZW50KCk7XG4gICAgICB0aGlzLl91aU1hbmFnZXIucmVidWlsZCh0aGlzKTtcbiAgICAgIHRoaXMuI3NldEVkaXRvckRpbWVuc2lvbnMoKTtcbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiAoKSA9PiB7XG4gICAgICAgIHNldFRleHQobmV3VGV4dCk7XG4gICAgICB9LFxuICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICBzZXRUZXh0KHNhdmVkVGV4dCk7XG4gICAgICB9LFxuICAgICAgbXVzdEV4ZWM6IGZhbHNlXG4gICAgfSk7XG4gICAgdGhpcy4jc2V0RWRpdG9yRGltZW5zaW9ucygpO1xuICB9XG4gIHNob3VsZEdldEtleWJvYXJkRXZlbnRzKCkge1xuICAgIHJldHVybiB0aGlzLmlzSW5FZGl0TW9kZSgpO1xuICB9XG4gIGVudGVySW5FZGl0TW9kZSgpIHtcbiAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgdGhpcy5lZGl0b3JEaXYuZm9jdXMoKTtcbiAgfVxuICBkYmxjbGljayhldmVudCkge1xuICAgIHRoaXMuZW50ZXJJbkVkaXRNb2RlKCk7XG4gIH1cbiAga2V5ZG93bihldmVudCkge1xuICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMuZGl2ICYmIGV2ZW50LmtleSA9PT0gXCJFbnRlclwiKSB7XG4gICAgICB0aGlzLmVudGVySW5FZGl0TW9kZSgpO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbiAgZWRpdG9yRGl2S2V5ZG93bihldmVudCkge1xuICAgIEZyZWVUZXh0RWRpdG9yLl9rZXlib2FyZE1hbmFnZXIuZXhlYyh0aGlzLCBldmVudCk7XG4gIH1cbiAgZWRpdG9yRGl2Rm9jdXMoZXZlbnQpIHtcbiAgICB0aGlzLmlzRWRpdGluZyA9IHRydWU7XG4gIH1cbiAgZWRpdG9yRGl2Qmx1cihldmVudCkge1xuICAgIHRoaXMuaXNFZGl0aW5nID0gZmFsc2U7XG4gIH1cbiAgZWRpdG9yRGl2SW5wdXQoZXZlbnQpIHtcbiAgICB0aGlzLnBhcmVudC5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImZyZWV0ZXh0RWRpdGluZ1wiLCB0aGlzLmlzRW1wdHkoKSk7XG4gIH1cbiAgZGlzYWJsZUVkaXRpbmcoKSB7XG4gICAgdGhpcy5lZGl0b3JEaXYuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImNvbW1lbnRcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1tdWx0aWxpbmVcIik7XG4gIH1cbiAgZW5hYmxlRWRpdGluZygpIHtcbiAgICB0aGlzLmVkaXRvckRpdi5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwidGV4dGJveFwiKTtcbiAgICB0aGlzLmVkaXRvckRpdi5zZXRBdHRyaWJ1dGUoXCJhcmlhLW11bHRpbGluZVwiLCB0cnVlKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXY7XG4gICAgfVxuICAgIGxldCBiYXNlWCwgYmFzZVk7XG4gICAgaWYgKHRoaXMud2lkdGgpIHtcbiAgICAgIGJhc2VYID0gdGhpcy54O1xuICAgICAgYmFzZVkgPSB0aGlzLnk7XG4gICAgfVxuICAgIHN1cGVyLnJlbmRlcigpO1xuICAgIHRoaXMuZWRpdG9yRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLmVkaXRvckRpdi5jbGFzc05hbWUgPSBcImludGVybmFsXCI7XG4gICAgdGhpcy5lZGl0b3JEaXYuc2V0QXR0cmlidXRlKFwiaWRcIiwgdGhpcy4jZWRpdG9yRGl2SWQpO1xuICAgIHRoaXMuZWRpdG9yRGl2LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLWZyZWUtdGV4dDJcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWF0dHJzXCIsIFwiZGVmYXVsdC1jb250ZW50XCIpO1xuICAgIHRoaXMuZW5hYmxlRWRpdGluZygpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmNvbnRlbnRFZGl0YWJsZSA9IHRydWU7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy5lZGl0b3JEaXY7XG4gICAgc3R5bGUuZm9udFNpemUgPSBgY2FsYygke3RoaXMuI2ZvbnRTaXplfXB4ICogdmFyKC0tc2NhbGUtZmFjdG9yKSlgO1xuICAgIHN0eWxlLmNvbG9yID0gdGhpcy4jY29sb3I7XG4gICAgdGhpcy5kaXYuYXBwZW5kKHRoaXMuZWRpdG9yRGl2KTtcbiAgICB0aGlzLm92ZXJsYXlEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMub3ZlcmxheURpdi5jbGFzc0xpc3QuYWRkKFwib3ZlcmxheVwiLCBcImVuYWJsZWRcIik7XG4gICAgdGhpcy5kaXYuYXBwZW5kKHRoaXMub3ZlcmxheURpdik7XG4gICAgYmluZEV2ZW50cyh0aGlzLCB0aGlzLmRpdiwgW1wiZGJsY2xpY2tcIiwgXCJrZXlkb3duXCJdKTtcbiAgICBpZiAodGhpcy53aWR0aCkge1xuICAgICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgICAgaWYgKHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcG9zaXRpb25cbiAgICAgICAgfSA9IHRoaXMuX2luaXRpYWxEYXRhO1xuICAgICAgICBsZXQgW3R4LCB0eV0gPSB0aGlzLmdldEluaXRpYWxUcmFuc2xhdGlvbigpO1xuICAgICAgICBbdHgsIHR5XSA9IHRoaXMucGFnZVRyYW5zbGF0aW9uVG9TY3JlZW4odHgsIHR5KTtcbiAgICAgICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgICAgICBjb25zdCBbcGFnZVgsIHBhZ2VZXSA9IHRoaXMucGFnZVRyYW5zbGF0aW9uO1xuICAgICAgICBsZXQgcG9zWCwgcG9zWTtcbiAgICAgICAgc3dpdGNoICh0aGlzLnJvdGF0aW9uKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcG9zWCA9IGJhc2VYICsgKHBvc2l0aW9uWzBdIC0gcGFnZVgpIC8gcGFnZVdpZHRoO1xuICAgICAgICAgICAgcG9zWSA9IGJhc2VZICsgdGhpcy5oZWlnaHQgLSAocG9zaXRpb25bMV0gLSBwYWdlWSkgLyBwYWdlSGVpZ2h0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA5MDpcbiAgICAgICAgICAgIHBvc1ggPSBiYXNlWCArIChwb3NpdGlvblswXSAtIHBhZ2VYKSAvIHBhZ2VXaWR0aDtcbiAgICAgICAgICAgIHBvc1kgPSBiYXNlWSAtIChwb3NpdGlvblsxXSAtIHBhZ2VZKSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgICAgICBbdHgsIHR5XSA9IFt0eSwgLXR4XTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTgwOlxuICAgICAgICAgICAgcG9zWCA9IGJhc2VYIC0gdGhpcy53aWR0aCArIChwb3NpdGlvblswXSAtIHBhZ2VYKSAvIHBhZ2VXaWR0aDtcbiAgICAgICAgICAgIHBvc1kgPSBiYXNlWSAtIChwb3NpdGlvblsxXSAtIHBhZ2VZKSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgICAgICBbdHgsIHR5XSA9IFstdHgsIC10eV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI3MDpcbiAgICAgICAgICAgIHBvc1ggPSBiYXNlWCArIChwb3NpdGlvblswXSAtIHBhZ2VYIC0gdGhpcy5oZWlnaHQgKiBwYWdlSGVpZ2h0KSAvIHBhZ2VXaWR0aDtcbiAgICAgICAgICAgIHBvc1kgPSBiYXNlWSArIChwb3NpdGlvblsxXSAtIHBhZ2VZIC0gdGhpcy53aWR0aCAqIHBhZ2VXaWR0aCkgLyBwYWdlSGVpZ2h0O1xuICAgICAgICAgICAgW3R4LCB0eV0gPSBbLXR5LCB0eF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEF0KHBvc1ggKiBwYXJlbnRXaWR0aCwgcG9zWSAqIHBhcmVudEhlaWdodCwgdHgsIHR5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0QXQoYmFzZVggKiBwYXJlbnRXaWR0aCwgYmFzZVkgKiBwYXJlbnRIZWlnaHQsIHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aCwgdGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQpO1xuICAgICAgfVxuICAgICAgdGhpcy4jc2V0Q29udGVudCgpO1xuICAgICAgdGhpcy5faXNEcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgdGhpcy5lZGl0b3JEaXYuY29udGVudEVkaXRhYmxlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICB0aGlzLmVkaXRvckRpdi5jb250ZW50RWRpdGFibGUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kaXY7XG4gIH1cbiAgc3RhdGljICNnZXROb2RlQ29udGVudChub2RlKSB7XG4gICAgcmV0dXJuIChub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSA/IG5vZGUubm9kZVZhbHVlIDogbm9kZS5pbm5lclRleHQpLnJlcGxhY2VBbGwoRU9MX1BBVFRFUk4sIFwiXCIpO1xuICB9XG4gIGVkaXRvckRpdlBhc3RlKGV2ZW50KSB7XG4gICAgY29uc3QgY2xpcGJvYXJkRGF0YSA9IGV2ZW50LmNsaXBib2FyZERhdGEgfHwgd2luZG93LmNsaXBib2FyZERhdGE7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZXNcbiAgICB9ID0gY2xpcGJvYXJkRGF0YTtcbiAgICBpZiAodHlwZXMubGVuZ3RoID09PSAxICYmIHR5cGVzWzBdID09PSBcInRleHQvcGxhaW5cIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IHBhc3RlID0gRnJlZVRleHRFZGl0b3IuI2Rlc2VyaWFsaXplQ29udGVudChjbGlwYm9hcmREYXRhLmdldERhdGEoXCJ0ZXh0XCIpIHx8IFwiXCIpLnJlcGxhY2VBbGwoRU9MX1BBVFRFUk4sIFwiXFxuXCIpO1xuICAgIGlmICghcGFzdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIGlmICghc2VsZWN0aW9uLnJhbmdlQ291bnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lZGl0b3JEaXYubm9ybWFsaXplKCk7XG4gICAgc2VsZWN0aW9uLmRlbGV0ZUZyb21Eb2N1bWVudCgpO1xuICAgIGNvbnN0IHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgaWYgKCFwYXN0ZS5pbmNsdWRlcyhcIlxcblwiKSkge1xuICAgICAgcmFuZ2UuaW5zZXJ0Tm9kZShkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShwYXN0ZSkpO1xuICAgICAgdGhpcy5lZGl0b3JEaXYubm9ybWFsaXplKCk7XG4gICAgICBzZWxlY3Rpb24uY29sbGFwc2VUb1N0YXJ0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHN0YXJ0Q29udGFpbmVyLFxuICAgICAgc3RhcnRPZmZzZXRcbiAgICB9ID0gcmFuZ2U7XG4gICAgY29uc3QgYnVmZmVyQmVmb3JlID0gW107XG4gICAgY29uc3QgYnVmZmVyQWZ0ZXIgPSBbXTtcbiAgICBpZiAoc3RhcnRDb250YWluZXIubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBzdGFydENvbnRhaW5lci5wYXJlbnRFbGVtZW50O1xuICAgICAgYnVmZmVyQWZ0ZXIucHVzaChzdGFydENvbnRhaW5lci5ub2RlVmFsdWUuc2xpY2Uoc3RhcnRPZmZzZXQpLnJlcGxhY2VBbGwoRU9MX1BBVFRFUk4sIFwiXCIpKTtcbiAgICAgIGlmIChwYXJlbnQgIT09IHRoaXMuZWRpdG9yRGl2KSB7XG4gICAgICAgIGxldCBidWZmZXIgPSBidWZmZXJCZWZvcmU7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5lZGl0b3JEaXYuY2hpbGROb2Rlcykge1xuICAgICAgICAgIGlmIChjaGlsZCA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgICBidWZmZXIgPSBidWZmZXJBZnRlcjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidWZmZXIucHVzaChGcmVlVGV4dEVkaXRvci4jZ2V0Tm9kZUNvbnRlbnQoY2hpbGQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnVmZmVyQmVmb3JlLnB1c2goc3RhcnRDb250YWluZXIubm9kZVZhbHVlLnNsaWNlKDAsIHN0YXJ0T2Zmc2V0KS5yZXBsYWNlQWxsKEVPTF9QQVRURVJOLCBcIlwiKSk7XG4gICAgfSBlbHNlIGlmIChzdGFydENvbnRhaW5lciA9PT0gdGhpcy5lZGl0b3JEaXYpIHtcbiAgICAgIGxldCBidWZmZXIgPSBidWZmZXJCZWZvcmU7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuZWRpdG9yRGl2LmNoaWxkTm9kZXMpIHtcbiAgICAgICAgaWYgKGkrKyA9PT0gc3RhcnRPZmZzZXQpIHtcbiAgICAgICAgICBidWZmZXIgPSBidWZmZXJBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXIucHVzaChGcmVlVGV4dEVkaXRvci4jZ2V0Tm9kZUNvbnRlbnQoY2hpbGQpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jY29udGVudCA9IGAke2J1ZmZlckJlZm9yZS5qb2luKFwiXFxuXCIpfSR7cGFzdGV9JHtidWZmZXJBZnRlci5qb2luKFwiXFxuXCIpfWA7XG4gICAgdGhpcy4jc2V0Q29udGVudCgpO1xuICAgIGNvbnN0IG5ld1JhbmdlID0gbmV3IFJhbmdlKCk7XG4gICAgbGV0IGJlZm9yZUxlbmd0aCA9IGJ1ZmZlckJlZm9yZS5yZWR1Y2UoKGFjYywgbGluZSkgPT4gYWNjICsgbGluZS5sZW5ndGgsIDApO1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgZmlyc3RDaGlsZFxuICAgIH0gb2YgdGhpcy5lZGl0b3JEaXYuY2hpbGROb2Rlcykge1xuICAgICAgaWYgKGZpcnN0Q2hpbGQubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGZpcnN0Q2hpbGQubm9kZVZhbHVlLmxlbmd0aDtcbiAgICAgICAgaWYgKGJlZm9yZUxlbmd0aCA8PSBsZW5ndGgpIHtcbiAgICAgICAgICBuZXdSYW5nZS5zZXRTdGFydChmaXJzdENoaWxkLCBiZWZvcmVMZW5ndGgpO1xuICAgICAgICAgIG5ld1JhbmdlLnNldEVuZChmaXJzdENoaWxkLCBiZWZvcmVMZW5ndGgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJlZm9yZUxlbmd0aCAtPSBsZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICBzZWxlY3Rpb24uYWRkUmFuZ2UobmV3UmFuZ2UpO1xuICB9XG4gICNzZXRDb250ZW50KCkge1xuICAgIHRoaXMuZWRpdG9yRGl2LnJlcGxhY2VDaGlsZHJlbigpO1xuICAgIGlmICghdGhpcy4jY29udGVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgdGhpcy4jY29udGVudC5zcGxpdChcIlxcblwiKSkge1xuICAgICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGRpdi5hcHBlbmQobGluZSA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxpbmUpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpKTtcbiAgICAgIHRoaXMuZWRpdG9yRGl2LmFwcGVuZChkaXYpO1xuICAgIH1cbiAgfVxuICAjc2VyaWFsaXplQ29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy4jY29udGVudC5yZXBsYWNlQWxsKFwiXFx4YTBcIiwgXCIgXCIpO1xuICB9XG4gIHN0YXRpYyAjZGVzZXJpYWxpemVDb250ZW50KGNvbnRlbnQpIHtcbiAgICByZXR1cm4gY29udGVudC5yZXBsYWNlQWxsKFwiIFwiLCBcIlxceGEwXCIpO1xuICB9XG4gIGdldCBjb250ZW50RGl2KCkge1xuICAgIHJldHVybiB0aGlzLmVkaXRvckRpdjtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpIHtcbiAgICBsZXQgaW5pdGlhbERhdGEgPSBudWxsO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgRnJlZVRleHRBbm5vdGF0aW9uRWxlbWVudCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgZGVmYXVsdEFwcGVhcmFuY2VEYXRhOiB7XG4gICAgICAgICAgICBmb250U2l6ZSxcbiAgICAgICAgICAgIGZvbnRDb2xvclxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVjdCxcbiAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBwb3B1cFJlZlxuICAgICAgICB9LFxuICAgICAgICB0ZXh0Q29udGVudCxcbiAgICAgICAgdGV4dFBvc2l0aW9uLFxuICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICBwYWdlOiB7XG4gICAgICAgICAgICBwYWdlTnVtYmVyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9ID0gZGF0YTtcbiAgICAgIGlmICghdGV4dENvbnRlbnQgfHwgdGV4dENvbnRlbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaW5pdGlhbERhdGEgPSBkYXRhID0ge1xuICAgICAgICBhbm5vdGF0aW9uVHlwZTogQW5ub3RhdGlvbkVkaXRvclR5cGUuRlJFRVRFWFQsXG4gICAgICAgIGNvbG9yOiBBcnJheS5mcm9tKGZvbnRDb2xvciksXG4gICAgICAgIGZvbnRTaXplLFxuICAgICAgICB2YWx1ZTogdGV4dENvbnRlbnQuam9pbihcIlxcblwiKSxcbiAgICAgICAgcG9zaXRpb246IHRleHRQb3NpdGlvbixcbiAgICAgICAgcGFnZUluZGV4OiBwYWdlTnVtYmVyIC0gMSxcbiAgICAgICAgcmVjdDogcmVjdC5zbGljZSgwKSxcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIGlkLFxuICAgICAgICBkZWxldGVkOiBmYWxzZSxcbiAgICAgICAgcG9wdXBSZWZcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvciA9IGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKTtcbiAgICBlZGl0b3IuI2ZvbnRTaXplID0gZGF0YS5mb250U2l6ZTtcbiAgICBlZGl0b3IuI2NvbG9yID0gVXRpbC5tYWtlSGV4Q29sb3IoLi4uZGF0YS5jb2xvcik7XG4gICAgZWRpdG9yLiNjb250ZW50ID0gRnJlZVRleHRFZGl0b3IuI2Rlc2VyaWFsaXplQ29udGVudChkYXRhLnZhbHVlKTtcbiAgICBlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCA9IGRhdGEuaWQgfHwgbnVsbDtcbiAgICBlZGl0b3IuX2luaXRpYWxEYXRhID0gaW5pdGlhbERhdGE7XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICBzZXJpYWxpemUoaXNGb3JDb3B5aW5nID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZWxldGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVEZWxldGVkKCk7XG4gICAgfVxuICAgIGNvbnN0IHBhZGRpbmcgPSBGcmVlVGV4dEVkaXRvci5faW50ZXJuYWxQYWRkaW5nICogdGhpcy5wYXJlbnRTY2FsZTtcbiAgICBjb25zdCByZWN0ID0gdGhpcy5nZXRSZWN0KHBhZGRpbmcsIHBhZGRpbmcpO1xuICAgIGNvbnN0IGNvbG9yID0gQW5ub3RhdGlvbkVkaXRvci5fY29sb3JNYW5hZ2VyLmNvbnZlcnQodGhpcy5pc0F0dGFjaGVkVG9ET00gPyBnZXRDb21wdXRlZFN0eWxlKHRoaXMuZWRpdG9yRGl2KS5jb2xvciA6IHRoaXMuI2NvbG9yKTtcbiAgICBjb25zdCBzZXJpYWxpemVkID0ge1xuICAgICAgYW5ub3RhdGlvblR5cGU6IEFubm90YXRpb25FZGl0b3JUeXBlLkZSRUVURVhULFxuICAgICAgY29sb3IsXG4gICAgICBmb250U2l6ZTogdGhpcy4jZm9udFNpemUsXG4gICAgICB2YWx1ZTogdGhpcy4jc2VyaWFsaXplQ29udGVudCgpLFxuICAgICAgcGFnZUluZGV4OiB0aGlzLnBhZ2VJbmRleCxcbiAgICAgIHJlY3QsXG4gICAgICByb3RhdGlvbjogdGhpcy5yb3RhdGlvbixcbiAgICAgIHN0cnVjdFRyZWVQYXJlbnRJZDogdGhpcy5fc3RydWN0VHJlZVBhcmVudElkXG4gICAgfTtcbiAgICBpZiAoaXNGb3JDb3B5aW5nKSB7XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gICAgaWYgKHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCAmJiAhdGhpcy4jaGFzRWxlbWVudENoYW5nZWQoc2VyaWFsaXplZCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzZXJpYWxpemVkLmlkID0gdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkO1xuICAgIHJldHVybiBzZXJpYWxpemVkO1xuICB9XG4gICNoYXNFbGVtZW50Q2hhbmdlZChzZXJpYWxpemVkKSB7XG4gICAgY29uc3Qge1xuICAgICAgdmFsdWUsXG4gICAgICBmb250U2l6ZSxcbiAgICAgIGNvbG9yLFxuICAgICAgcGFnZUluZGV4XG4gICAgfSA9IHRoaXMuX2luaXRpYWxEYXRhO1xuICAgIHJldHVybiB0aGlzLl9oYXNCZWVuTW92ZWQgfHwgc2VyaWFsaXplZC52YWx1ZSAhPT0gdmFsdWUgfHwgc2VyaWFsaXplZC5mb250U2l6ZSAhPT0gZm9udFNpemUgfHwgc2VyaWFsaXplZC5jb2xvci5zb21lKChjLCBpKSA9PiBjICE9PSBjb2xvcltpXSkgfHwgc2VyaWFsaXplZC5wYWdlSW5kZXggIT09IHBhZ2VJbmRleDtcbiAgfVxuICByZW5kZXJBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKSB7XG4gICAgY29uc3QgY29udGVudCA9IHN1cGVyLnJlbmRlckFubm90YXRpb25FbGVtZW50KGFubm90YXRpb24pO1xuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSBjb250ZW50O1xuICAgIHN0eWxlLmZvbnRTaXplID0gYGNhbGMoJHt0aGlzLiNmb250U2l6ZX1weCAqIHZhcigtLXNjYWxlLWZhY3RvcikpYDtcbiAgICBzdHlsZS5jb2xvciA9IHRoaXMuI2NvbG9yO1xuICAgIGNvbnRlbnQucmVwbGFjZUNoaWxkcmVuKCk7XG4gICAgZm9yIChjb25zdCBsaW5lIG9mIHRoaXMuI2NvbnRlbnQuc3BsaXQoXCJcXG5cIikpIHtcbiAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBkaXYuYXBwZW5kKGxpbmUgPyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsaW5lKSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSk7XG4gICAgICBjb250ZW50LmFwcGVuZChkaXYpO1xuICAgIH1cbiAgICBjb25zdCBwYWRkaW5nID0gRnJlZVRleHRFZGl0b3IuX2ludGVybmFsUGFkZGluZyAqIHRoaXMucGFyZW50U2NhbGU7XG4gICAgYW5ub3RhdGlvbi51cGRhdGVFZGl0ZWQoe1xuICAgICAgcmVjdDogdGhpcy5nZXRSZWN0KHBhZGRpbmcsIHBhZGRpbmcpLFxuICAgICAgcG9wdXBDb250ZW50OiB0aGlzLiNjb250ZW50XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cbiAgcmVzZXRBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKSB7XG4gICAgc3VwZXIucmVzZXRBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKTtcbiAgICBhbm5vdGF0aW9uLnJlc2V0RWRpdGVkKCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2RyYXdlcnMvb3V0bGluZS5qc1xuXG5jbGFzcyBPdXRsaW5lIHtcbiAgc3RhdGljIFBSRUNJU0lPTiA9IDFlLTQ7XG4gIHRvU1ZHUGF0aCgpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IG1ldGhvZCBgdG9TVkdQYXRoYCBtdXN0IGJlIGltcGxlbWVudGVkLlwiKTtcbiAgfVxuICBnZXQgYm94KCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgZ2V0dGVyIGBib3hgIG11c3QgYmUgaW1wbGVtZW50ZWQuXCIpO1xuICB9XG4gIHNlcmlhbGl6ZShfYmJveCwgX3JvdGF0aW9uKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBtZXRob2QgYHNlcmlhbGl6ZWAgbXVzdCBiZSBpbXBsZW1lbnRlZC5cIik7XG4gIH1cbiAgc3RhdGljIF9yZXNjYWxlKHNyYywgdHgsIHR5LCBzeCwgc3ksIGRlc3QpIHtcbiAgICBkZXN0IHx8PSBuZXcgRmxvYXQzMkFycmF5KHNyYy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHNyYy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBkZXN0W2ldID0gdHggKyBzcmNbaV0gKiBzeDtcbiAgICAgIGRlc3RbaSArIDFdID0gdHkgKyBzcmNbaSArIDFdICogc3k7XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xuICB9XG4gIHN0YXRpYyBfcmVzY2FsZUFuZFN3YXAoc3JjLCB0eCwgdHksIHN4LCBzeSwgZGVzdCkge1xuICAgIGRlc3QgfHw9IG5ldyBGbG9hdDMyQXJyYXkoc3JjLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gc3JjLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIGRlc3RbaV0gPSB0eCArIHNyY1tpICsgMV0gKiBzeDtcbiAgICAgIGRlc3RbaSArIDFdID0gdHkgKyBzcmNbaV0gKiBzeTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cbiAgc3RhdGljIF90cmFuc2xhdGUoc3JjLCB0eCwgdHksIGRlc3QpIHtcbiAgICBkZXN0IHx8PSBuZXcgRmxvYXQzMkFycmF5KHNyYy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHNyYy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBkZXN0W2ldID0gdHggKyBzcmNbaV07XG4gICAgICBkZXN0W2kgKyAxXSA9IHR5ICsgc3JjW2kgKyAxXTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cbiAgc3RhdGljIHN2Z1JvdW5kKHgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh4ICogMTAwMDApO1xuICB9XG4gIHN0YXRpYyBfbm9ybWFsaXplUG9pbnQoeCwgeSwgcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodCwgcm90YXRpb24pIHtcbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gWzEgLSB5IC8gcGFyZW50V2lkdGgsIHggLyBwYXJlbnRIZWlnaHRdO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbMSAtIHggLyBwYXJlbnRXaWR0aCwgMSAtIHkgLyBwYXJlbnRIZWlnaHRdO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbeSAvIHBhcmVudFdpZHRoLCAxIC0geCAvIHBhcmVudEhlaWdodF07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gW3ggLyBwYXJlbnRXaWR0aCwgeSAvIHBhcmVudEhlaWdodF07XG4gICAgfVxuICB9XG4gIHN0YXRpYyBfbm9ybWFsaXplUGFnZVBvaW50KHgsIHksIHJvdGF0aW9uKSB7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFsxIC0geSwgeF07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFsxIC0geCwgMSAtIHldO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbeSwgMSAtIHhdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGNyZWF0ZUJlemllclBvaW50cyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgcmV0dXJuIFsoeDEgKyA1ICogeDIpIC8gNiwgKHkxICsgNSAqIHkyKSAvIDYsICg1ICogeDIgKyB4MykgLyA2LCAoNSAqIHkyICsgeTMpIC8gNiwgKHgyICsgeDMpIC8gMiwgKHkyICsgeTMpIC8gMl07XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2RyYXdlcnMvZnJlZWRyYXcuanNcblxuXG5jbGFzcyBGcmVlRHJhd091dGxpbmVyIHtcbiAgI2JveDtcbiAgI2JvdHRvbSA9IFtdO1xuICAjaW5uZXJNYXJnaW47XG4gICNpc0xUUjtcbiAgI3RvcCA9IFtdO1xuICAjbGFzdCA9IG5ldyBGbG9hdDMyQXJyYXkoMTgpO1xuICAjbGFzdFg7XG4gICNsYXN0WTtcbiAgI21pbjtcbiAgI21pbl9kaXN0O1xuICAjc2NhbGVGYWN0b3I7XG4gICN0aGlja25lc3M7XG4gICNwb2ludHMgPSBbXTtcbiAgc3RhdGljICNNSU5fRElTVCA9IDg7XG4gIHN0YXRpYyAjTUlOX0RJRkYgPSAyO1xuICBzdGF0aWMgI01JTiA9IEZyZWVEcmF3T3V0bGluZXIuI01JTl9ESVNUICsgRnJlZURyYXdPdXRsaW5lci4jTUlOX0RJRkY7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB4LFxuICAgIHlcbiAgfSwgYm94LCBzY2FsZUZhY3RvciwgdGhpY2tuZXNzLCBpc0xUUiwgaW5uZXJNYXJnaW4gPSAwKSB7XG4gICAgdGhpcy4jYm94ID0gYm94O1xuICAgIHRoaXMuI3RoaWNrbmVzcyA9IHRoaWNrbmVzcyAqIHNjYWxlRmFjdG9yO1xuICAgIHRoaXMuI2lzTFRSID0gaXNMVFI7XG4gICAgdGhpcy4jbGFzdC5zZXQoW05hTiwgTmFOLCBOYU4sIE5hTiwgeCwgeV0sIDYpO1xuICAgIHRoaXMuI2lubmVyTWFyZ2luID0gaW5uZXJNYXJnaW47XG4gICAgdGhpcy4jbWluX2Rpc3QgPSBGcmVlRHJhd091dGxpbmVyLiNNSU5fRElTVCAqIHNjYWxlRmFjdG9yO1xuICAgIHRoaXMuI21pbiA9IEZyZWVEcmF3T3V0bGluZXIuI01JTiAqIHNjYWxlRmFjdG9yO1xuICAgIHRoaXMuI3NjYWxlRmFjdG9yID0gc2NhbGVGYWN0b3I7XG4gICAgdGhpcy4jcG9pbnRzLnB1c2goeCwgeSk7XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gaXNOYU4odGhpcy4jbGFzdFs4XSk7XG4gIH1cbiAgI2dldExhc3RDb29yZHMoKSB7XG4gICAgY29uc3QgbGFzdFRvcCA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoNCwgNik7XG4gICAgY29uc3QgbGFzdEJvdHRvbSA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoMTYsIDE4KTtcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNib3g7XG4gICAgcmV0dXJuIFsodGhpcy4jbGFzdFggKyAobGFzdFRvcFswXSAtIGxhc3RCb3R0b21bMF0pIC8gMiAtIHgpIC8gd2lkdGgsICh0aGlzLiNsYXN0WSArIChsYXN0VG9wWzFdIC0gbGFzdEJvdHRvbVsxXSkgLyAyIC0geSkgLyBoZWlnaHQsICh0aGlzLiNsYXN0WCArIChsYXN0Qm90dG9tWzBdIC0gbGFzdFRvcFswXSkgLyAyIC0geCkgLyB3aWR0aCwgKHRoaXMuI2xhc3RZICsgKGxhc3RCb3R0b21bMV0gLSBsYXN0VG9wWzFdKSAvIDIgLSB5KSAvIGhlaWdodF07XG4gIH1cbiAgYWRkKHtcbiAgICB4LFxuICAgIHlcbiAgfSkge1xuICAgIHRoaXMuI2xhc3RYID0geDtcbiAgICB0aGlzLiNsYXN0WSA9IHk7XG4gICAgY29uc3QgW2xheWVyWCwgbGF5ZXJZLCBsYXllcldpZHRoLCBsYXllckhlaWdodF0gPSB0aGlzLiNib3g7XG4gICAgbGV0IFt4MSwgeTEsIHgyLCB5Ml0gPSB0aGlzLiNsYXN0LnN1YmFycmF5KDgsIDEyKTtcbiAgICBjb25zdCBkaWZmWCA9IHggLSB4MjtcbiAgICBjb25zdCBkaWZmWSA9IHkgLSB5MjtcbiAgICBjb25zdCBkID0gTWF0aC5oeXBvdChkaWZmWCwgZGlmZlkpO1xuICAgIGlmIChkIDwgdGhpcy4jbWluKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGRpZmZEID0gZCAtIHRoaXMuI21pbl9kaXN0O1xuICAgIGNvbnN0IEsgPSBkaWZmRCAvIGQ7XG4gICAgY29uc3Qgc2hpZnRYID0gSyAqIGRpZmZYO1xuICAgIGNvbnN0IHNoaWZ0WSA9IEsgKiBkaWZmWTtcbiAgICBsZXQgeDAgPSB4MTtcbiAgICBsZXQgeTAgPSB5MTtcbiAgICB4MSA9IHgyO1xuICAgIHkxID0geTI7XG4gICAgeDIgKz0gc2hpZnRYO1xuICAgIHkyICs9IHNoaWZ0WTtcbiAgICB0aGlzLiNwb2ludHM/LnB1c2goeCwgeSk7XG4gICAgY29uc3QgblggPSAtc2hpZnRZIC8gZGlmZkQ7XG4gICAgY29uc3QgblkgPSBzaGlmdFggLyBkaWZmRDtcbiAgICBjb25zdCB0aFggPSBuWCAqIHRoaXMuI3RoaWNrbmVzcztcbiAgICBjb25zdCB0aFkgPSBuWSAqIHRoaXMuI3RoaWNrbmVzcztcbiAgICB0aGlzLiNsYXN0LnNldCh0aGlzLiNsYXN0LnN1YmFycmF5KDIsIDgpLCAwKTtcbiAgICB0aGlzLiNsYXN0LnNldChbeDIgKyB0aFgsIHkyICsgdGhZXSwgNCk7XG4gICAgdGhpcy4jbGFzdC5zZXQodGhpcy4jbGFzdC5zdWJhcnJheSgxNCwgMTgpLCAxMik7XG4gICAgdGhpcy4jbGFzdC5zZXQoW3gyIC0gdGhYLCB5MiAtIHRoWV0sIDE2KTtcbiAgICBpZiAoaXNOYU4odGhpcy4jbGFzdFs2XSkpIHtcbiAgICAgIGlmICh0aGlzLiN0b3AubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuI2xhc3Quc2V0KFt4MSArIHRoWCwgeTEgKyB0aFldLCAyKTtcbiAgICAgICAgdGhpcy4jdG9wLnB1c2goTmFOLCBOYU4sIE5hTiwgTmFOLCAoeDEgKyB0aFggLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKHkxICsgdGhZIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0KTtcbiAgICAgICAgdGhpcy4jbGFzdC5zZXQoW3gxIC0gdGhYLCB5MSAtIHRoWV0sIDE0KTtcbiAgICAgICAgdGhpcy4jYm90dG9tLnB1c2goTmFOLCBOYU4sIE5hTiwgTmFOLCAoeDEgLSB0aFggLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKHkxIC0gdGhZIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI2xhc3Quc2V0KFt4MCwgeTAsIHgxLCB5MSwgeDIsIHkyXSwgNik7XG4gICAgICByZXR1cm4gIXRoaXMuaXNFbXB0eSgpO1xuICAgIH1cbiAgICB0aGlzLiNsYXN0LnNldChbeDAsIHkwLCB4MSwgeTEsIHgyLCB5Ml0sIDYpO1xuICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5hYnMoTWF0aC5hdGFuMih5MCAtIHkxLCB4MCAtIHgxKSAtIE1hdGguYXRhbjIoc2hpZnRZLCBzaGlmdFgpKTtcbiAgICBpZiAoYW5nbGUgPCBNYXRoLlBJIC8gMikge1xuICAgICAgW3gxLCB5MSwgeDIsIHkyXSA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoMiwgNik7XG4gICAgICB0aGlzLiN0b3AucHVzaChOYU4sIE5hTiwgTmFOLCBOYU4sICgoeDEgKyB4MikgLyAyIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICgoeTEgKyB5MikgLyAyIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0KTtcbiAgICAgIFt4MSwgeTEsIHgwLCB5MF0gPSB0aGlzLiNsYXN0LnN1YmFycmF5KDE0LCAxOCk7XG4gICAgICB0aGlzLiNib3R0b20ucHVzaChOYU4sIE5hTiwgTmFOLCBOYU4sICgoeDAgKyB4MSkgLyAyIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICgoeTAgKyB5MSkgLyAyIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBbeDAsIHkwLCB4MSwgeTEsIHgyLCB5Ml0gPSB0aGlzLiNsYXN0LnN1YmFycmF5KDAsIDYpO1xuICAgIHRoaXMuI3RvcC5wdXNoKCgoeDAgKyA1ICogeDEpIC8gNiAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoKHkwICsgNSAqIHkxKSAvIDYgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQsICgoNSAqIHgxICsgeDIpIC8gNiAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoKDUgKiB5MSArIHkyKSAvIDYgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQsICgoeDEgKyB4MikgLyAyIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICgoeTEgKyB5MikgLyAyIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0KTtcbiAgICBbeDIsIHkyLCB4MSwgeTEsIHgwLCB5MF0gPSB0aGlzLiNsYXN0LnN1YmFycmF5KDEyLCAxOCk7XG4gICAgdGhpcy4jYm90dG9tLnB1c2goKCh4MCArIDUgKiB4MSkgLyA2IC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICgoeTAgKyA1ICogeTEpIC8gNiAtIGxheWVyWSkgLyBsYXllckhlaWdodCwgKCg1ICogeDEgKyB4MikgLyA2IC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICgoNSAqIHkxICsgeTIpIC8gNiAtIGxheWVyWSkgLyBsYXllckhlaWdodCwgKCh4MSArIHgyKSAvIDIgLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKCh5MSArIHkyKSAvIDIgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHRvU1ZHUGF0aCgpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBjb25zdCB0b3AgPSB0aGlzLiN0b3A7XG4gICAgY29uc3QgYm90dG9tID0gdGhpcy4jYm90dG9tO1xuICAgIGlmIChpc05hTih0aGlzLiNsYXN0WzZdKSAmJiAhdGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLiN0b1NWR1BhdGhUd29Qb2ludHMoKTtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyID0gW107XG4gICAgYnVmZmVyLnB1c2goYE0ke3RvcFs0XX0gJHt0b3BbNV19YCk7XG4gICAgZm9yIChsZXQgaSA9IDY7IGkgPCB0b3AubGVuZ3RoOyBpICs9IDYpIHtcbiAgICAgIGlmIChpc05hTih0b3BbaV0pKSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKGBMJHt0b3BbaSArIDRdfSAke3RvcFtpICsgNV19YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWZmZXIucHVzaChgQyR7dG9wW2ldfSAke3RvcFtpICsgMV19ICR7dG9wW2kgKyAyXX0gJHt0b3BbaSArIDNdfSAke3RvcFtpICsgNF19ICR7dG9wW2kgKyA1XX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jdG9TVkdQYXRoRW5kKGJ1ZmZlcik7XG4gICAgZm9yIChsZXQgaSA9IGJvdHRvbS5sZW5ndGggLSA2OyBpID49IDY7IGkgLT0gNikge1xuICAgICAgaWYgKGlzTmFOKGJvdHRvbVtpXSkpIHtcbiAgICAgICAgYnVmZmVyLnB1c2goYEwke2JvdHRvbVtpICsgNF19ICR7Ym90dG9tW2kgKyA1XX1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKGBDJHtib3R0b21baV19ICR7Ym90dG9tW2kgKyAxXX0gJHtib3R0b21baSArIDJdfSAke2JvdHRvbVtpICsgM119ICR7Ym90dG9tW2kgKyA0XX0gJHtib3R0b21baSArIDVdfWApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiN0b1NWR1BhdGhTdGFydChidWZmZXIpO1xuICAgIHJldHVybiBidWZmZXIuam9pbihcIiBcIik7XG4gIH1cbiAgI3RvU1ZHUGF0aFR3b1BvaW50cygpIHtcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNib3g7XG4gICAgY29uc3QgW2xhc3RUb3BYLCBsYXN0VG9wWSwgbGFzdEJvdHRvbVgsIGxhc3RCb3R0b21ZXSA9IHRoaXMuI2dldExhc3RDb29yZHMoKTtcbiAgICByZXR1cm4gYE0keyh0aGlzLiNsYXN0WzJdIC0geCkgLyB3aWR0aH0gJHsodGhpcy4jbGFzdFszXSAtIHkpIC8gaGVpZ2h0fSBMJHsodGhpcy4jbGFzdFs0XSAtIHgpIC8gd2lkdGh9ICR7KHRoaXMuI2xhc3RbNV0gLSB5KSAvIGhlaWdodH0gTCR7bGFzdFRvcFh9ICR7bGFzdFRvcFl9IEwke2xhc3RCb3R0b21YfSAke2xhc3RCb3R0b21ZfSBMJHsodGhpcy4jbGFzdFsxNl0gLSB4KSAvIHdpZHRofSAkeyh0aGlzLiNsYXN0WzE3XSAtIHkpIC8gaGVpZ2h0fSBMJHsodGhpcy4jbGFzdFsxNF0gLSB4KSAvIHdpZHRofSAkeyh0aGlzLiNsYXN0WzE1XSAtIHkpIC8gaGVpZ2h0fSBaYDtcbiAgfVxuICAjdG9TVkdQYXRoU3RhcnQoYnVmZmVyKSB7XG4gICAgY29uc3QgYm90dG9tID0gdGhpcy4jYm90dG9tO1xuICAgIGJ1ZmZlci5wdXNoKGBMJHtib3R0b21bNF19ICR7Ym90dG9tWzVdfSBaYCk7XG4gIH1cbiAgI3RvU1ZHUGF0aEVuZChidWZmZXIpIHtcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNib3g7XG4gICAgY29uc3QgbGFzdFRvcCA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoNCwgNik7XG4gICAgY29uc3QgbGFzdEJvdHRvbSA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoMTYsIDE4KTtcbiAgICBjb25zdCBbbGFzdFRvcFgsIGxhc3RUb3BZLCBsYXN0Qm90dG9tWCwgbGFzdEJvdHRvbVldID0gdGhpcy4jZ2V0TGFzdENvb3JkcygpO1xuICAgIGJ1ZmZlci5wdXNoKGBMJHsobGFzdFRvcFswXSAtIHgpIC8gd2lkdGh9ICR7KGxhc3RUb3BbMV0gLSB5KSAvIGhlaWdodH0gTCR7bGFzdFRvcFh9ICR7bGFzdFRvcFl9IEwke2xhc3RCb3R0b21YfSAke2xhc3RCb3R0b21ZfSBMJHsobGFzdEJvdHRvbVswXSAtIHgpIC8gd2lkdGh9ICR7KGxhc3RCb3R0b21bMV0gLSB5KSAvIGhlaWdodH1gKTtcbiAgfVxuICBuZXdGcmVlRHJhd091dGxpbmUob3V0bGluZSwgcG9pbnRzLCBib3gsIHNjYWxlRmFjdG9yLCBpbm5lck1hcmdpbiwgaXNMVFIpIHtcbiAgICByZXR1cm4gbmV3IEZyZWVEcmF3T3V0bGluZShvdXRsaW5lLCBwb2ludHMsIGJveCwgc2NhbGVGYWN0b3IsIGlubmVyTWFyZ2luLCBpc0xUUik7XG4gIH1cbiAgZ2V0T3V0bGluZXMoKSB7XG4gICAgY29uc3QgdG9wID0gdGhpcy4jdG9wO1xuICAgIGNvbnN0IGJvdHRvbSA9IHRoaXMuI2JvdHRvbTtcbiAgICBjb25zdCBsYXN0ID0gdGhpcy4jbGFzdDtcbiAgICBjb25zdCBbbGF5ZXJYLCBsYXllclksIGxheWVyV2lkdGgsIGxheWVySGVpZ2h0XSA9IHRoaXMuI2JveDtcbiAgICBjb25zdCBwb2ludHMgPSBuZXcgRmxvYXQzMkFycmF5KCh0aGlzLiNwb2ludHM/Lmxlbmd0aCA/PyAwKSArIDIpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvaW50cy5sZW5ndGggLSAyOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgcG9pbnRzW2ldID0gKHRoaXMuI3BvaW50c1tpXSAtIGxheWVyWCkgLyBsYXllcldpZHRoO1xuICAgICAgcG9pbnRzW2kgKyAxXSA9ICh0aGlzLiNwb2ludHNbaSArIDFdIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0O1xuICAgIH1cbiAgICBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdID0gKHRoaXMuI2xhc3RYIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGg7XG4gICAgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSA9ICh0aGlzLiNsYXN0WSAtIGxheWVyWSkgLyBsYXllckhlaWdodDtcbiAgICBpZiAoaXNOYU4obGFzdFs2XSkgJiYgIXRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy4jZ2V0T3V0bGluZVR3b1BvaW50cyhwb2ludHMpO1xuICAgIH1cbiAgICBjb25zdCBvdXRsaW5lID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLiN0b3AubGVuZ3RoICsgMjQgKyB0aGlzLiNib3R0b20ubGVuZ3RoKTtcbiAgICBsZXQgTiA9IHRvcC5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyBpICs9IDIpIHtcbiAgICAgIGlmIChpc05hTih0b3BbaV0pKSB7XG4gICAgICAgIG91dGxpbmVbaV0gPSBvdXRsaW5lW2kgKyAxXSA9IE5hTjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBvdXRsaW5lW2ldID0gdG9wW2ldO1xuICAgICAgb3V0bGluZVtpICsgMV0gPSB0b3BbaSArIDFdO1xuICAgIH1cbiAgICBOID0gdGhpcy4jZ2V0T3V0bGluZUVuZChvdXRsaW5lLCBOKTtcbiAgICBmb3IgKGxldCBpID0gYm90dG9tLmxlbmd0aCAtIDY7IGkgPj0gNjsgaSAtPSA2KSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDY7IGogKz0gMikge1xuICAgICAgICBpZiAoaXNOYU4oYm90dG9tW2kgKyBqXSkpIHtcbiAgICAgICAgICBvdXRsaW5lW05dID0gb3V0bGluZVtOICsgMV0gPSBOYU47XG4gICAgICAgICAgTiArPSAyO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG91dGxpbmVbTl0gPSBib3R0b21baSArIGpdO1xuICAgICAgICBvdXRsaW5lW04gKyAxXSA9IGJvdHRvbVtpICsgaiArIDFdO1xuICAgICAgICBOICs9IDI7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2dldE91dGxpbmVTdGFydChvdXRsaW5lLCBOKTtcbiAgICByZXR1cm4gdGhpcy5uZXdGcmVlRHJhd091dGxpbmUob3V0bGluZSwgcG9pbnRzLCB0aGlzLiNib3gsIHRoaXMuI3NjYWxlRmFjdG9yLCB0aGlzLiNpbm5lck1hcmdpbiwgdGhpcy4jaXNMVFIpO1xuICB9XG4gICNnZXRPdXRsaW5lVHdvUG9pbnRzKHBvaW50cykge1xuICAgIGNvbnN0IGxhc3QgPSB0aGlzLiNsYXN0O1xuICAgIGNvbnN0IFtsYXllclgsIGxheWVyWSwgbGF5ZXJXaWR0aCwgbGF5ZXJIZWlnaHRdID0gdGhpcy4jYm94O1xuICAgIGNvbnN0IFtsYXN0VG9wWCwgbGFzdFRvcFksIGxhc3RCb3R0b21YLCBsYXN0Qm90dG9tWV0gPSB0aGlzLiNnZXRMYXN0Q29vcmRzKCk7XG4gICAgY29uc3Qgb3V0bGluZSA9IG5ldyBGbG9hdDMyQXJyYXkoMzYpO1xuICAgIG91dGxpbmUuc2V0KFtOYU4sIE5hTiwgTmFOLCBOYU4sIChsYXN0WzJdIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsIChsYXN0WzNdIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0LCBOYU4sIE5hTiwgTmFOLCBOYU4sIChsYXN0WzRdIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsIChsYXN0WzVdIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0LCBOYU4sIE5hTiwgTmFOLCBOYU4sIGxhc3RUb3BYLCBsYXN0VG9wWSwgTmFOLCBOYU4sIE5hTiwgTmFOLCBsYXN0Qm90dG9tWCwgbGFzdEJvdHRvbVksIE5hTiwgTmFOLCBOYU4sIE5hTiwgKGxhc3RbMTZdIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsIChsYXN0WzE3XSAtIGxheWVyWSkgLyBsYXllckhlaWdodCwgTmFOLCBOYU4sIE5hTiwgTmFOLCAobGFzdFsxNF0gLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKGxhc3RbMTVdIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0XSwgMCk7XG4gICAgcmV0dXJuIHRoaXMubmV3RnJlZURyYXdPdXRsaW5lKG91dGxpbmUsIHBvaW50cywgdGhpcy4jYm94LCB0aGlzLiNzY2FsZUZhY3RvciwgdGhpcy4jaW5uZXJNYXJnaW4sIHRoaXMuI2lzTFRSKTtcbiAgfVxuICAjZ2V0T3V0bGluZVN0YXJ0KG91dGxpbmUsIHBvcykge1xuICAgIGNvbnN0IGJvdHRvbSA9IHRoaXMuI2JvdHRvbTtcbiAgICBvdXRsaW5lLnNldChbTmFOLCBOYU4sIE5hTiwgTmFOLCBib3R0b21bNF0sIGJvdHRvbVs1XV0sIHBvcyk7XG4gICAgcmV0dXJuIHBvcyArPSA2O1xuICB9XG4gICNnZXRPdXRsaW5lRW5kKG91dGxpbmUsIHBvcykge1xuICAgIGNvbnN0IGxhc3RUb3AgPSB0aGlzLiNsYXN0LnN1YmFycmF5KDQsIDYpO1xuICAgIGNvbnN0IGxhc3RCb3R0b20gPSB0aGlzLiNsYXN0LnN1YmFycmF5KDE2LCAxOCk7XG4gICAgY29uc3QgW2xheWVyWCwgbGF5ZXJZLCBsYXllcldpZHRoLCBsYXllckhlaWdodF0gPSB0aGlzLiNib3g7XG4gICAgY29uc3QgW2xhc3RUb3BYLCBsYXN0VG9wWSwgbGFzdEJvdHRvbVgsIGxhc3RCb3R0b21ZXSA9IHRoaXMuI2dldExhc3RDb29yZHMoKTtcbiAgICBvdXRsaW5lLnNldChbTmFOLCBOYU4sIE5hTiwgTmFOLCAobGFzdFRvcFswXSAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAobGFzdFRvcFsxXSAtIGxheWVyWSkgLyBsYXllckhlaWdodCwgTmFOLCBOYU4sIE5hTiwgTmFOLCBsYXN0VG9wWCwgbGFzdFRvcFksIE5hTiwgTmFOLCBOYU4sIE5hTiwgbGFzdEJvdHRvbVgsIGxhc3RCb3R0b21ZLCBOYU4sIE5hTiwgTmFOLCBOYU4sIChsYXN0Qm90dG9tWzBdIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsIChsYXN0Qm90dG9tWzFdIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0XSwgcG9zKTtcbiAgICByZXR1cm4gcG9zICs9IDI0O1xuICB9XG59XG5jbGFzcyBGcmVlRHJhd091dGxpbmUgZXh0ZW5kcyBPdXRsaW5lIHtcbiAgI2JveDtcbiAgI2Jib3ggPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAjaW5uZXJNYXJnaW47XG4gICNpc0xUUjtcbiAgI3BvaW50cztcbiAgI3NjYWxlRmFjdG9yO1xuICAjb3V0bGluZTtcbiAgY29uc3RydWN0b3Iob3V0bGluZSwgcG9pbnRzLCBib3gsIHNjYWxlRmFjdG9yLCBpbm5lck1hcmdpbiwgaXNMVFIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuI291dGxpbmUgPSBvdXRsaW5lO1xuICAgIHRoaXMuI3BvaW50cyA9IHBvaW50cztcbiAgICB0aGlzLiNib3ggPSBib3g7XG4gICAgdGhpcy4jc2NhbGVGYWN0b3IgPSBzY2FsZUZhY3RvcjtcbiAgICB0aGlzLiNpbm5lck1hcmdpbiA9IGlubmVyTWFyZ2luO1xuICAgIHRoaXMuI2lzTFRSID0gaXNMVFI7XG4gICAgdGhpcy5sYXN0UG9pbnQgPSBbTmFOLCBOYU5dO1xuICAgIHRoaXMuI2NvbXB1dGVNaW5NYXgoaXNMVFIpO1xuICAgIGNvbnN0IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSA9IHRoaXMuI2Jib3g7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gb3V0bGluZS5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBvdXRsaW5lW2ldID0gKG91dGxpbmVbaV0gLSB4KSAvIHdpZHRoO1xuICAgICAgb3V0bGluZVtpICsgMV0gPSAob3V0bGluZVtpICsgMV0gLSB5KSAvIGhlaWdodDtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIHBvaW50c1tpXSA9IChwb2ludHNbaV0gLSB4KSAvIHdpZHRoO1xuICAgICAgcG9pbnRzW2kgKyAxXSA9IChwb2ludHNbaSArIDFdIC0geSkgLyBoZWlnaHQ7XG4gICAgfVxuICB9XG4gIHRvU1ZHUGF0aCgpIHtcbiAgICBjb25zdCBidWZmZXIgPSBbYE0ke3RoaXMuI291dGxpbmVbNF19ICR7dGhpcy4jb3V0bGluZVs1XX1gXTtcbiAgICBmb3IgKGxldCBpID0gNiwgaWkgPSB0aGlzLiNvdXRsaW5lLmxlbmd0aDsgaSA8IGlpOyBpICs9IDYpIHtcbiAgICAgIGlmIChpc05hTih0aGlzLiNvdXRsaW5lW2ldKSkge1xuICAgICAgICBidWZmZXIucHVzaChgTCR7dGhpcy4jb3V0bGluZVtpICsgNF19ICR7dGhpcy4jb3V0bGluZVtpICsgNV19YCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnVmZmVyLnB1c2goYEMke3RoaXMuI291dGxpbmVbaV19ICR7dGhpcy4jb3V0bGluZVtpICsgMV19ICR7dGhpcy4jb3V0bGluZVtpICsgMl19ICR7dGhpcy4jb3V0bGluZVtpICsgM119ICR7dGhpcy4jb3V0bGluZVtpICsgNF19ICR7dGhpcy4jb3V0bGluZVtpICsgNV19YCk7XG4gICAgfVxuICAgIGJ1ZmZlci5wdXNoKFwiWlwiKTtcbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oXCIgXCIpO1xuICB9XG4gIHNlcmlhbGl6ZShbYmxYLCBibFksIHRyWCwgdHJZXSwgcm90YXRpb24pIHtcbiAgICBjb25zdCB3aWR0aCA9IHRyWCAtIGJsWDtcbiAgICBjb25zdCBoZWlnaHQgPSB0clkgLSBibFk7XG4gICAgbGV0IG91dGxpbmU7XG4gICAgbGV0IHBvaW50cztcbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIG91dGxpbmUgPSBPdXRsaW5lLl9yZXNjYWxlKHRoaXMuI291dGxpbmUsIGJsWCwgdHJZLCB3aWR0aCwgLWhlaWdodCk7XG4gICAgICAgIHBvaW50cyA9IE91dGxpbmUuX3Jlc2NhbGUodGhpcy4jcG9pbnRzLCBibFgsIHRyWSwgd2lkdGgsIC1oZWlnaHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIG91dGxpbmUgPSBPdXRsaW5lLl9yZXNjYWxlQW5kU3dhcCh0aGlzLiNvdXRsaW5lLCBibFgsIGJsWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHBvaW50cyA9IE91dGxpbmUuX3Jlc2NhbGVBbmRTd2FwKHRoaXMuI3BvaW50cywgYmxYLCBibFksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICBvdXRsaW5lID0gT3V0bGluZS5fcmVzY2FsZSh0aGlzLiNvdXRsaW5lLCB0clgsIGJsWSwgLXdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBwb2ludHMgPSBPdXRsaW5lLl9yZXNjYWxlKHRoaXMuI3BvaW50cywgdHJYLCBibFksIC13aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgb3V0bGluZSA9IE91dGxpbmUuX3Jlc2NhbGVBbmRTd2FwKHRoaXMuI291dGxpbmUsIHRyWCwgdHJZLCAtd2lkdGgsIC1oZWlnaHQpO1xuICAgICAgICBwb2ludHMgPSBPdXRsaW5lLl9yZXNjYWxlQW5kU3dhcCh0aGlzLiNwb2ludHMsIHRyWCwgdHJZLCAtd2lkdGgsIC1oZWlnaHQpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG91dGxpbmU6IEFycmF5LmZyb20ob3V0bGluZSksXG4gICAgICBwb2ludHM6IFtBcnJheS5mcm9tKHBvaW50cyldXG4gICAgfTtcbiAgfVxuICAjY29tcHV0ZU1pbk1heChpc0xUUikge1xuICAgIGNvbnN0IG91dGxpbmUgPSB0aGlzLiNvdXRsaW5lO1xuICAgIGxldCBsYXN0WCA9IG91dGxpbmVbNF07XG4gICAgbGV0IGxhc3RZID0gb3V0bGluZVs1XTtcbiAgICBsZXQgbWluWCA9IGxhc3RYO1xuICAgIGxldCBtaW5ZID0gbGFzdFk7XG4gICAgbGV0IG1heFggPSBsYXN0WDtcbiAgICBsZXQgbWF4WSA9IGxhc3RZO1xuICAgIGxldCBsYXN0UG9pbnRYID0gbGFzdFg7XG4gICAgbGV0IGxhc3RQb2ludFkgPSBsYXN0WTtcbiAgICBjb25zdCBsdHJDYWxsYmFjayA9IGlzTFRSID8gTWF0aC5tYXggOiBNYXRoLm1pbjtcbiAgICBmb3IgKGxldCBpID0gNiwgaWkgPSBvdXRsaW5lLmxlbmd0aDsgaSA8IGlpOyBpICs9IDYpIHtcbiAgICAgIGlmIChpc05hTihvdXRsaW5lW2ldKSkge1xuICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgb3V0bGluZVtpICsgNF0pO1xuICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgb3V0bGluZVtpICsgNV0pO1xuICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgb3V0bGluZVtpICsgNF0pO1xuICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgb3V0bGluZVtpICsgNV0pO1xuICAgICAgICBpZiAobGFzdFBvaW50WSA8IG91dGxpbmVbaSArIDVdKSB7XG4gICAgICAgICAgbGFzdFBvaW50WCA9IG91dGxpbmVbaSArIDRdO1xuICAgICAgICAgIGxhc3RQb2ludFkgPSBvdXRsaW5lW2kgKyA1XTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0UG9pbnRZID09PSBvdXRsaW5lW2kgKyA1XSkge1xuICAgICAgICAgIGxhc3RQb2ludFggPSBsdHJDYWxsYmFjayhsYXN0UG9pbnRYLCBvdXRsaW5lW2kgKyA0XSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGJib3ggPSBVdGlsLmJlemllckJvdW5kaW5nQm94KGxhc3RYLCBsYXN0WSwgLi4ub3V0bGluZS5zbGljZShpLCBpICsgNikpO1xuICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgYmJveFswXSk7XG4gICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCBiYm94WzFdKTtcbiAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIGJib3hbMl0pO1xuICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgYmJveFszXSk7XG4gICAgICAgIGlmIChsYXN0UG9pbnRZIDwgYmJveFszXSkge1xuICAgICAgICAgIGxhc3RQb2ludFggPSBiYm94WzJdO1xuICAgICAgICAgIGxhc3RQb2ludFkgPSBiYm94WzNdO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3RQb2ludFkgPT09IGJib3hbM10pIHtcbiAgICAgICAgICBsYXN0UG9pbnRYID0gbHRyQ2FsbGJhY2sobGFzdFBvaW50WCwgYmJveFsyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxhc3RYID0gb3V0bGluZVtpICsgNF07XG4gICAgICBsYXN0WSA9IG91dGxpbmVbaSArIDVdO1xuICAgIH1cbiAgICBjb25zdCBiYm94ID0gdGhpcy4jYmJveDtcbiAgICBiYm94WzBdID0gbWluWCAtIHRoaXMuI2lubmVyTWFyZ2luO1xuICAgIGJib3hbMV0gPSBtaW5ZIC0gdGhpcy4jaW5uZXJNYXJnaW47XG4gICAgYmJveFsyXSA9IG1heFggLSBtaW5YICsgMiAqIHRoaXMuI2lubmVyTWFyZ2luO1xuICAgIGJib3hbM10gPSBtYXhZIC0gbWluWSArIDIgKiB0aGlzLiNpbm5lck1hcmdpbjtcbiAgICB0aGlzLmxhc3RQb2ludCA9IFtsYXN0UG9pbnRYLCBsYXN0UG9pbnRZXTtcbiAgfVxuICBnZXQgYm94KCkge1xuICAgIHJldHVybiB0aGlzLiNiYm94O1xuICB9XG4gIG5ld091dGxpbmVyKHBvaW50LCBib3gsIHNjYWxlRmFjdG9yLCB0aGlja25lc3MsIGlzTFRSLCBpbm5lck1hcmdpbiA9IDApIHtcbiAgICByZXR1cm4gbmV3IEZyZWVEcmF3T3V0bGluZXIocG9pbnQsIGJveCwgc2NhbGVGYWN0b3IsIHRoaWNrbmVzcywgaXNMVFIsIGlubmVyTWFyZ2luKTtcbiAgfVxuICBnZXROZXdPdXRsaW5lKHRoaWNrbmVzcywgaW5uZXJNYXJnaW4pIHtcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNiYm94O1xuICAgIGNvbnN0IFtsYXllclgsIGxheWVyWSwgbGF5ZXJXaWR0aCwgbGF5ZXJIZWlnaHRdID0gdGhpcy4jYm94O1xuICAgIGNvbnN0IHN4ID0gd2lkdGggKiBsYXllcldpZHRoO1xuICAgIGNvbnN0IHN5ID0gaGVpZ2h0ICogbGF5ZXJIZWlnaHQ7XG4gICAgY29uc3QgdHggPSB4ICogbGF5ZXJXaWR0aCArIGxheWVyWDtcbiAgICBjb25zdCB0eSA9IHkgKiBsYXllckhlaWdodCArIGxheWVyWTtcbiAgICBjb25zdCBvdXRsaW5lciA9IHRoaXMubmV3T3V0bGluZXIoe1xuICAgICAgeDogdGhpcy4jcG9pbnRzWzBdICogc3ggKyB0eCxcbiAgICAgIHk6IHRoaXMuI3BvaW50c1sxXSAqIHN5ICsgdHlcbiAgICB9LCB0aGlzLiNib3gsIHRoaXMuI3NjYWxlRmFjdG9yLCB0aGlja25lc3MsIHRoaXMuI2lzTFRSLCBpbm5lck1hcmdpbiA/PyB0aGlzLiNpbm5lck1hcmdpbik7XG4gICAgZm9yIChsZXQgaSA9IDI7IGkgPCB0aGlzLiNwb2ludHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIG91dGxpbmVyLmFkZCh7XG4gICAgICAgIHg6IHRoaXMuI3BvaW50c1tpXSAqIHN4ICsgdHgsXG4gICAgICAgIHk6IHRoaXMuI3BvaW50c1tpICsgMV0gKiBzeSArIHR5XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dGxpbmVyLmdldE91dGxpbmVzKCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2RyYXdlcnMvaGlnaGxpZ2h0LmpzXG5cblxuY2xhc3MgSGlnaGxpZ2h0T3V0bGluZXIge1xuICAjYm94O1xuICAjbGFzdFBvaW50O1xuICAjdmVydGljYWxFZGdlcyA9IFtdO1xuICAjaW50ZXJ2YWxzID0gW107XG4gIGNvbnN0cnVjdG9yKGJveGVzLCBib3JkZXJXaWR0aCA9IDAsIGlubmVyTWFyZ2luID0gMCwgaXNMVFIgPSB0cnVlKSB7XG4gICAgbGV0IG1pblggPSBJbmZpbml0eTtcbiAgICBsZXQgbWF4WCA9IC1JbmZpbml0eTtcbiAgICBsZXQgbWluWSA9IEluZmluaXR5O1xuICAgIGxldCBtYXhZID0gLUluZmluaXR5O1xuICAgIGNvbnN0IE5VTUJFUl9PRl9ESUdJVFMgPSA0O1xuICAgIGNvbnN0IEVQU0lMT04gPSAxMCAqKiAtTlVNQkVSX09GX0RJR0lUUztcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9IG9mIGJveGVzKSB7XG4gICAgICBjb25zdCB4MSA9IE1hdGguZmxvb3IoKHggLSBib3JkZXJXaWR0aCkgLyBFUFNJTE9OKSAqIEVQU0lMT047XG4gICAgICBjb25zdCB4MiA9IE1hdGguY2VpbCgoeCArIHdpZHRoICsgYm9yZGVyV2lkdGgpIC8gRVBTSUxPTikgKiBFUFNJTE9OO1xuICAgICAgY29uc3QgeTEgPSBNYXRoLmZsb29yKCh5IC0gYm9yZGVyV2lkdGgpIC8gRVBTSUxPTikgKiBFUFNJTE9OO1xuICAgICAgY29uc3QgeTIgPSBNYXRoLmNlaWwoKHkgKyBoZWlnaHQgKyBib3JkZXJXaWR0aCkgLyBFUFNJTE9OKSAqIEVQU0lMT047XG4gICAgICBjb25zdCBsZWZ0ID0gW3gxLCB5MSwgeTIsIHRydWVdO1xuICAgICAgY29uc3QgcmlnaHQgPSBbeDIsIHkxLCB5MiwgZmFsc2VdO1xuICAgICAgdGhpcy4jdmVydGljYWxFZGdlcy5wdXNoKGxlZnQsIHJpZ2h0KTtcbiAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB4MSk7XG4gICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgeDIpO1xuICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHkxKTtcbiAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB5Mik7XG4gICAgfVxuICAgIGNvbnN0IGJib3hXaWR0aCA9IG1heFggLSBtaW5YICsgMiAqIGlubmVyTWFyZ2luO1xuICAgIGNvbnN0IGJib3hIZWlnaHQgPSBtYXhZIC0gbWluWSArIDIgKiBpbm5lck1hcmdpbjtcbiAgICBjb25zdCBzaGlmdGVkTWluWCA9IG1pblggLSBpbm5lck1hcmdpbjtcbiAgICBjb25zdCBzaGlmdGVkTWluWSA9IG1pblkgLSBpbm5lck1hcmdpbjtcbiAgICBjb25zdCBsYXN0RWRnZSA9IHRoaXMuI3ZlcnRpY2FsRWRnZXMuYXQoaXNMVFIgPyAtMSA6IC0yKTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBbbGFzdEVkZ2VbMF0sIGxhc3RFZGdlWzJdXTtcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgdGhpcy4jdmVydGljYWxFZGdlcykge1xuICAgICAgY29uc3QgW3gsIHkxLCB5Ml0gPSBlZGdlO1xuICAgICAgZWRnZVswXSA9ICh4IC0gc2hpZnRlZE1pblgpIC8gYmJveFdpZHRoO1xuICAgICAgZWRnZVsxXSA9ICh5MSAtIHNoaWZ0ZWRNaW5ZKSAvIGJib3hIZWlnaHQ7XG4gICAgICBlZGdlWzJdID0gKHkyIC0gc2hpZnRlZE1pblkpIC8gYmJveEhlaWdodDtcbiAgICB9XG4gICAgdGhpcy4jYm94ID0gbmV3IEZsb2F0MzJBcnJheShbc2hpZnRlZE1pblgsIHNoaWZ0ZWRNaW5ZLCBiYm94V2lkdGgsIGJib3hIZWlnaHRdKTtcbiAgICB0aGlzLiNsYXN0UG9pbnQgPSBsYXN0UG9pbnQ7XG4gIH1cbiAgZ2V0T3V0bGluZXMoKSB7XG4gICAgdGhpcy4jdmVydGljYWxFZGdlcy5zb3J0KChhLCBiKSA9PiBhWzBdIC0gYlswXSB8fCBhWzFdIC0gYlsxXSB8fCBhWzJdIC0gYlsyXSk7XG4gICAgY29uc3Qgb3V0bGluZVZlcnRpY2FsRWRnZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgdGhpcy4jdmVydGljYWxFZGdlcykge1xuICAgICAgaWYgKGVkZ2VbM10pIHtcbiAgICAgICAgb3V0bGluZVZlcnRpY2FsRWRnZXMucHVzaCguLi50aGlzLiNicmVha0VkZ2UoZWRnZSkpO1xuICAgICAgICB0aGlzLiNpbnNlcnQoZWRnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiNyZW1vdmUoZWRnZSk7XG4gICAgICAgIG91dGxpbmVWZXJ0aWNhbEVkZ2VzLnB1c2goLi4udGhpcy4jYnJlYWtFZGdlKGVkZ2UpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI2dldE91dGxpbmVzKG91dGxpbmVWZXJ0aWNhbEVkZ2VzKTtcbiAgfVxuICAjZ2V0T3V0bGluZXMob3V0bGluZVZlcnRpY2FsRWRnZXMpIHtcbiAgICBjb25zdCBlZGdlcyA9IFtdO1xuICAgIGNvbnN0IGFsbEVkZ2VzID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgZWRnZSBvZiBvdXRsaW5lVmVydGljYWxFZGdlcykge1xuICAgICAgY29uc3QgW3gsIHkxLCB5Ml0gPSBlZGdlO1xuICAgICAgZWRnZXMucHVzaChbeCwgeTEsIGVkZ2VdLCBbeCwgeTIsIGVkZ2VdKTtcbiAgICB9XG4gICAgZWRnZXMuc29ydCgoYSwgYikgPT4gYVsxXSAtIGJbMV0gfHwgYVswXSAtIGJbMF0pO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGVkZ2VzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IGVkZ2UxID0gZWRnZXNbaV1bMl07XG4gICAgICBjb25zdCBlZGdlMiA9IGVkZ2VzW2kgKyAxXVsyXTtcbiAgICAgIGVkZ2UxLnB1c2goZWRnZTIpO1xuICAgICAgZWRnZTIucHVzaChlZGdlMSk7XG4gICAgICBhbGxFZGdlcy5hZGQoZWRnZTEpO1xuICAgICAgYWxsRWRnZXMuYWRkKGVkZ2UyKTtcbiAgICB9XG4gICAgY29uc3Qgb3V0bGluZXMgPSBbXTtcbiAgICBsZXQgb3V0bGluZTtcbiAgICB3aGlsZSAoYWxsRWRnZXMuc2l6ZSA+IDApIHtcbiAgICAgIGNvbnN0IGVkZ2UgPSBhbGxFZGdlcy52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XG4gICAgICBsZXQgW3gsIHkxLCB5MiwgZWRnZTEsIGVkZ2UyXSA9IGVkZ2U7XG4gICAgICBhbGxFZGdlcy5kZWxldGUoZWRnZSk7XG4gICAgICBsZXQgbGFzdFBvaW50WCA9IHg7XG4gICAgICBsZXQgbGFzdFBvaW50WSA9IHkxO1xuICAgICAgb3V0bGluZSA9IFt4LCB5Ml07XG4gICAgICBvdXRsaW5lcy5wdXNoKG91dGxpbmUpO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbGV0IGU7XG4gICAgICAgIGlmIChhbGxFZGdlcy5oYXMoZWRnZTEpKSB7XG4gICAgICAgICAgZSA9IGVkZ2UxO1xuICAgICAgICB9IGVsc2UgaWYgKGFsbEVkZ2VzLmhhcyhlZGdlMikpIHtcbiAgICAgICAgICBlID0gZWRnZTI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYWxsRWRnZXMuZGVsZXRlKGUpO1xuICAgICAgICBbeCwgeTEsIHkyLCBlZGdlMSwgZWRnZTJdID0gZTtcbiAgICAgICAgaWYgKGxhc3RQb2ludFggIT09IHgpIHtcbiAgICAgICAgICBvdXRsaW5lLnB1c2gobGFzdFBvaW50WCwgbGFzdFBvaW50WSwgeCwgbGFzdFBvaW50WSA9PT0geTEgPyB5MSA6IHkyKTtcbiAgICAgICAgICBsYXN0UG9pbnRYID0geDtcbiAgICAgICAgfVxuICAgICAgICBsYXN0UG9pbnRZID0gbGFzdFBvaW50WSA9PT0geTEgPyB5MiA6IHkxO1xuICAgICAgfVxuICAgICAgb3V0bGluZS5wdXNoKGxhc3RQb2ludFgsIGxhc3RQb2ludFkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEhpZ2hsaWdodE91dGxpbmUob3V0bGluZXMsIHRoaXMuI2JveCwgdGhpcy4jbGFzdFBvaW50KTtcbiAgfVxuICAjYmluYXJ5U2VhcmNoKHkpIHtcbiAgICBjb25zdCBhcnJheSA9IHRoaXMuI2ludGVydmFscztcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBlbmQgPSBhcnJheS5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChzdGFydCA8PSBlbmQpIHtcbiAgICAgIGNvbnN0IG1pZGRsZSA9IHN0YXJ0ICsgZW5kID4+IDE7XG4gICAgICBjb25zdCB5MSA9IGFycmF5W21pZGRsZV1bMF07XG4gICAgICBpZiAoeTEgPT09IHkpIHtcbiAgICAgICAgcmV0dXJuIG1pZGRsZTtcbiAgICAgIH1cbiAgICAgIGlmICh5MSA8IHkpIHtcbiAgICAgICAgc3RhcnQgPSBtaWRkbGUgKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gbWlkZGxlIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVuZCArIDE7XG4gIH1cbiAgI2luc2VydChbLCB5MSwgeTJdKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLiNiaW5hcnlTZWFyY2goeTEpO1xuICAgIHRoaXMuI2ludGVydmFscy5zcGxpY2UoaW5kZXgsIDAsIFt5MSwgeTJdKTtcbiAgfVxuICAjcmVtb3ZlKFssIHkxLCB5Ml0pIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuI2JpbmFyeVNlYXJjaCh5MSk7XG4gICAgZm9yIChsZXQgaSA9IGluZGV4OyBpIDwgdGhpcy4jaW50ZXJ2YWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSB0aGlzLiNpbnRlcnZhbHNbaV07XG4gICAgICBpZiAoc3RhcnQgIT09IHkxKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ID09PSB5MSAmJiBlbmQgPT09IHkyKSB7XG4gICAgICAgIHRoaXMuI2ludGVydmFscy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IGluZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IFtzdGFydCwgZW5kXSA9IHRoaXMuI2ludGVydmFsc1tpXTtcbiAgICAgIGlmIChzdGFydCAhPT0geTEpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgPT09IHkxICYmIGVuZCA9PT0geTIpIHtcbiAgICAgICAgdGhpcy4jaW50ZXJ2YWxzLnNwbGljZShpLCAxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAjYnJlYWtFZGdlKGVkZ2UpIHtcbiAgICBjb25zdCBbeCwgeTEsIHkyXSA9IGVkZ2U7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtbeCwgeTEsIHkyXV07XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLiNiaW5hcnlTZWFyY2goeTIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkrKykge1xuICAgICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gdGhpcy4jaW50ZXJ2YWxzW2ldO1xuICAgICAgZm9yIChsZXQgaiA9IDAsIGpqID0gcmVzdWx0cy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgIGNvbnN0IFssIHkzLCB5NF0gPSByZXN1bHRzW2pdO1xuICAgICAgICBpZiAoZW5kIDw9IHkzIHx8IHk0IDw9IHN0YXJ0KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkzID49IHN0YXJ0KSB7XG4gICAgICAgICAgaWYgKHk0ID4gZW5kKSB7XG4gICAgICAgICAgICByZXN1bHRzW2pdWzFdID0gZW5kO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoamogPT09IDEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0cy5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICBqLS07XG4gICAgICAgICAgICBqai0tO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRzW2pdWzJdID0gc3RhcnQ7XG4gICAgICAgIGlmICh5NCA+IGVuZCkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChbeCwgZW5kLCB5NF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG59XG5jbGFzcyBIaWdobGlnaHRPdXRsaW5lIGV4dGVuZHMgT3V0bGluZSB7XG4gICNib3g7XG4gICNvdXRsaW5lcztcbiAgY29uc3RydWN0b3Iob3V0bGluZXMsIGJveCwgbGFzdFBvaW50KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLiNvdXRsaW5lcyA9IG91dGxpbmVzO1xuICAgIHRoaXMuI2JveCA9IGJveDtcbiAgICB0aGlzLmxhc3RQb2ludCA9IGxhc3RQb2ludDtcbiAgfVxuICB0b1NWR1BhdGgoKSB7XG4gICAgY29uc3QgYnVmZmVyID0gW107XG4gICAgZm9yIChjb25zdCBwb2x5Z29uIG9mIHRoaXMuI291dGxpbmVzKSB7XG4gICAgICBsZXQgW3ByZXZYLCBwcmV2WV0gPSBwb2x5Z29uO1xuICAgICAgYnVmZmVyLnB1c2goYE0ke3ByZXZYfSAke3ByZXZZfWApO1xuICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCBwb2x5Z29uLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IHggPSBwb2x5Z29uW2ldO1xuICAgICAgICBjb25zdCB5ID0gcG9seWdvbltpICsgMV07XG4gICAgICAgIGlmICh4ID09PSBwcmV2WCkge1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKGBWJHt5fWApO1xuICAgICAgICAgIHByZXZZID0geTtcbiAgICAgICAgfSBlbHNlIGlmICh5ID09PSBwcmV2WSkge1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKGBIJHt4fWApO1xuICAgICAgICAgIHByZXZYID0geDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnVmZmVyLnB1c2goXCJaXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oXCIgXCIpO1xuICB9XG4gIHNlcmlhbGl6ZShbYmxYLCBibFksIHRyWCwgdHJZXSwgX3JvdGF0aW9uKSB7XG4gICAgY29uc3Qgb3V0bGluZXMgPSBbXTtcbiAgICBjb25zdCB3aWR0aCA9IHRyWCAtIGJsWDtcbiAgICBjb25zdCBoZWlnaHQgPSB0clkgLSBibFk7XG4gICAgZm9yIChjb25zdCBvdXRsaW5lIG9mIHRoaXMuI291dGxpbmVzKSB7XG4gICAgICBjb25zdCBwb2ludHMgPSBuZXcgQXJyYXkob3V0bGluZS5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRsaW5lLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHBvaW50c1tpXSA9IGJsWCArIG91dGxpbmVbaV0gKiB3aWR0aDtcbiAgICAgICAgcG9pbnRzW2kgKyAxXSA9IHRyWSAtIG91dGxpbmVbaSArIDFdICogaGVpZ2h0O1xuICAgICAgfVxuICAgICAgb3V0bGluZXMucHVzaChwb2ludHMpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0bGluZXM7XG4gIH1cbiAgZ2V0IGJveCgpIHtcbiAgICByZXR1cm4gdGhpcy4jYm94O1xuICB9XG4gIGdldCBjbGFzc05hbWVzRm9yT3V0bGluaW5nKCkge1xuICAgIHJldHVybiBbXCJoaWdobGlnaHRPdXRsaW5lXCJdO1xuICB9XG59XG5jbGFzcyBGcmVlSGlnaGxpZ2h0T3V0bGluZXIgZXh0ZW5kcyBGcmVlRHJhd091dGxpbmVyIHtcbiAgbmV3RnJlZURyYXdPdXRsaW5lKG91dGxpbmUsIHBvaW50cywgYm94LCBzY2FsZUZhY3RvciwgaW5uZXJNYXJnaW4sIGlzTFRSKSB7XG4gICAgcmV0dXJuIG5ldyBGcmVlSGlnaGxpZ2h0T3V0bGluZShvdXRsaW5lLCBwb2ludHMsIGJveCwgc2NhbGVGYWN0b3IsIGlubmVyTWFyZ2luLCBpc0xUUik7XG4gIH1cbn1cbmNsYXNzIEZyZWVIaWdobGlnaHRPdXRsaW5lIGV4dGVuZHMgRnJlZURyYXdPdXRsaW5lIHtcbiAgbmV3T3V0bGluZXIocG9pbnQsIGJveCwgc2NhbGVGYWN0b3IsIHRoaWNrbmVzcywgaXNMVFIsIGlubmVyTWFyZ2luID0gMCkge1xuICAgIHJldHVybiBuZXcgRnJlZUhpZ2hsaWdodE91dGxpbmVyKHBvaW50LCBib3gsIHNjYWxlRmFjdG9yLCB0aGlja25lc3MsIGlzTFRSLCBpbm5lck1hcmdpbik7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2NvbG9yX3BpY2tlci5qc1xuXG5cblxuY2xhc3MgQ29sb3JQaWNrZXIge1xuICAjYnV0dG9uID0gbnVsbDtcbiAgI2J1dHRvblN3YXRjaCA9IG51bGw7XG4gICNkZWZhdWx0Q29sb3I7XG4gICNkcm9wZG93biA9IG51bGw7XG4gICNkcm9wZG93bldhc0Zyb21LZXlib2FyZCA9IGZhbHNlO1xuICAjaXNNYWluQ29sb3JQaWNrZXIgPSBmYWxzZTtcbiAgI2VkaXRvciA9IG51bGw7XG4gICNldmVudEJ1cztcbiAgI29wZW5Ecm9wZG93bkFDID0gbnVsbDtcbiAgI3VpTWFuYWdlciA9IG51bGw7XG4gICN0eXBlO1xuICBzdGF0aWMgI2wxMG5Db2xvciA9IG51bGw7XG4gIHN0YXRpYyBnZXQgX2tleWJvYXJkTWFuYWdlcigpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2tleWJvYXJkTWFuYWdlclwiLCBuZXcgS2V5Ym9hcmRNYW5hZ2VyKFtbW1wiRXNjYXBlXCIsIFwibWFjK0VzY2FwZVwiXSwgQ29sb3JQaWNrZXIucHJvdG90eXBlLl9oaWRlRHJvcGRvd25Gcm9tS2V5Ym9hcmRdLCBbW1wiIFwiLCBcIm1hYysgXCJdLCBDb2xvclBpY2tlci5wcm90b3R5cGUuX2NvbG9yU2VsZWN0RnJvbUtleWJvYXJkXSwgW1tcIkFycm93RG93blwiLCBcIkFycm93UmlnaHRcIiwgXCJtYWMrQXJyb3dEb3duXCIsIFwibWFjK0Fycm93UmlnaHRcIl0sIENvbG9yUGlja2VyLnByb3RvdHlwZS5fbW92ZVRvTmV4dF0sIFtbXCJBcnJvd1VwXCIsIFwiQXJyb3dMZWZ0XCIsIFwibWFjK0Fycm93VXBcIiwgXCJtYWMrQXJyb3dMZWZ0XCJdLCBDb2xvclBpY2tlci5wcm90b3R5cGUuX21vdmVUb1ByZXZpb3VzXSwgW1tcIkhvbWVcIiwgXCJtYWMrSG9tZVwiXSwgQ29sb3JQaWNrZXIucHJvdG90eXBlLl9tb3ZlVG9CZWdpbm5pbmddLCBbW1wiRW5kXCIsIFwibWFjK0VuZFwiXSwgQ29sb3JQaWNrZXIucHJvdG90eXBlLl9tb3ZlVG9FbmRdXSkpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBlZGl0b3IgPSBudWxsLFxuICAgIHVpTWFuYWdlciA9IG51bGxcbiAgfSkge1xuICAgIGlmIChlZGl0b3IpIHtcbiAgICAgIHRoaXMuI2lzTWFpbkNvbG9yUGlja2VyID0gZmFsc2U7XG4gICAgICB0aGlzLiN0eXBlID0gQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX0NPTE9SO1xuICAgICAgdGhpcy4jZWRpdG9yID0gZWRpdG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNpc01haW5Db2xvclBpY2tlciA9IHRydWU7XG4gICAgICB0aGlzLiN0eXBlID0gQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX0RFRkFVTFRfQ09MT1I7XG4gICAgfVxuICAgIHRoaXMuI3VpTWFuYWdlciA9IGVkaXRvcj8uX3VpTWFuYWdlciB8fCB1aU1hbmFnZXI7XG4gICAgdGhpcy4jZXZlbnRCdXMgPSB0aGlzLiN1aU1hbmFnZXIuX2V2ZW50QnVzO1xuICAgIHRoaXMuI2RlZmF1bHRDb2xvciA9IGVkaXRvcj8uY29sb3IgfHwgdGhpcy4jdWlNYW5hZ2VyPy5oaWdobGlnaHRDb2xvcnMudmFsdWVzKCkubmV4dCgpLnZhbHVlIHx8IFwiI0ZGRkY5OFwiO1xuICAgIENvbG9yUGlja2VyLiNsMTBuQ29sb3IgfHw9IE9iamVjdC5mcmVlemUoe1xuICAgICAgYmx1ZTogXCJwZGZqcy1lZGl0b3ItY29sb3JwaWNrZXItYmx1ZVwiLFxuICAgICAgZ3JlZW46IFwicGRmanMtZWRpdG9yLWNvbG9ycGlja2VyLWdyZWVuXCIsXG4gICAgICBwaW5rOiBcInBkZmpzLWVkaXRvci1jb2xvcnBpY2tlci1waW5rXCIsXG4gICAgICByZWQ6IFwicGRmanMtZWRpdG9yLWNvbG9ycGlja2VyLXJlZFwiLFxuICAgICAgeWVsbG93OiBcInBkZmpzLWVkaXRvci1jb2xvcnBpY2tlci15ZWxsb3dcIlxuICAgIH0pO1xuICB9XG4gIHJlbmRlckJ1dHRvbigpIHtcbiAgICBjb25zdCBidXR0b24gPSB0aGlzLiNidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgIGJ1dHRvbi5jbGFzc05hbWUgPSBcImNvbG9yUGlja2VyXCI7XG4gICAgYnV0dG9uLnRhYkluZGV4ID0gXCIwXCI7XG4gICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLWVkaXRvci1jb2xvcnBpY2tlci1idXR0b25cIik7XG4gICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtaGFzcG9wdXBcIiwgdHJ1ZSk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLiNvcGVuRHJvcGRvd24uYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2tleURvd24uYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgY29uc3Qgc3dhdGNoID0gdGhpcy4jYnV0dG9uU3dhdGNoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgc3dhdGNoLmNsYXNzTmFtZSA9IFwic3dhdGNoXCI7XG4gICAgc3dhdGNoLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIHRydWUpO1xuICAgIHN3YXRjaC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLiNkZWZhdWx0Q29sb3I7XG4gICAgYnV0dG9uLmFwcGVuZChzd2F0Y2gpO1xuICAgIHJldHVybiBidXR0b247XG4gIH1cbiAgcmVuZGVyTWFpbkRyb3Bkb3duKCkge1xuICAgIGNvbnN0IGRyb3Bkb3duID0gdGhpcy4jZHJvcGRvd24gPSB0aGlzLiNnZXREcm9wZG93blJvb3QoKTtcbiAgICBkcm9wZG93bi5zZXRBdHRyaWJ1dGUoXCJhcmlhLW9yaWVudGF0aW9uXCIsIFwiaG9yaXpvbnRhbFwiKTtcbiAgICBkcm9wZG93bi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsbGVkYnlcIiwgXCJoaWdobGlnaHRDb2xvclBpY2tlckxhYmVsXCIpO1xuICAgIHJldHVybiBkcm9wZG93bjtcbiAgfVxuICAjZ2V0RHJvcGRvd25Sb290KCkge1xuICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBkaXYuY2xhc3NOYW1lID0gXCJkcm9wZG93blwiO1xuICAgIGRpdi5yb2xlID0gXCJsaXN0Ym94XCI7XG4gICAgZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtbXVsdGlzZWxlY3RhYmxlXCIsIGZhbHNlKTtcbiAgICBkaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1vcmllbnRhdGlvblwiLCBcInZlcnRpY2FsXCIpO1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1lZGl0b3ItY29sb3JwaWNrZXItZHJvcGRvd25cIik7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgY29sb3JdIG9mIHRoaXMuI3VpTWFuYWdlci5oaWdobGlnaHRDb2xvcnMpIHtcbiAgICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICBidXR0b24udGFiSW5kZXggPSBcIjBcIjtcbiAgICAgIGJ1dHRvbi5yb2xlID0gXCJvcHRpb25cIjtcbiAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWNvbG9yXCIsIGNvbG9yKTtcbiAgICAgIGJ1dHRvbi50aXRsZSA9IG5hbWU7XG4gICAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIENvbG9yUGlja2VyLiNsMTBuQ29sb3JbbmFtZV0pO1xuICAgICAgY29uc3Qgc3dhdGNoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICBidXR0b24uYXBwZW5kKHN3YXRjaCk7XG4gICAgICBzd2F0Y2guY2xhc3NOYW1lID0gXCJzd2F0Y2hcIjtcbiAgICAgIHN3YXRjaC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtcbiAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsIGNvbG9yID09PSB0aGlzLiNkZWZhdWx0Q29sb3IpO1xuICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLiNjb2xvclNlbGVjdC5iaW5kKHRoaXMsIGNvbG9yKSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgZGl2LmFwcGVuZChidXR0b24pO1xuICAgIH1cbiAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4ja2V5RG93bi5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICByZXR1cm4gZGl2O1xuICB9XG4gICNjb2xvclNlbGVjdChjb2xvciwgZXZlbnQpIHtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB0aGlzLiNldmVudEJ1cy5kaXNwYXRjaChcInN3aXRjaGFubm90YXRpb25lZGl0b3JwYXJhbXNcIiwge1xuICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgdHlwZTogdGhpcy4jdHlwZSxcbiAgICAgIHZhbHVlOiBjb2xvclxuICAgIH0pO1xuICB9XG4gIF9jb2xvclNlbGVjdEZyb21LZXlib2FyZChldmVudCkge1xuICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMuI2J1dHRvbikge1xuICAgICAgdGhpcy4jb3BlbkRyb3Bkb3duKGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29sb3IgPSBldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1jb2xvclwiKTtcbiAgICBpZiAoIWNvbG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvbG9yU2VsZWN0KGNvbG9yLCBldmVudCk7XG4gIH1cbiAgX21vdmVUb05leHQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICB0aGlzLiNvcGVuRHJvcGRvd24oZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLiNidXR0b24pIHtcbiAgICAgIHRoaXMuI2Ryb3Bkb3duLmZpcnN0Q2hpbGQ/LmZvY3VzKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50LnRhcmdldC5uZXh0U2libGluZz8uZm9jdXMoKTtcbiAgfVxuICBfbW92ZVRvUHJldmlvdXMoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLiNkcm9wZG93bj8uZmlyc3RDaGlsZCB8fCBldmVudC50YXJnZXQgPT09IHRoaXMuI2J1dHRvbikge1xuICAgICAgaWYgKHRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICAgIHRoaXMuX2hpZGVEcm9wZG93bkZyb21LZXlib2FyZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICB0aGlzLiNvcGVuRHJvcGRvd24oZXZlbnQpO1xuICAgIH1cbiAgICBldmVudC50YXJnZXQucHJldmlvdXNTaWJsaW5nPy5mb2N1cygpO1xuICB9XG4gIF9tb3ZlVG9CZWdpbm5pbmcoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICB0aGlzLiNvcGVuRHJvcGRvd24oZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNkcm9wZG93bi5maXJzdENoaWxkPy5mb2N1cygpO1xuICB9XG4gIF9tb3ZlVG9FbmQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICB0aGlzLiNvcGVuRHJvcGRvd24oZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNkcm9wZG93bi5sYXN0Q2hpbGQ/LmZvY3VzKCk7XG4gIH1cbiAgI2tleURvd24oZXZlbnQpIHtcbiAgICBDb2xvclBpY2tlci5fa2V5Ym9hcmRNYW5hZ2VyLmV4ZWModGhpcywgZXZlbnQpO1xuICB9XG4gICNvcGVuRHJvcGRvd24oZXZlbnQpIHtcbiAgICBpZiAodGhpcy4jaXNEcm9wZG93blZpc2libGUpIHtcbiAgICAgIHRoaXMuaGlkZURyb3Bkb3duKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2Ryb3Bkb3duV2FzRnJvbUtleWJvYXJkID0gZXZlbnQuZGV0YWlsID09PSAwO1xuICAgIGlmICghdGhpcy4jb3BlbkRyb3Bkb3duQUMpIHtcbiAgICAgIHRoaXMuI29wZW5Ecm9wZG93bkFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLiNwb2ludGVyRG93bi5iaW5kKHRoaXMpLCB7XG4gICAgICAgIHNpZ25hbDogdGhpcy4jdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKHRoaXMuI29wZW5Ecm9wZG93bkFDKVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNkcm9wZG93bikge1xuICAgICAgdGhpcy4jZHJvcGRvd24uY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgcm9vdCA9IHRoaXMuI2Ryb3Bkb3duID0gdGhpcy4jZ2V0RHJvcGRvd25Sb290KCk7XG4gICAgdGhpcy4jYnV0dG9uLmFwcGVuZChyb290KTtcbiAgfVxuICAjcG9pbnRlckRvd24oZXZlbnQpIHtcbiAgICBpZiAodGhpcy4jZHJvcGRvd24/LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5oaWRlRHJvcGRvd24oKTtcbiAgfVxuICBoaWRlRHJvcGRvd24oKSB7XG4gICAgdGhpcy4jZHJvcGRvd24/LmNsYXNzTGlzdC5hZGQoXCJoaWRkZW5cIik7XG4gICAgdGhpcy4jb3BlbkRyb3Bkb3duQUM/LmFib3J0KCk7XG4gICAgdGhpcy4jb3BlbkRyb3Bkb3duQUMgPSBudWxsO1xuICB9XG4gIGdldCAjaXNEcm9wZG93blZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Ryb3Bkb3duICYmICF0aGlzLiNkcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoXCJoaWRkZW5cIik7XG4gIH1cbiAgX2hpZGVEcm9wZG93bkZyb21LZXlib2FyZCgpIHtcbiAgICBpZiAodGhpcy4jaXNNYWluQ29sb3JQaWNrZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNpc0Ryb3Bkb3duVmlzaWJsZSkge1xuICAgICAgdGhpcy4jZWRpdG9yPy51bnNlbGVjdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmhpZGVEcm9wZG93bigpO1xuICAgIHRoaXMuI2J1dHRvbi5mb2N1cyh7XG4gICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlLFxuICAgICAgZm9jdXNWaXNpYmxlOiB0aGlzLiNkcm9wZG93bldhc0Zyb21LZXlib2FyZFxuICAgIH0pO1xuICB9XG4gIHVwZGF0ZUNvbG9yKGNvbG9yKSB7XG4gICAgaWYgKHRoaXMuI2J1dHRvblN3YXRjaCkge1xuICAgICAgdGhpcy4jYnV0dG9uU3dhdGNoLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2Ryb3Bkb3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGkgPSB0aGlzLiN1aU1hbmFnZXIuaGlnaGxpZ2h0Q29sb3JzLnZhbHVlcygpO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy4jZHJvcGRvd24uY2hpbGRyZW4pIHtcbiAgICAgIGNoaWxkLnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgaS5uZXh0KCkudmFsdWUgPT09IGNvbG9yKTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiNidXR0b24/LnJlbW92ZSgpO1xuICAgIHRoaXMuI2J1dHRvbiA9IG51bGw7XG4gICAgdGhpcy4jYnV0dG9uU3dhdGNoID0gbnVsbDtcbiAgICB0aGlzLiNkcm9wZG93bj8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jZHJvcGRvd24gPSBudWxsO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9oaWdobGlnaHQuanNcblxuXG5cblxuXG5cblxuY2xhc3MgSGlnaGxpZ2h0RWRpdG9yIGV4dGVuZHMgQW5ub3RhdGlvbkVkaXRvciB7XG4gICNhbmNob3JOb2RlID0gbnVsbDtcbiAgI2FuY2hvck9mZnNldCA9IDA7XG4gICNib3hlcztcbiAgI2NsaXBQYXRoSWQgPSBudWxsO1xuICAjY29sb3JQaWNrZXIgPSBudWxsO1xuICAjZm9jdXNPdXRsaW5lcyA9IG51bGw7XG4gICNmb2N1c05vZGUgPSBudWxsO1xuICAjZm9jdXNPZmZzZXQgPSAwO1xuICAjaGlnaGxpZ2h0RGl2ID0gbnVsbDtcbiAgI2hpZ2hsaWdodE91dGxpbmVzID0gbnVsbDtcbiAgI2lkID0gbnVsbDtcbiAgI2lzRnJlZUhpZ2hsaWdodCA9IGZhbHNlO1xuICAjbGFzdFBvaW50ID0gbnVsbDtcbiAgI29wYWNpdHk7XG4gICNvdXRsaW5lSWQgPSBudWxsO1xuICAjdGV4dCA9IFwiXCI7XG4gICN0aGlja25lc3M7XG4gICNtZXRob2RPZkNyZWF0aW9uID0gXCJcIjtcbiAgc3RhdGljIF9kZWZhdWx0Q29sb3IgPSBudWxsO1xuICBzdGF0aWMgX2RlZmF1bHRPcGFjaXR5ID0gMTtcbiAgc3RhdGljIF9kZWZhdWx0VGhpY2tuZXNzID0gMTI7XG4gIHN0YXRpYyBfdHlwZSA9IFwiaGlnaGxpZ2h0XCI7XG4gIHN0YXRpYyBfZWRpdG9yVHlwZSA9IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVDtcbiAgc3RhdGljIF9mcmVlSGlnaGxpZ2h0SWQgPSAtMTtcbiAgc3RhdGljIF9mcmVlSGlnaGxpZ2h0ID0gbnVsbDtcbiAgc3RhdGljIF9mcmVlSGlnaGxpZ2h0Q2xpcElkID0gXCJcIjtcbiAgc3RhdGljIGdldCBfa2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIGNvbnN0IHByb3RvID0gSGlnaGxpZ2h0RWRpdG9yLnByb3RvdHlwZTtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2tleWJvYXJkTWFuYWdlclwiLCBuZXcgS2V5Ym9hcmRNYW5hZ2VyKFtbW1wiQXJyb3dMZWZ0XCIsIFwibWFjK0Fycm93TGVmdFwiXSwgcHJvdG8uX21vdmVDYXJldCwge1xuICAgICAgYXJnczogWzBdXG4gICAgfV0sIFtbXCJBcnJvd1JpZ2h0XCIsIFwibWFjK0Fycm93UmlnaHRcIl0sIHByb3RvLl9tb3ZlQ2FyZXQsIHtcbiAgICAgIGFyZ3M6IFsxXVxuICAgIH1dLCBbW1wiQXJyb3dVcFwiLCBcIm1hYytBcnJvd1VwXCJdLCBwcm90by5fbW92ZUNhcmV0LCB7XG4gICAgICBhcmdzOiBbMl1cbiAgICB9XSwgW1tcIkFycm93RG93blwiLCBcIm1hYytBcnJvd0Rvd25cIl0sIHByb3RvLl9tb3ZlQ2FyZXQsIHtcbiAgICAgIGFyZ3M6IFszXVxuICAgIH1dXSkpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLnBhcmFtcyxcbiAgICAgIG5hbWU6IFwiaGlnaGxpZ2h0RWRpdG9yXCJcbiAgICB9KTtcbiAgICB0aGlzLmNvbG9yID0gcGFyYW1zLmNvbG9yIHx8IEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdENvbG9yO1xuICAgIHRoaXMuI3RoaWNrbmVzcyA9IHBhcmFtcy50aGlja25lc3MgfHwgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0VGhpY2tuZXNzO1xuICAgIHRoaXMuI29wYWNpdHkgPSBwYXJhbXMub3BhY2l0eSB8fCBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRPcGFjaXR5O1xuICAgIHRoaXMuI2JveGVzID0gcGFyYW1zLmJveGVzIHx8IG51bGw7XG4gICAgdGhpcy4jbWV0aG9kT2ZDcmVhdGlvbiA9IHBhcmFtcy5tZXRob2RPZkNyZWF0aW9uIHx8IFwiXCI7XG4gICAgdGhpcy4jdGV4dCA9IHBhcmFtcy50ZXh0IHx8IFwiXCI7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSBmYWxzZTtcbiAgICBpZiAocGFyYW1zLmhpZ2hsaWdodElkID4gLTEpIHtcbiAgICAgIHRoaXMuI2lzRnJlZUhpZ2hsaWdodCA9IHRydWU7XG4gICAgICB0aGlzLiNjcmVhdGVGcmVlT3V0bGluZXMocGFyYW1zKTtcbiAgICAgIHRoaXMuI2FkZFRvRHJhd0xheWVyKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLiNib3hlcykge1xuICAgICAgdGhpcy4jYW5jaG9yTm9kZSA9IHBhcmFtcy5hbmNob3JOb2RlO1xuICAgICAgdGhpcy4jYW5jaG9yT2Zmc2V0ID0gcGFyYW1zLmFuY2hvck9mZnNldDtcbiAgICAgIHRoaXMuI2ZvY3VzTm9kZSA9IHBhcmFtcy5mb2N1c05vZGU7XG4gICAgICB0aGlzLiNmb2N1c09mZnNldCA9IHBhcmFtcy5mb2N1c09mZnNldDtcbiAgICAgIHRoaXMuI2NyZWF0ZU91dGxpbmVzKCk7XG4gICAgICB0aGlzLiNhZGRUb0RyYXdMYXllcigpO1xuICAgICAgdGhpcy5yb3RhdGUodGhpcy5yb3RhdGlvbik7XG4gICAgfVxuICB9XG4gIGdldCB0ZWxlbWV0cnlJbml0aWFsRGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWN0aW9uOiBcImFkZGVkXCIsXG4gICAgICB0eXBlOiB0aGlzLiNpc0ZyZWVIaWdobGlnaHQgPyBcImZyZWVfaGlnaGxpZ2h0XCIgOiBcImhpZ2hsaWdodFwiLFxuICAgICAgY29sb3I6IHRoaXMuX3VpTWFuYWdlci5oaWdobGlnaHRDb2xvck5hbWVzLmdldCh0aGlzLmNvbG9yKSxcbiAgICAgIHRoaWNrbmVzczogdGhpcy4jdGhpY2tuZXNzLFxuICAgICAgbWV0aG9kT2ZDcmVhdGlvbjogdGhpcy4jbWV0aG9kT2ZDcmVhdGlvblxuICAgIH07XG4gIH1cbiAgZ2V0IHRlbGVtZXRyeUZpbmFsRGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJoaWdobGlnaHRcIixcbiAgICAgIGNvbG9yOiB0aGlzLl91aU1hbmFnZXIuaGlnaGxpZ2h0Q29sb3JOYW1lcy5nZXQodGhpcy5jb2xvcilcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBjb21wdXRlVGVsZW1ldHJ5RmluYWxEYXRhKGRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbnVtYmVyT2ZDb2xvcnM6IGRhdGEuZ2V0KFwiY29sb3JcIikuc2l6ZVxuICAgIH07XG4gIH1cbiAgI2NyZWF0ZU91dGxpbmVzKCkge1xuICAgIGNvbnN0IG91dGxpbmVyID0gbmV3IEhpZ2hsaWdodE91dGxpbmVyKHRoaXMuI2JveGVzLCAwLjAwMSk7XG4gICAgdGhpcy4jaGlnaGxpZ2h0T3V0bGluZXMgPSBvdXRsaW5lci5nZXRPdXRsaW5lcygpO1xuICAgIFt0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHRdID0gdGhpcy4jaGlnaGxpZ2h0T3V0bGluZXMuYm94O1xuICAgIGNvbnN0IG91dGxpbmVyRm9yT3V0bGluZSA9IG5ldyBIaWdobGlnaHRPdXRsaW5lcih0aGlzLiNib3hlcywgMC4wMDI1LCAwLjAwMSwgdGhpcy5fdWlNYW5hZ2VyLmRpcmVjdGlvbiA9PT0gXCJsdHJcIik7XG4gICAgdGhpcy4jZm9jdXNPdXRsaW5lcyA9IG91dGxpbmVyRm9yT3V0bGluZS5nZXRPdXRsaW5lcygpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhc3RQb2ludFxuICAgIH0gPSB0aGlzLiNmb2N1c091dGxpbmVzO1xuICAgIHRoaXMuI2xhc3RQb2ludCA9IFsobGFzdFBvaW50WzBdIC0gdGhpcy54KSAvIHRoaXMud2lkdGgsIChsYXN0UG9pbnRbMV0gLSB0aGlzLnkpIC8gdGhpcy5oZWlnaHRdO1xuICB9XG4gICNjcmVhdGVGcmVlT3V0bGluZXMoe1xuICAgIGhpZ2hsaWdodE91dGxpbmVzLFxuICAgIGhpZ2hsaWdodElkLFxuICAgIGNsaXBQYXRoSWRcbiAgfSkge1xuICAgIHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzID0gaGlnaGxpZ2h0T3V0bGluZXM7XG4gICAgY29uc3QgZXh0cmFUaGlja25lc3MgPSAxLjU7XG4gICAgdGhpcy4jZm9jdXNPdXRsaW5lcyA9IGhpZ2hsaWdodE91dGxpbmVzLmdldE5ld091dGxpbmUodGhpcy4jdGhpY2tuZXNzIC8gMiArIGV4dHJhVGhpY2tuZXNzLCAwLjAwMjUpO1xuICAgIGlmIChoaWdobGlnaHRJZCA+PSAwKSB7XG4gICAgICB0aGlzLiNpZCA9IGhpZ2hsaWdodElkO1xuICAgICAgdGhpcy4jY2xpcFBhdGhJZCA9IGNsaXBQYXRoSWQ7XG4gICAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIuZmluYWxpemVEcmF3KGhpZ2hsaWdodElkLCB7XG4gICAgICAgIGJib3g6IGhpZ2hsaWdodE91dGxpbmVzLmJveCxcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIGQ6IGhpZ2hsaWdodE91dGxpbmVzLnRvU1ZHUGF0aCgpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy4jb3V0bGluZUlkID0gdGhpcy5wYXJlbnQuZHJhd0xheWVyLmRyYXdPdXRsaW5lKHtcbiAgICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgICAgaGlnaGxpZ2h0T3V0bGluZTogdHJ1ZSxcbiAgICAgICAgICBmcmVlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGJib3g6IHRoaXMuI2ZvY3VzT3V0bGluZXMuYm94LFxuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgZDogdGhpcy4jZm9jdXNPdXRsaW5lcy50b1NWR1BhdGgoKVxuICAgICAgICB9XG4gICAgICB9LCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICBjb25zdCBhbmdsZSA9IHRoaXMucGFyZW50LnZpZXdwb3J0LnJvdGF0aW9uO1xuICAgICAgdGhpcy5wYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jaWQsIHtcbiAgICAgICAgYmJveDogSGlnaGxpZ2h0RWRpdG9yLiNyb3RhdGVCYm94KHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzLmJveCwgKGFuZ2xlIC0gdGhpcy5yb3RhdGlvbiArIDM2MCkgJSAzNjApLFxuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgZDogaGlnaGxpZ2h0T3V0bGluZXMudG9TVkdQYXRoKClcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLiNvdXRsaW5lSWQsIHtcbiAgICAgICAgYmJveDogSGlnaGxpZ2h0RWRpdG9yLiNyb3RhdGVCYm94KHRoaXMuI2ZvY3VzT3V0bGluZXMuYm94LCBhbmdsZSksXG4gICAgICAgIHBhdGg6IHtcbiAgICAgICAgICBkOiB0aGlzLiNmb2N1c091dGxpbmVzLnRvU1ZHUGF0aCgpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSBoaWdobGlnaHRPdXRsaW5lcy5ib3g7XG4gICAgc3dpdGNoICh0aGlzLnJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgICAgICAgIHRoaXMueCA9IHk7XG4gICAgICAgICAgdGhpcy55ID0gMSAtIHg7XG4gICAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoICogcGFnZUhlaWdodCAvIHBhZ2VXaWR0aDtcbiAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAqIHBhZ2VXaWR0aCAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICB0aGlzLnggPSAxIC0geDtcbiAgICAgICAgdGhpcy55ID0gMSAtIHk7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICAgICAgICB0aGlzLnggPSAxIC0geTtcbiAgICAgICAgICB0aGlzLnkgPSB4O1xuICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aCAqIHBhZ2VIZWlnaHQgLyBwYWdlV2lkdGg7XG4gICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgKiBwYWdlV2lkdGggLyBwYWdlSGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGxhc3RQb2ludFxuICAgIH0gPSB0aGlzLiNmb2N1c091dGxpbmVzO1xuICAgIHRoaXMuI2xhc3RQb2ludCA9IFsobGFzdFBvaW50WzBdIC0geCkgLyB3aWR0aCwgKGxhc3RQb2ludFsxXSAtIHkpIC8gaGVpZ2h0XTtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpIHtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLmluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKTtcbiAgICBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRDb2xvciB8fD0gdWlNYW5hZ2VyLmhpZ2hsaWdodENvbG9ycz8udmFsdWVzKCkubmV4dCgpLnZhbHVlIHx8IFwiI2ZmZjA2NlwiO1xuICB9XG4gIHN0YXRpYyB1cGRhdGVEZWZhdWx0UGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9ERUZBVUxUX0NPTE9SOlxuICAgICAgICBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRDb2xvciA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX1RISUNLTkVTUzpcbiAgICAgICAgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0VGhpY2tuZXNzID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB0cmFuc2xhdGVJblBhZ2UoeCwgeSkge31cbiAgZ2V0IHRvb2xiYXJQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4jbGFzdFBvaW50O1xuICB9XG4gIHVwZGF0ZVBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfQ09MT1I6XG4gICAgICAgIHRoaXMuI3VwZGF0ZUNvbG9yKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9USElDS05FU1M6XG4gICAgICAgIHRoaXMuI3VwZGF0ZVRoaWNrbmVzcyh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0IGRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX0RFRkFVTFRfQ09MT1IsIEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdENvbG9yXSwgW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9USElDS05FU1MsIEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdFRoaWNrbmVzc11dO1xuICB9XG4gIGdldCBwcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX0NPTE9SLCB0aGlzLmNvbG9yIHx8IEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdENvbG9yXSwgW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9USElDS05FU1MsIHRoaXMuI3RoaWNrbmVzcyB8fCBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRUaGlja25lc3NdLCBbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX0ZSRUUsIHRoaXMuI2lzRnJlZUhpZ2hsaWdodF1dO1xuICB9XG4gICN1cGRhdGVDb2xvcihjb2xvcikge1xuICAgIGNvbnN0IHNldENvbG9yQW5kT3BhY2l0eSA9IChjb2wsIG9wYSkgPT4ge1xuICAgICAgdGhpcy5jb2xvciA9IGNvbDtcbiAgICAgIHRoaXMuI29wYWNpdHkgPSBvcGE7XG4gICAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jaWQsIHtcbiAgICAgICAgcm9vdDoge1xuICAgICAgICAgIGZpbGw6IGNvbCxcbiAgICAgICAgICBcImZpbGwtb3BhY2l0eVwiOiBvcGFcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLiNjb2xvclBpY2tlcj8udXBkYXRlQ29sb3IoY29sKTtcbiAgICB9O1xuICAgIGNvbnN0IHNhdmVkQ29sb3IgPSB0aGlzLmNvbG9yO1xuICAgIGNvbnN0IHNhdmVkT3BhY2l0eSA9IHRoaXMuI29wYWNpdHk7XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6IHNldENvbG9yQW5kT3BhY2l0eS5iaW5kKHRoaXMsIGNvbG9yLCBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRPcGFjaXR5KSxcbiAgICAgIHVuZG86IHNldENvbG9yQW5kT3BhY2l0eS5iaW5kKHRoaXMsIHNhdmVkQ29sb3IsIHNhdmVkT3BhY2l0eSksXG4gICAgICBwb3N0OiB0aGlzLl91aU1hbmFnZXIudXBkYXRlVUkuYmluZCh0aGlzLl91aU1hbmFnZXIsIHRoaXMpLFxuICAgICAgbXVzdEV4ZWM6IHRydWUsXG4gICAgICB0eXBlOiBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfQ09MT1IsXG4gICAgICBvdmVyd3JpdGVJZlNhbWVUeXBlOiB0cnVlLFxuICAgICAga2VlcFVuZG86IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLl9yZXBvcnRUZWxlbWV0cnkoe1xuICAgICAgYWN0aW9uOiBcImNvbG9yX2NoYW5nZWRcIixcbiAgICAgIGNvbG9yOiB0aGlzLl91aU1hbmFnZXIuaGlnaGxpZ2h0Q29sb3JOYW1lcy5nZXQoY29sb3IpXG4gICAgfSwgdHJ1ZSk7XG4gIH1cbiAgI3VwZGF0ZVRoaWNrbmVzcyh0aGlja25lc3MpIHtcbiAgICBjb25zdCBzYXZlZFRoaWNrbmVzcyA9IHRoaXMuI3RoaWNrbmVzcztcbiAgICBjb25zdCBzZXRUaGlja25lc3MgPSB0aCA9PiB7XG4gICAgICB0aGlzLiN0aGlja25lc3MgPSB0aDtcbiAgICAgIHRoaXMuI2NoYW5nZVRoaWNrbmVzcyh0aCk7XG4gICAgfTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogc2V0VGhpY2tuZXNzLmJpbmQodGhpcywgdGhpY2tuZXNzKSxcbiAgICAgIHVuZG86IHNldFRoaWNrbmVzcy5iaW5kKHRoaXMsIHNhdmVkVGhpY2tuZXNzKSxcbiAgICAgIHBvc3Q6IHRoaXMuX3VpTWFuYWdlci51cGRhdGVVSS5iaW5kKHRoaXMuX3VpTWFuYWdlciwgdGhpcyksXG4gICAgICBtdXN0RXhlYzogdHJ1ZSxcbiAgICAgIHR5cGU6IEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19USElDS05FU1MsXG4gICAgICBvdmVyd3JpdGVJZlNhbWVUeXBlOiB0cnVlLFxuICAgICAga2VlcFVuZG86IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLl9yZXBvcnRUZWxlbWV0cnkoe1xuICAgICAgYWN0aW9uOiBcInRoaWNrbmVzc19jaGFuZ2VkXCIsXG4gICAgICB0aGlja25lc3NcbiAgICB9LCB0cnVlKTtcbiAgfVxuICBhc3luYyBhZGRFZGl0VG9vbGJhcigpIHtcbiAgICBjb25zdCB0b29sYmFyID0gYXdhaXQgc3VwZXIuYWRkRWRpdFRvb2xiYXIoKTtcbiAgICBpZiAoIXRvb2xiYXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5fdWlNYW5hZ2VyLmhpZ2hsaWdodENvbG9ycykge1xuICAgICAgdGhpcy4jY29sb3JQaWNrZXIgPSBuZXcgQ29sb3JQaWNrZXIoe1xuICAgICAgICBlZGl0b3I6IHRoaXNcbiAgICAgIH0pO1xuICAgICAgdG9vbGJhci5hZGRDb2xvclBpY2tlcih0aGlzLiNjb2xvclBpY2tlcik7XG4gICAgfVxuICAgIHJldHVybiB0b29sYmFyO1xuICB9XG4gIGRpc2FibGVFZGl0aW5nKCkge1xuICAgIHN1cGVyLmRpc2FibGVFZGl0aW5nKCk7XG4gICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImRpc2FibGVkXCIsIHRydWUpO1xuICB9XG4gIGVuYWJsZUVkaXRpbmcoKSB7XG4gICAgc3VwZXIuZW5hYmxlRWRpdGluZygpO1xuICAgIHRoaXMuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJkaXNhYmxlZFwiLCBmYWxzZSk7XG4gIH1cbiAgZml4QW5kU2V0UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHN1cGVyLmZpeEFuZFNldFBvc2l0aW9uKHRoaXMuI2dldFJvdGF0aW9uKCkpO1xuICB9XG4gIGdldEJhc2VUcmFuc2xhdGlvbigpIHtcbiAgICByZXR1cm4gWzAsIDBdO1xuICB9XG4gIGdldFJlY3QodHgsIHR5KSB7XG4gICAgcmV0dXJuIHN1cGVyLmdldFJlY3QodHgsIHR5LCB0aGlzLiNnZXRSb3RhdGlvbigpKTtcbiAgfVxuICBvbmNlQWRkZWQoKSB7XG4gICAgaWYgKCF0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIHRoaXMucGFyZW50LmFkZFVuZG9hYmxlRWRpdG9yKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLmRpdi5mb2N1cygpO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLiNjbGVhbkRyYXdMYXllcigpO1xuICAgIHRoaXMuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICBhY3Rpb246IFwiZGVsZXRlZFwiXG4gICAgfSk7XG4gICAgc3VwZXIucmVtb3ZlKCk7XG4gIH1cbiAgcmVidWlsZCgpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLnJlYnVpbGQoKTtcbiAgICBpZiAodGhpcy5kaXYgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYWRkVG9EcmF3TGF5ZXIoKTtcbiAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICB0aGlzLnBhcmVudC5hZGQodGhpcyk7XG4gICAgfVxuICB9XG4gIHNldFBhcmVudChwYXJlbnQpIHtcbiAgICBsZXQgbXVzdEJlU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5wYXJlbnQgJiYgIXBhcmVudCkge1xuICAgICAgdGhpcy4jY2xlYW5EcmF3TGF5ZXIoKTtcbiAgICB9IGVsc2UgaWYgKHBhcmVudCkge1xuICAgICAgdGhpcy4jYWRkVG9EcmF3TGF5ZXIocGFyZW50KTtcbiAgICAgIG11c3RCZVNlbGVjdGVkID0gIXRoaXMucGFyZW50ICYmIHRoaXMuZGl2Py5jbGFzc0xpc3QuY29udGFpbnMoXCJzZWxlY3RlZEVkaXRvclwiKTtcbiAgICB9XG4gICAgc3VwZXIuc2V0UGFyZW50KHBhcmVudCk7XG4gICAgdGhpcy5zaG93KHRoaXMuX2lzVmlzaWJsZSk7XG4gICAgaWYgKG11c3RCZVNlbGVjdGVkKSB7XG4gICAgICB0aGlzLnNlbGVjdCgpO1xuICAgIH1cbiAgfVxuICAjY2hhbmdlVGhpY2tuZXNzKHRoaWNrbmVzcykge1xuICAgIGlmICghdGhpcy4jaXNGcmVlSGlnaGxpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NyZWF0ZUZyZWVPdXRsaW5lcyh7XG4gICAgICBoaWdobGlnaHRPdXRsaW5lczogdGhpcy4jaGlnaGxpZ2h0T3V0bGluZXMuZ2V0TmV3T3V0bGluZSh0aGlja25lc3MgLyAyKVxuICAgIH0pO1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy5zZXREaW1zKHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aCwgdGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQpO1xuICB9XG4gICNjbGVhbkRyYXdMYXllcigpIHtcbiAgICBpZiAodGhpcy4jaWQgPT09IG51bGwgfHwgIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGFyZW50LmRyYXdMYXllci5yZW1vdmUodGhpcy4jaWQpO1xuICAgIHRoaXMuI2lkID0gbnVsbDtcbiAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIucmVtb3ZlKHRoaXMuI291dGxpbmVJZCk7XG4gICAgdGhpcy4jb3V0bGluZUlkID0gbnVsbDtcbiAgfVxuICAjYWRkVG9EcmF3TGF5ZXIocGFyZW50ID0gdGhpcy5wYXJlbnQpIHtcbiAgICBpZiAodGhpcy4jaWQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgKHtcbiAgICAgIGlkOiB0aGlzLiNpZCxcbiAgICAgIGNsaXBQYXRoSWQ6IHRoaXMuI2NsaXBQYXRoSWRcbiAgICB9ID0gcGFyZW50LmRyYXdMYXllci5kcmF3KHtcbiAgICAgIGJib3g6IHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzLmJveCxcbiAgICAgIHJvb3Q6IHtcbiAgICAgICAgdmlld0JveDogXCIwIDAgMSAxXCIsXG4gICAgICAgIGZpbGw6IHRoaXMuY29sb3IsXG4gICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IHRoaXMuI29wYWNpdHlcbiAgICAgIH0sXG4gICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgaGlnaGxpZ2h0OiB0cnVlLFxuICAgICAgICBmcmVlOiB0aGlzLiNpc0ZyZWVIaWdobGlnaHRcbiAgICAgIH0sXG4gICAgICBwYXRoOiB7XG4gICAgICAgIGQ6IHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzLnRvU1ZHUGF0aCgpXG4gICAgICB9XG4gICAgfSwgZmFsc2UsIHRydWUpKTtcbiAgICB0aGlzLiNvdXRsaW5lSWQgPSBwYXJlbnQuZHJhd0xheWVyLmRyYXdPdXRsaW5lKHtcbiAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICBoaWdobGlnaHRPdXRsaW5lOiB0cnVlLFxuICAgICAgICBmcmVlOiB0aGlzLiNpc0ZyZWVIaWdobGlnaHRcbiAgICAgIH0sXG4gICAgICBiYm94OiB0aGlzLiNmb2N1c091dGxpbmVzLmJveCxcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy4jZm9jdXNPdXRsaW5lcy50b1NWR1BhdGgoKVxuICAgICAgfVxuICAgIH0sIHRoaXMuI2lzRnJlZUhpZ2hsaWdodCk7XG4gICAgaWYgKHRoaXMuI2hpZ2hsaWdodERpdikge1xuICAgICAgdGhpcy4jaGlnaGxpZ2h0RGl2LnN0eWxlLmNsaXBQYXRoID0gdGhpcy4jY2xpcFBhdGhJZDtcbiAgICB9XG4gIH1cbiAgc3RhdGljICNyb3RhdGVCYm94KFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSwgYW5nbGUpIHtcbiAgICBzd2l0Y2ggKGFuZ2xlKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gWzEgLSB5IC0gaGVpZ2h0LCB4LCBoZWlnaHQsIHdpZHRoXTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gWzEgLSB4IC0gd2lkdGgsIDEgLSB5IC0gaGVpZ2h0LCB3aWR0aCwgaGVpZ2h0XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3ksIDEgLSB4IC0gd2lkdGgsIGhlaWdodCwgd2lkdGhdO1xuICAgIH1cbiAgICByZXR1cm4gW3gsIHksIHdpZHRoLCBoZWlnaHRdO1xuICB9XG4gIHJvdGF0ZShhbmdsZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRyYXdMYXllclxuICAgIH0gPSB0aGlzLnBhcmVudDtcbiAgICBsZXQgYm94O1xuICAgIGlmICh0aGlzLiNpc0ZyZWVIaWdobGlnaHQpIHtcbiAgICAgIGFuZ2xlID0gKGFuZ2xlIC0gdGhpcy5yb3RhdGlvbiArIDM2MCkgJSAzNjA7XG4gICAgICBib3ggPSBIaWdobGlnaHRFZGl0b3IuI3JvdGF0ZUJib3godGhpcy4jaGlnaGxpZ2h0T3V0bGluZXMuYm94LCBhbmdsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJveCA9IEhpZ2hsaWdodEVkaXRvci4jcm90YXRlQmJveChbdGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XSwgYW5nbGUpO1xuICAgIH1cbiAgICBkcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLiNpZCwge1xuICAgICAgYmJveDogYm94LFxuICAgICAgcm9vdDoge1xuICAgICAgICBcImRhdGEtbWFpbi1yb3RhdGlvblwiOiBhbmdsZVxuICAgICAgfVxuICAgIH0pO1xuICAgIGRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuI291dGxpbmVJZCwge1xuICAgICAgYmJveDogSGlnaGxpZ2h0RWRpdG9yLiNyb3RhdGVCYm94KHRoaXMuI2ZvY3VzT3V0bGluZXMuYm94LCBhbmdsZSksXG4gICAgICByb290OiB7XG4gICAgICAgIFwiZGF0YS1tYWluLXJvdGF0aW9uXCI6IGFuZ2xlXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgcmV0dXJuIHRoaXMuZGl2O1xuICAgIH1cbiAgICBjb25zdCBkaXYgPSBzdXBlci5yZW5kZXIoKTtcbiAgICBpZiAodGhpcy4jdGV4dCkge1xuICAgICAgZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdGhpcy4jdGV4dCk7XG4gICAgICBkaXYuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcIm1hcmtcIik7XG4gICAgfVxuICAgIGlmICh0aGlzLiNpc0ZyZWVIaWdobGlnaHQpIHtcbiAgICAgIGRpdi5jbGFzc0xpc3QuYWRkKFwiZnJlZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4ja2V5ZG93bi5iaW5kKHRoaXMpLCB7XG4gICAgICAgIHNpZ25hbDogdGhpcy5fdWlNYW5hZ2VyLl9zaWduYWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBoaWdobGlnaHREaXYgPSB0aGlzLiNoaWdobGlnaHREaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdi5hcHBlbmQoaGlnaGxpZ2h0RGl2KTtcbiAgICBoaWdobGlnaHREaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgIGhpZ2hsaWdodERpdi5jbGFzc05hbWUgPSBcImludGVybmFsXCI7XG4gICAgaGlnaGxpZ2h0RGl2LnN0eWxlLmNsaXBQYXRoID0gdGhpcy4jY2xpcFBhdGhJZDtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy5zZXREaW1zKHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aCwgdGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQpO1xuICAgIGJpbmRFdmVudHModGhpcywgdGhpcy4jaGlnaGxpZ2h0RGl2LCBbXCJwb2ludGVyb3ZlclwiLCBcInBvaW50ZXJsZWF2ZVwiXSk7XG4gICAgdGhpcy5lbmFibGVFZGl0aW5nKCk7XG4gICAgcmV0dXJuIGRpdjtcbiAgfVxuICBwb2ludGVyb3ZlcigpIHtcbiAgICBpZiAoIXRoaXMuaXNTZWxlY3RlZCkge1xuICAgICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuI291dGxpbmVJZCwge1xuICAgICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgICBob3ZlcmVkOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBwb2ludGVybGVhdmUoKSB7XG4gICAgaWYgKCF0aGlzLmlzU2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLiNvdXRsaW5lSWQsIHtcbiAgICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgICAgaG92ZXJlZDogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gICNrZXlkb3duKGV2ZW50KSB7XG4gICAgSGlnaGxpZ2h0RWRpdG9yLl9rZXlib2FyZE1hbmFnZXIuZXhlYyh0aGlzLCBldmVudCk7XG4gIH1cbiAgX21vdmVDYXJldChkaXJlY3Rpb24pIHtcbiAgICB0aGlzLnBhcmVudC51bnNlbGVjdCh0aGlzKTtcbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgY2FzZSAyOlxuICAgICAgICB0aGlzLiNzZXRDYXJldCh0cnVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHRoaXMuI3NldENhcmV0KGZhbHNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gICNzZXRDYXJldChzdGFydCkge1xuICAgIGlmICghdGhpcy4jYW5jaG9yTm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICBzZWxlY3Rpb24uc2V0UG9zaXRpb24odGhpcy4jYW5jaG9yTm9kZSwgdGhpcy4jYW5jaG9yT2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZWN0aW9uLnNldFBvc2l0aW9uKHRoaXMuI2ZvY3VzTm9kZSwgdGhpcy4jZm9jdXNPZmZzZXQpO1xuICAgIH1cbiAgfVxuICBzZWxlY3QoKSB7XG4gICAgc3VwZXIuc2VsZWN0KCk7XG4gICAgaWYgKCF0aGlzLiNvdXRsaW5lSWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuI291dGxpbmVJZCwge1xuICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgIGhvdmVyZWQ6IGZhbHNlLFxuICAgICAgICBzZWxlY3RlZDogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHVuc2VsZWN0KCkge1xuICAgIHN1cGVyLnVuc2VsZWN0KCk7XG4gICAgaWYgKCF0aGlzLiNvdXRsaW5lSWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuI291dGxpbmVJZCwge1xuICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgIHNlbGVjdGVkOiBmYWxzZVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghdGhpcy4jaXNGcmVlSGlnaGxpZ2h0KSB7XG4gICAgICB0aGlzLiNzZXRDYXJldChmYWxzZSk7XG4gICAgfVxuICB9XG4gIGdldCBfbXVzdEZpeFBvc2l0aW9uKCkge1xuICAgIHJldHVybiAhdGhpcy4jaXNGcmVlSGlnaGxpZ2h0O1xuICB9XG4gIHNob3codmlzaWJsZSA9IHRoaXMuX2lzVmlzaWJsZSkge1xuICAgIHN1cGVyLnNob3codmlzaWJsZSk7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLiNpZCwge1xuICAgICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgICBoaWRkZW46ICF2aXNpYmxlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5wYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jb3V0bGluZUlkLCB7XG4gICAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICAgIGhpZGRlbjogIXZpc2libGVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gICNnZXRSb3RhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4jaXNGcmVlSGlnaGxpZ2h0ID8gdGhpcy5yb3RhdGlvbiA6IDA7XG4gIH1cbiAgI3NlcmlhbGl6ZUJveGVzKCkge1xuICAgIGlmICh0aGlzLiNpc0ZyZWVIaWdobGlnaHQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgY29uc3QgW3BhZ2VYLCBwYWdlWV0gPSB0aGlzLnBhZ2VUcmFuc2xhdGlvbjtcbiAgICBjb25zdCBib3hlcyA9IHRoaXMuI2JveGVzO1xuICAgIGNvbnN0IHF1YWRQb2ludHMgPSBuZXcgRmxvYXQzMkFycmF5KGJveGVzLmxlbmd0aCAqIDgpO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9IG9mIGJveGVzKSB7XG4gICAgICBjb25zdCBzeCA9IHggKiBwYWdlV2lkdGggKyBwYWdlWDtcbiAgICAgIGNvbnN0IHN5ID0gKDEgLSB5KSAqIHBhZ2VIZWlnaHQgKyBwYWdlWTtcbiAgICAgIHF1YWRQb2ludHNbaV0gPSBxdWFkUG9pbnRzW2kgKyA0XSA9IHN4O1xuICAgICAgcXVhZFBvaW50c1tpICsgMV0gPSBxdWFkUG9pbnRzW2kgKyAzXSA9IHN5O1xuICAgICAgcXVhZFBvaW50c1tpICsgMl0gPSBxdWFkUG9pbnRzW2kgKyA2XSA9IHN4ICsgd2lkdGggKiBwYWdlV2lkdGg7XG4gICAgICBxdWFkUG9pbnRzW2kgKyA1XSA9IHF1YWRQb2ludHNbaSArIDddID0gc3kgLSBoZWlnaHQgKiBwYWdlSGVpZ2h0O1xuICAgICAgaSArPSA4O1xuICAgIH1cbiAgICByZXR1cm4gcXVhZFBvaW50cztcbiAgfVxuICAjc2VyaWFsaXplT3V0bGluZXMocmVjdCkge1xuICAgIHJldHVybiB0aGlzLiNoaWdobGlnaHRPdXRsaW5lcy5zZXJpYWxpemUocmVjdCwgdGhpcy4jZ2V0Um90YXRpb24oKSk7XG4gIH1cbiAgc3RhdGljIHN0YXJ0SGlnaGxpZ2h0aW5nKHBhcmVudCwgaXNMVFIsIHtcbiAgICB0YXJnZXQ6IHRleHRMYXllcixcbiAgICB4LFxuICAgIHlcbiAgfSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHg6IGxheWVyWCxcbiAgICAgIHk6IGxheWVyWSxcbiAgICAgIHdpZHRoOiBwYXJlbnRXaWR0aCxcbiAgICAgIGhlaWdodDogcGFyZW50SGVpZ2h0XG4gICAgfSA9IHRleHRMYXllci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSBwYXJlbnQuY29tYmluZWRTaWduYWwoYWMpO1xuICAgIGNvbnN0IHBvaW50ZXJVcENhbGxiYWNrID0gZSA9PiB7XG4gICAgICBhYy5hYm9ydCgpO1xuICAgICAgdGhpcy4jZW5kSGlnaGxpZ2h0KHBhcmVudCwgZSk7XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgcG9pbnRlclVwQ2FsbGJhY2ssIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHBvaW50ZXJVcENhbGxiYWNrLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHN0b3BFdmVudCwge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0ZXh0TGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIHRoaXMuI2hpZ2hsaWdodE1vdmUuYmluZCh0aGlzLCBwYXJlbnQpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLl9mcmVlSGlnaGxpZ2h0ID0gbmV3IEZyZWVIaWdobGlnaHRPdXRsaW5lcih7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0sIFtsYXllclgsIGxheWVyWSwgcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0sIHBhcmVudC5zY2FsZSwgdGhpcy5fZGVmYXVsdFRoaWNrbmVzcyAvIDIsIGlzTFRSLCAwLjAwMSk7XG4gICAgKHtcbiAgICAgIGlkOiB0aGlzLl9mcmVlSGlnaGxpZ2h0SWQsXG4gICAgICBjbGlwUGF0aElkOiB0aGlzLl9mcmVlSGlnaGxpZ2h0Q2xpcElkXG4gICAgfSA9IHBhcmVudC5kcmF3TGF5ZXIuZHJhdyh7XG4gICAgICBiYm94OiBbMCwgMCwgMSwgMV0sXG4gICAgICByb290OiB7XG4gICAgICAgIHZpZXdCb3g6IFwiMCAwIDEgMVwiLFxuICAgICAgICBmaWxsOiB0aGlzLl9kZWZhdWx0Q29sb3IsXG4gICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IHRoaXMuX2RlZmF1bHRPcGFjaXR5XG4gICAgICB9LFxuICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgIGhpZ2hsaWdodDogdHJ1ZSxcbiAgICAgICAgZnJlZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy5fZnJlZUhpZ2hsaWdodC50b1NWR1BhdGgoKVxuICAgICAgfVxuICAgIH0sIHRydWUsIHRydWUpKTtcbiAgfVxuICBzdGF0aWMgI2hpZ2hsaWdodE1vdmUocGFyZW50LCBldmVudCkge1xuICAgIGlmICh0aGlzLl9mcmVlSGlnaGxpZ2h0LmFkZChldmVudCkpIHtcbiAgICAgIHBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9mcmVlSGlnaGxpZ2h0SWQsIHtcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIGQ6IHRoaXMuX2ZyZWVIaWdobGlnaHQudG9TVkdQYXRoKClcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyAjZW5kSGlnaGxpZ2h0KHBhcmVudCwgZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX2ZyZWVIaWdobGlnaHQuaXNFbXB0eSgpKSB7XG4gICAgICBwYXJlbnQuY3JlYXRlQW5kQWRkTmV3RWRpdG9yKGV2ZW50LCBmYWxzZSwge1xuICAgICAgICBoaWdobGlnaHRJZDogdGhpcy5fZnJlZUhpZ2hsaWdodElkLFxuICAgICAgICBoaWdobGlnaHRPdXRsaW5lczogdGhpcy5fZnJlZUhpZ2hsaWdodC5nZXRPdXRsaW5lcygpLFxuICAgICAgICBjbGlwUGF0aElkOiB0aGlzLl9mcmVlSGlnaGxpZ2h0Q2xpcElkLFxuICAgICAgICBtZXRob2RPZkNyZWF0aW9uOiBcIm1haW5fdG9vbGJhclwiXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50LmRyYXdMYXllci5yZW1vdmUodGhpcy5fZnJlZUhpZ2hsaWdodElkKTtcbiAgICB9XG4gICAgdGhpcy5fZnJlZUhpZ2hsaWdodElkID0gLTE7XG4gICAgdGhpcy5fZnJlZUhpZ2hsaWdodCA9IG51bGw7XG4gICAgdGhpcy5fZnJlZUhpZ2hsaWdodENsaXBJZCA9IFwiXCI7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKSB7XG4gICAgbGV0IGluaXRpYWxEYXRhID0gbnVsbDtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEhpZ2hsaWdodEFubm90YXRpb25FbGVtZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBxdWFkUG9pbnRzLFxuICAgICAgICAgIHJlY3QsXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgY29sb3IsXG4gICAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgICBwb3B1cFJlZlxuICAgICAgICB9LFxuICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICBwYWdlOiB7XG4gICAgICAgICAgICBwYWdlTnVtYmVyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9ID0gZGF0YTtcbiAgICAgIGluaXRpYWxEYXRhID0gZGF0YSA9IHtcbiAgICAgICAgYW5ub3RhdGlvblR5cGU6IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCxcbiAgICAgICAgY29sb3I6IEFycmF5LmZyb20oY29sb3IpLFxuICAgICAgICBvcGFjaXR5LFxuICAgICAgICBxdWFkUG9pbnRzLFxuICAgICAgICBib3hlczogbnVsbCxcbiAgICAgICAgcGFnZUluZGV4OiBwYWdlTnVtYmVyIC0gMSxcbiAgICAgICAgcmVjdDogcmVjdC5zbGljZSgwKSxcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIGlkLFxuICAgICAgICBkZWxldGVkOiBmYWxzZSxcbiAgICAgICAgcG9wdXBSZWZcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgSW5rQW5ub3RhdGlvbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGlua0xpc3RzLFxuICAgICAgICAgIHJlY3QsXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgY29sb3IsXG4gICAgICAgICAgYm9yZGVyU3R5bGU6IHtcbiAgICAgICAgICAgIHJhd1dpZHRoOiB0aGlja25lc3NcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBvcHVwUmVmXG4gICAgICAgIH0sXG4gICAgICAgIHBhcmVudDoge1xuICAgICAgICAgIHBhZ2U6IHtcbiAgICAgICAgICAgIHBhZ2VOdW1iZXJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gPSBkYXRhO1xuICAgICAgaW5pdGlhbERhdGEgPSBkYXRhID0ge1xuICAgICAgICBhbm5vdGF0aW9uVHlwZTogQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hULFxuICAgICAgICBjb2xvcjogQXJyYXkuZnJvbShjb2xvciksXG4gICAgICAgIHRoaWNrbmVzcyxcbiAgICAgICAgaW5rTGlzdHMsXG4gICAgICAgIGJveGVzOiBudWxsLFxuICAgICAgICBwYWdlSW5kZXg6IHBhZ2VOdW1iZXIgLSAxLFxuICAgICAgICByZWN0OiByZWN0LnNsaWNlKDApLFxuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgaWQsXG4gICAgICAgIGRlbGV0ZWQ6IGZhbHNlLFxuICAgICAgICBwb3B1cFJlZlxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY29sb3IsXG4gICAgICBxdWFkUG9pbnRzLFxuICAgICAgaW5rTGlzdHMsXG4gICAgICBvcGFjaXR5XG4gICAgfSA9IGRhdGE7XG4gICAgY29uc3QgZWRpdG9yID0gYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpO1xuICAgIGVkaXRvci5jb2xvciA9IFV0aWwubWFrZUhleENvbG9yKC4uLmNvbG9yKTtcbiAgICBlZGl0b3IuI29wYWNpdHkgPSBvcGFjaXR5IHx8IDE7XG4gICAgaWYgKGlua0xpc3RzKSB7XG4gICAgICBlZGl0b3IuI3RoaWNrbmVzcyA9IGRhdGEudGhpY2tuZXNzO1xuICAgIH1cbiAgICBlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCA9IGRhdGEuaWQgfHwgbnVsbDtcbiAgICBlZGl0b3IuX2luaXRpYWxEYXRhID0gaW5pdGlhbERhdGE7XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSBlZGl0b3IucGFnZURpbWVuc2lvbnM7XG4gICAgY29uc3QgW3BhZ2VYLCBwYWdlWV0gPSBlZGl0b3IucGFnZVRyYW5zbGF0aW9uO1xuICAgIGlmIChxdWFkUG9pbnRzKSB7XG4gICAgICBjb25zdCBib3hlcyA9IGVkaXRvci4jYm94ZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVhZFBvaW50cy5sZW5ndGg7IGkgKz0gOCkge1xuICAgICAgICBib3hlcy5wdXNoKHtcbiAgICAgICAgICB4OiAocXVhZFBvaW50c1tpXSAtIHBhZ2VYKSAvIHBhZ2VXaWR0aCxcbiAgICAgICAgICB5OiAxIC0gKHF1YWRQb2ludHNbaSArIDFdIC0gcGFnZVkpIC8gcGFnZUhlaWdodCxcbiAgICAgICAgICB3aWR0aDogKHF1YWRQb2ludHNbaSArIDJdIC0gcXVhZFBvaW50c1tpXSkgLyBwYWdlV2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiAocXVhZFBvaW50c1tpICsgMV0gLSBxdWFkUG9pbnRzW2kgKyA1XSkgLyBwYWdlSGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWRpdG9yLiNjcmVhdGVPdXRsaW5lcygpO1xuICAgICAgZWRpdG9yLiNhZGRUb0RyYXdMYXllcigpO1xuICAgICAgZWRpdG9yLnJvdGF0ZShlZGl0b3Iucm90YXRpb24pO1xuICAgIH0gZWxzZSBpZiAoaW5rTGlzdHMpIHtcbiAgICAgIGVkaXRvci4jaXNGcmVlSGlnaGxpZ2h0ID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHBvaW50cyA9IGlua0xpc3RzWzBdO1xuICAgICAgY29uc3QgcG9pbnQgPSB7XG4gICAgICAgIHg6IHBvaW50c1swXSAtIHBhZ2VYLFxuICAgICAgICB5OiBwYWdlSGVpZ2h0IC0gKHBvaW50c1sxXSAtIHBhZ2VZKVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG91dGxpbmVyID0gbmV3IEZyZWVIaWdobGlnaHRPdXRsaW5lcihwb2ludCwgWzAsIDAsIHBhZ2VXaWR0aCwgcGFnZUhlaWdodF0sIDEsIGVkaXRvci4jdGhpY2tuZXNzIC8gMiwgdHJ1ZSwgMC4wMDEpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgcG9pbnQueCA9IHBvaW50c1tpXSAtIHBhZ2VYO1xuICAgICAgICBwb2ludC55ID0gcGFnZUhlaWdodCAtIChwb2ludHNbaSArIDFdIC0gcGFnZVkpO1xuICAgICAgICBvdXRsaW5lci5hZGQocG9pbnQpO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBpZCxcbiAgICAgICAgY2xpcFBhdGhJZFxuICAgICAgfSA9IHBhcmVudC5kcmF3TGF5ZXIuZHJhdyh7XG4gICAgICAgIGJib3g6IFswLCAwLCAxLCAxXSxcbiAgICAgICAgcm9vdDoge1xuICAgICAgICAgIHZpZXdCb3g6IFwiMCAwIDEgMVwiLFxuICAgICAgICAgIGZpbGw6IGVkaXRvci5jb2xvcixcbiAgICAgICAgICBcImZpbGwtb3BhY2l0eVwiOiBlZGl0b3IuX2RlZmF1bHRPcGFjaXR5XG4gICAgICAgIH0sXG4gICAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICAgIGhpZ2hsaWdodDogdHJ1ZSxcbiAgICAgICAgICBmcmVlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHBhdGg6IHtcbiAgICAgICAgICBkOiBvdXRsaW5lci50b1NWR1BhdGgoKVxuICAgICAgICB9XG4gICAgICB9LCB0cnVlLCB0cnVlKTtcbiAgICAgIGVkaXRvci4jY3JlYXRlRnJlZU91dGxpbmVzKHtcbiAgICAgICAgaGlnaGxpZ2h0T3V0bGluZXM6IG91dGxpbmVyLmdldE91dGxpbmVzKCksXG4gICAgICAgIGhpZ2hsaWdodElkOiBpZCxcbiAgICAgICAgY2xpcFBhdGhJZFxuICAgICAgfSk7XG4gICAgICBlZGl0b3IuI2FkZFRvRHJhd0xheWVyKCk7XG4gICAgfVxuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgc2VyaWFsaXplKGlzRm9yQ29weWluZyA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpIHx8IGlzRm9yQ29weWluZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZURlbGV0ZWQoKTtcbiAgICB9XG4gICAgY29uc3QgcmVjdCA9IHRoaXMuZ2V0UmVjdCgwLCAwKTtcbiAgICBjb25zdCBjb2xvciA9IEFubm90YXRpb25FZGl0b3IuX2NvbG9yTWFuYWdlci5jb252ZXJ0KHRoaXMuY29sb3IpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7XG4gICAgICBhbm5vdGF0aW9uVHlwZTogQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hULFxuICAgICAgY29sb3IsXG4gICAgICBvcGFjaXR5OiB0aGlzLiNvcGFjaXR5LFxuICAgICAgdGhpY2tuZXNzOiB0aGlzLiN0aGlja25lc3MsXG4gICAgICBxdWFkUG9pbnRzOiB0aGlzLiNzZXJpYWxpemVCb3hlcygpLFxuICAgICAgb3V0bGluZXM6IHRoaXMuI3NlcmlhbGl6ZU91dGxpbmVzKHJlY3QpLFxuICAgICAgcGFnZUluZGV4OiB0aGlzLnBhZ2VJbmRleCxcbiAgICAgIHJlY3QsXG4gICAgICByb3RhdGlvbjogdGhpcy4jZ2V0Um90YXRpb24oKSxcbiAgICAgIHN0cnVjdFRyZWVQYXJlbnRJZDogdGhpcy5fc3RydWN0VHJlZVBhcmVudElkXG4gICAgfTtcbiAgICBpZiAodGhpcy5hbm5vdGF0aW9uRWxlbWVudElkICYmICF0aGlzLiNoYXNFbGVtZW50Q2hhbmdlZChzZXJpYWxpemVkKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHNlcmlhbGl6ZWQuaWQgPSB0aGlzLmFubm90YXRpb25FbGVtZW50SWQ7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gIH1cbiAgI2hhc0VsZW1lbnRDaGFuZ2VkKHNlcmlhbGl6ZWQpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb2xvclxuICAgIH0gPSB0aGlzLl9pbml0aWFsRGF0YTtcbiAgICByZXR1cm4gc2VyaWFsaXplZC5jb2xvci5zb21lKChjLCBpKSA9PiBjICE9PSBjb2xvcltpXSk7XG4gIH1cbiAgcmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIGFubm90YXRpb24udXBkYXRlRWRpdGVkKHtcbiAgICAgIHJlY3Q6IHRoaXMuZ2V0UmVjdCgwLCAwKVxuICAgIH0pO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHN0YXRpYyBjYW5DcmVhdGVOZXdFbXB0eUVkaXRvcigpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2RyYXcuanNcblxuXG5cbmNsYXNzIERyYXdpbmdPcHRpb25zIHtcbiAgI3N2Z1Byb3BlcnRpZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB1cGRhdGVQcm9wZXJ0eShuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXNbbmFtZV0gPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZVNWR1Byb3BlcnR5KG5hbWUsIHZhbHVlKTtcbiAgfVxuICB1cGRhdGVQcm9wZXJ0aWVzKHByb3BlcnRpZXMpIHtcbiAgICBpZiAoIXByb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHByb3BlcnRpZXMpKSB7XG4gICAgICB0aGlzLnVwZGF0ZVByb3BlcnR5KG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlU1ZHUHJvcGVydHkobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLiNzdmdQcm9wZXJ0aWVzW25hbWVdID0gdmFsdWU7XG4gIH1cbiAgdG9TVkdQcm9wZXJ0aWVzKCkge1xuICAgIGNvbnN0IHJvb3QgPSB0aGlzLiNzdmdQcm9wZXJ0aWVzO1xuICAgIHRoaXMuI3N2Z1Byb3BlcnRpZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHJldHVybiB7XG4gICAgICByb290XG4gICAgfTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLiNzdmdQcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICB1cGRhdGVBbGwob3B0aW9ucyA9IHRoaXMpIHtcbiAgICB0aGlzLnVwZGF0ZVByb3BlcnRpZXMob3B0aW9ucyk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgdW5yZWFjaGFibGUoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbn1cbmNsYXNzIERyYXdpbmdFZGl0b3IgZXh0ZW5kcyBBbm5vdGF0aW9uRWRpdG9yIHtcbiAgI2RyYXdPdXRsaW5lcyA9IG51bGw7XG4gICNtdXN0QmVDb21taXR0ZWQ7XG4gIF9kcmF3SWQgPSBudWxsO1xuICBzdGF0aWMgX2N1cnJlbnREcmF3SWQgPSAtMTtcbiAgc3RhdGljIF9jdXJyZW50RHJhdyA9IG51bGw7XG4gIHN0YXRpYyBfY3VycmVudERyYXdpbmdPcHRpb25zID0gbnVsbDtcbiAgc3RhdGljIF9jdXJyZW50UGFyZW50ID0gbnVsbDtcbiAgc3RhdGljIF9JTk5FUl9NQVJHSU4gPSAzO1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICBzdXBlcihwYXJhbXMpO1xuICAgIHRoaXMuI211c3RCZUNvbW1pdHRlZCA9IHBhcmFtcy5tdXN0QmVDb21taXR0ZWQgfHwgZmFsc2U7XG4gICAgaWYgKHBhcmFtcy5kcmF3T3V0bGluZXMpIHtcbiAgICAgIHRoaXMuI2NyZWF0ZURyYXdPdXRsaW5lcyhwYXJhbXMpO1xuICAgICAgdGhpcy4jYWRkVG9EcmF3TGF5ZXIoKTtcbiAgICB9XG4gIH1cbiAgI2NyZWF0ZURyYXdPdXRsaW5lcyh7XG4gICAgZHJhd091dGxpbmVzLFxuICAgIGRyYXdJZCxcbiAgICBkcmF3aW5nT3B0aW9uc1xuICB9KSB7XG4gICAgdGhpcy4jZHJhd091dGxpbmVzID0gZHJhd091dGxpbmVzO1xuICAgIHRoaXMuX2RyYXdpbmdPcHRpb25zIHx8PSBkcmF3aW5nT3B0aW9ucztcbiAgICBpZiAoZHJhd0lkID49IDApIHtcbiAgICAgIHRoaXMuX2RyYXdJZCA9IGRyYXdJZDtcbiAgICAgIHRoaXMucGFyZW50LmRyYXdMYXllci5maW5hbGl6ZURyYXcoZHJhd0lkLCBkcmF3T3V0bGluZXMuZGVmYXVsdFByb3BlcnRpZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kcmF3SWQgPSB0aGlzLiNjcmVhdGVEcmF3aW5nKGRyYXdPdXRsaW5lcywgdGhpcy5wYXJlbnQpO1xuICAgIH1cbiAgICB0aGlzLiN1cGRhdGVCYm94KGRyYXdPdXRsaW5lcy5ib3gpO1xuICB9XG4gICNjcmVhdGVEcmF3aW5nKGRyYXdPdXRsaW5lcywgcGFyZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaWRcbiAgICB9ID0gcGFyZW50LmRyYXdMYXllci5kcmF3KERyYXdpbmdFZGl0b3IuX21lcmdlU1ZHUHJvcGVydGllcyh0aGlzLl9kcmF3aW5nT3B0aW9ucy50b1NWR1Byb3BlcnRpZXMoKSwgZHJhd091dGxpbmVzLmRlZmF1bHRTVkdQcm9wZXJ0aWVzKSwgZmFsc2UsIGZhbHNlKTtcbiAgICByZXR1cm4gaWQ7XG4gIH1cbiAgc3RhdGljIF9tZXJnZVNWR1Byb3BlcnRpZXMocDEsIHAyKSB7XG4gICAgY29uc3QgcDFLZXlzID0gbmV3IFNldChPYmplY3Qua2V5cyhwMSkpO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHAyKSkge1xuICAgICAgaWYgKHAxS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHAxW2tleV0sIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHAxW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHAxO1xuICB9XG4gIHN0YXRpYyBnZXREZWZhdWx0RHJhd2luZ09wdGlvbnMoX29wdGlvbnMpIHtcbiAgICB1bnJlYWNoYWJsZShcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGVzTWFwKCkge1xuICAgIHVucmVhY2hhYmxlKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHN0YXRpYyBnZXQgaXNEcmF3ZXIoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc3RhdGljIGdldCBzdXBwb3J0TXVsdGlwbGVEcmF3aW5ncygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhdGljIHVwZGF0ZURlZmF1bHRQYXJhbXModHlwZSwgdmFsdWUpIHtcbiAgICBjb25zdCBwcm9wZXJ0eU5hbWUgPSB0aGlzLnR5cGVzTWFwLmdldCh0eXBlKTtcbiAgICBpZiAocHJvcGVydHlOYW1lKSB7XG4gICAgICB0aGlzLl9kZWZhdWx0RHJhd2luZ09wdGlvbnMudXBkYXRlUHJvcGVydHkocHJvcGVydHlOYW1lLCB2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9jdXJyZW50UGFyZW50KSB7XG4gICAgICB0aGlzLl9jdXJyZW50RHJhdy51cGRhdGVQcm9wZXJ0eShwcm9wZXJ0eU5hbWUsIHZhbHVlKTtcbiAgICAgIHRoaXMuX2N1cnJlbnRQYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fY3VycmVudERyYXdJZCwgdGhpcy5fZGVmYXVsdERyYXdpbmdPcHRpb25zLnRvU1ZHUHJvcGVydGllcygpKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlUGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgY29uc3QgcHJvcGVydHlOYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci50eXBlc01hcC5nZXQodHlwZSk7XG4gICAgaWYgKHByb3BlcnR5TmFtZSkge1xuICAgICAgdGhpcy5fdXBkYXRlUHJvcGVydHkodHlwZSwgcHJvcGVydHlOYW1lLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXQgZGVmYXVsdFByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gW107XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9ucztcbiAgICBmb3IgKGNvbnN0IFt0eXBlLCBuYW1lXSBvZiB0aGlzLnR5cGVzTWFwKSB7XG4gICAgICBwcm9wZXJ0aWVzLnB1c2goW3R5cGUsIG9wdGlvbnNbbmFtZV1dKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gIH1cbiAgZ2V0IHByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gW107XG4gICAgY29uc3Qge1xuICAgICAgX2RyYXdpbmdPcHRpb25zXG4gICAgfSA9IHRoaXM7XG4gICAgZm9yIChjb25zdCBbdHlwZSwgbmFtZV0gb2YgdGhpcy5jb25zdHJ1Y3Rvci50eXBlc01hcCkge1xuICAgICAgcHJvcGVydGllcy5wdXNoKFt0eXBlLCBfZHJhd2luZ09wdGlvbnNbbmFtZV1dKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gIH1cbiAgX3VwZGF0ZVByb3BlcnR5KHR5cGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX2RyYXdpbmdPcHRpb25zO1xuICAgIGNvbnN0IHNhdmVkVmFsdWUgPSBvcHRpb25zW25hbWVdO1xuICAgIGNvbnN0IHNldHRlciA9IHZhbCA9PiB7XG4gICAgICBvcHRpb25zLnVwZGF0ZVByb3BlcnR5KG5hbWUsIHZhbCk7XG4gICAgICBjb25zdCBiYm94ID0gdGhpcy4jZHJhd091dGxpbmVzLnVwZGF0ZVByb3BlcnR5KG5hbWUsIHZhbCk7XG4gICAgICBpZiAoYmJveCkge1xuICAgICAgICB0aGlzLiN1cGRhdGVCYm94KGJib3gpO1xuICAgICAgfVxuICAgICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2RyYXdJZCwgb3B0aW9ucy50b1NWR1Byb3BlcnRpZXMoKSk7XG4gICAgfTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogc2V0dGVyLmJpbmQodGhpcywgdmFsdWUpLFxuICAgICAgdW5kbzogc2V0dGVyLmJpbmQodGhpcywgc2F2ZWRWYWx1ZSksXG4gICAgICBwb3N0OiB0aGlzLl91aU1hbmFnZXIudXBkYXRlVUkuYmluZCh0aGlzLl91aU1hbmFnZXIsIHRoaXMpLFxuICAgICAgbXVzdEV4ZWM6IHRydWUsXG4gICAgICB0eXBlLFxuICAgICAgb3ZlcndyaXRlSWZTYW1lVHlwZTogdHJ1ZSxcbiAgICAgIGtlZXBVbmRvOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgX29uUmVzaXppbmcoKSB7XG4gICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2RyYXdJZCwgRHJhd2luZ0VkaXRvci5fbWVyZ2VTVkdQcm9wZXJ0aWVzKHRoaXMuI2RyYXdPdXRsaW5lcy5nZXRQYXRoUmVzaXppbmdTVkdQcm9wZXJ0aWVzKHRoaXMuI2NvbnZlcnRUb0RyYXdTcGFjZSgpKSwge1xuICAgICAgYmJveDogdGhpcy4jcm90YXRlQm94KClcbiAgICB9KSk7XG4gIH1cbiAgX29uUmVzaXplZCgpIHtcbiAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fZHJhd0lkLCBEcmF3aW5nRWRpdG9yLl9tZXJnZVNWR1Byb3BlcnRpZXModGhpcy4jZHJhd091dGxpbmVzLmdldFBhdGhSZXNpemVkU1ZHUHJvcGVydGllcyh0aGlzLiNjb252ZXJ0VG9EcmF3U3BhY2UoKSksIHtcbiAgICAgIGJib3g6IHRoaXMuI3JvdGF0ZUJveCgpXG4gICAgfSkpO1xuICB9XG4gIF9vblRyYW5zbGF0aW5nKHgsIHkpIHtcbiAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fZHJhd0lkLCB7XG4gICAgICBiYm94OiB0aGlzLiNyb3RhdGVCb3goeCwgeSlcbiAgICB9KTtcbiAgfVxuICBfb25UcmFuc2xhdGVkKCkge1xuICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9kcmF3SWQsIERyYXdpbmdFZGl0b3IuX21lcmdlU1ZHUHJvcGVydGllcyh0aGlzLiNkcmF3T3V0bGluZXMuZ2V0UGF0aFRyYW5zbGF0ZWRTVkdQcm9wZXJ0aWVzKHRoaXMuI2NvbnZlcnRUb0RyYXdTcGFjZSgpLCB0aGlzLnBhcmVudERpbWVuc2lvbnMpLCB7XG4gICAgICBiYm94OiB0aGlzLiNyb3RhdGVCb3goKVxuICAgIH0pKTtcbiAgfVxuICBfb25TdGFydERyYWdnaW5nKCkge1xuICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9kcmF3SWQsIHtcbiAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICBtb3Zpbmc6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfb25TdG9wRHJhZ2dpbmcoKSB7XG4gICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2RyYXdJZCwge1xuICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgIG1vdmluZzogZmFsc2VcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjb21taXQoKSB7XG4gICAgc3VwZXIuY29tbWl0KCk7XG4gICAgdGhpcy5kaXNhYmxlRWRpdE1vZGUoKTtcbiAgICB0aGlzLmRpc2FibGVFZGl0aW5nKCk7XG4gIH1cbiAgZGlzYWJsZUVkaXRpbmcoKSB7XG4gICAgc3VwZXIuZGlzYWJsZUVkaXRpbmcoKTtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZGlzYWJsZWRcIiwgdHJ1ZSk7XG4gIH1cbiAgZW5hYmxlRWRpdGluZygpIHtcbiAgICBzdXBlci5lbmFibGVFZGl0aW5nKCk7XG4gICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImRpc2FibGVkXCIsIGZhbHNlKTtcbiAgfVxuICBnZXRCYXNlVHJhbnNsYXRpb24oKSB7XG4gICAgcmV0dXJuIFswLCAwXTtcbiAgfVxuICBnZXQgaXNSZXNpemFibGUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgb25jZUFkZGVkKCkge1xuICAgIGlmICghdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICB0aGlzLnBhcmVudC5hZGRVbmRvYWJsZUVkaXRvcih0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSB0cnVlO1xuICAgIGlmICh0aGlzLiNtdXN0QmVDb21taXR0ZWQpIHtcbiAgICAgIHRoaXMuI211c3RCZUNvbW1pdHRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5jb21taXQoKTtcbiAgICAgIHRoaXMucGFyZW50LnNldFNlbGVjdGVkKHRoaXMpO1xuICAgICAgaWYgKHRoaXMuaXNPblNjcmVlbikge1xuICAgICAgICB0aGlzLmRpdi5mb2N1cygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZW1vdmUoKSB7XG4gICAgdGhpcy4jY2xlYW5EcmF3TGF5ZXIoKTtcbiAgICBzdXBlci5yZW1vdmUoKTtcbiAgfVxuICByZWJ1aWxkKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIucmVidWlsZCgpO1xuICAgIGlmICh0aGlzLmRpdiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhZGRUb0RyYXdMYXllcigpO1xuICAgIHRoaXMuI3VwZGF0ZUJib3godGhpcy4jZHJhd091dGxpbmVzLmJveCk7XG4gICAgaWYgKCF0aGlzLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgdGhpcy5wYXJlbnQuYWRkKHRoaXMpO1xuICAgIH1cbiAgfVxuICBzZXRQYXJlbnQocGFyZW50KSB7XG4gICAgbGV0IG11c3RCZVNlbGVjdGVkID0gZmFsc2U7XG4gICAgaWYgKHRoaXMucGFyZW50ICYmICFwYXJlbnQpIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5yZW1vdmVTaG91bGRSZXNjYWxlKHRoaXMpO1xuICAgICAgdGhpcy4jY2xlYW5EcmF3TGF5ZXIoKTtcbiAgICB9IGVsc2UgaWYgKHBhcmVudCkge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmFkZFNob3VsZFJlc2NhbGUodGhpcyk7XG4gICAgICB0aGlzLiNhZGRUb0RyYXdMYXllcihwYXJlbnQpO1xuICAgICAgbXVzdEJlU2VsZWN0ZWQgPSAhdGhpcy5wYXJlbnQgJiYgdGhpcy5kaXY/LmNsYXNzTGlzdC5jb250YWlucyhcInNlbGVjdGVkRWRpdG9yXCIpO1xuICAgIH1cbiAgICBzdXBlci5zZXRQYXJlbnQocGFyZW50KTtcbiAgICBpZiAobXVzdEJlU2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuc2VsZWN0KCk7XG4gICAgfVxuICB9XG4gICNjbGVhbkRyYXdMYXllcigpIHtcbiAgICBpZiAodGhpcy5fZHJhd0lkID09PSBudWxsIHx8ICF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIucmVtb3ZlKHRoaXMuX2RyYXdJZCk7XG4gICAgdGhpcy5fZHJhd0lkID0gbnVsbDtcbiAgICB0aGlzLl9kcmF3aW5nT3B0aW9ucy5yZXNldCgpO1xuICB9XG4gICNhZGRUb0RyYXdMYXllcihwYXJlbnQgPSB0aGlzLnBhcmVudCkge1xuICAgIGlmICh0aGlzLl9kcmF3SWQgIT09IG51bGwgJiYgdGhpcy5wYXJlbnQgPT09IHBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZHJhd0lkICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUGFyZW50KHRoaXMuX2RyYXdJZCwgcGFyZW50LmRyYXdMYXllcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2RyYXdpbmdPcHRpb25zLnVwZGF0ZUFsbCgpO1xuICAgIHRoaXMuX2RyYXdJZCA9IHRoaXMuI2NyZWF0ZURyYXdpbmcodGhpcy4jZHJhd091dGxpbmVzLCBwYXJlbnQpO1xuICB9XG4gICNjb252ZXJ0VG9QYXJlbnRTcGFjZShbeCwgeSwgd2lkdGgsIGhlaWdodF0pIHtcbiAgICBjb25zdCB7XG4gICAgICBwYXJlbnREaW1lbnNpb25zOiBbcFcsIHBIXSxcbiAgICAgIHJvdGF0aW9uXG4gICAgfSA9IHRoaXM7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFt5LCAxIC0geCwgd2lkdGggKiAocEggLyBwVyksIGhlaWdodCAqIChwVyAvIHBIKV07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFsxIC0geCwgMSAtIHksIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbMSAtIHksIHgsIHdpZHRoICogKHBIIC8gcFcpLCBoZWlnaHQgKiAocFcgLyBwSCldO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFt4LCB5LCB3aWR0aCwgaGVpZ2h0XTtcbiAgICB9XG4gIH1cbiAgI2NvbnZlcnRUb0RyYXdTcGFjZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgcGFyZW50RGltZW5zaW9uczogW3BXLCBwSF0sXG4gICAgICByb3RhdGlvblxuICAgIH0gPSB0aGlzO1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbMSAtIHksIHgsIHdpZHRoICogKHBXIC8gcEgpLCBoZWlnaHQgKiAocEggLyBwVyldO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbMSAtIHgsIDEgLSB5LCB3aWR0aCwgaGVpZ2h0XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3ksIDEgLSB4LCB3aWR0aCAqIChwVyAvIHBIKSwgaGVpZ2h0ICogKHBIIC8gcFcpXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbeCwgeSwgd2lkdGgsIGhlaWdodF07XG4gICAgfVxuICB9XG4gICN1cGRhdGVCYm94KGJib3gpIHtcbiAgICBbdGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XSA9IHRoaXMuI2NvbnZlcnRUb1BhcmVudFNwYWNlKGJib3gpO1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICAgICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgICAgdGhpcy5zZXREaW1zKHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aCwgdGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQpO1xuICAgIH1cbiAgICB0aGlzLl9vblJlc2l6ZWQoKTtcbiAgfVxuICAjcm90YXRlQm94KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICByb3RhdGlvbixcbiAgICAgIHBhcmVudFJvdGF0aW9uLFxuICAgICAgcGFyZW50RGltZW5zaW9uczogW3BXLCBwSF1cbiAgICB9ID0gdGhpcztcbiAgICBzd2l0Y2ggKChyb3RhdGlvbiAqIDQgKyBwYXJlbnRSb3RhdGlvbikgLyA5MCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gWzEgLSB5IC0gaGVpZ2h0LCB4LCBoZWlnaHQsIHdpZHRoXTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIFsxIC0geCAtIHdpZHRoLCAxIC0geSAtIGhlaWdodCwgd2lkdGgsIGhlaWdodF07XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiBbeSwgMSAtIHggLSB3aWR0aCwgaGVpZ2h0LCB3aWR0aF07XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHJldHVybiBbeCwgeSAtIHdpZHRoICogKHBXIC8gcEgpLCBoZWlnaHQgKiAocEggLyBwVyksIHdpZHRoICogKHBXIC8gcEgpXTtcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgcmV0dXJuIFsxIC0geSwgeCwgd2lkdGggKiAocFcgLyBwSCksIGhlaWdodCAqIChwSCAvIHBXKV07XG4gICAgICBjYXNlIDY6XG4gICAgICAgIHJldHVybiBbMSAtIHggLSBoZWlnaHQgKiAocEggLyBwVyksIDEgLSB5LCBoZWlnaHQgKiAocEggLyBwVyksIHdpZHRoICogKHBXIC8gcEgpXTtcbiAgICAgIGNhc2UgNzpcbiAgICAgICAgcmV0dXJuIFt5IC0gd2lkdGggKiAocFcgLyBwSCksIDEgLSB4IC0gaGVpZ2h0ICogKHBIIC8gcFcpLCB3aWR0aCAqIChwVyAvIHBIKSwgaGVpZ2h0ICogKHBIIC8gcFcpXTtcbiAgICAgIGNhc2UgODpcbiAgICAgICAgcmV0dXJuIFt4IC0gd2lkdGgsIHkgLSBoZWlnaHQsIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSA5OlxuICAgICAgICByZXR1cm4gWzEgLSB5LCB4IC0gd2lkdGgsIGhlaWdodCwgd2lkdGhdO1xuICAgICAgY2FzZSAxMDpcbiAgICAgICAgcmV0dXJuIFsxIC0geCwgMSAtIHksIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSAxMTpcbiAgICAgICAgcmV0dXJuIFt5IC0gaGVpZ2h0LCAxIC0geCwgaGVpZ2h0LCB3aWR0aF07XG4gICAgICBjYXNlIDEyOlxuICAgICAgICByZXR1cm4gW3ggLSBoZWlnaHQgKiAocEggLyBwVyksIHksIGhlaWdodCAqIChwSCAvIHBXKSwgd2lkdGggKiAocFcgLyBwSCldO1xuICAgICAgY2FzZSAxMzpcbiAgICAgICAgcmV0dXJuIFsxIC0geSAtIHdpZHRoICogKHBXIC8gcEgpLCB4IC0gaGVpZ2h0ICogKHBIIC8gcFcpLCB3aWR0aCAqIChwVyAvIHBIKSwgaGVpZ2h0ICogKHBIIC8gcFcpXTtcbiAgICAgIGNhc2UgMTQ6XG4gICAgICAgIHJldHVybiBbMSAtIHgsIDEgLSB5IC0gd2lkdGggKiAocFcgLyBwSCksIGhlaWdodCAqIChwSCAvIHBXKSwgd2lkdGggKiAocFcgLyBwSCldO1xuICAgICAgY2FzZSAxNTpcbiAgICAgICAgcmV0dXJuIFt5LCAxIC0geCwgd2lkdGggKiAocFcgLyBwSCksIGhlaWdodCAqIChwSCAvIHBXKV07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gW3gsIHksIHdpZHRoLCBoZWlnaHRdO1xuICAgIH1cbiAgfVxuICByb3RhdGUoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9kcmF3SWQsIERyYXdpbmdFZGl0b3IuX21lcmdlU1ZHUHJvcGVydGllcyh7XG4gICAgICBiYm94OiB0aGlzLiNyb3RhdGVCb3goKVxuICAgIH0sIHRoaXMuI2RyYXdPdXRsaW5lcy51cGRhdGVSb3RhdGlvbigodGhpcy5wYXJlbnRSb3RhdGlvbiAtIHRoaXMucm90YXRpb24gKyAzNjApICUgMzYwKSkpO1xuICB9XG4gIG9uU2NhbGVDaGFuZ2luZygpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3VwZGF0ZUJib3godGhpcy4jZHJhd091dGxpbmVzLnVwZGF0ZVBhcmVudERpbWVuc2lvbnModGhpcy5wYXJlbnREaW1lbnNpb25zLCB0aGlzLnBhcmVudC5zY2FsZSkpO1xuICB9XG4gIHN0YXRpYyBvblNjYWxlQ2hhbmdpbmdXaGVuRHJhd2luZygpIHt9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpdjtcbiAgICB9XG4gICAgY29uc3QgZGl2ID0gc3VwZXIucmVuZGVyKCk7XG4gICAgZGl2LmNsYXNzTGlzdC5hZGQoXCJkcmF3XCIpO1xuICAgIGNvbnN0IGRyYXdEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdi5hcHBlbmQoZHJhd0Rpdik7XG4gICAgZHJhd0Rpdi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgZHJhd0Rpdi5jbGFzc05hbWUgPSBcImludGVybmFsXCI7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMuc2V0RGltcyh0aGlzLndpZHRoICogcGFyZW50V2lkdGgsIHRoaXMuaGVpZ2h0ICogcGFyZW50SGVpZ2h0KTtcbiAgICB0aGlzLl91aU1hbmFnZXIuYWRkU2hvdWxkUmVzY2FsZSh0aGlzKTtcbiAgICB0aGlzLmRpc2FibGVFZGl0aW5nKCk7XG4gICAgcmV0dXJuIGRpdjtcbiAgfVxuICBzdGF0aWMgY3JlYXRlRHJhd2VySW5zdGFuY2UoX3gsIF95LCBfcGFyZW50V2lkdGgsIF9wYXJlbnRIZWlnaHQsIF9yb3RhdGlvbikge1xuICAgIHVucmVhY2hhYmxlKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHN0YXRpYyBzdGFydERyYXdpbmcocGFyZW50LCB1aU1hbmFnZXIsIF9pc0xUUiwge1xuICAgIHRhcmdldCxcbiAgICBvZmZzZXRYOiB4LFxuICAgIG9mZnNldFk6IHlcbiAgfSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIHJvdGF0aW9uXG4gICAgICB9XG4gICAgfSA9IHBhcmVudDtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aDogcGFyZW50V2lkdGgsXG4gICAgICBoZWlnaHQ6IHBhcmVudEhlaWdodFxuICAgIH0gPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gcGFyZW50LmNvbWJpbmVkU2lnbmFsKGFjKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBlID0+IHtcbiAgICAgIGFjLmFib3J0KCk7XG4gICAgICBwYXJlbnQudG9nZ2xlRHJhd2luZyh0cnVlKTtcbiAgICAgIHRoaXMuX2VuZERyYXcoZSk7XG4gICAgfSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBzdG9wRXZlbnQsIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCB0aGlzLl9kcmF3TW92ZS5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBwYXJlbnQudG9nZ2xlRHJhd2luZygpO1xuICAgIHVpTWFuYWdlci5fZWRpdG9yVW5kb0Jhcj8uaGlkZSgpO1xuICAgIGlmICh0aGlzLl9jdXJyZW50RHJhdykge1xuICAgICAgcGFyZW50LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2N1cnJlbnREcmF3SWQsIHRoaXMuX2N1cnJlbnREcmF3LnN0YXJ0TmV3KHgsIHksIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHJvdGF0aW9uKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHVpTWFuYWdlci51cGRhdGVVSUZvckRlZmF1bHRQcm9wZXJ0aWVzKHRoaXMpO1xuICAgIHRoaXMuX2N1cnJlbnREcmF3ID0gdGhpcy5jcmVhdGVEcmF3ZXJJbnN0YW5jZSh4LCB5LCBwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0LCByb3RhdGlvbik7XG4gICAgdGhpcy5fY3VycmVudERyYXdpbmdPcHRpb25zID0gdGhpcy5nZXREZWZhdWx0RHJhd2luZ09wdGlvbnMoKTtcbiAgICB0aGlzLl9jdXJyZW50UGFyZW50ID0gcGFyZW50O1xuICAgICh7XG4gICAgICBpZDogdGhpcy5fY3VycmVudERyYXdJZFxuICAgIH0gPSBwYXJlbnQuZHJhd0xheWVyLmRyYXcodGhpcy5fbWVyZ2VTVkdQcm9wZXJ0aWVzKHRoaXMuX2N1cnJlbnREcmF3aW5nT3B0aW9ucy50b1NWR1Byb3BlcnRpZXMoKSwgdGhpcy5fY3VycmVudERyYXcuZGVmYXVsdFNWR1Byb3BlcnRpZXMpLCB0cnVlLCBmYWxzZSkpO1xuICB9XG4gIHN0YXRpYyBfZHJhd01vdmUoe1xuICAgIG9mZnNldFgsXG4gICAgb2Zmc2V0WVxuICB9KSB7XG4gICAgdGhpcy5fY3VycmVudFBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9jdXJyZW50RHJhd0lkLCB0aGlzLl9jdXJyZW50RHJhdy5hZGQob2Zmc2V0WCwgb2Zmc2V0WSkpO1xuICB9XG4gIHN0YXRpYyBfZW5kRHJhdyh7XG4gICAgb2Zmc2V0WCxcbiAgICBvZmZzZXRZXG4gIH0pIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl9jdXJyZW50UGFyZW50O1xuICAgIHBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9jdXJyZW50RHJhd0lkLCB0aGlzLl9jdXJyZW50RHJhdy5lbmQob2Zmc2V0WCwgb2Zmc2V0WSkpO1xuICAgIGlmICh0aGlzLnN1cHBvcnRNdWx0aXBsZURyYXdpbmdzKSB7XG4gICAgICBjb25zdCBkcmF3ID0gdGhpcy5fY3VycmVudERyYXc7XG4gICAgICBjb25zdCBkcmF3SWQgPSB0aGlzLl9jdXJyZW50RHJhd0lkO1xuICAgICAgY29uc3QgbGFzdEVsZW1lbnQgPSBkcmF3LmdldExhc3RFbGVtZW50KCk7XG4gICAgICBwYXJlbnQuYWRkQ29tbWFuZHMoe1xuICAgICAgICBjbWQ6ICgpID0+IHtcbiAgICAgICAgICBwYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXMoZHJhd0lkLCBkcmF3LnNldExhc3RFbGVtZW50KGxhc3RFbGVtZW50KSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgICBwYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXMoZHJhd0lkLCBkcmF3LnJlbW92ZUxhc3RFbGVtZW50KCkpO1xuICAgICAgICB9LFxuICAgICAgICBtdXN0RXhlYzogZmFsc2UsXG4gICAgICAgIHR5cGU6IEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkRSQVdfU1RFUFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZW5kRHJhd2luZyhmYWxzZSk7XG4gIH1cbiAgc3RhdGljIGVuZERyYXdpbmcoaXNBYm9ydGVkKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5fY3VycmVudFBhcmVudDtcbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHBhcmVudC50b2dnbGVEcmF3aW5nKHRydWUpO1xuICAgIHBhcmVudC5jbGVhblVuZG9TdGFjayhBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5EUkFXX1NURVApO1xuICAgIGlmICghdGhpcy5fY3VycmVudERyYXcuaXNFbXB0eSgpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhZ2VEaW1lbnNpb25zOiBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSxcbiAgICAgICAgc2NhbGVcbiAgICAgIH0gPSBwYXJlbnQ7XG4gICAgICBjb25zdCBlZGl0b3IgPSBwYXJlbnQuY3JlYXRlQW5kQWRkTmV3RWRpdG9yKHtcbiAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgb2Zmc2V0WTogMFxuICAgICAgfSwgZmFsc2UsIHtcbiAgICAgICAgZHJhd0lkOiB0aGlzLl9jdXJyZW50RHJhd0lkLFxuICAgICAgICBkcmF3T3V0bGluZXM6IHRoaXMuX2N1cnJlbnREcmF3LmdldE91dGxpbmVzKHBhZ2VXaWR0aCAqIHNjYWxlLCBwYWdlSGVpZ2h0ICogc2NhbGUsIHNjYWxlLCB0aGlzLl9JTk5FUl9NQVJHSU4pLFxuICAgICAgICBkcmF3aW5nT3B0aW9uczogdGhpcy5fY3VycmVudERyYXdpbmdPcHRpb25zLFxuICAgICAgICBtdXN0QmVDb21taXR0ZWQ6ICFpc0Fib3J0ZWRcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fY2xlYW51cCgpO1xuICAgICAgcmV0dXJuIGVkaXRvcjtcbiAgICB9XG4gICAgcGFyZW50LmRyYXdMYXllci5yZW1vdmUodGhpcy5fY3VycmVudERyYXdJZCk7XG4gICAgdGhpcy5fY2xlYW51cCgpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHN0YXRpYyBfY2xlYW51cCgpIHtcbiAgICB0aGlzLl9jdXJyZW50RHJhd0lkID0gLTE7XG4gICAgdGhpcy5fY3VycmVudERyYXcgPSBudWxsO1xuICAgIHRoaXMuX2N1cnJlbnREcmF3aW5nT3B0aW9ucyA9IG51bGw7XG4gICAgdGhpcy5fY3VycmVudFBhcmVudCA9IG51bGw7XG4gIH1cbiAgY3JlYXRlRHJhd2luZ09wdGlvbnMoX2RhdGEpIHt9XG4gIHN0YXRpYyBkZXNlcmlhbGl6ZURyYXcoX3BhZ2VYLCBfcGFnZVksIF9wYWdlV2lkdGgsIF9wYWdlSGVpZ2h0LCBfaW5uZXJXaWR0aCwgX2RhdGEpIHtcbiAgICB1bnJlYWNoYWJsZShcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpIHtcbiAgICBjb25zdCB7XG4gICAgICByYXdEaW1zOiB7XG4gICAgICAgIHBhZ2VXaWR0aCxcbiAgICAgICAgcGFnZUhlaWdodCxcbiAgICAgICAgcGFnZVgsXG4gICAgICAgIHBhZ2VZXG4gICAgICB9XG4gICAgfSA9IHBhcmVudC52aWV3cG9ydDtcbiAgICBjb25zdCBkcmF3T3V0bGluZXMgPSB0aGlzLmRlc2VyaWFsaXplRHJhdyhwYWdlWCwgcGFnZVksIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgdGhpcy5fSU5ORVJfTUFSR0lOLCBkYXRhKTtcbiAgICBjb25zdCBlZGl0b3IgPSBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcik7XG4gICAgZWRpdG9yLmNyZWF0ZURyYXdpbmdPcHRpb25zKGRhdGEpO1xuICAgIGVkaXRvci4jY3JlYXRlRHJhd091dGxpbmVzKHtcbiAgICAgIGRyYXdPdXRsaW5lc1xuICAgIH0pO1xuICAgIGVkaXRvci4jYWRkVG9EcmF3TGF5ZXIoKTtcbiAgICBlZGl0b3Iub25TY2FsZUNoYW5naW5nKCk7XG4gICAgZWRpdG9yLnJvdGF0ZSgpO1xuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgc2VyaWFsaXplRHJhdyhpc0ZvckNvcHlpbmcpIHtcbiAgICBjb25zdCBbcGFnZVgsIHBhZ2VZXSA9IHRoaXMucGFnZVRyYW5zbGF0aW9uO1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICByZXR1cm4gdGhpcy4jZHJhd091dGxpbmVzLnNlcmlhbGl6ZShbcGFnZVgsIHBhZ2VZLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdLCBpc0ZvckNvcHlpbmcpO1xuICB9XG4gIHJlbmRlckFubm90YXRpb25FbGVtZW50KGFubm90YXRpb24pIHtcbiAgICBhbm5vdGF0aW9uLnVwZGF0ZUVkaXRlZCh7XG4gICAgICByZWN0OiB0aGlzLmdldFJlY3QoMCwgMClcbiAgICB9KTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBzdGF0aWMgY2FuQ3JlYXRlTmV3RW1wdHlFZGl0b3IoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9kcmF3ZXJzL2lua2RyYXcuanNcblxuXG5jbGFzcyBJbmtEcmF3T3V0bGluZXIge1xuICAjbGFzdCA9IG5ldyBGbG9hdDY0QXJyYXkoNik7XG4gICNsaW5lO1xuICAjbGluZXM7XG4gICNyb3RhdGlvbjtcbiAgI3RoaWNrbmVzcztcbiAgI3BvaW50cztcbiAgI2xhc3RTVkdQYXRoID0gXCJcIjtcbiAgI2xhc3RJbmRleCA9IDA7XG4gICNvdXRsaW5lcyA9IG5ldyBJbmtEcmF3T3V0bGluZSgpO1xuICAjcGFyZW50V2lkdGg7XG4gICNwYXJlbnRIZWlnaHQ7XG4gIGNvbnN0cnVjdG9yKHgsIHksIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHJvdGF0aW9uLCB0aGlja25lc3MpIHtcbiAgICB0aGlzLiNwYXJlbnRXaWR0aCA9IHBhcmVudFdpZHRoO1xuICAgIHRoaXMuI3BhcmVudEhlaWdodCA9IHBhcmVudEhlaWdodDtcbiAgICB0aGlzLiNyb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHRoaXMuI3RoaWNrbmVzcyA9IHRoaWNrbmVzcztcbiAgICBbeCwgeV0gPSB0aGlzLiNub3JtYWxpemVQb2ludCh4LCB5KTtcbiAgICBjb25zdCBsaW5lID0gdGhpcy4jbGluZSA9IFtOYU4sIE5hTiwgTmFOLCBOYU4sIHgsIHldO1xuICAgIHRoaXMuI3BvaW50cyA9IFt4LCB5XTtcbiAgICB0aGlzLiNsaW5lcyA9IFt7XG4gICAgICBsaW5lLFxuICAgICAgcG9pbnRzOiB0aGlzLiNwb2ludHNcbiAgICB9XTtcbiAgICB0aGlzLiNsYXN0LnNldChsaW5lLCAwKTtcbiAgfVxuICB1cGRhdGVQcm9wZXJ0eShuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChuYW1lID09PSBcInN0cm9rZS13aWR0aFwiKSB7XG4gICAgICB0aGlzLiN0aGlja25lc3MgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgI25vcm1hbGl6ZVBvaW50KHgsIHkpIHtcbiAgICByZXR1cm4gT3V0bGluZS5fbm9ybWFsaXplUG9pbnQoeCwgeSwgdGhpcy4jcGFyZW50V2lkdGgsIHRoaXMuI3BhcmVudEhlaWdodCwgdGhpcy4jcm90YXRpb24pO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuICF0aGlzLiNsaW5lcyB8fCB0aGlzLiNsaW5lcy5sZW5ndGggPT09IDA7XG4gIH1cbiAgYWRkKHgsIHkpIHtcbiAgICBbeCwgeV0gPSB0aGlzLiNub3JtYWxpemVQb2ludCh4LCB5KTtcbiAgICBjb25zdCBbeDEsIHkxLCB4MiwgeTJdID0gdGhpcy4jbGFzdC5zdWJhcnJheSgyLCA2KTtcbiAgICBjb25zdCBkaWZmWCA9IHggLSB4MjtcbiAgICBjb25zdCBkaWZmWSA9IHkgLSB5MjtcbiAgICBjb25zdCBkID0gTWF0aC5oeXBvdCh0aGlzLiNwYXJlbnRXaWR0aCAqIGRpZmZYLCB0aGlzLiNwYXJlbnRIZWlnaHQgKiBkaWZmWSk7XG4gICAgaWYgKGQgPD0gMikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRoaXMuI3BvaW50cy5wdXNoKHgsIHkpO1xuICAgIGlmIChpc05hTih4MSkpIHtcbiAgICAgIHRoaXMuI2xhc3Quc2V0KFt4MiwgeTIsIHgsIHldLCAyKTtcbiAgICAgIHRoaXMuI2xpbmUucHVzaChOYU4sIE5hTiwgTmFOLCBOYU4sIHgsIHkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIGQ6IHRoaXMudG9TVkdQYXRoKClcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGlzTmFOKHRoaXMuI2xhc3RbMF0pKSB7XG4gICAgICB0aGlzLiNsaW5lLnNwbGljZSg2LCA2KTtcbiAgICB9XG4gICAgdGhpcy4jbGFzdC5zZXQoW3gxLCB5MSwgeDIsIHkyLCB4LCB5XSwgMCk7XG4gICAgdGhpcy4jbGluZS5wdXNoKC4uLk91dGxpbmUuY3JlYXRlQmV6aWVyUG9pbnRzKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy50b1NWR1BhdGgoKVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZW5kKHgsIHkpIHtcbiAgICBjb25zdCBjaGFuZ2UgPSB0aGlzLmFkZCh4LCB5KTtcbiAgICBpZiAoY2hhbmdlKSB7XG4gICAgICByZXR1cm4gY2hhbmdlO1xuICAgIH1cbiAgICBpZiAodGhpcy4jcG9pbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIGQ6IHRoaXMudG9TVkdQYXRoKClcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgc3RhcnROZXcoeCwgeSwgcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodCwgcm90YXRpb24pIHtcbiAgICB0aGlzLiNwYXJlbnRXaWR0aCA9IHBhcmVudFdpZHRoO1xuICAgIHRoaXMuI3BhcmVudEhlaWdodCA9IHBhcmVudEhlaWdodDtcbiAgICB0aGlzLiNyb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIFt4LCB5XSA9IHRoaXMuI25vcm1hbGl6ZVBvaW50KHgsIHkpO1xuICAgIGNvbnN0IGxpbmUgPSB0aGlzLiNsaW5lID0gW05hTiwgTmFOLCBOYU4sIE5hTiwgeCwgeV07XG4gICAgdGhpcy4jcG9pbnRzID0gW3gsIHldO1xuICAgIGNvbnN0IGxhc3QgPSB0aGlzLiNsaW5lcy5hdCgtMSk7XG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubGluZSA9IG5ldyBGbG9hdDMyQXJyYXkobGFzdC5saW5lKTtcbiAgICAgIGxhc3QucG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheShsYXN0LnBvaW50cyk7XG4gICAgfVxuICAgIHRoaXMuI2xpbmVzLnB1c2goe1xuICAgICAgbGluZSxcbiAgICAgIHBvaW50czogdGhpcy4jcG9pbnRzXG4gICAgfSk7XG4gICAgdGhpcy4jbGFzdC5zZXQobGluZSwgMCk7XG4gICAgdGhpcy4jbGFzdEluZGV4ID0gMDtcbiAgICB0aGlzLnRvU1ZHUGF0aCgpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldExhc3RFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLiNsaW5lcy5hdCgtMSk7XG4gIH1cbiAgc2V0TGFzdEVsZW1lbnQoZWxlbWVudCkge1xuICAgIGlmICghdGhpcy4jbGluZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLiNvdXRsaW5lcy5zZXRMYXN0RWxlbWVudChlbGVtZW50KTtcbiAgICB9XG4gICAgdGhpcy4jbGluZXMucHVzaChlbGVtZW50KTtcbiAgICB0aGlzLiNsaW5lID0gZWxlbWVudC5saW5lO1xuICAgIHRoaXMuI3BvaW50cyA9IGVsZW1lbnQucG9pbnRzO1xuICAgIHRoaXMuI2xhc3RJbmRleCA9IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy50b1NWR1BhdGgoKVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmVtb3ZlTGFzdEVsZW1lbnQoKSB7XG4gICAgaWYgKCF0aGlzLiNsaW5lcykge1xuICAgICAgcmV0dXJuIHRoaXMuI291dGxpbmVzLnJlbW92ZUxhc3RFbGVtZW50KCk7XG4gICAgfVxuICAgIHRoaXMuI2xpbmVzLnBvcCgpO1xuICAgIHRoaXMuI2xhc3RTVkdQYXRoID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSB0aGlzLiNsaW5lcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxpbmUsXG4gICAgICAgIHBvaW50c1xuICAgICAgfSA9IHRoaXMuI2xpbmVzW2ldO1xuICAgICAgdGhpcy4jbGluZSA9IGxpbmU7XG4gICAgICB0aGlzLiNwb2ludHMgPSBwb2ludHM7XG4gICAgICB0aGlzLiNsYXN0SW5kZXggPSAwO1xuICAgICAgdGhpcy50b1NWR1BhdGgoKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy4jbGFzdFNWR1BhdGhcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRvU1ZHUGF0aCgpIHtcbiAgICBjb25zdCBmaXJzdFggPSBPdXRsaW5lLnN2Z1JvdW5kKHRoaXMuI2xpbmVbNF0pO1xuICAgIGNvbnN0IGZpcnN0WSA9IE91dGxpbmUuc3ZnUm91bmQodGhpcy4jbGluZVs1XSk7XG4gICAgaWYgKHRoaXMuI3BvaW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHRoaXMuI2xhc3RTVkdQYXRoID0gYCR7dGhpcy4jbGFzdFNWR1BhdGh9IE0gJHtmaXJzdFh9ICR7Zmlyc3RZfSBaYDtcbiAgICAgIHJldHVybiB0aGlzLiNsYXN0U1ZHUGF0aDtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3BvaW50cy5sZW5ndGggPD0gNikge1xuICAgICAgY29uc3QgaSA9IHRoaXMuI2xhc3RTVkdQYXRoLmxhc3RJbmRleE9mKFwiTVwiKTtcbiAgICAgIHRoaXMuI2xhc3RTVkdQYXRoID0gYCR7dGhpcy4jbGFzdFNWR1BhdGguc2xpY2UoMCwgaSl9IE0gJHtmaXJzdFh9ICR7Zmlyc3RZfWA7XG4gICAgICB0aGlzLiNsYXN0SW5kZXggPSA2O1xuICAgIH1cbiAgICBpZiAodGhpcy4jcG9pbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgY29uc3Qgc2Vjb25kWCA9IE91dGxpbmUuc3ZnUm91bmQodGhpcy4jbGluZVsxMF0pO1xuICAgICAgY29uc3Qgc2Vjb25kWSA9IE91dGxpbmUuc3ZnUm91bmQodGhpcy4jbGluZVsxMV0pO1xuICAgICAgdGhpcy4jbGFzdFNWR1BhdGggPSBgJHt0aGlzLiNsYXN0U1ZHUGF0aH0gTCAke3NlY29uZFh9ICR7c2Vjb25kWX1gO1xuICAgICAgdGhpcy4jbGFzdEluZGV4ID0gMTI7XG4gICAgICByZXR1cm4gdGhpcy4jbGFzdFNWR1BhdGg7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlciA9IFtdO1xuICAgIGlmICh0aGlzLiNsYXN0SW5kZXggPT09IDApIHtcbiAgICAgIGJ1ZmZlci5wdXNoKGBNICR7Zmlyc3RYfSAke2ZpcnN0WX1gKTtcbiAgICAgIHRoaXMuI2xhc3RJbmRleCA9IDY7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSB0aGlzLiNsYXN0SW5kZXgsIGlpID0gdGhpcy4jbGluZS5sZW5ndGg7IGkgPCBpaTsgaSArPSA2KSB7XG4gICAgICBjb25zdCBbYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5XSA9IHRoaXMuI2xpbmUuc2xpY2UoaSwgaSArIDYpLm1hcChPdXRsaW5lLnN2Z1JvdW5kKTtcbiAgICAgIGJ1ZmZlci5wdXNoKGBDJHtjMXh9ICR7YzF5fSAke2MyeH0gJHtjMnl9ICR7eH0gJHt5fWApO1xuICAgIH1cbiAgICB0aGlzLiNsYXN0U1ZHUGF0aCArPSBidWZmZXIuam9pbihcIiBcIik7XG4gICAgdGhpcy4jbGFzdEluZGV4ID0gdGhpcy4jbGluZS5sZW5ndGg7XG4gICAgcmV0dXJuIHRoaXMuI2xhc3RTVkdQYXRoO1xuICB9XG4gIGdldE91dGxpbmVzKHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHNjYWxlLCBpbm5lck1hcmdpbikge1xuICAgIGNvbnN0IGxhc3QgPSB0aGlzLiNsaW5lcy5hdCgtMSk7XG4gICAgbGFzdC5saW5lID0gbmV3IEZsb2F0MzJBcnJheShsYXN0LmxpbmUpO1xuICAgIGxhc3QucG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheShsYXN0LnBvaW50cyk7XG4gICAgdGhpcy4jb3V0bGluZXMuYnVpbGQodGhpcy4jbGluZXMsIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHNjYWxlLCB0aGlzLiNyb3RhdGlvbiwgdGhpcy4jdGhpY2tuZXNzLCBpbm5lck1hcmdpbik7XG4gICAgdGhpcy4jbGFzdCA9IG51bGw7XG4gICAgdGhpcy4jbGluZSA9IG51bGw7XG4gICAgdGhpcy4jbGluZXMgPSBudWxsO1xuICAgIHRoaXMuI2xhc3RTVkdQYXRoID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcy4jb3V0bGluZXM7XG4gIH1cbiAgZ2V0IGRlZmF1bHRTVkdQcm9wZXJ0aWVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICByb290OiB7XG4gICAgICAgIHZpZXdCb3g6IFwiMCAwIDEwMDAwIDEwMDAwXCJcbiAgICAgIH0sXG4gICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgZHJhdzogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGJib3g6IFswLCAwLCAxLCAxXVxuICAgIH07XG4gIH1cbn1cbmNsYXNzIElua0RyYXdPdXRsaW5lIGV4dGVuZHMgT3V0bGluZSB7XG4gICNiYm94O1xuICAjY3VycmVudFJvdGF0aW9uID0gMDtcbiAgI2lubmVyTWFyZ2luO1xuICAjbGluZXM7XG4gICNwYXJlbnRXaWR0aDtcbiAgI3BhcmVudEhlaWdodDtcbiAgI3BhcmVudFNjYWxlO1xuICAjcm90YXRpb247XG4gICN0aGlja25lc3M7XG4gIGJ1aWxkKGxpbmVzLCBwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0LCBwYXJlbnRTY2FsZSwgcm90YXRpb24sIHRoaWNrbmVzcywgaW5uZXJNYXJnaW4pIHtcbiAgICB0aGlzLiNwYXJlbnRXaWR0aCA9IHBhcmVudFdpZHRoO1xuICAgIHRoaXMuI3BhcmVudEhlaWdodCA9IHBhcmVudEhlaWdodDtcbiAgICB0aGlzLiNwYXJlbnRTY2FsZSA9IHBhcmVudFNjYWxlO1xuICAgIHRoaXMuI3JvdGF0aW9uID0gcm90YXRpb247XG4gICAgdGhpcy4jdGhpY2tuZXNzID0gdGhpY2tuZXNzO1xuICAgIHRoaXMuI2lubmVyTWFyZ2luID0gaW5uZXJNYXJnaW4gPz8gMDtcbiAgICB0aGlzLiNsaW5lcyA9IGxpbmVzO1xuICAgIHRoaXMuI2NvbXB1dGVCYm94KCk7XG4gIH1cbiAgc2V0TGFzdEVsZW1lbnQoZWxlbWVudCkge1xuICAgIHRoaXMuI2xpbmVzLnB1c2goZWxlbWVudCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy50b1NWR1BhdGgoKVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmVtb3ZlTGFzdEVsZW1lbnQoKSB7XG4gICAgdGhpcy4jbGluZXMucG9wKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy50b1NWR1BhdGgoKVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgdG9TVkdQYXRoKCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IFtdO1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgbGluZVxuICAgIH0gb2YgdGhpcy4jbGluZXMpIHtcbiAgICAgIGJ1ZmZlci5wdXNoKGBNJHtPdXRsaW5lLnN2Z1JvdW5kKGxpbmVbNF0pfSAke091dGxpbmUuc3ZnUm91bmQobGluZVs1XSl9YCk7XG4gICAgICBpZiAobGluZS5sZW5ndGggPT09IDYpIHtcbiAgICAgICAgYnVmZmVyLnB1c2goXCJaXCIpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lLmxlbmd0aCA9PT0gMTIpIHtcbiAgICAgICAgYnVmZmVyLnB1c2goYEwke091dGxpbmUuc3ZnUm91bmQobGluZVsxMF0pfSAke091dGxpbmUuc3ZnUm91bmQobGluZVsxMV0pfWApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSA2LCBpaSA9IGxpbmUubGVuZ3RoOyBpIDwgaWk7IGkgKz0gNikge1xuICAgICAgICBjb25zdCBbYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5XSA9IGxpbmUuc3ViYXJyYXkoaSwgaSArIDYpLm1hcChPdXRsaW5lLnN2Z1JvdW5kKTtcbiAgICAgICAgYnVmZmVyLnB1c2goYEMke2MxeH0gJHtjMXl9ICR7YzJ4fSAke2MyeX0gJHt4fSAke3l9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBidWZmZXIuam9pbihcIlwiKTtcbiAgfVxuICBzZXJpYWxpemUoW3BhZ2VYLCBwYWdlWSwgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSwgaXNGb3JDb3B5aW5nKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZExpbmVzID0gW107XG4gICAgY29uc3Qgc2VyaWFsaXplZFBvaW50cyA9IFtdO1xuICAgIGNvbnN0IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSA9IHRoaXMuI2dldEJCb3hXaXRoTm9NYXJnaW4oKTtcbiAgICBsZXQgdHgsIHR5LCBzeCwgc3ksIHgxLCB5MSwgeDIsIHkyLCByZXNjYWxlRm47XG4gICAgc3dpdGNoICh0aGlzLiNyb3RhdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXNjYWxlRm4gPSBPdXRsaW5lLl9yZXNjYWxlO1xuICAgICAgICB0eCA9IHBhZ2VYO1xuICAgICAgICB0eSA9IHBhZ2VZICsgcGFnZUhlaWdodDtcbiAgICAgICAgc3ggPSBwYWdlV2lkdGg7XG4gICAgICAgIHN5ID0gLXBhZ2VIZWlnaHQ7XG4gICAgICAgIHgxID0gcGFnZVggKyB4ICogcGFnZVdpZHRoO1xuICAgICAgICB5MSA9IHBhZ2VZICsgKDEgLSB5IC0gaGVpZ2h0KSAqIHBhZ2VIZWlnaHQ7XG4gICAgICAgIHgyID0gcGFnZVggKyAoeCArIHdpZHRoKSAqIHBhZ2VXaWR0aDtcbiAgICAgICAgeTIgPSBwYWdlWSArICgxIC0geSkgKiBwYWdlSGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJlc2NhbGVGbiA9IE91dGxpbmUuX3Jlc2NhbGVBbmRTd2FwO1xuICAgICAgICB0eCA9IHBhZ2VYO1xuICAgICAgICB0eSA9IHBhZ2VZO1xuICAgICAgICBzeCA9IHBhZ2VXaWR0aDtcbiAgICAgICAgc3kgPSBwYWdlSGVpZ2h0O1xuICAgICAgICB4MSA9IHBhZ2VYICsgeSAqIHBhZ2VXaWR0aDtcbiAgICAgICAgeTEgPSBwYWdlWSArIHggKiBwYWdlSGVpZ2h0O1xuICAgICAgICB4MiA9IHBhZ2VYICsgKHkgKyBoZWlnaHQpICogcGFnZVdpZHRoO1xuICAgICAgICB5MiA9IHBhZ2VZICsgKHggKyB3aWR0aCkgKiBwYWdlSGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXNjYWxlRm4gPSBPdXRsaW5lLl9yZXNjYWxlO1xuICAgICAgICB0eCA9IHBhZ2VYICsgcGFnZVdpZHRoO1xuICAgICAgICB0eSA9IHBhZ2VZO1xuICAgICAgICBzeCA9IC1wYWdlV2lkdGg7XG4gICAgICAgIHN5ID0gcGFnZUhlaWdodDtcbiAgICAgICAgeDEgPSBwYWdlWCArICgxIC0geCAtIHdpZHRoKSAqIHBhZ2VXaWR0aDtcbiAgICAgICAgeTEgPSBwYWdlWSArIHkgKiBwYWdlSGVpZ2h0O1xuICAgICAgICB4MiA9IHBhZ2VYICsgKDEgLSB4KSAqIHBhZ2VXaWR0aDtcbiAgICAgICAgeTIgPSBwYWdlWSArICh5ICsgaGVpZ2h0KSAqIHBhZ2VIZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJlc2NhbGVGbiA9IE91dGxpbmUuX3Jlc2NhbGVBbmRTd2FwO1xuICAgICAgICB0eCA9IHBhZ2VYICsgcGFnZVdpZHRoO1xuICAgICAgICB0eSA9IHBhZ2VZICsgcGFnZUhlaWdodDtcbiAgICAgICAgc3ggPSAtcGFnZVdpZHRoO1xuICAgICAgICBzeSA9IC1wYWdlSGVpZ2h0O1xuICAgICAgICB4MSA9IHBhZ2VYICsgKDEgLSB5IC0gaGVpZ2h0KSAqIHBhZ2VXaWR0aDtcbiAgICAgICAgeTEgPSBwYWdlWSArICgxIC0geCAtIHdpZHRoKSAqIHBhZ2VIZWlnaHQ7XG4gICAgICAgIHgyID0gcGFnZVggKyAoMSAtIHkpICogcGFnZVdpZHRoO1xuICAgICAgICB5MiA9IHBhZ2VZICsgKDEgLSB4KSAqIHBhZ2VIZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIGxpbmUsXG4gICAgICBwb2ludHNcbiAgICB9IG9mIHRoaXMuI2xpbmVzKSB7XG4gICAgICBzZXJpYWxpemVkTGluZXMucHVzaChyZXNjYWxlRm4obGluZSwgdHgsIHR5LCBzeCwgc3ksIGlzRm9yQ29weWluZyA/IG5ldyBBcnJheShsaW5lLmxlbmd0aCkgOiBudWxsKSk7XG4gICAgICBzZXJpYWxpemVkUG9pbnRzLnB1c2gocmVzY2FsZUZuKHBvaW50cywgdHgsIHR5LCBzeCwgc3ksIGlzRm9yQ29weWluZyA/IG5ldyBBcnJheShwb2ludHMubGVuZ3RoKSA6IG51bGwpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmVzOiBzZXJpYWxpemVkTGluZXMsXG4gICAgICBwb2ludHM6IHNlcmlhbGl6ZWRQb2ludHMsXG4gICAgICByZWN0OiBbeDEsIHkxLCB4MiwgeTJdXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZGVzZXJpYWxpemUocGFnZVgsIHBhZ2VZLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQsIGlubmVyTWFyZ2luLCB7XG4gICAgcGF0aHM6IHtcbiAgICAgIGxpbmVzLFxuICAgICAgcG9pbnRzXG4gICAgfSxcbiAgICByb3RhdGlvbixcbiAgICB0aGlja25lc3NcbiAgfSkge1xuICAgIGNvbnN0IG5ld0xpbmVzID0gW107XG4gICAgbGV0IHR4LCB0eSwgc3gsIHN5LCByZXNjYWxlRm47XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXNjYWxlRm4gPSBPdXRsaW5lLl9yZXNjYWxlO1xuICAgICAgICB0eCA9IC1wYWdlWCAvIHBhZ2VXaWR0aDtcbiAgICAgICAgdHkgPSBwYWdlWSAvIHBhZ2VIZWlnaHQgKyAxO1xuICAgICAgICBzeCA9IDEgLyBwYWdlV2lkdGg7XG4gICAgICAgIHN5ID0gLTEgLyBwYWdlSGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJlc2NhbGVGbiA9IE91dGxpbmUuX3Jlc2NhbGVBbmRTd2FwO1xuICAgICAgICB0eCA9IC1wYWdlWSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgIHR5ID0gLXBhZ2VYIC8gcGFnZVdpZHRoO1xuICAgICAgICBzeCA9IDEgLyBwYWdlSGVpZ2h0O1xuICAgICAgICBzeSA9IDEgLyBwYWdlV2lkdGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJlc2NhbGVGbiA9IE91dGxpbmUuX3Jlc2NhbGU7XG4gICAgICAgIHR4ID0gcGFnZVggLyBwYWdlV2lkdGggKyAxO1xuICAgICAgICB0eSA9IC1wYWdlWSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgIHN4ID0gLTEgLyBwYWdlV2lkdGg7XG4gICAgICAgIHN5ID0gMSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJlc2NhbGVGbiA9IE91dGxpbmUuX3Jlc2NhbGVBbmRTd2FwO1xuICAgICAgICB0eCA9IHBhZ2VZIC8gcGFnZUhlaWdodCArIDE7XG4gICAgICAgIHR5ID0gcGFnZVggLyBwYWdlV2lkdGggKyAxO1xuICAgICAgICBzeCA9IC0xIC8gcGFnZUhlaWdodDtcbiAgICAgICAgc3kgPSAtMSAvIHBhZ2VXaWR0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICghbGluZXMpIHtcbiAgICAgIGxpbmVzID0gW107XG4gICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIHBvaW50cykge1xuICAgICAgICBjb25zdCBsZW4gPSBwb2ludC5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPT09IDIpIHtcbiAgICAgICAgICBsaW5lcy5wdXNoKG5ldyBGbG9hdDMyQXJyYXkoW05hTiwgTmFOLCBOYU4sIE5hTiwgcG9pbnRbMF0sIHBvaW50WzFdXSkpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW4gPT09IDQpIHtcbiAgICAgICAgICBsaW5lcy5wdXNoKG5ldyBGbG9hdDMyQXJyYXkoW05hTiwgTmFOLCBOYU4sIE5hTiwgcG9pbnRbMF0sIHBvaW50WzFdLCBOYU4sIE5hTiwgTmFOLCBOYU4sIHBvaW50WzJdLCBwb2ludFszXV0pKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaW5lID0gbmV3IEZsb2F0MzJBcnJheSgzICogKGxlbiAtIDIpKTtcbiAgICAgICAgbGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgbGV0IFt4MSwgeTEsIHgyLCB5Ml0gPSBwb2ludC5zdWJhcnJheSgwLCA0KTtcbiAgICAgICAgbGluZS5zZXQoW05hTiwgTmFOLCBOYU4sIE5hTiwgeDEsIHkxXSwgMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSA0OyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICAgICAgICBjb25zdCB4ID0gcG9pbnRbaV07XG4gICAgICAgICAgY29uc3QgeSA9IHBvaW50W2kgKyAxXTtcbiAgICAgICAgICBsaW5lLnNldChPdXRsaW5lLmNyZWF0ZUJlemllclBvaW50cyh4MSwgeTEsIHgyLCB5MiwgeCwgeSksIChpIC0gMikgKiAzKTtcbiAgICAgICAgICBbeDEsIHkxLCB4MiwgeTJdID0gW3gyLCB5MiwgeCwgeV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gbGluZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgbmV3TGluZXMucHVzaCh7XG4gICAgICAgIGxpbmU6IHJlc2NhbGVGbihsaW5lc1tpXS5tYXAoeCA9PiB4ID8/IE5hTiksIHR4LCB0eSwgc3gsIHN5KSxcbiAgICAgICAgcG9pbnRzOiByZXNjYWxlRm4ocG9pbnRzW2ldLm1hcCh4ID0+IHggPz8gTmFOKSwgdHgsIHR5LCBzeCwgc3kpXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgb3V0bGluZXMgPSBuZXcgSW5rRHJhd091dGxpbmUoKTtcbiAgICBvdXRsaW5lcy5idWlsZChuZXdMaW5lcywgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0LCAxLCByb3RhdGlvbiwgdGhpY2tuZXNzLCBpbm5lck1hcmdpbik7XG4gICAgcmV0dXJuIG91dGxpbmVzO1xuICB9XG4gICNnZXRNYXJnaW5Db21wb25lbnRzKHRoaWNrbmVzcyA9IHRoaXMuI3RoaWNrbmVzcykge1xuICAgIGNvbnN0IG1hcmdpbiA9IHRoaXMuI2lubmVyTWFyZ2luICsgdGhpY2tuZXNzIC8gMiAqIHRoaXMuI3BhcmVudFNjYWxlO1xuICAgIHJldHVybiB0aGlzLiNyb3RhdGlvbiAlIDE4MCA9PT0gMCA/IFttYXJnaW4gLyB0aGlzLiNwYXJlbnRXaWR0aCwgbWFyZ2luIC8gdGhpcy4jcGFyZW50SGVpZ2h0XSA6IFttYXJnaW4gLyB0aGlzLiNwYXJlbnRIZWlnaHQsIG1hcmdpbiAvIHRoaXMuI3BhcmVudFdpZHRoXTtcbiAgfVxuICAjZ2V0QkJveFdpdGhOb01hcmdpbigpIHtcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNiYm94O1xuICAgIGNvbnN0IFttYXJnaW5YLCBtYXJnaW5ZXSA9IHRoaXMuI2dldE1hcmdpbkNvbXBvbmVudHMoMCk7XG4gICAgcmV0dXJuIFt4ICsgbWFyZ2luWCwgeSArIG1hcmdpblksIHdpZHRoIC0gMiAqIG1hcmdpblgsIGhlaWdodCAtIDIgKiBtYXJnaW5ZXTtcbiAgfVxuICAjY29tcHV0ZUJib3goKSB7XG4gICAgY29uc3QgYmJveCA9IHRoaXMuI2Jib3ggPSBuZXcgRmxvYXQzMkFycmF5KFtJbmZpbml0eSwgSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5XSk7XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBsaW5lXG4gICAgfSBvZiB0aGlzLiNsaW5lcykge1xuICAgICAgaWYgKGxpbmUubGVuZ3RoIDw9IDEyKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSA0LCBpaSA9IGxpbmUubGVuZ3RoOyBpIDwgaWk7IGkgKz0gNikge1xuICAgICAgICAgIGNvbnN0IFt4LCB5XSA9IGxpbmUuc3ViYXJyYXkoaSwgaSArIDIpO1xuICAgICAgICAgIGJib3hbMF0gPSBNYXRoLm1pbihiYm94WzBdLCB4KTtcbiAgICAgICAgICBiYm94WzFdID0gTWF0aC5taW4oYmJveFsxXSwgeSk7XG4gICAgICAgICAgYmJveFsyXSA9IE1hdGgubWF4KGJib3hbMl0sIHgpO1xuICAgICAgICAgIGJib3hbM10gPSBNYXRoLm1heChiYm94WzNdLCB5KTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCBsYXN0WCA9IGxpbmVbNF0sXG4gICAgICAgIGxhc3RZID0gbGluZVs1XTtcbiAgICAgIGZvciAobGV0IGkgPSA2LCBpaSA9IGxpbmUubGVuZ3RoOyBpIDwgaWk7IGkgKz0gNikge1xuICAgICAgICBjb25zdCBbYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5XSA9IGxpbmUuc3ViYXJyYXkoaSwgaSArIDYpO1xuICAgICAgICBVdGlsLmJlemllckJvdW5kaW5nQm94KGxhc3RYLCBsYXN0WSwgYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5LCBiYm94KTtcbiAgICAgICAgbGFzdFggPSB4O1xuICAgICAgICBsYXN0WSA9IHk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IFttYXJnaW5YLCBtYXJnaW5ZXSA9IHRoaXMuI2dldE1hcmdpbkNvbXBvbmVudHMoKTtcbiAgICBiYm94WzBdID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgYmJveFswXSAtIG1hcmdpblgpKTtcbiAgICBiYm94WzFdID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgYmJveFsxXSAtIG1hcmdpblkpKTtcbiAgICBiYm94WzJdID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgYmJveFsyXSArIG1hcmdpblgpKTtcbiAgICBiYm94WzNdID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgYmJveFszXSArIG1hcmdpblkpKTtcbiAgICBiYm94WzJdIC09IGJib3hbMF07XG4gICAgYmJveFszXSAtPSBiYm94WzFdO1xuICB9XG4gIGdldCBib3goKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Jib3g7XG4gIH1cbiAgdXBkYXRlUHJvcGVydHkobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAobmFtZSA9PT0gXCJzdHJva2Utd2lkdGhcIikge1xuICAgICAgcmV0dXJuIHRoaXMuI3VwZGF0ZVRoaWNrbmVzcyh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gICN1cGRhdGVUaGlja25lc3ModGhpY2tuZXNzKSB7XG4gICAgY29uc3QgW29sZE1hcmdpblgsIG9sZE1hcmdpblldID0gdGhpcy4jZ2V0TWFyZ2luQ29tcG9uZW50cygpO1xuICAgIHRoaXMuI3RoaWNrbmVzcyA9IHRoaWNrbmVzcztcbiAgICBjb25zdCBbbmV3TWFyZ2luWCwgbmV3TWFyZ2luWV0gPSB0aGlzLiNnZXRNYXJnaW5Db21wb25lbnRzKCk7XG4gICAgY29uc3QgW2RpZmZNYXJnaW5YLCBkaWZmTWFyZ2luWV0gPSBbbmV3TWFyZ2luWCAtIG9sZE1hcmdpblgsIG5ld01hcmdpblkgLSBvbGRNYXJnaW5ZXTtcbiAgICBjb25zdCBiYm94ID0gdGhpcy4jYmJveDtcbiAgICBiYm94WzBdIC09IGRpZmZNYXJnaW5YO1xuICAgIGJib3hbMV0gLT0gZGlmZk1hcmdpblk7XG4gICAgYmJveFsyXSArPSAyICogZGlmZk1hcmdpblg7XG4gICAgYmJveFszXSArPSAyICogZGlmZk1hcmdpblk7XG4gICAgcmV0dXJuIGJib3g7XG4gIH1cbiAgdXBkYXRlUGFyZW50RGltZW5zaW9ucyhbd2lkdGgsIGhlaWdodF0sIHNjYWxlKSB7XG4gICAgY29uc3QgW29sZE1hcmdpblgsIG9sZE1hcmdpblldID0gdGhpcy4jZ2V0TWFyZ2luQ29tcG9uZW50cygpO1xuICAgIHRoaXMuI3BhcmVudFdpZHRoID0gd2lkdGg7XG4gICAgdGhpcy4jcGFyZW50SGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuI3BhcmVudFNjYWxlID0gc2NhbGU7XG4gICAgY29uc3QgW25ld01hcmdpblgsIG5ld01hcmdpblldID0gdGhpcy4jZ2V0TWFyZ2luQ29tcG9uZW50cygpO1xuICAgIGNvbnN0IGRpZmZNYXJnaW5YID0gbmV3TWFyZ2luWCAtIG9sZE1hcmdpblg7XG4gICAgY29uc3QgZGlmZk1hcmdpblkgPSBuZXdNYXJnaW5ZIC0gb2xkTWFyZ2luWTtcbiAgICBjb25zdCBiYm94ID0gdGhpcy4jYmJveDtcbiAgICBiYm94WzBdIC09IGRpZmZNYXJnaW5YO1xuICAgIGJib3hbMV0gLT0gZGlmZk1hcmdpblk7XG4gICAgYmJveFsyXSArPSAyICogZGlmZk1hcmdpblg7XG4gICAgYmJveFszXSArPSAyICogZGlmZk1hcmdpblk7XG4gICAgcmV0dXJuIGJib3g7XG4gIH1cbiAgdXBkYXRlUm90YXRpb24ocm90YXRpb24pIHtcbiAgICB0aGlzLiNjdXJyZW50Um90YXRpb24gPSByb3RhdGlvbjtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDoge1xuICAgICAgICB0cmFuc2Zvcm06IHRoaXMucm90YXRpb25UcmFuc2Zvcm1cbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGdldCB2aWV3Qm94KCkge1xuICAgIHJldHVybiB0aGlzLiNiYm94Lm1hcChPdXRsaW5lLnN2Z1JvdW5kKS5qb2luKFwiIFwiKTtcbiAgfVxuICBnZXQgZGVmYXVsdFByb3BlcnRpZXMoKSB7XG4gICAgY29uc3QgW3gsIHldID0gdGhpcy4jYmJveDtcbiAgICByZXR1cm4ge1xuICAgICAgcm9vdDoge1xuICAgICAgICB2aWV3Qm94OiB0aGlzLnZpZXdCb3hcbiAgICAgIH0sXG4gICAgICBwYXRoOiB7XG4gICAgICAgIFwidHJhbnNmb3JtLW9yaWdpblwiOiBgJHtPdXRsaW5lLnN2Z1JvdW5kKHgpfSAke091dGxpbmUuc3ZnUm91bmQoeSl9YFxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZ2V0IHJvdGF0aW9uVHJhbnNmb3JtKCkge1xuICAgIGNvbnN0IFssLCB3aWR0aCwgaGVpZ2h0XSA9IHRoaXMuI2Jib3g7XG4gICAgbGV0IGEgPSAwLFxuICAgICAgYiA9IDAsXG4gICAgICBjID0gMCxcbiAgICAgIGQgPSAwLFxuICAgICAgZSA9IDAsXG4gICAgICBmID0gMDtcbiAgICBzd2l0Y2ggKHRoaXMuI2N1cnJlbnRSb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgYiA9IGhlaWdodCAvIHdpZHRoO1xuICAgICAgICBjID0gLXdpZHRoIC8gaGVpZ2h0O1xuICAgICAgICBlID0gd2lkdGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIGEgPSAtMTtcbiAgICAgICAgZCA9IC0xO1xuICAgICAgICBlID0gd2lkdGg7XG4gICAgICAgIGYgPSBoZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIGIgPSAtaGVpZ2h0IC8gd2lkdGg7XG4gICAgICAgIGMgPSB3aWR0aCAvIGhlaWdodDtcbiAgICAgICAgZiA9IGhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIGBtYXRyaXgoJHthfSAke2J9ICR7Y30gJHtkfSAke091dGxpbmUuc3ZnUm91bmQoZSl9ICR7T3V0bGluZS5zdmdSb3VuZChmKX0pYDtcbiAgfVxuICBnZXRQYXRoUmVzaXppbmdTVkdQcm9wZXJ0aWVzKFtuZXdYLCBuZXdZLCBuZXdXaWR0aCwgbmV3SGVpZ2h0XSkge1xuICAgIGNvbnN0IFttYXJnaW5YLCBtYXJnaW5ZXSA9IHRoaXMuI2dldE1hcmdpbkNvbXBvbmVudHMoKTtcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNiYm94O1xuICAgIGlmIChNYXRoLmFicyh3aWR0aCAtIG1hcmdpblgpIDw9IE91dGxpbmUuUFJFQ0lTSU9OIHx8IE1hdGguYWJzKGhlaWdodCAtIG1hcmdpblkpIDw9IE91dGxpbmUuUFJFQ0lTSU9OKSB7XG4gICAgICBjb25zdCB0eCA9IG5ld1ggKyBuZXdXaWR0aCAvIDIgLSAoeCArIHdpZHRoIC8gMik7XG4gICAgICBjb25zdCB0eSA9IG5ld1kgKyBuZXdIZWlnaHQgLyAyIC0gKHkgKyBoZWlnaHQgLyAyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGg6IHtcbiAgICAgICAgICBcInRyYW5zZm9ybS1vcmlnaW5cIjogYCR7T3V0bGluZS5zdmdSb3VuZChuZXdYKX0gJHtPdXRsaW5lLnN2Z1JvdW5kKG5ld1kpfWAsXG4gICAgICAgICAgdHJhbnNmb3JtOiBgJHt0aGlzLnJvdGF0aW9uVHJhbnNmb3JtfSB0cmFuc2xhdGUoJHt0eH0gJHt0eX0pYFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBzMXggPSAobmV3V2lkdGggLSAyICogbWFyZ2luWCkgLyAod2lkdGggLSAyICogbWFyZ2luWCk7XG4gICAgY29uc3QgczF5ID0gKG5ld0hlaWdodCAtIDIgKiBtYXJnaW5ZKSAvIChoZWlnaHQgLSAyICogbWFyZ2luWSk7XG4gICAgY29uc3QgczJ4ID0gd2lkdGggLyBuZXdXaWR0aDtcbiAgICBjb25zdCBzMnkgPSBoZWlnaHQgLyBuZXdIZWlnaHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgXCJ0cmFuc2Zvcm0tb3JpZ2luXCI6IGAke091dGxpbmUuc3ZnUm91bmQoeCl9ICR7T3V0bGluZS5zdmdSb3VuZCh5KX1gLFxuICAgICAgICB0cmFuc2Zvcm06IGAke3RoaXMucm90YXRpb25UcmFuc2Zvcm19IHNjYWxlKCR7czJ4fSAke3MyeX0pIGAgKyBgdHJhbnNsYXRlKCR7T3V0bGluZS5zdmdSb3VuZChtYXJnaW5YKX0gJHtPdXRsaW5lLnN2Z1JvdW5kKG1hcmdpblkpfSkgc2NhbGUoJHtzMXh9ICR7czF5fSkgYCArIGB0cmFuc2xhdGUoJHtPdXRsaW5lLnN2Z1JvdW5kKC1tYXJnaW5YKX0gJHtPdXRsaW5lLnN2Z1JvdW5kKC1tYXJnaW5ZKX0pYFxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZ2V0UGF0aFJlc2l6ZWRTVkdQcm9wZXJ0aWVzKFtuZXdYLCBuZXdZLCBuZXdXaWR0aCwgbmV3SGVpZ2h0XSkge1xuICAgIGNvbnN0IFttYXJnaW5YLCBtYXJnaW5ZXSA9IHRoaXMuI2dldE1hcmdpbkNvbXBvbmVudHMoKTtcbiAgICBjb25zdCBiYm94ID0gdGhpcy4jYmJveDtcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSBiYm94O1xuICAgIGJib3hbMF0gPSBuZXdYO1xuICAgIGJib3hbMV0gPSBuZXdZO1xuICAgIGJib3hbMl0gPSBuZXdXaWR0aDtcbiAgICBiYm94WzNdID0gbmV3SGVpZ2h0O1xuICAgIGlmIChNYXRoLmFicyh3aWR0aCAtIG1hcmdpblgpIDw9IE91dGxpbmUuUFJFQ0lTSU9OIHx8IE1hdGguYWJzKGhlaWdodCAtIG1hcmdpblkpIDw9IE91dGxpbmUuUFJFQ0lTSU9OKSB7XG4gICAgICBjb25zdCB0eCA9IG5ld1ggKyBuZXdXaWR0aCAvIDIgLSAoeCArIHdpZHRoIC8gMik7XG4gICAgICBjb25zdCB0eSA9IG5ld1kgKyBuZXdIZWlnaHQgLyAyIC0gKHkgKyBoZWlnaHQgLyAyKTtcbiAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICBsaW5lLFxuICAgICAgICBwb2ludHNcbiAgICAgIH0gb2YgdGhpcy4jbGluZXMpIHtcbiAgICAgICAgT3V0bGluZS5fdHJhbnNsYXRlKGxpbmUsIHR4LCB0eSwgbGluZSk7XG4gICAgICAgIE91dGxpbmUuX3RyYW5zbGF0ZShwb2ludHMsIHR4LCB0eSwgcG9pbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICB2aWV3Qm94OiB0aGlzLnZpZXdCb3hcbiAgICAgICAgfSxcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIFwidHJhbnNmb3JtLW9yaWdpblwiOiBgJHtPdXRsaW5lLnN2Z1JvdW5kKG5ld1gpfSAke091dGxpbmUuc3ZnUm91bmQobmV3WSl9YCxcbiAgICAgICAgICB0cmFuc2Zvcm06IHRoaXMucm90YXRpb25UcmFuc2Zvcm0gfHwgbnVsbCxcbiAgICAgICAgICBkOiB0aGlzLnRvU1ZHUGF0aCgpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHMxeCA9IChuZXdXaWR0aCAtIDIgKiBtYXJnaW5YKSAvICh3aWR0aCAtIDIgKiBtYXJnaW5YKTtcbiAgICBjb25zdCBzMXkgPSAobmV3SGVpZ2h0IC0gMiAqIG1hcmdpblkpIC8gKGhlaWdodCAtIDIgKiBtYXJnaW5ZKTtcbiAgICBjb25zdCB0eCA9IC1zMXggKiAoeCArIG1hcmdpblgpICsgbmV3WCArIG1hcmdpblg7XG4gICAgY29uc3QgdHkgPSAtczF5ICogKHkgKyBtYXJnaW5ZKSArIG5ld1kgKyBtYXJnaW5ZO1xuICAgIGlmIChzMXggIT09IDEgfHwgczF5ICE9PSAxIHx8IHR4ICE9PSAwIHx8IHR5ICE9PSAwKSB7XG4gICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgbGluZSxcbiAgICAgICAgcG9pbnRzXG4gICAgICB9IG9mIHRoaXMuI2xpbmVzKSB7XG4gICAgICAgIE91dGxpbmUuX3Jlc2NhbGUobGluZSwgdHgsIHR5LCBzMXgsIHMxeSwgbGluZSk7XG4gICAgICAgIE91dGxpbmUuX3Jlc2NhbGUocG9pbnRzLCB0eCwgdHksIHMxeCwgczF5LCBwb2ludHMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcm9vdDoge1xuICAgICAgICB2aWV3Qm94OiB0aGlzLnZpZXdCb3hcbiAgICAgIH0sXG4gICAgICBwYXRoOiB7XG4gICAgICAgIFwidHJhbnNmb3JtLW9yaWdpblwiOiBgJHtPdXRsaW5lLnN2Z1JvdW5kKG5ld1gpfSAke091dGxpbmUuc3ZnUm91bmQobmV3WSl9YCxcbiAgICAgICAgdHJhbnNmb3JtOiB0aGlzLnJvdGF0aW9uVHJhbnNmb3JtIHx8IG51bGwsXG4gICAgICAgIGQ6IHRoaXMudG9TVkdQYXRoKClcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGdldFBhdGhUcmFuc2xhdGVkU1ZHUHJvcGVydGllcyhbbmV3WCwgbmV3WV0sIHBhcmVudERpbWVuc2lvbnMpIHtcbiAgICBjb25zdCBbbmV3UGFyZW50V2lkdGgsIG5ld1BhcmVudEhlaWdodF0gPSBwYXJlbnREaW1lbnNpb25zO1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLiNiYm94O1xuICAgIGNvbnN0IHR4ID0gbmV3WCAtIGJib3hbMF07XG4gICAgY29uc3QgdHkgPSBuZXdZIC0gYmJveFsxXTtcbiAgICBpZiAodGhpcy4jcGFyZW50V2lkdGggPT09IG5ld1BhcmVudFdpZHRoICYmIHRoaXMuI3BhcmVudEhlaWdodCA9PT0gbmV3UGFyZW50SGVpZ2h0KSB7XG4gICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgbGluZSxcbiAgICAgICAgcG9pbnRzXG4gICAgICB9IG9mIHRoaXMuI2xpbmVzKSB7XG4gICAgICAgIE91dGxpbmUuX3RyYW5zbGF0ZShsaW5lLCB0eCwgdHksIGxpbmUpO1xuICAgICAgICBPdXRsaW5lLl90cmFuc2xhdGUocG9pbnRzLCB0eCwgdHksIHBvaW50cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN4ID0gdGhpcy4jcGFyZW50V2lkdGggLyBuZXdQYXJlbnRXaWR0aDtcbiAgICAgIGNvbnN0IHN5ID0gdGhpcy4jcGFyZW50SGVpZ2h0IC8gbmV3UGFyZW50SGVpZ2h0O1xuICAgICAgdGhpcy4jcGFyZW50V2lkdGggPSBuZXdQYXJlbnRXaWR0aDtcbiAgICAgIHRoaXMuI3BhcmVudEhlaWdodCA9IG5ld1BhcmVudEhlaWdodDtcbiAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICBsaW5lLFxuICAgICAgICBwb2ludHNcbiAgICAgIH0gb2YgdGhpcy4jbGluZXMpIHtcbiAgICAgICAgT3V0bGluZS5fcmVzY2FsZShsaW5lLCB0eCwgdHksIHN4LCBzeSwgbGluZSk7XG4gICAgICAgIE91dGxpbmUuX3Jlc2NhbGUocG9pbnRzLCB0eCwgdHksIHN4LCBzeSwgcG9pbnRzKTtcbiAgICAgIH1cbiAgICAgIGJib3hbMl0gKj0gc3g7XG4gICAgICBiYm94WzNdICo9IHN5O1xuICAgIH1cbiAgICBiYm94WzBdID0gbmV3WDtcbiAgICBiYm94WzFdID0gbmV3WTtcbiAgICByZXR1cm4ge1xuICAgICAgcm9vdDoge1xuICAgICAgICB2aWV3Qm94OiB0aGlzLnZpZXdCb3hcbiAgICAgIH0sXG4gICAgICBwYXRoOiB7XG4gICAgICAgIGQ6IHRoaXMudG9TVkdQYXRoKCksXG4gICAgICAgIFwidHJhbnNmb3JtLW9yaWdpblwiOiBgJHtPdXRsaW5lLnN2Z1JvdW5kKG5ld1gpfSAke091dGxpbmUuc3ZnUm91bmQobmV3WSl9YFxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZ2V0IGRlZmF1bHRTVkdQcm9wZXJ0aWVzKCkge1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLiNiYm94O1xuICAgIHJldHVybiB7XG4gICAgICByb290OiB7XG4gICAgICAgIHZpZXdCb3g6IHRoaXMudmlld0JveFxuICAgICAgfSxcbiAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICBkcmF3OiB0cnVlXG4gICAgICB9LFxuICAgICAgcGF0aDoge1xuICAgICAgICBkOiB0aGlzLnRvU1ZHUGF0aCgpLFxuICAgICAgICBcInRyYW5zZm9ybS1vcmlnaW5cIjogYCR7T3V0bGluZS5zdmdSb3VuZChiYm94WzBdKX0gJHtPdXRsaW5lLnN2Z1JvdW5kKGJib3hbMV0pfWAsXG4gICAgICAgIHRyYW5zZm9ybTogdGhpcy5yb3RhdGlvblRyYW5zZm9ybSB8fCBudWxsXG4gICAgICB9LFxuICAgICAgYmJveFxuICAgIH07XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2luay5qc1xuXG5cblxuXG5cbmNsYXNzIElua0RyYXdpbmdPcHRpb25zIGV4dGVuZHMgRHJhd2luZ09wdGlvbnMge1xuICAjdmlld1BhcmFtZXRlcnM7XG4gIGNvbnN0cnVjdG9yKHZpZXdlclBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuI3ZpZXdQYXJhbWV0ZXJzID0gdmlld2VyUGFyYW1ldGVycztcbiAgICBzdXBlci51cGRhdGVQcm9wZXJ0aWVzKHtcbiAgICAgIGZpbGw6IFwibm9uZVwiLFxuICAgICAgc3Ryb2tlOiBBbm5vdGF0aW9uRWRpdG9yLl9kZWZhdWx0TGluZUNvbG9yLFxuICAgICAgXCJzdHJva2Utb3BhY2l0eVwiOiAxLFxuICAgICAgXCJzdHJva2Utd2lkdGhcIjogMSxcbiAgICAgIFwic3Ryb2tlLWxpbmVjYXBcIjogXCJyb3VuZFwiLFxuICAgICAgXCJzdHJva2UtbGluZWpvaW5cIjogXCJyb3VuZFwiLFxuICAgICAgXCJzdHJva2UtbWl0ZXJsaW1pdFwiOiAxMFxuICAgIH0pO1xuICB9XG4gIHVwZGF0ZVNWR1Byb3BlcnR5KG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKG5hbWUgPT09IFwic3Ryb2tlLXdpZHRoXCIpIHtcbiAgICAgIHZhbHVlID8/PSB0aGlzW1wic3Ryb2tlLXdpZHRoXCJdO1xuICAgICAgdmFsdWUgKj0gdGhpcy4jdmlld1BhcmFtZXRlcnMucmVhbFNjYWxlO1xuICAgIH1cbiAgICBzdXBlci51cGRhdGVTVkdQcm9wZXJ0eShuYW1lLCB2YWx1ZSk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgSW5rRHJhd2luZ09wdGlvbnModGhpcy4jdmlld1BhcmFtZXRlcnMpO1xuICAgIGNsb25lLnVwZGF0ZUFsbCh0aGlzKTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbn1cbmNsYXNzIElua0VkaXRvciBleHRlbmRzIERyYXdpbmdFZGl0b3Ige1xuICBzdGF0aWMgX3R5cGUgPSBcImlua1wiO1xuICBzdGF0aWMgX2VkaXRvclR5cGUgPSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5JTks7XG4gIHN0YXRpYyBfZGVmYXVsdERyYXdpbmdPcHRpb25zID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgbmFtZTogXCJpbmtFZGl0b3JcIlxuICAgIH0pO1xuICAgIHRoaXMuX3dpbGxLZWVwQXNwZWN0UmF0aW8gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpbml0aWFsaXplKGwxMG4sIHVpTWFuYWdlcikge1xuICAgIEFubm90YXRpb25FZGl0b3IuaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpO1xuICAgIHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9ucyA9IG5ldyBJbmtEcmF3aW5nT3B0aW9ucyh1aU1hbmFnZXIudmlld1BhcmFtZXRlcnMpO1xuICB9XG4gIHN0YXRpYyBnZXREZWZhdWx0RHJhd2luZ09wdGlvbnMob3B0aW9ucykge1xuICAgIGNvbnN0IGNsb25lID0gdGhpcy5fZGVmYXVsdERyYXdpbmdPcHRpb25zLmNsb25lKCk7XG4gICAgY2xvbmUudXBkYXRlUHJvcGVydGllcyhvcHRpb25zKTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbiAgc3RhdGljIGdldCBzdXBwb3J0TXVsdGlwbGVEcmF3aW5ncygpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGVzTWFwKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJ0eXBlc01hcFwiLCBuZXcgTWFwKFtbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX1RISUNLTkVTUywgXCJzdHJva2Utd2lkdGhcIl0sIFtBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfQ09MT1IsIFwic3Ryb2tlXCJdLCBbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX09QQUNJVFksIFwic3Ryb2tlLW9wYWNpdHlcIl1dKSk7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZURyYXdlckluc3RhbmNlKHgsIHksIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHJvdGF0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBJbmtEcmF3T3V0bGluZXIoeCwgeSwgcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodCwgcm90YXRpb24sIHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9uc1tcInN0cm9rZS13aWR0aFwiXSk7XG4gIH1cbiAgc3RhdGljIGRlc2VyaWFsaXplRHJhdyhwYWdlWCwgcGFnZVksIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgaW5uZXJNYXJnaW4sIGRhdGEpIHtcbiAgICByZXR1cm4gSW5rRHJhd091dGxpbmUuZGVzZXJpYWxpemUocGFnZVgsIHBhZ2VZLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQsIGlubmVyTWFyZ2luLCBkYXRhKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpIHtcbiAgICBsZXQgaW5pdGlhbERhdGEgPSBudWxsO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgSW5rQW5ub3RhdGlvbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGlua0xpc3RzLFxuICAgICAgICAgIHJlY3QsXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgY29sb3IsXG4gICAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgICBib3JkZXJTdHlsZToge1xuICAgICAgICAgICAgcmF3V2lkdGg6IHRoaWNrbmVzc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcG9wdXBSZWZcbiAgICAgICAgfSxcbiAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgcGFnZToge1xuICAgICAgICAgICAgcGFnZU51bWJlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSA9IGRhdGE7XG4gICAgICBpbml0aWFsRGF0YSA9IGRhdGEgPSB7XG4gICAgICAgIGFubm90YXRpb25UeXBlOiBBbm5vdGF0aW9uRWRpdG9yVHlwZS5JTkssXG4gICAgICAgIGNvbG9yOiBBcnJheS5mcm9tKGNvbG9yKSxcbiAgICAgICAgdGhpY2tuZXNzLFxuICAgICAgICBvcGFjaXR5LFxuICAgICAgICBwYXRoczoge1xuICAgICAgICAgIHBvaW50czogaW5rTGlzdHNcbiAgICAgICAgfSxcbiAgICAgICAgYm94ZXM6IG51bGwsXG4gICAgICAgIHBhZ2VJbmRleDogcGFnZU51bWJlciAtIDEsXG4gICAgICAgIHJlY3Q6IHJlY3Quc2xpY2UoMCksXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICBpZCxcbiAgICAgICAgZGVsZXRlZDogZmFsc2UsXG4gICAgICAgIHBvcHVwUmVmXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3IgPSBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcik7XG4gICAgZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQgPSBkYXRhLmlkIHx8IG51bGw7XG4gICAgZWRpdG9yLl9pbml0aWFsRGF0YSA9IGluaXRpYWxEYXRhO1xuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgb25TY2FsZUNoYW5naW5nKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIub25TY2FsZUNoYW5naW5nKCk7XG4gICAgY29uc3Qge1xuICAgICAgX2RyYXdJZCxcbiAgICAgIF9kcmF3aW5nT3B0aW9ucyxcbiAgICAgIHBhcmVudFxuICAgIH0gPSB0aGlzO1xuICAgIF9kcmF3aW5nT3B0aW9ucy51cGRhdGVTVkdQcm9wZXJ0eShcInN0cm9rZS13aWR0aFwiKTtcbiAgICBwYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXMoX2RyYXdJZCwgX2RyYXdpbmdPcHRpb25zLnRvU1ZHUHJvcGVydGllcygpKTtcbiAgfVxuICBzdGF0aWMgb25TY2FsZUNoYW5naW5nV2hlbkRyYXdpbmcoKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5fY3VycmVudFBhcmVudDtcbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5vblNjYWxlQ2hhbmdpbmdXaGVuRHJhd2luZygpO1xuICAgIHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9ucy51cGRhdGVTVkdQcm9wZXJ0eShcInN0cm9rZS13aWR0aFwiKTtcbiAgICBwYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fY3VycmVudERyYXdJZCwgdGhpcy5fZGVmYXVsdERyYXdpbmdPcHRpb25zLnRvU1ZHUHJvcGVydGllcygpKTtcbiAgfVxuICBjcmVhdGVEcmF3aW5nT3B0aW9ucyh7XG4gICAgY29sb3IsXG4gICAgdGhpY2tuZXNzLFxuICAgIG9wYWNpdHlcbiAgfSkge1xuICAgIHRoaXMuX2RyYXdpbmdPcHRpb25zID0gSW5rRWRpdG9yLmdldERlZmF1bHREcmF3aW5nT3B0aW9ucyh7XG4gICAgICBzdHJva2U6IFV0aWwubWFrZUhleENvbG9yKC4uLmNvbG9yKSxcbiAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IHRoaWNrbmVzcyxcbiAgICAgIFwic3Ryb2tlLW9wYWNpdHlcIjogb3BhY2l0eVxuICAgIH0pO1xuICB9XG4gIHNlcmlhbGl6ZShpc0ZvckNvcHlpbmcgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZURlbGV0ZWQoKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgbGluZXMsXG4gICAgICBwb2ludHMsXG4gICAgICByZWN0XG4gICAgfSA9IHRoaXMuc2VyaWFsaXplRHJhdyhpc0ZvckNvcHlpbmcpO1xuICAgIGNvbnN0IHtcbiAgICAgIF9kcmF3aW5nT3B0aW9uczoge1xuICAgICAgICBzdHJva2UsXG4gICAgICAgIFwic3Ryb2tlLW9wYWNpdHlcIjogb3BhY2l0eSxcbiAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogdGhpY2tuZXNzXG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHtcbiAgICAgIGFubm90YXRpb25UeXBlOiBBbm5vdGF0aW9uRWRpdG9yVHlwZS5JTkssXG4gICAgICBjb2xvcjogQW5ub3RhdGlvbkVkaXRvci5fY29sb3JNYW5hZ2VyLmNvbnZlcnQoc3Ryb2tlKSxcbiAgICAgIG9wYWNpdHksXG4gICAgICB0aGlja25lc3MsXG4gICAgICBwYXRoczoge1xuICAgICAgICBsaW5lcyxcbiAgICAgICAgcG9pbnRzXG4gICAgICB9LFxuICAgICAgcGFnZUluZGV4OiB0aGlzLnBhZ2VJbmRleCxcbiAgICAgIHJlY3QsXG4gICAgICByb3RhdGlvbjogdGhpcy5yb3RhdGlvbixcbiAgICAgIHN0cnVjdFRyZWVQYXJlbnRJZDogdGhpcy5fc3RydWN0VHJlZVBhcmVudElkXG4gICAgfTtcbiAgICBpZiAoaXNGb3JDb3B5aW5nKSB7XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gICAgaWYgKHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCAmJiAhdGhpcy4jaGFzRWxlbWVudENoYW5nZWQoc2VyaWFsaXplZCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzZXJpYWxpemVkLmlkID0gdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkO1xuICAgIHJldHVybiBzZXJpYWxpemVkO1xuICB9XG4gICNoYXNFbGVtZW50Q2hhbmdlZChzZXJpYWxpemVkKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29sb3IsXG4gICAgICB0aGlja25lc3MsXG4gICAgICBvcGFjaXR5LFxuICAgICAgcGFnZUluZGV4XG4gICAgfSA9IHRoaXMuX2luaXRpYWxEYXRhO1xuICAgIHJldHVybiB0aGlzLl9oYXNCZWVuTW92ZWQgfHwgdGhpcy5faGFzQmVlblJlc2l6ZWQgfHwgc2VyaWFsaXplZC5jb2xvci5zb21lKChjLCBpKSA9PiBjICE9PSBjb2xvcltpXSkgfHwgc2VyaWFsaXplZC50aGlja25lc3MgIT09IHRoaWNrbmVzcyB8fCBzZXJpYWxpemVkLm9wYWNpdHkgIT09IG9wYWNpdHkgfHwgc2VyaWFsaXplZC5wYWdlSW5kZXggIT09IHBhZ2VJbmRleDtcbiAgfVxuICByZW5kZXJBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgcG9pbnRzLFxuICAgICAgcmVjdFxuICAgIH0gPSB0aGlzLnNlcmlhbGl6ZURyYXcoZmFsc2UpO1xuICAgIGFubm90YXRpb24udXBkYXRlRWRpdGVkKHtcbiAgICAgIHJlY3QsXG4gICAgICB0aGlja25lc3M6IHRoaXMuX2RyYXdpbmdPcHRpb25zW1wic3Ryb2tlLXdpZHRoXCJdLFxuICAgICAgcG9pbnRzXG4gICAgfSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL3N0YW1wLmpzXG5cblxuXG5cbmNsYXNzIFN0YW1wRWRpdG9yIGV4dGVuZHMgQW5ub3RhdGlvbkVkaXRvciB7XG4gICNiaXRtYXAgPSBudWxsO1xuICAjYml0bWFwSWQgPSBudWxsO1xuICAjYml0bWFwUHJvbWlzZSA9IG51bGw7XG4gICNiaXRtYXBVcmwgPSBudWxsO1xuICAjYml0bWFwRmlsZSA9IG51bGw7XG4gICNiaXRtYXBGaWxlTmFtZSA9IFwiXCI7XG4gICNjYW52YXMgPSBudWxsO1xuICAjb2JzZXJ2ZXIgPSBudWxsO1xuICAjcmVzaXplVGltZW91dElkID0gbnVsbDtcbiAgI2lzU3ZnID0gZmFsc2U7XG4gICNoYXNCZWVuQWRkZWRJblVuZG9TdGFjayA9IGZhbHNlO1xuICBzdGF0aWMgX3R5cGUgPSBcInN0YW1wXCI7XG4gIHN0YXRpYyBfZWRpdG9yVHlwZSA9IEFubm90YXRpb25FZGl0b3JUeXBlLlNUQU1QO1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBuYW1lOiBcInN0YW1wRWRpdG9yXCJcbiAgICB9KTtcbiAgICB0aGlzLiNiaXRtYXBVcmwgPSBwYXJhbXMuYml0bWFwVXJsO1xuICAgIHRoaXMuI2JpdG1hcEZpbGUgPSBwYXJhbXMuYml0bWFwRmlsZTtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpIHtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLmluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHN1cHBvcnRlZFR5cGVzKCkge1xuICAgIGNvbnN0IHR5cGVzID0gW1wiYXBuZ1wiLCBcImF2aWZcIiwgXCJibXBcIiwgXCJnaWZcIiwgXCJqcGVnXCIsIFwicG5nXCIsIFwic3ZnK3htbFwiLCBcIndlYnBcIiwgXCJ4LWljb25cIl07XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcInN1cHBvcnRlZFR5cGVzXCIsIHR5cGVzLm1hcCh0eXBlID0+IGBpbWFnZS8ke3R5cGV9YCkpO1xuICB9XG4gIHN0YXRpYyBnZXQgc3VwcG9ydGVkVHlwZXNTdHIoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcInN1cHBvcnRlZFR5cGVzU3RyXCIsIHRoaXMuc3VwcG9ydGVkVHlwZXMuam9pbihcIixcIikpO1xuICB9XG4gIHN0YXRpYyBpc0hhbmRsaW5nTWltZUZvclBhc3RpbmcobWltZSkge1xuICAgIHJldHVybiB0aGlzLnN1cHBvcnRlZFR5cGVzLmluY2x1ZGVzKG1pbWUpO1xuICB9XG4gIHN0YXRpYyBwYXN0ZShpdGVtLCBwYXJlbnQpIHtcbiAgICBwYXJlbnQucGFzdGVFZGl0b3IoQW5ub3RhdGlvbkVkaXRvclR5cGUuU1RBTVAsIHtcbiAgICAgIGJpdG1hcEZpbGU6IGl0ZW0uZ2V0QXNGaWxlKClcbiAgICB9KTtcbiAgfVxuICBhbHRUZXh0RmluaXNoKCkge1xuICAgIGlmICh0aGlzLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dEZsb3cpIHtcbiAgICAgIHRoaXMuZGl2LmhpZGRlbiA9IGZhbHNlO1xuICAgIH1cbiAgICBzdXBlci5hbHRUZXh0RmluaXNoKCk7XG4gIH1cbiAgZ2V0IHRlbGVtZXRyeUZpbmFsRGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzdGFtcFwiLFxuICAgICAgaGFzQWx0VGV4dDogISF0aGlzLmFsdFRleHREYXRhPy5hbHRUZXh0XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgY29tcHV0ZVRlbGVtZXRyeUZpbmFsRGF0YShkYXRhKSB7XG4gICAgY29uc3QgaGFzQWx0VGV4dFN0YXRzID0gZGF0YS5nZXQoXCJoYXNBbHRUZXh0XCIpO1xuICAgIHJldHVybiB7XG4gICAgICBoYXNBbHRUZXh0OiBoYXNBbHRUZXh0U3RhdHMuZ2V0KHRydWUpID8/IDAsXG4gICAgICBoYXNOb0FsdFRleHQ6IGhhc0FsdFRleHRTdGF0cy5nZXQoZmFsc2UpID8/IDBcbiAgICB9O1xuICB9XG4gICNnZXRCaXRtYXBGZXRjaGVkKGRhdGEsIGZyb21JZCA9IGZhbHNlKSB7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNiaXRtYXAgPSBkYXRhLmJpdG1hcDtcbiAgICBpZiAoIWZyb21JZCkge1xuICAgICAgdGhpcy4jYml0bWFwSWQgPSBkYXRhLmlkO1xuICAgICAgdGhpcy4jaXNTdmcgPSBkYXRhLmlzU3ZnO1xuICAgIH1cbiAgICBpZiAoZGF0YS5maWxlKSB7XG4gICAgICB0aGlzLiNiaXRtYXBGaWxlTmFtZSA9IGRhdGEuZmlsZS5uYW1lO1xuICAgIH1cbiAgICB0aGlzLiNjcmVhdGVDYW52YXMoKTtcbiAgfVxuICAjZ2V0Qml0bWFwRG9uZSgpIHtcbiAgICB0aGlzLiNiaXRtYXBQcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLl91aU1hbmFnZXIuZW5hYmxlV2FpdGluZyhmYWxzZSk7XG4gICAgaWYgKCF0aGlzLiNjYW52YXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3VpTWFuYWdlci51c2VOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlICYmIHRoaXMuX3VpTWFuYWdlci51c2VOZXdBbHRUZXh0RmxvdyAmJiB0aGlzLiNiaXRtYXApIHtcbiAgICAgIHRoaXMuX2VkaXRUb29sYmFyLmhpZGUoKTtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5lZGl0QWx0VGV4dCh0aGlzLCB0cnVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSAmJiB0aGlzLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dEZsb3cgJiYgdGhpcy4jYml0bWFwKSB7XG4gICAgICB0aGlzLl9yZXBvcnRUZWxlbWV0cnkoe1xuICAgICAgICBhY3Rpb246IFwicGRmanMuaW1hZ2UuaW1hZ2VfYWRkZWRcIixcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGFsdF90ZXh0X21vZGFsOiBmYWxzZSxcbiAgICAgICAgICBhbHRfdGV4dF90eXBlOiBcImVtcHR5XCJcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLm1sR3Vlc3NBbHRUZXh0KCk7XG4gICAgICB9IGNhdGNoIHt9XG4gICAgfVxuICAgIHRoaXMuZGl2LmZvY3VzKCk7XG4gIH1cbiAgYXN5bmMgbWxHdWVzc0FsdFRleHQoaW1hZ2VEYXRhID0gbnVsbCwgdXBkYXRlQWx0VGV4dERhdGEgPSB0cnVlKSB7XG4gICAgaWYgKHRoaXMuaGFzQWx0VGV4dERhdGEoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIG1sTWFuYWdlclxuICAgIH0gPSB0aGlzLl91aU1hbmFnZXI7XG4gICAgaWYgKCFtbE1hbmFnZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIE1MLlwiKTtcbiAgICB9XG4gICAgaWYgKCEoYXdhaXQgbWxNYW5hZ2VyLmlzRW5hYmxlZEZvcihcImFsdFRleHRcIikpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNTCBpc24ndCBlbmFibGVkIGZvciBhbHQgdGV4dC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBpbWFnZURhdGEgfHwgdGhpcy5jb3B5Q2FudmFzKG51bGwsIG51bGwsIHRydWUpLmltYWdlRGF0YTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG1sTWFuYWdlci5ndWVzcyh7XG4gICAgICBuYW1lOiBcImFsdFRleHRcIixcbiAgICAgIHJlcXVlc3Q6IHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgY2hhbm5lbHM6IGRhdGEubGVuZ3RoIC8gKHdpZHRoICogaGVpZ2h0KVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJlc3BvbnNlIGZyb20gdGhlIEFJIHNlcnZpY2UuXCIpO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIGZyb20gdGhlIEFJIHNlcnZpY2UuXCIpO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2UuY2FuY2VsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZS5vdXRwdXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHZhbGlkIHJlc3BvbnNlIGZyb20gdGhlIEFJIHNlcnZpY2UuXCIpO1xuICAgIH1cbiAgICBjb25zdCBhbHRUZXh0ID0gcmVzcG9uc2Uub3V0cHV0O1xuICAgIGF3YWl0IHRoaXMuc2V0R3Vlc3NlZEFsdFRleHQoYWx0VGV4dCk7XG4gICAgaWYgKHVwZGF0ZUFsdFRleHREYXRhICYmICF0aGlzLmhhc0FsdFRleHREYXRhKCkpIHtcbiAgICAgIHRoaXMuYWx0VGV4dERhdGEgPSB7XG4gICAgICAgIGFsdDogYWx0VGV4dCxcbiAgICAgICAgZGVjb3JhdGl2ZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBhbHRUZXh0O1xuICB9XG4gICNnZXRCaXRtYXAoKSB7XG4gICAgaWYgKHRoaXMuI2JpdG1hcElkKSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuZW5hYmxlV2FpdGluZyh0cnVlKTtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5pbWFnZU1hbmFnZXIuZ2V0RnJvbUlkKHRoaXMuI2JpdG1hcElkKS50aGVuKGRhdGEgPT4gdGhpcy4jZ2V0Qml0bWFwRmV0Y2hlZChkYXRhLCB0cnVlKSkuZmluYWxseSgoKSA9PiB0aGlzLiNnZXRCaXRtYXBEb25lKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jYml0bWFwVXJsKSB7XG4gICAgICBjb25zdCB1cmwgPSB0aGlzLiNiaXRtYXBVcmw7XG4gICAgICB0aGlzLiNiaXRtYXBVcmwgPSBudWxsO1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcodHJ1ZSk7XG4gICAgICB0aGlzLiNiaXRtYXBQcm9taXNlID0gdGhpcy5fdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5nZXRGcm9tVXJsKHVybCkudGhlbihkYXRhID0+IHRoaXMuI2dldEJpdG1hcEZldGNoZWQoZGF0YSkpLmZpbmFsbHkoKCkgPT4gdGhpcy4jZ2V0Qml0bWFwRG9uZSgpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2JpdG1hcEZpbGUpIHtcbiAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLiNiaXRtYXBGaWxlO1xuICAgICAgdGhpcy4jYml0bWFwRmlsZSA9IG51bGw7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuZW5hYmxlV2FpdGluZyh0cnVlKTtcbiAgICAgIHRoaXMuI2JpdG1hcFByb21pc2UgPSB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldEZyb21GaWxlKGZpbGUpLnRoZW4oZGF0YSA9PiB0aGlzLiNnZXRCaXRtYXBGZXRjaGVkKGRhdGEpKS5maW5hbGx5KCgpID0+IHRoaXMuI2dldEJpdG1hcERvbmUoKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgIGlucHV0LnR5cGUgPSBcImZpbGVcIjtcbiAgICBpbnB1dC5hY2NlcHQgPSBTdGFtcEVkaXRvci5zdXBwb3J0ZWRUeXBlc1N0cjtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLl91aU1hbmFnZXIuX3NpZ25hbDtcbiAgICB0aGlzLiNiaXRtYXBQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKCFpbnB1dC5maWxlcyB8fCBpbnB1dC5maWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3VpTWFuYWdlci5lbmFibGVXYWl0aW5nKHRydWUpO1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldEZyb21GaWxlKGlucHV0LmZpbGVzWzBdKTtcbiAgICAgICAgICB0aGlzLl9yZXBvcnRUZWxlbWV0cnkoe1xuICAgICAgICAgICAgYWN0aW9uOiBcInBkZmpzLmltYWdlLmltYWdlX3NlbGVjdGVkXCIsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIGFsdF90ZXh0X21vZGFsOiB0aGlzLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dEZsb3dcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLiNnZXRCaXRtYXBGZXRjaGVkKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0sIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJjYW5jZWxcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9LCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgfSkuZmluYWxseSgoKSA9PiB0aGlzLiNnZXRCaXRtYXBEb25lKCkpO1xuICAgIGlucHV0LmNsaWNrKCk7XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIGlmICh0aGlzLiNiaXRtYXBJZCkge1xuICAgICAgdGhpcy4jYml0bWFwID0gbnVsbDtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5pbWFnZU1hbmFnZXIuZGVsZXRlSWQodGhpcy4jYml0bWFwSWQpO1xuICAgICAgdGhpcy4jY2FudmFzPy5yZW1vdmUoKTtcbiAgICAgIHRoaXMuI2NhbnZhcyA9IG51bGw7XG4gICAgICB0aGlzLiNvYnNlcnZlcj8uZGlzY29ubmVjdCgpO1xuICAgICAgdGhpcy4jb2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgaWYgKHRoaXMuI3Jlc2l6ZVRpbWVvdXRJZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy4jcmVzaXplVGltZW91dElkKTtcbiAgICAgICAgdGhpcy4jcmVzaXplVGltZW91dElkID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgc3VwZXIucmVtb3ZlKCk7XG4gIH1cbiAgcmVidWlsZCgpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICBpZiAodGhpcy4jYml0bWFwSWQpIHtcbiAgICAgICAgdGhpcy4jZ2V0Qml0bWFwKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLnJlYnVpbGQoKTtcbiAgICBpZiAodGhpcy5kaXYgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2JpdG1hcElkICYmIHRoaXMuI2NhbnZhcyA9PT0gbnVsbCkge1xuICAgICAgdGhpcy4jZ2V0Qml0bWFwKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHRoaXMucGFyZW50LmFkZCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgb25jZUFkZGVkKCkge1xuICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmRpdi5mb2N1cygpO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuICEodGhpcy4jYml0bWFwUHJvbWlzZSB8fCB0aGlzLiNiaXRtYXAgfHwgdGhpcy4jYml0bWFwVXJsIHx8IHRoaXMuI2JpdG1hcEZpbGUgfHwgdGhpcy4jYml0bWFwSWQpO1xuICB9XG4gIGdldCBpc1Jlc2l6YWJsZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXY7XG4gICAgfVxuICAgIGxldCBiYXNlWCwgYmFzZVk7XG4gICAgaWYgKHRoaXMud2lkdGgpIHtcbiAgICAgIGJhc2VYID0gdGhpcy54O1xuICAgICAgYmFzZVkgPSB0aGlzLnk7XG4gICAgfVxuICAgIHN1cGVyLnJlbmRlcigpO1xuICAgIHRoaXMuZGl2LmhpZGRlbiA9IHRydWU7XG4gICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImZpZ3VyZVwiKTtcbiAgICB0aGlzLmFkZEFsdFRleHRCdXR0b24oKTtcbiAgICBpZiAodGhpcy4jYml0bWFwKSB7XG4gICAgICB0aGlzLiNjcmVhdGVDYW52YXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jZ2V0Qml0bWFwKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLndpZHRoICYmICF0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICAgIHRoaXMuc2V0QXQoYmFzZVggKiBwYXJlbnRXaWR0aCwgYmFzZVkgKiBwYXJlbnRIZWlnaHQsIHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aCwgdGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kaXY7XG4gIH1cbiAgI2NyZWF0ZUNhbnZhcygpIHtcbiAgICBjb25zdCB7XG4gICAgICBkaXZcbiAgICB9ID0gdGhpcztcbiAgICBsZXQge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcy4jYml0bWFwO1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICBjb25zdCBNQVhfUkFUSU8gPSAwLjc1O1xuICAgIGlmICh0aGlzLndpZHRoKSB7XG4gICAgICB3aWR0aCA9IHRoaXMud2lkdGggKiBwYWdlV2lkdGg7XG4gICAgICBoZWlnaHQgPSB0aGlzLmhlaWdodCAqIHBhZ2VIZWlnaHQ7XG4gICAgfSBlbHNlIGlmICh3aWR0aCA+IE1BWF9SQVRJTyAqIHBhZ2VXaWR0aCB8fCBoZWlnaHQgPiBNQVhfUkFUSU8gKiBwYWdlSGVpZ2h0KSB7XG4gICAgICBjb25zdCBmYWN0b3IgPSBNYXRoLm1pbihNQVhfUkFUSU8gKiBwYWdlV2lkdGggLyB3aWR0aCwgTUFYX1JBVElPICogcGFnZUhlaWdodCAvIGhlaWdodCk7XG4gICAgICB3aWR0aCAqPSBmYWN0b3I7XG4gICAgICBoZWlnaHQgKj0gZmFjdG9yO1xuICAgIH1cbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy5zZXREaW1zKHdpZHRoICogcGFyZW50V2lkdGggLyBwYWdlV2lkdGgsIGhlaWdodCAqIHBhcmVudEhlaWdodCAvIHBhZ2VIZWlnaHQpO1xuICAgIHRoaXMuX3VpTWFuYWdlci5lbmFibGVXYWl0aW5nKGZhbHNlKTtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLiNjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiaW1nXCIpO1xuICAgIHRoaXMuYWRkQ29udGFpbmVyKGNhbnZhcyk7XG4gICAgaWYgKCF0aGlzLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSB8fCAhdGhpcy5fdWlNYW5hZ2VyLnVzZU5ld0FsdFRleHRGbG93IHx8IHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgZGl2LmhpZGRlbiA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLiNkcmF3Qml0bWFwKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuI2NyZWF0ZU9ic2VydmVyKCk7XG4gICAgaWYgKCF0aGlzLiNoYXNCZWVuQWRkZWRJblVuZG9TdGFjaykge1xuICAgICAgdGhpcy5wYXJlbnQuYWRkVW5kb2FibGVFZGl0b3IodGhpcyk7XG4gICAgICB0aGlzLiNoYXNCZWVuQWRkZWRJblVuZG9TdGFjayA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICBhY3Rpb246IFwiaW5zZXJ0ZWRfaW1hZ2VcIlxuICAgIH0pO1xuICAgIGlmICh0aGlzLiNiaXRtYXBGaWxlTmFtZSkge1xuICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdGhpcy4jYml0bWFwRmlsZU5hbWUpO1xuICAgIH1cbiAgfVxuICBjb3B5Q2FudmFzKG1heERhdGFEaW1lbnNpb24sIG1heFByZXZpZXdEaW1lbnNpb24sIGNyZWF0ZUltYWdlRGF0YSA9IGZhbHNlKSB7XG4gICAgaWYgKCFtYXhEYXRhRGltZW5zaW9uKSB7XG4gICAgICBtYXhEYXRhRGltZW5zaW9uID0gMjI0O1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICB3aWR0aDogYml0bWFwV2lkdGgsXG4gICAgICBoZWlnaHQ6IGJpdG1hcEhlaWdodFxuICAgIH0gPSB0aGlzLiNiaXRtYXA7XG4gICAgY29uc3Qgb3V0cHV0U2NhbGUgPSBuZXcgT3V0cHV0U2NhbGUoKTtcbiAgICBsZXQgYml0bWFwID0gdGhpcy4jYml0bWFwO1xuICAgIGxldCB3aWR0aCA9IGJpdG1hcFdpZHRoLFxuICAgICAgaGVpZ2h0ID0gYml0bWFwSGVpZ2h0O1xuICAgIGxldCBjYW52YXMgPSBudWxsO1xuICAgIGlmIChtYXhQcmV2aWV3RGltZW5zaW9uKSB7XG4gICAgICBpZiAoYml0bWFwV2lkdGggPiBtYXhQcmV2aWV3RGltZW5zaW9uIHx8IGJpdG1hcEhlaWdodCA+IG1heFByZXZpZXdEaW1lbnNpb24pIHtcbiAgICAgICAgY29uc3QgcmF0aW8gPSBNYXRoLm1pbihtYXhQcmV2aWV3RGltZW5zaW9uIC8gYml0bWFwV2lkdGgsIG1heFByZXZpZXdEaW1lbnNpb24gLyBiaXRtYXBIZWlnaHQpO1xuICAgICAgICB3aWR0aCA9IE1hdGguZmxvb3IoYml0bWFwV2lkdGggKiByYXRpbyk7XG4gICAgICAgIGhlaWdodCA9IE1hdGguZmxvb3IoYml0bWFwSGVpZ2h0ICogcmF0aW8pO1xuICAgICAgfVxuICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgIGNvbnN0IHNjYWxlZFdpZHRoID0gY2FudmFzLndpZHRoID0gTWF0aC5jZWlsKHdpZHRoICogb3V0cHV0U2NhbGUuc3gpO1xuICAgICAgY29uc3Qgc2NhbGVkSGVpZ2h0ID0gY2FudmFzLmhlaWdodCA9IE1hdGguY2VpbChoZWlnaHQgKiBvdXRwdXRTY2FsZS5zeSk7XG4gICAgICBpZiAoIXRoaXMuI2lzU3ZnKSB7XG4gICAgICAgIGJpdG1hcCA9IHRoaXMuI3NjYWxlQml0bWFwKHNjYWxlZFdpZHRoLCBzY2FsZWRIZWlnaHQpO1xuICAgICAgfVxuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIGN0eC5maWx0ZXIgPSB0aGlzLl91aU1hbmFnZXIuaGNtRmlsdGVyO1xuICAgICAgbGV0IHdoaXRlID0gXCJ3aGl0ZVwiLFxuICAgICAgICBibGFjayA9IFwiI2NmY2ZkOFwiO1xuICAgICAgaWYgKHRoaXMuX3VpTWFuYWdlci5oY21GaWx0ZXIgIT09IFwibm9uZVwiKSB7XG4gICAgICAgIGJsYWNrID0gXCJibGFja1wiO1xuICAgICAgfSBlbHNlIGlmICh3aW5kb3cubWF0Y2hNZWRpYT8uKFwiKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKVwiKS5tYXRjaGVzKSB7XG4gICAgICAgIHdoaXRlID0gXCIjOGY4ZjlkXCI7XG4gICAgICAgIGJsYWNrID0gXCIjNDI0MTRkXCI7XG4gICAgICB9XG4gICAgICBjb25zdCBib3hEaW0gPSAxNTtcbiAgICAgIGNvbnN0IGJveERpbVdpZHRoID0gYm94RGltICogb3V0cHV0U2NhbGUuc3g7XG4gICAgICBjb25zdCBib3hEaW1IZWlnaHQgPSBib3hEaW0gKiBvdXRwdXRTY2FsZS5zeTtcbiAgICAgIGNvbnN0IHBhdHRlcm4gPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKGJveERpbVdpZHRoICogMiwgYm94RGltSGVpZ2h0ICogMik7XG4gICAgICBjb25zdCBwYXR0ZXJuQ3R4ID0gcGF0dGVybi5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBwYXR0ZXJuQ3R4LmZpbGxTdHlsZSA9IHdoaXRlO1xuICAgICAgcGF0dGVybkN0eC5maWxsUmVjdCgwLCAwLCBib3hEaW1XaWR0aCAqIDIsIGJveERpbUhlaWdodCAqIDIpO1xuICAgICAgcGF0dGVybkN0eC5maWxsU3R5bGUgPSBibGFjaztcbiAgICAgIHBhdHRlcm5DdHguZmlsbFJlY3QoMCwgMCwgYm94RGltV2lkdGgsIGJveERpbUhlaWdodCk7XG4gICAgICBwYXR0ZXJuQ3R4LmZpbGxSZWN0KGJveERpbVdpZHRoLCBib3hEaW1IZWlnaHQsIGJveERpbVdpZHRoLCBib3hEaW1IZWlnaHQpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGN0eC5jcmVhdGVQYXR0ZXJuKHBhdHRlcm4sIFwicmVwZWF0XCIpO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHNjYWxlZFdpZHRoLCBzY2FsZWRIZWlnaHQpO1xuICAgICAgY3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDAsIGJpdG1hcC53aWR0aCwgYml0bWFwLmhlaWdodCwgMCwgMCwgc2NhbGVkV2lkdGgsIHNjYWxlZEhlaWdodCk7XG4gICAgfVxuICAgIGxldCBpbWFnZURhdGEgPSBudWxsO1xuICAgIGlmIChjcmVhdGVJbWFnZURhdGEpIHtcbiAgICAgIGxldCBkYXRhV2lkdGgsIGRhdGFIZWlnaHQ7XG4gICAgICBpZiAob3V0cHV0U2NhbGUuc3ltbWV0cmljICYmIGJpdG1hcC53aWR0aCA8IG1heERhdGFEaW1lbnNpb24gJiYgYml0bWFwLmhlaWdodCA8IG1heERhdGFEaW1lbnNpb24pIHtcbiAgICAgICAgZGF0YVdpZHRoID0gYml0bWFwLndpZHRoO1xuICAgICAgICBkYXRhSGVpZ2h0ID0gYml0bWFwLmhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJpdG1hcCA9IHRoaXMuI2JpdG1hcDtcbiAgICAgICAgaWYgKGJpdG1hcFdpZHRoID4gbWF4RGF0YURpbWVuc2lvbiB8fCBiaXRtYXBIZWlnaHQgPiBtYXhEYXRhRGltZW5zaW9uKSB7XG4gICAgICAgICAgY29uc3QgcmF0aW8gPSBNYXRoLm1pbihtYXhEYXRhRGltZW5zaW9uIC8gYml0bWFwV2lkdGgsIG1heERhdGFEaW1lbnNpb24gLyBiaXRtYXBIZWlnaHQpO1xuICAgICAgICAgIGRhdGFXaWR0aCA9IE1hdGguZmxvb3IoYml0bWFwV2lkdGggKiByYXRpbyk7XG4gICAgICAgICAgZGF0YUhlaWdodCA9IE1hdGguZmxvb3IoYml0bWFwSGVpZ2h0ICogcmF0aW8pO1xuICAgICAgICAgIGlmICghdGhpcy4jaXNTdmcpIHtcbiAgICAgICAgICAgIGJpdG1hcCA9IHRoaXMuI3NjYWxlQml0bWFwKGRhdGFXaWR0aCwgZGF0YUhlaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBvZmZzY3JlZW4gPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKGRhdGFXaWR0aCwgZGF0YUhlaWdodCk7XG4gICAgICBjb25zdCBvZmZzY3JlZW5DdHggPSBvZmZzY3JlZW4uZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgICAgd2lsbFJlYWRGcmVxdWVudGx5OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIG9mZnNjcmVlbkN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwLCBiaXRtYXAud2lkdGgsIGJpdG1hcC5oZWlnaHQsIDAsIDAsIGRhdGFXaWR0aCwgZGF0YUhlaWdodCk7XG4gICAgICBpbWFnZURhdGEgPSB7XG4gICAgICAgIHdpZHRoOiBkYXRhV2lkdGgsXG4gICAgICAgIGhlaWdodDogZGF0YUhlaWdodCxcbiAgICAgICAgZGF0YTogb2Zmc2NyZWVuQ3R4LmdldEltYWdlRGF0YSgwLCAwLCBkYXRhV2lkdGgsIGRhdGFIZWlnaHQpLmRhdGFcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBjYW52YXMsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGltYWdlRGF0YVxuICAgIH07XG4gIH1cbiAgI3NldERpbWVuc2lvbnMod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICB0aGlzLndpZHRoID0gd2lkdGggLyBwYXJlbnRXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAvIHBhcmVudEhlaWdodDtcbiAgICBpZiAodGhpcy5faW5pdGlhbE9wdGlvbnM/LmlzQ2VudGVyZWQpIHtcbiAgICAgIHRoaXMuY2VudGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICB9XG4gICAgdGhpcy5faW5pdGlhbE9wdGlvbnMgPSBudWxsO1xuICAgIGlmICh0aGlzLiNyZXNpemVUaW1lb3V0SWQgIT09IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNyZXNpemVUaW1lb3V0SWQpO1xuICAgIH1cbiAgICBjb25zdCBUSU1FX1RPX1dBSVQgPSAyMDA7XG4gICAgdGhpcy4jcmVzaXplVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLiNyZXNpemVUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgdGhpcy4jZHJhd0JpdG1hcCh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LCBUSU1FX1RPX1dBSVQpO1xuICB9XG4gICNzY2FsZUJpdG1hcCh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGg6IGJpdG1hcFdpZHRoLFxuICAgICAgaGVpZ2h0OiBiaXRtYXBIZWlnaHRcbiAgICB9ID0gdGhpcy4jYml0bWFwO1xuICAgIGxldCBuZXdXaWR0aCA9IGJpdG1hcFdpZHRoO1xuICAgIGxldCBuZXdIZWlnaHQgPSBiaXRtYXBIZWlnaHQ7XG4gICAgbGV0IGJpdG1hcCA9IHRoaXMuI2JpdG1hcDtcbiAgICB3aGlsZSAobmV3V2lkdGggPiAyICogd2lkdGggfHwgbmV3SGVpZ2h0ID4gMiAqIGhlaWdodCkge1xuICAgICAgY29uc3QgcHJldldpZHRoID0gbmV3V2lkdGg7XG4gICAgICBjb25zdCBwcmV2SGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgaWYgKG5ld1dpZHRoID4gMiAqIHdpZHRoKSB7XG4gICAgICAgIG5ld1dpZHRoID0gbmV3V2lkdGggPj0gMTYzODQgPyBNYXRoLmZsb29yKG5ld1dpZHRoIC8gMikgLSAxIDogTWF0aC5jZWlsKG5ld1dpZHRoIC8gMik7XG4gICAgICB9XG4gICAgICBpZiAobmV3SGVpZ2h0ID4gMiAqIGhlaWdodCkge1xuICAgICAgICBuZXdIZWlnaHQgPSBuZXdIZWlnaHQgPj0gMTYzODQgPyBNYXRoLmZsb29yKG5ld0hlaWdodCAvIDIpIC0gMSA6IE1hdGguY2VpbChuZXdIZWlnaHQgLyAyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9mZnNjcmVlbiA9IG5ldyBPZmZzY3JlZW5DYW52YXMobmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICBjb25zdCBjdHggPSBvZmZzY3JlZW4uZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgY3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDAsIHByZXZXaWR0aCwgcHJldkhlaWdodCwgMCwgMCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICBiaXRtYXAgPSBvZmZzY3JlZW4udHJhbnNmZXJUb0ltYWdlQml0bWFwKCk7XG4gICAgfVxuICAgIHJldHVybiBiaXRtYXA7XG4gIH1cbiAgI2RyYXdCaXRtYXAod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IG91dHB1dFNjYWxlID0gbmV3IE91dHB1dFNjYWxlKCk7XG4gICAgY29uc3Qgc2NhbGVkV2lkdGggPSBNYXRoLmNlaWwod2lkdGggKiBvdXRwdXRTY2FsZS5zeCk7XG4gICAgY29uc3Qgc2NhbGVkSGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCAqIG91dHB1dFNjYWxlLnN5KTtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLiNjYW52YXM7XG4gICAgaWYgKCFjYW52YXMgfHwgY2FudmFzLndpZHRoID09PSBzY2FsZWRXaWR0aCAmJiBjYW52YXMuaGVpZ2h0ID09PSBzY2FsZWRIZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FudmFzLndpZHRoID0gc2NhbGVkV2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IHNjYWxlZEhlaWdodDtcbiAgICBjb25zdCBiaXRtYXAgPSB0aGlzLiNpc1N2ZyA/IHRoaXMuI2JpdG1hcCA6IHRoaXMuI3NjYWxlQml0bWFwKHNjYWxlZFdpZHRoLCBzY2FsZWRIZWlnaHQpO1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgY3R4LmZpbHRlciA9IHRoaXMuX3VpTWFuYWdlci5oY21GaWx0ZXI7XG4gICAgY3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDAsIGJpdG1hcC53aWR0aCwgYml0bWFwLmhlaWdodCwgMCwgMCwgc2NhbGVkV2lkdGgsIHNjYWxlZEhlaWdodCk7XG4gIH1cbiAgZ2V0SW1hZ2VGb3JBbHRUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLiNjYW52YXM7XG4gIH1cbiAgI3NlcmlhbGl6ZUJpdG1hcCh0b1VybCkge1xuICAgIGlmICh0b1VybCkge1xuICAgICAgaWYgKHRoaXMuI2lzU3ZnKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IHRoaXMuX3VpTWFuYWdlci5pbWFnZU1hbmFnZXIuZ2V0U3ZnVXJsKHRoaXMuI2JpdG1hcElkKTtcbiAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgIHJldHVybiB1cmw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAoe1xuICAgICAgICB3aWR0aDogY2FudmFzLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHRcbiAgICAgIH0gPSB0aGlzLiNiaXRtYXApO1xuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy4jYml0bWFwLCAwLCAwKTtcbiAgICAgIHJldHVybiBjYW52YXMudG9EYXRhVVJMKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNpc1N2Zykge1xuICAgICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLnJvdW5kKHRoaXMud2lkdGggKiBwYWdlV2lkdGggKiBQaXhlbHNQZXJJbmNoLlBERl9UT19DU1NfVU5JVFMpO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5yb3VuZCh0aGlzLmhlaWdodCAqIHBhZ2VIZWlnaHQgKiBQaXhlbHNQZXJJbmNoLlBERl9UT19DU1NfVU5JVFMpO1xuICAgICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGNvbnN0IGN0eCA9IG9mZnNjcmVlbi5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBjdHguZHJhd0ltYWdlKHRoaXMuI2JpdG1hcCwgMCwgMCwgdGhpcy4jYml0bWFwLndpZHRoLCB0aGlzLiNiaXRtYXAuaGVpZ2h0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHJldHVybiBvZmZzY3JlZW4udHJhbnNmZXJUb0ltYWdlQml0bWFwKCk7XG4gICAgfVxuICAgIHJldHVybiBzdHJ1Y3R1cmVkQ2xvbmUodGhpcy4jYml0bWFwKTtcbiAgfVxuICAjY3JlYXRlT2JzZXJ2ZXIoKSB7XG4gICAgaWYgKCF0aGlzLl91aU1hbmFnZXIuX3NpZ25hbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICAgIGNvbnN0IHJlY3QgPSBlbnRyaWVzWzBdLmNvbnRlbnRSZWN0O1xuICAgICAgaWYgKHJlY3Qud2lkdGggJiYgcmVjdC5oZWlnaHQpIHtcbiAgICAgICAgdGhpcy4jc2V0RGltZW5zaW9ucyhyZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy4jb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmRpdik7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLl9zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHtcbiAgICAgIHRoaXMuI29ic2VydmVyPy5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLiNvYnNlcnZlciA9IG51bGw7XG4gICAgfSwge1xuICAgICAgb25jZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBhc3luYyBkZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcikge1xuICAgIGxldCBpbml0aWFsRGF0YSA9IG51bGw7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBTdGFtcEFubm90YXRpb25FbGVtZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICByZWN0LFxuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIHN0cnVjdFBhcmVudCxcbiAgICAgICAgICBwb3B1cFJlZlxuICAgICAgICB9LFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIHBhcmVudDoge1xuICAgICAgICAgIHBhZ2U6IHtcbiAgICAgICAgICAgIHBhZ2VOdW1iZXJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gPSBkYXRhO1xuICAgICAgY29uc3QgY2FudmFzID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCJjYW52YXNcIik7XG4gICAgICBjb25zdCBpbWFnZURhdGEgPSB1aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldEZyb21DYW52YXMoY29udGFpbmVyLmlkLCBjYW52YXMpO1xuICAgICAgY2FudmFzLnJlbW92ZSgpO1xuICAgICAgY29uc3QgYWx0VGV4dCA9IChhd2FpdCBwYXJlbnQuX3N0cnVjdFRyZWUuZ2V0QXJpYUF0dHJpYnV0ZXMoYCR7QW5ub3RhdGlvblByZWZpeH0ke2lkfWApKT8uZ2V0KFwiYXJpYS1sYWJlbFwiKSB8fCBcIlwiO1xuICAgICAgaW5pdGlhbERhdGEgPSBkYXRhID0ge1xuICAgICAgICBhbm5vdGF0aW9uVHlwZTogQW5ub3RhdGlvbkVkaXRvclR5cGUuU1RBTVAsXG4gICAgICAgIGJpdG1hcElkOiBpbWFnZURhdGEuaWQsXG4gICAgICAgIGJpdG1hcDogaW1hZ2VEYXRhLmJpdG1hcCxcbiAgICAgICAgcGFnZUluZGV4OiBwYWdlTnVtYmVyIC0gMSxcbiAgICAgICAgcmVjdDogcmVjdC5zbGljZSgwKSxcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIGlkLFxuICAgICAgICBkZWxldGVkOiBmYWxzZSxcbiAgICAgICAgYWNjZXNzaWJpbGl0eURhdGE6IHtcbiAgICAgICAgICBkZWNvcmF0aXZlOiBmYWxzZSxcbiAgICAgICAgICBhbHRUZXh0XG4gICAgICAgIH0sXG4gICAgICAgIGlzU3ZnOiBmYWxzZSxcbiAgICAgICAgc3RydWN0UGFyZW50LFxuICAgICAgICBwb3B1cFJlZlxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZWRpdG9yID0gYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlY3QsXG4gICAgICBiaXRtYXAsXG4gICAgICBiaXRtYXBVcmwsXG4gICAgICBiaXRtYXBJZCxcbiAgICAgIGlzU3ZnLFxuICAgICAgYWNjZXNzaWJpbGl0eURhdGFcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoYml0bWFwSWQgJiYgdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5pc1ZhbGlkSWQoYml0bWFwSWQpKSB7XG4gICAgICBlZGl0b3IuI2JpdG1hcElkID0gYml0bWFwSWQ7XG4gICAgICBpZiAoYml0bWFwKSB7XG4gICAgICAgIGVkaXRvci4jYml0bWFwID0gYml0bWFwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlZGl0b3IuI2JpdG1hcFVybCA9IGJpdG1hcFVybDtcbiAgICB9XG4gICAgZWRpdG9yLiNpc1N2ZyA9IGlzU3ZnO1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IGVkaXRvci5wYWdlRGltZW5zaW9ucztcbiAgICBlZGl0b3Iud2lkdGggPSAocmVjdFsyXSAtIHJlY3RbMF0pIC8gcGFyZW50V2lkdGg7XG4gICAgZWRpdG9yLmhlaWdodCA9IChyZWN0WzNdIC0gcmVjdFsxXSkgLyBwYXJlbnRIZWlnaHQ7XG4gICAgZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQgPSBkYXRhLmlkIHx8IG51bGw7XG4gICAgaWYgKGFjY2Vzc2liaWxpdHlEYXRhKSB7XG4gICAgICBlZGl0b3IuYWx0VGV4dERhdGEgPSBhY2Nlc3NpYmlsaXR5RGF0YTtcbiAgICB9XG4gICAgZWRpdG9yLl9pbml0aWFsRGF0YSA9IGluaXRpYWxEYXRhO1xuICAgIGVkaXRvci4jaGFzQmVlbkFkZGVkSW5VbmRvU3RhY2sgPSAhIWluaXRpYWxEYXRhO1xuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgc2VyaWFsaXplKGlzRm9yQ29weWluZyA9IGZhbHNlLCBjb250ZXh0ID0gbnVsbCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZURlbGV0ZWQoKTtcbiAgICB9XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHtcbiAgICAgIGFubm90YXRpb25UeXBlOiBBbm5vdGF0aW9uRWRpdG9yVHlwZS5TVEFNUCxcbiAgICAgIGJpdG1hcElkOiB0aGlzLiNiaXRtYXBJZCxcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5wYWdlSW5kZXgsXG4gICAgICByZWN0OiB0aGlzLmdldFJlY3QoMCwgMCksXG4gICAgICByb3RhdGlvbjogdGhpcy5yb3RhdGlvbixcbiAgICAgIGlzU3ZnOiB0aGlzLiNpc1N2ZyxcbiAgICAgIHN0cnVjdFRyZWVQYXJlbnRJZDogdGhpcy5fc3RydWN0VHJlZVBhcmVudElkXG4gICAgfTtcbiAgICBpZiAoaXNGb3JDb3B5aW5nKSB7XG4gICAgICBzZXJpYWxpemVkLmJpdG1hcFVybCA9IHRoaXMuI3NlcmlhbGl6ZUJpdG1hcCh0cnVlKTtcbiAgICAgIHNlcmlhbGl6ZWQuYWNjZXNzaWJpbGl0eURhdGEgPSB0aGlzLnNlcmlhbGl6ZUFsdFRleHQodHJ1ZSk7XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZGVjb3JhdGl2ZSxcbiAgICAgIGFsdFRleHRcbiAgICB9ID0gdGhpcy5zZXJpYWxpemVBbHRUZXh0KGZhbHNlKTtcbiAgICBpZiAoIWRlY29yYXRpdmUgJiYgYWx0VGV4dCkge1xuICAgICAgc2VyaWFsaXplZC5hY2Nlc3NpYmlsaXR5RGF0YSA9IHtcbiAgICAgICAgdHlwZTogXCJGaWd1cmVcIixcbiAgICAgICAgYWx0OiBhbHRUZXh0XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy4jaGFzRWxlbWVudENoYW5nZWQoc2VyaWFsaXplZCk7XG4gICAgICBpZiAoY2hhbmdlcy5pc1NhbWUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoY2hhbmdlcy5pc1NhbWVBbHRUZXh0KSB7XG4gICAgICAgIGRlbGV0ZSBzZXJpYWxpemVkLmFjY2Vzc2liaWxpdHlEYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VyaWFsaXplZC5hY2Nlc3NpYmlsaXR5RGF0YS5zdHJ1Y3RQYXJlbnQgPSB0aGlzLl9pbml0aWFsRGF0YS5zdHJ1Y3RQYXJlbnQgPz8gLTE7XG4gICAgICB9XG4gICAgfVxuICAgIHNlcmlhbGl6ZWQuaWQgPSB0aGlzLmFubm90YXRpb25FbGVtZW50SWQ7XG4gICAgaWYgKGNvbnRleHQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbiAgICBjb250ZXh0LnN0YW1wcyB8fD0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGFyZWEgPSB0aGlzLiNpc1N2ZyA/IChzZXJpYWxpemVkLnJlY3RbMl0gLSBzZXJpYWxpemVkLnJlY3RbMF0pICogKHNlcmlhbGl6ZWQucmVjdFszXSAtIHNlcmlhbGl6ZWQucmVjdFsxXSkgOiBudWxsO1xuICAgIGlmICghY29udGV4dC5zdGFtcHMuaGFzKHRoaXMuI2JpdG1hcElkKSkge1xuICAgICAgY29udGV4dC5zdGFtcHMuc2V0KHRoaXMuI2JpdG1hcElkLCB7XG4gICAgICAgIGFyZWEsXG4gICAgICAgIHNlcmlhbGl6ZWRcbiAgICAgIH0pO1xuICAgICAgc2VyaWFsaXplZC5iaXRtYXAgPSB0aGlzLiNzZXJpYWxpemVCaXRtYXAoZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAodGhpcy4jaXNTdmcpIHtcbiAgICAgIGNvbnN0IHByZXZEYXRhID0gY29udGV4dC5zdGFtcHMuZ2V0KHRoaXMuI2JpdG1hcElkKTtcbiAgICAgIGlmIChhcmVhID4gcHJldkRhdGEuYXJlYSkge1xuICAgICAgICBwcmV2RGF0YS5hcmVhID0gYXJlYTtcbiAgICAgICAgcHJldkRhdGEuc2VyaWFsaXplZC5iaXRtYXAuY2xvc2UoKTtcbiAgICAgICAgcHJldkRhdGEuc2VyaWFsaXplZC5iaXRtYXAgPSB0aGlzLiNzZXJpYWxpemVCaXRtYXAoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgfVxuICAjaGFzRWxlbWVudENoYW5nZWQoc2VyaWFsaXplZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VJbmRleCxcbiAgICAgIGFjY2Vzc2liaWxpdHlEYXRhOiB7XG4gICAgICAgIGFsdFRleHRcbiAgICAgIH1cbiAgICB9ID0gdGhpcy5faW5pdGlhbERhdGE7XG4gICAgY29uc3QgaXNTYW1lUGFnZUluZGV4ID0gc2VyaWFsaXplZC5wYWdlSW5kZXggPT09IHBhZ2VJbmRleDtcbiAgICBjb25zdCBpc1NhbWVBbHRUZXh0ID0gKHNlcmlhbGl6ZWQuYWNjZXNzaWJpbGl0eURhdGE/LmFsdCB8fCBcIlwiKSA9PT0gYWx0VGV4dDtcbiAgICByZXR1cm4ge1xuICAgICAgaXNTYW1lOiAhdGhpcy5faGFzQmVlbk1vdmVkICYmICF0aGlzLl9oYXNCZWVuUmVzaXplZCAmJiBpc1NhbWVQYWdlSW5kZXggJiYgaXNTYW1lQWx0VGV4dCxcbiAgICAgIGlzU2FtZUFsdFRleHRcbiAgICB9O1xuICB9XG4gIHJlbmRlckFubm90YXRpb25FbGVtZW50KGFubm90YXRpb24pIHtcbiAgICBhbm5vdGF0aW9uLnVwZGF0ZUVkaXRlZCh7XG4gICAgICByZWN0OiB0aGlzLmdldFJlY3QoMCwgMClcbiAgICB9KTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvYW5ub3RhdGlvbl9lZGl0b3JfbGF5ZXIuanNcblxuXG5cblxuXG5cblxuY2xhc3MgQW5ub3RhdGlvbkVkaXRvckxheWVyIHtcbiAgI2FjY2Vzc2liaWxpdHlNYW5hZ2VyO1xuICAjYWxsb3dDbGljayA9IGZhbHNlO1xuICAjYW5ub3RhdGlvbkxheWVyID0gbnVsbDtcbiAgI2NsaWNrQUMgPSBudWxsO1xuICAjZWRpdG9yRm9jdXNUaW1lb3V0SWQgPSBudWxsO1xuICAjZWRpdG9ycyA9IG5ldyBNYXAoKTtcbiAgI2hhZFBvaW50ZXJEb3duID0gZmFsc2U7XG4gICNpc0Rpc2FibGluZyA9IGZhbHNlO1xuICAjZHJhd2luZ0FDID0gbnVsbDtcbiAgI3RleHRMYXllciA9IG51bGw7XG4gICN0ZXh0U2VsZWN0aW9uQUMgPSBudWxsO1xuICAjdWlNYW5hZ2VyO1xuICBzdGF0aWMgX2luaXRpYWxpemVkID0gZmFsc2U7XG4gIHN0YXRpYyAjZWRpdG9yVHlwZXMgPSBuZXcgTWFwKFtGcmVlVGV4dEVkaXRvciwgSW5rRWRpdG9yLCBTdGFtcEVkaXRvciwgSGlnaGxpZ2h0RWRpdG9yXS5tYXAodHlwZSA9PiBbdHlwZS5fZWRpdG9yVHlwZSwgdHlwZV0pKTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHVpTWFuYWdlcixcbiAgICBwYWdlSW5kZXgsXG4gICAgZGl2LFxuICAgIHN0cnVjdFRyZWVMYXllcixcbiAgICBhY2Nlc3NpYmlsaXR5TWFuYWdlcixcbiAgICBhbm5vdGF0aW9uTGF5ZXIsXG4gICAgZHJhd0xheWVyLFxuICAgIHRleHRMYXllcixcbiAgICB2aWV3cG9ydCxcbiAgICBsMTBuXG4gIH0pIHtcbiAgICBjb25zdCBlZGl0b3JUeXBlcyA9IFsuLi5Bbm5vdGF0aW9uRWRpdG9yTGF5ZXIuI2VkaXRvclR5cGVzLnZhbHVlcygpXTtcbiAgICBpZiAoIUFubm90YXRpb25FZGl0b3JMYXllci5faW5pdGlhbGl6ZWQpIHtcbiAgICAgIEFubm90YXRpb25FZGl0b3JMYXllci5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIGVkaXRvclR5cGVzKSB7XG4gICAgICAgIGVkaXRvclR5cGUuaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICB1aU1hbmFnZXIucmVnaXN0ZXJFZGl0b3JUeXBlcyhlZGl0b3JUeXBlcyk7XG4gICAgdGhpcy4jdWlNYW5hZ2VyID0gdWlNYW5hZ2VyO1xuICAgIHRoaXMucGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgIHRoaXMuZGl2ID0gZGl2O1xuICAgIHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyID0gYWNjZXNzaWJpbGl0eU1hbmFnZXI7XG4gICAgdGhpcy4jYW5ub3RhdGlvbkxheWVyID0gYW5ub3RhdGlvbkxheWVyO1xuICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICB0aGlzLiN0ZXh0TGF5ZXIgPSB0ZXh0TGF5ZXI7XG4gICAgdGhpcy5kcmF3TGF5ZXIgPSBkcmF3TGF5ZXI7XG4gICAgdGhpcy5fc3RydWN0VHJlZSA9IHN0cnVjdFRyZWVMYXllcjtcbiAgICB0aGlzLiN1aU1hbmFnZXIuYWRkTGF5ZXIodGhpcyk7XG4gIH1cbiAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2VkaXRvcnMuc2l6ZSA9PT0gMDtcbiAgfVxuICBnZXQgaXNJbnZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNFbXB0eSAmJiB0aGlzLiN1aU1hbmFnZXIuZ2V0TW9kZSgpID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FO1xuICB9XG4gIHVwZGF0ZVRvb2xiYXIobW9kZSkge1xuICAgIHRoaXMuI3VpTWFuYWdlci51cGRhdGVUb29sYmFyKG1vZGUpO1xuICB9XG4gIHVwZGF0ZU1vZGUobW9kZSA9IHRoaXMuI3VpTWFuYWdlci5nZXRNb2RlKCkpIHtcbiAgICB0aGlzLiNjbGVhbnVwKCk7XG4gICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JUeXBlLk5PTkU6XG4gICAgICAgIHRoaXMuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy50b2dnbGVQb2ludGVyRXZlbnRzKGZhbHNlKTtcbiAgICAgICAgdGhpcy50b2dnbGVBbm5vdGF0aW9uTGF5ZXJQb2ludGVyRXZlbnRzKHRydWUpO1xuICAgICAgICB0aGlzLmRpc2FibGVDbGljaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JUeXBlLklOSzpcbiAgICAgICAgdGhpcy5kaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLnRvZ2dsZVBvaW50ZXJFdmVudHModHJ1ZSk7XG4gICAgICAgIHRoaXMuZW5hYmxlQ2xpY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVDpcbiAgICAgICAgdGhpcy5lbmFibGVUZXh0U2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMudG9nZ2xlUG9pbnRlckV2ZW50cyhmYWxzZSk7XG4gICAgICAgIHRoaXMuZGlzYWJsZUNsaWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5kaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLnRvZ2dsZVBvaW50ZXJFdmVudHModHJ1ZSk7XG4gICAgICAgIHRoaXMuZW5hYmxlQ2xpY2soKTtcbiAgICB9XG4gICAgdGhpcy50b2dnbGVBbm5vdGF0aW9uTGF5ZXJQb2ludGVyRXZlbnRzKGZhbHNlKTtcbiAgICBjb25zdCB7XG4gICAgICBjbGFzc0xpc3RcbiAgICB9ID0gdGhpcy5kaXY7XG4gICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIEFubm90YXRpb25FZGl0b3JMYXllci4jZWRpdG9yVHlwZXMudmFsdWVzKCkpIHtcbiAgICAgIGNsYXNzTGlzdC50b2dnbGUoYCR7ZWRpdG9yVHlwZS5fdHlwZX1FZGl0aW5nYCwgbW9kZSA9PT0gZWRpdG9yVHlwZS5fZWRpdG9yVHlwZSk7XG4gICAgfVxuICAgIHRoaXMuZGl2LmhpZGRlbiA9IGZhbHNlO1xuICB9XG4gIGhhc1RleHRMYXllcih0ZXh0TGF5ZXIpIHtcbiAgICByZXR1cm4gdGV4dExheWVyID09PSB0aGlzLiN0ZXh0TGF5ZXI/LmRpdjtcbiAgfVxuICBzZXRFZGl0aW5nU3RhdGUoaXNFZGl0aW5nKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnNldEVkaXRpbmdTdGF0ZShpc0VkaXRpbmcpO1xuICB9XG4gIGFkZENvbW1hbmRzKHBhcmFtcykge1xuICAgIHRoaXMuI3VpTWFuYWdlci5hZGRDb21tYW5kcyhwYXJhbXMpO1xuICB9XG4gIGNsZWFuVW5kb1N0YWNrKHR5cGUpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIuY2xlYW5VbmRvU3RhY2sodHlwZSk7XG4gIH1cbiAgdG9nZ2xlRHJhd2luZyhlbmFibGVkID0gZmFsc2UpIHtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZHJhd2luZ1wiLCAhZW5hYmxlZCk7XG4gIH1cbiAgdG9nZ2xlUG9pbnRlckV2ZW50cyhlbmFibGVkID0gZmFsc2UpIHtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZGlzYWJsZWRcIiwgIWVuYWJsZWQpO1xuICB9XG4gIHRvZ2dsZUFubm90YXRpb25MYXllclBvaW50ZXJFdmVudHMoZW5hYmxlZCA9IGZhbHNlKSB7XG4gICAgdGhpcy4jYW5ub3RhdGlvbkxheWVyPy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImRpc2FibGVkXCIsICFlbmFibGVkKTtcbiAgfVxuICBhc3luYyBlbmFibGUoKSB7XG4gICAgdGhpcy5kaXYudGFiSW5kZXggPSAwO1xuICAgIHRoaXMudG9nZ2xlUG9pbnRlckV2ZW50cyh0cnVlKTtcbiAgICBjb25zdCBhbm5vdGF0aW9uRWxlbWVudElkcyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNlZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBlZGl0b3IuZW5hYmxlRWRpdGluZygpO1xuICAgICAgZWRpdG9yLnNob3codHJ1ZSk7XG4gICAgICBpZiAoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgICAgdGhpcy4jdWlNYW5hZ2VyLnJlbW92ZUNoYW5nZWRFeGlzdGluZ0Fubm90YXRpb24oZWRpdG9yKTtcbiAgICAgICAgYW5ub3RhdGlvbkVsZW1lbnRJZHMuYWRkKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLiNhbm5vdGF0aW9uTGF5ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZWRpdGFibGVzID0gdGhpcy4jYW5ub3RhdGlvbkxheWVyLmdldEVkaXRhYmxlQW5ub3RhdGlvbnMoKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRhYmxlIG9mIGVkaXRhYmxlcykge1xuICAgICAgZWRpdGFibGUuaGlkZSgpO1xuICAgICAgaWYgKHRoaXMuI3VpTWFuYWdlci5pc0RlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChlZGl0YWJsZS5kYXRhLmlkKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChhbm5vdGF0aW9uRWxlbWVudElkcy5oYXMoZWRpdGFibGUuZGF0YS5pZCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBlZGl0b3IgPSBhd2FpdCB0aGlzLmRlc2VyaWFsaXplKGVkaXRhYmxlKTtcbiAgICAgIGlmICghZWRpdG9yKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5hZGRPclJlYnVpbGQoZWRpdG9yKTtcbiAgICAgIGVkaXRvci5lbmFibGVFZGl0aW5nKCk7XG4gICAgfVxuICB9XG4gIGRpc2FibGUoKSB7XG4gICAgdGhpcy4jaXNEaXNhYmxpbmcgPSB0cnVlO1xuICAgIHRoaXMuZGl2LnRhYkluZGV4ID0gLTE7XG4gICAgdGhpcy50b2dnbGVQb2ludGVyRXZlbnRzKGZhbHNlKTtcbiAgICBjb25zdCBjaGFuZ2VkQW5ub3RhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgcmVzZXRBbm5vdGF0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNlZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBlZGl0b3IuZGlzYWJsZUVkaXRpbmcoKTtcbiAgICAgIGlmICghZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoZWRpdG9yLnNlcmlhbGl6ZSgpICE9PSBudWxsKSB7XG4gICAgICAgIGNoYW5nZWRBbm5vdGF0aW9ucy5zZXQoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQsIGVkaXRvcik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzZXRBbm5vdGF0aW9ucy5zZXQoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQsIGVkaXRvcik7XG4gICAgICB9XG4gICAgICB0aGlzLmdldEVkaXRhYmxlQW5ub3RhdGlvbihlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCk/LnNob3coKTtcbiAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2Fubm90YXRpb25MYXllcikge1xuICAgICAgY29uc3QgZWRpdGFibGVzID0gdGhpcy4jYW5ub3RhdGlvbkxheWVyLmdldEVkaXRhYmxlQW5ub3RhdGlvbnMoKTtcbiAgICAgIGZvciAoY29uc3QgZWRpdGFibGUgb2YgZWRpdGFibGVzKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBpZFxuICAgICAgICB9ID0gZWRpdGFibGUuZGF0YTtcbiAgICAgICAgaWYgKHRoaXMuI3VpTWFuYWdlci5pc0RlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChpZCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZWRpdG9yID0gcmVzZXRBbm5vdGF0aW9ucy5nZXQoaWQpO1xuICAgICAgICBpZiAoZWRpdG9yKSB7XG4gICAgICAgICAgZWRpdG9yLnJlc2V0QW5ub3RhdGlvbkVsZW1lbnQoZWRpdGFibGUpO1xuICAgICAgICAgIGVkaXRvci5zaG93KGZhbHNlKTtcbiAgICAgICAgICBlZGl0YWJsZS5zaG93KCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWRpdG9yID0gY2hhbmdlZEFubm90YXRpb25zLmdldChpZCk7XG4gICAgICAgIGlmIChlZGl0b3IpIHtcbiAgICAgICAgICB0aGlzLiN1aU1hbmFnZXIuYWRkQ2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbihlZGl0b3IpO1xuICAgICAgICAgIGlmIChlZGl0b3IucmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoZWRpdGFibGUpKSB7XG4gICAgICAgICAgICBlZGl0b3Iuc2hvdyhmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVkaXRhYmxlLnNob3coKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jY2xlYW51cCgpO1xuICAgIGlmICh0aGlzLmlzRW1wdHkpIHtcbiAgICAgIHRoaXMuZGl2LmhpZGRlbiA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNsYXNzTGlzdFxuICAgIH0gPSB0aGlzLmRpdjtcbiAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgQW5ub3RhdGlvbkVkaXRvckxheWVyLiNlZGl0b3JUeXBlcy52YWx1ZXMoKSkge1xuICAgICAgY2xhc3NMaXN0LnJlbW92ZShgJHtlZGl0b3JUeXBlLl90eXBlfUVkaXRpbmdgKTtcbiAgICB9XG4gICAgdGhpcy5kaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xuICAgIHRoaXMudG9nZ2xlQW5ub3RhdGlvbkxheWVyUG9pbnRlckV2ZW50cyh0cnVlKTtcbiAgICB0aGlzLiNpc0Rpc2FibGluZyA9IGZhbHNlO1xuICB9XG4gIGdldEVkaXRhYmxlQW5ub3RhdGlvbihpZCkge1xuICAgIHJldHVybiB0aGlzLiNhbm5vdGF0aW9uTGF5ZXI/LmdldEVkaXRhYmxlQW5ub3RhdGlvbihpZCkgfHwgbnVsbDtcbiAgfVxuICBzZXRBY3RpdmVFZGl0b3IoZWRpdG9yKSB7XG4gICAgY29uc3QgY3VycmVudEFjdGl2ZSA9IHRoaXMuI3VpTWFuYWdlci5nZXRBY3RpdmUoKTtcbiAgICBpZiAoY3VycmVudEFjdGl2ZSA9PT0gZWRpdG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3VpTWFuYWdlci5zZXRBY3RpdmVFZGl0b3IoZWRpdG9yKTtcbiAgfVxuICBlbmFibGVUZXh0U2VsZWN0aW9uKCkge1xuICAgIHRoaXMuZGl2LnRhYkluZGV4ID0gLTE7XG4gICAgaWYgKHRoaXMuI3RleHRMYXllcj8uZGl2ICYmICF0aGlzLiN0ZXh0U2VsZWN0aW9uQUMpIHtcbiAgICAgIHRoaXMuI3RleHRTZWxlY3Rpb25BQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbCh0aGlzLiN0ZXh0U2VsZWN0aW9uQUMpO1xuICAgICAgdGhpcy4jdGV4dExheWVyLmRpdi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcy4jdGV4dExheWVyUG9pbnRlckRvd24uYmluZCh0aGlzKSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgdGhpcy4jdGV4dExheWVyLmRpdi5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0aW5nXCIpO1xuICAgIH1cbiAgfVxuICBkaXNhYmxlVGV4dFNlbGVjdGlvbigpIHtcbiAgICB0aGlzLmRpdi50YWJJbmRleCA9IDA7XG4gICAgaWYgKHRoaXMuI3RleHRMYXllcj8uZGl2ICYmIHRoaXMuI3RleHRTZWxlY3Rpb25BQykge1xuICAgICAgdGhpcy4jdGV4dFNlbGVjdGlvbkFDLmFib3J0KCk7XG4gICAgICB0aGlzLiN0ZXh0U2VsZWN0aW9uQUMgPSBudWxsO1xuICAgICAgdGhpcy4jdGV4dExheWVyLmRpdi5jbGFzc0xpc3QucmVtb3ZlKFwiaGlnaGxpZ2h0aW5nXCIpO1xuICAgIH1cbiAgfVxuICAjdGV4dExheWVyUG9pbnRlckRvd24oZXZlbnQpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIudW5zZWxlY3RBbGwoKTtcbiAgICBjb25zdCB7XG4gICAgICB0YXJnZXRcbiAgICB9ID0gZXZlbnQ7XG4gICAgaWYgKHRhcmdldCA9PT0gdGhpcy4jdGV4dExheWVyLmRpdiB8fCAodGFyZ2V0LmdldEF0dHJpYnV0ZShcInJvbGVcIikgPT09IFwiaW1nXCIgfHwgdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcImVuZE9mQ29udGVudFwiKSkgJiYgdGhpcy4jdGV4dExheWVyLmRpdi5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGlzTWFjXG4gICAgICB9ID0gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgZXZlbnQuY3RybEtleSAmJiBpc01hYykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLiN1aU1hbmFnZXIuc2hvd0FsbEVkaXRvcnMoXCJoaWdobGlnaHRcIiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICB0aGlzLiN0ZXh0TGF5ZXIuZGl2LmNsYXNzTGlzdC5hZGQoXCJmcmVlXCIpO1xuICAgICAgdGhpcy50b2dnbGVEcmF3aW5nKCk7XG4gICAgICBIaWdobGlnaHRFZGl0b3Iuc3RhcnRIaWdobGlnaHRpbmcodGhpcywgdGhpcy4jdWlNYW5hZ2VyLmRpcmVjdGlvbiA9PT0gXCJsdHJcIiwge1xuICAgICAgICB0YXJnZXQ6IHRoaXMuI3RleHRMYXllci5kaXYsXG4gICAgICAgIHg6IGV2ZW50LngsXG4gICAgICAgIHk6IGV2ZW50LnlcbiAgICAgIH0pO1xuICAgICAgdGhpcy4jdGV4dExheWVyLmRpdi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy4jdGV4dExheWVyLmRpdi5jbGFzc0xpc3QucmVtb3ZlKFwiZnJlZVwiKTtcbiAgICAgICAgdGhpcy50b2dnbGVEcmF3aW5nKHRydWUpO1xuICAgICAgfSwge1xuICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICBzaWduYWw6IHRoaXMuI3VpTWFuYWdlci5fc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG4gIGVuYWJsZUNsaWNrKCkge1xuICAgIGlmICh0aGlzLiNjbGlja0FDKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NsaWNrQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKHRoaXMuI2NsaWNrQUMpO1xuICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLnBvaW50ZXJkb3duLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgdGhpcy5wb2ludGVydXAuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgZGlzYWJsZUNsaWNrKCkge1xuICAgIHRoaXMuI2NsaWNrQUM/LmFib3J0KCk7XG4gICAgdGhpcy4jY2xpY2tBQyA9IG51bGw7XG4gIH1cbiAgYXR0YWNoKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvcnMuc2V0KGVkaXRvci5pZCwgZWRpdG9yKTtcbiAgICBjb25zdCB7XG4gICAgICBhbm5vdGF0aW9uRWxlbWVudElkXG4gICAgfSA9IGVkaXRvcjtcbiAgICBpZiAoYW5ub3RhdGlvbkVsZW1lbnRJZCAmJiB0aGlzLiN1aU1hbmFnZXIuaXNEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbkVsZW1lbnRJZCkpIHtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci5yZW1vdmVEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yKTtcbiAgICB9XG4gIH1cbiAgZGV0YWNoKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvcnMuZGVsZXRlKGVkaXRvci5pZCk7XG4gICAgdGhpcy4jYWNjZXNzaWJpbGl0eU1hbmFnZXI/LnJlbW92ZVBvaW50ZXJJblRleHRMYXllcihlZGl0b3IuY29udGVudERpdik7XG4gICAgaWYgKCF0aGlzLiNpc0Rpc2FibGluZyAmJiBlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLmFkZERlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpO1xuICAgIH1cbiAgfVxuICByZW1vdmUoZWRpdG9yKSB7XG4gICAgdGhpcy5kZXRhY2goZWRpdG9yKTtcbiAgICB0aGlzLiN1aU1hbmFnZXIucmVtb3ZlRWRpdG9yKGVkaXRvcik7XG4gICAgZWRpdG9yLmRpdi5yZW1vdmUoKTtcbiAgICBlZGl0b3IuaXNBdHRhY2hlZFRvRE9NID0gZmFsc2U7XG4gIH1cbiAgY2hhbmdlUGFyZW50KGVkaXRvcikge1xuICAgIGlmIChlZGl0b3IucGFyZW50ID09PSB0aGlzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlZGl0b3IucGFyZW50ICYmIGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIuYWRkRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgICAgIEFubm90YXRpb25FZGl0b3IuZGVsZXRlQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yKTtcbiAgICAgIGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5hdHRhY2goZWRpdG9yKTtcbiAgICBlZGl0b3IucGFyZW50Py5kZXRhY2goZWRpdG9yKTtcbiAgICBlZGl0b3Iuc2V0UGFyZW50KHRoaXMpO1xuICAgIGlmIChlZGl0b3IuZGl2ICYmIGVkaXRvci5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIGVkaXRvci5kaXYucmVtb3ZlKCk7XG4gICAgICB0aGlzLmRpdi5hcHBlbmQoZWRpdG9yLmRpdik7XG4gICAgfVxuICB9XG4gIGFkZChlZGl0b3IpIHtcbiAgICBpZiAoZWRpdG9yLnBhcmVudCA9PT0gdGhpcyAmJiBlZGl0b3IuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY2hhbmdlUGFyZW50KGVkaXRvcik7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLmFkZEVkaXRvcihlZGl0b3IpO1xuICAgIHRoaXMuYXR0YWNoKGVkaXRvcik7XG4gICAgaWYgKCFlZGl0b3IuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICBjb25zdCBkaXYgPSBlZGl0b3IucmVuZGVyKCk7XG4gICAgICB0aGlzLmRpdi5hcHBlbmQoZGl2KTtcbiAgICAgIGVkaXRvci5pc0F0dGFjaGVkVG9ET00gPSB0cnVlO1xuICAgIH1cbiAgICBlZGl0b3IuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICBlZGl0b3Iub25jZUFkZGVkKCk7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLmFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoZWRpdG9yKTtcbiAgICBlZGl0b3IuX3JlcG9ydFRlbGVtZXRyeShlZGl0b3IudGVsZW1ldHJ5SW5pdGlhbERhdGEpO1xuICB9XG4gIG1vdmVFZGl0b3JJbkRPTShlZGl0b3IpIHtcbiAgICBpZiAoIWVkaXRvci5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYWN0aXZlRWxlbWVudFxuICAgIH0gPSBkb2N1bWVudDtcbiAgICBpZiAoZWRpdG9yLmRpdi5jb250YWlucyhhY3RpdmVFbGVtZW50KSAmJiAhdGhpcy4jZWRpdG9yRm9jdXNUaW1lb3V0SWQpIHtcbiAgICAgIGVkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gZmFsc2U7XG4gICAgICB0aGlzLiNlZGl0b3JGb2N1c1RpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLiNlZGl0b3JGb2N1c1RpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgIGlmICghZWRpdG9yLmRpdi5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgICAgIGVkaXRvci5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgKCkgPT4ge1xuICAgICAgICAgICAgZWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSB0cnVlO1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG9uY2U6IHRydWUsXG4gICAgICAgICAgICBzaWduYWw6IHRoaXMuI3VpTWFuYWdlci5fc2lnbmFsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSwgMCk7XG4gICAgfVxuICAgIGVkaXRvci5fc3RydWN0VHJlZVBhcmVudElkID0gdGhpcy4jYWNjZXNzaWJpbGl0eU1hbmFnZXI/Lm1vdmVFbGVtZW50SW5ET00odGhpcy5kaXYsIGVkaXRvci5kaXYsIGVkaXRvci5jb250ZW50RGl2LCB0cnVlKTtcbiAgfVxuICBhZGRPclJlYnVpbGQoZWRpdG9yKSB7XG4gICAgaWYgKGVkaXRvci5uZWVkc1RvQmVSZWJ1aWx0KCkpIHtcbiAgICAgIGVkaXRvci5wYXJlbnQgfHw9IHRoaXM7XG4gICAgICBlZGl0b3IucmVidWlsZCgpO1xuICAgICAgZWRpdG9yLnNob3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGQoZWRpdG9yKTtcbiAgICB9XG4gIH1cbiAgYWRkVW5kb2FibGVFZGl0b3IoZWRpdG9yKSB7XG4gICAgY29uc3QgY21kID0gKCkgPT4gZWRpdG9yLl91aU1hbmFnZXIucmVidWlsZChlZGl0b3IpO1xuICAgIGNvbnN0IHVuZG8gPSAoKSA9PiB7XG4gICAgICBlZGl0b3IucmVtb3ZlKCk7XG4gICAgfTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZCxcbiAgICAgIHVuZG8sXG4gICAgICBtdXN0RXhlYzogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBnZXROZXh0SWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3VpTWFuYWdlci5nZXRJZCgpO1xuICB9XG4gIGdldCAjY3VycmVudEVkaXRvclR5cGUoKSB7XG4gICAgcmV0dXJuIEFubm90YXRpb25FZGl0b3JMYXllci4jZWRpdG9yVHlwZXMuZ2V0KHRoaXMuI3VpTWFuYWdlci5nZXRNb2RlKCkpO1xuICB9XG4gIGNvbWJpbmVkU2lnbmFsKGFjKSB7XG4gICAgcmV0dXJuIHRoaXMuI3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbChhYyk7XG4gIH1cbiAgI2NyZWF0ZU5ld0VkaXRvcihwYXJhbXMpIHtcbiAgICBjb25zdCBlZGl0b3JUeXBlID0gdGhpcy4jY3VycmVudEVkaXRvclR5cGU7XG4gICAgcmV0dXJuIGVkaXRvclR5cGUgPyBuZXcgZWRpdG9yVHlwZS5wcm90b3R5cGUuY29uc3RydWN0b3IocGFyYW1zKSA6IG51bGw7XG4gIH1cbiAgY2FuQ3JlYXRlTmV3RW1wdHlFZGl0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2N1cnJlbnRFZGl0b3JUeXBlPy5jYW5DcmVhdGVOZXdFbXB0eUVkaXRvcigpO1xuICB9XG4gIHBhc3RlRWRpdG9yKG1vZGUsIHBhcmFtcykge1xuICAgIHRoaXMuI3VpTWFuYWdlci51cGRhdGVUb29sYmFyKG1vZGUpO1xuICAgIHRoaXMuI3VpTWFuYWdlci51cGRhdGVNb2RlKG1vZGUpO1xuICAgIGNvbnN0IHtcbiAgICAgIG9mZnNldFgsXG4gICAgICBvZmZzZXRZXG4gICAgfSA9IHRoaXMuI2dldENlbnRlclBvaW50KCk7XG4gICAgY29uc3QgaWQgPSB0aGlzLmdldE5leHRJZCgpO1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuI2NyZWF0ZU5ld0VkaXRvcih7XG4gICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICBpZCxcbiAgICAgIHg6IG9mZnNldFgsXG4gICAgICB5OiBvZmZzZXRZLFxuICAgICAgdWlNYW5hZ2VyOiB0aGlzLiN1aU1hbmFnZXIsXG4gICAgICBpc0NlbnRlcmVkOiB0cnVlLFxuICAgICAgLi4ucGFyYW1zXG4gICAgfSk7XG4gICAgaWYgKGVkaXRvcikge1xuICAgICAgdGhpcy5hZGQoZWRpdG9yKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZGVzZXJpYWxpemUoZGF0YSkge1xuICAgIHJldHVybiAoYXdhaXQgQW5ub3RhdGlvbkVkaXRvckxheWVyLiNlZGl0b3JUeXBlcy5nZXQoZGF0YS5hbm5vdGF0aW9uVHlwZSA/PyBkYXRhLmFubm90YXRpb25FZGl0b3JUeXBlKT8uZGVzZXJpYWxpemUoZGF0YSwgdGhpcywgdGhpcy4jdWlNYW5hZ2VyKSkgfHwgbnVsbDtcbiAgfVxuICBjcmVhdGVBbmRBZGROZXdFZGl0b3IoZXZlbnQsIGlzQ2VudGVyZWQsIGRhdGEgPSB7fSkge1xuICAgIGNvbnN0IGlkID0gdGhpcy5nZXROZXh0SWQoKTtcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLiNjcmVhdGVOZXdFZGl0b3Ioe1xuICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgaWQsXG4gICAgICB4OiBldmVudC5vZmZzZXRYLFxuICAgICAgeTogZXZlbnQub2Zmc2V0WSxcbiAgICAgIHVpTWFuYWdlcjogdGhpcy4jdWlNYW5hZ2VyLFxuICAgICAgaXNDZW50ZXJlZCxcbiAgICAgIC4uLmRhdGFcbiAgICB9KTtcbiAgICBpZiAoZWRpdG9yKSB7XG4gICAgICB0aGlzLmFkZChlZGl0b3IpO1xuICAgIH1cbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG4gICNnZXRDZW50ZXJQb2ludCgpIHtcbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXMuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHRsWCA9IE1hdGgubWF4KDAsIHgpO1xuICAgIGNvbnN0IHRsWSA9IE1hdGgubWF4KDAsIHkpO1xuICAgIGNvbnN0IGJyWCA9IE1hdGgubWluKHdpbmRvdy5pbm5lcldpZHRoLCB4ICsgd2lkdGgpO1xuICAgIGNvbnN0IGJyWSA9IE1hdGgubWluKHdpbmRvdy5pbm5lckhlaWdodCwgeSArIGhlaWdodCk7XG4gICAgY29uc3QgY2VudGVyWCA9ICh0bFggKyBiclgpIC8gMiAtIHg7XG4gICAgY29uc3QgY2VudGVyWSA9ICh0bFkgKyBiclkpIC8gMiAtIHk7XG4gICAgY29uc3QgW29mZnNldFgsIG9mZnNldFldID0gdGhpcy52aWV3cG9ydC5yb3RhdGlvbiAlIDE4MCA9PT0gMCA/IFtjZW50ZXJYLCBjZW50ZXJZXSA6IFtjZW50ZXJZLCBjZW50ZXJYXTtcbiAgICByZXR1cm4ge1xuICAgICAgb2Zmc2V0WCxcbiAgICAgIG9mZnNldFlcbiAgICB9O1xuICB9XG4gIGFkZE5ld0VkaXRvcigpIHtcbiAgICB0aGlzLmNyZWF0ZUFuZEFkZE5ld0VkaXRvcih0aGlzLiNnZXRDZW50ZXJQb2ludCgpLCB0cnVlKTtcbiAgfVxuICBzZXRTZWxlY3RlZChlZGl0b3IpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIuc2V0U2VsZWN0ZWQoZWRpdG9yKTtcbiAgfVxuICB0b2dnbGVTZWxlY3RlZChlZGl0b3IpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIudG9nZ2xlU2VsZWN0ZWQoZWRpdG9yKTtcbiAgfVxuICB1bnNlbGVjdChlZGl0b3IpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIudW5zZWxlY3QoZWRpdG9yKTtcbiAgfVxuICBwb2ludGVydXAoZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBpc01hY1xuICAgIH0gPSB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgZXZlbnQuY3RybEtleSAmJiBpc01hYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSB0aGlzLmRpdikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2hhZFBvaW50ZXJEb3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2hhZFBvaW50ZXJEb3duID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuI2N1cnJlbnRFZGl0b3JUeXBlPy5pc0RyYXdlciAmJiB0aGlzLiNjdXJyZW50RWRpdG9yVHlwZS5zdXBwb3J0TXVsdGlwbGVEcmF3aW5ncykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2FsbG93Q2xpY2spIHtcbiAgICAgIHRoaXMuI2FsbG93Q2xpY2sgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jdWlNYW5hZ2VyLmdldE1vZGUoKSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuU1RBTVApIHtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci51bnNlbGVjdEFsbCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNyZWF0ZUFuZEFkZE5ld0VkaXRvcihldmVudCwgZmFsc2UpO1xuICB9XG4gIHBvaW50ZXJkb3duKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuI3VpTWFuYWdlci5nZXRNb2RlKCkgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCkge1xuICAgICAgdGhpcy5lbmFibGVUZXh0U2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNoYWRQb2ludGVyRG93bikge1xuICAgICAgdGhpcy4jaGFkUG9pbnRlckRvd24gPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8IGV2ZW50LmN0cmxLZXkgJiYgaXNNYWMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gdGhpcy5kaXYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jaGFkUG9pbnRlckRvd24gPSB0cnVlO1xuICAgIGlmICh0aGlzLiNjdXJyZW50RWRpdG9yVHlwZT8uaXNEcmF3ZXIpIHtcbiAgICAgIHRoaXMuc3RhcnREcmF3aW5nU2Vzc2lvbihldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuI3VpTWFuYWdlci5nZXRBY3RpdmUoKTtcbiAgICB0aGlzLiNhbGxvd0NsaWNrID0gIWVkaXRvciB8fCBlZGl0b3IuaXNFbXB0eSgpO1xuICB9XG4gIHN0YXJ0RHJhd2luZ1Nlc3Npb24oZXZlbnQpIHtcbiAgICB0aGlzLmRpdi5mb2N1cygpO1xuICAgIGlmICh0aGlzLiNkcmF3aW5nQUMpIHtcbiAgICAgIHRoaXMuI2N1cnJlbnRFZGl0b3JUeXBlLnN0YXJ0RHJhd2luZyh0aGlzLCB0aGlzLiN1aU1hbmFnZXIsIGZhbHNlLCBldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3VpTWFuYWdlci5zZXRDdXJyZW50RHJhd2luZ1Nlc3Npb24odGhpcyk7XG4gICAgdGhpcy4jZHJhd2luZ0FDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbCh0aGlzLiNkcmF3aW5nQUMpO1xuICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsICh7XG4gICAgICByZWxhdGVkVGFyZ2V0XG4gICAgfSkgPT4ge1xuICAgICAgaWYgKHJlbGF0ZWRUYXJnZXQgJiYgIXRoaXMuZGl2LmNvbnRhaW5zKHJlbGF0ZWRUYXJnZXQpKSB7XG4gICAgICAgIHRoaXMuY29tbWl0T3JSZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLiNjdXJyZW50RWRpdG9yVHlwZS5zdGFydERyYXdpbmcodGhpcywgdGhpcy4jdWlNYW5hZ2VyLCBmYWxzZSwgZXZlbnQpO1xuICB9XG4gIGVuZERyYXdpbmdTZXNzaW9uKGlzQWJvcnRlZCA9IGZhbHNlKSB7XG4gICAgaWYgKCF0aGlzLiNkcmF3aW5nQUMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0aGlzLiN1aU1hbmFnZXIuc2V0Q3VycmVudERyYXdpbmdTZXNzaW9uKG51bGwpO1xuICAgIHRoaXMuI2RyYXdpbmdBQy5hYm9ydCgpO1xuICAgIHRoaXMuI2RyYXdpbmdBQyA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXMuI2N1cnJlbnRFZGl0b3JUeXBlLmVuZERyYXdpbmcoaXNBYm9ydGVkKTtcbiAgfVxuICBmaW5kTmV3UGFyZW50KGVkaXRvciwgeCwgeSkge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy4jdWlNYW5hZ2VyLmZpbmRQYXJlbnQoeCwgeSk7XG4gICAgaWYgKGxheWVyID09PSBudWxsIHx8IGxheWVyID09PSB0aGlzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxheWVyLmNoYW5nZVBhcmVudChlZGl0b3IpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbW1pdE9yUmVtb3ZlKCkge1xuICAgIGlmICh0aGlzLiNkcmF3aW5nQUMpIHtcbiAgICAgIHRoaXMuZW5kRHJhd2luZ1Nlc3Npb24oKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgb25TY2FsZUNoYW5naW5nKCkge1xuICAgIGlmICghdGhpcy4jZHJhd2luZ0FDKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2N1cnJlbnRFZGl0b3JUeXBlLm9uU2NhbGVDaGFuZ2luZ1doZW5EcmF3aW5nKHRoaXMpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgIGlmICh0aGlzLiN1aU1hbmFnZXIuZ2V0QWN0aXZlKCk/LnBhcmVudCA9PT0gdGhpcykge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIuc2V0QWN0aXZlRWRpdG9yKG51bGwpO1xuICAgIH1cbiAgICBpZiAodGhpcy4jZWRpdG9yRm9jdXNUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNlZGl0b3JGb2N1c1RpbWVvdXRJZCk7XG4gICAgICB0aGlzLiNlZGl0b3JGb2N1c1RpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyPy5yZW1vdmVQb2ludGVySW5UZXh0TGF5ZXIoZWRpdG9yLmNvbnRlbnREaXYpO1xuICAgICAgZWRpdG9yLnNldFBhcmVudChudWxsKTtcbiAgICAgIGVkaXRvci5pc0F0dGFjaGVkVG9ET00gPSBmYWxzZTtcbiAgICAgIGVkaXRvci5kaXYucmVtb3ZlKCk7XG4gICAgfVxuICAgIHRoaXMuZGl2ID0gbnVsbDtcbiAgICB0aGlzLiNlZGl0b3JzLmNsZWFyKCk7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnJlbW92ZUxheWVyKHRoaXMpO1xuICB9XG4gICNjbGVhbnVwKCkge1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlZGl0b3IuaXNFbXB0eSgpKSB7XG4gICAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVuZGVyKHtcbiAgICB2aWV3cG9ydFxuICB9KSB7XG4gICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgIHNldExheWVyRGltZW5zaW9ucyh0aGlzLmRpdiwgdmlld3BvcnQpO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3VpTWFuYWdlci5nZXRFZGl0b3JzKHRoaXMucGFnZUluZGV4KSkge1xuICAgICAgdGhpcy5hZGQoZWRpdG9yKTtcbiAgICAgIGVkaXRvci5yZWJ1aWxkKCk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlTW9kZSgpO1xuICB9XG4gIHVwZGF0ZSh7XG4gICAgdmlld3BvcnRcbiAgfSkge1xuICAgIHRoaXMuI3VpTWFuYWdlci5jb21taXRPclJlbW92ZSgpO1xuICAgIHRoaXMuI2NsZWFudXAoKTtcbiAgICBjb25zdCBvbGRSb3RhdGlvbiA9IHRoaXMudmlld3BvcnQucm90YXRpb247XG4gICAgY29uc3Qgcm90YXRpb24gPSB2aWV3cG9ydC5yb3RhdGlvbjtcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgc2V0TGF5ZXJEaW1lbnNpb25zKHRoaXMuZGl2LCB7XG4gICAgICByb3RhdGlvblxuICAgIH0pO1xuICAgIGlmIChvbGRSb3RhdGlvbiAhPT0gcm90YXRpb24pIHtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgICAgZWRpdG9yLnJvdGF0ZShyb3RhdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBwYWdlRGltZW5zaW9ucygpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0XG4gICAgfSA9IHRoaXMudmlld3BvcnQucmF3RGltcztcbiAgICByZXR1cm4gW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF07XG4gIH1cbiAgZ2V0IHNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLiN1aU1hbmFnZXIudmlld1BhcmFtZXRlcnMucmVhbFNjYWxlO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2RyYXdfbGF5ZXIuanNcblxuXG5jbGFzcyBEcmF3TGF5ZXIge1xuICAjcGFyZW50ID0gbnVsbDtcbiAgI2lkID0gMDtcbiAgI21hcHBpbmcgPSBuZXcgTWFwKCk7XG4gICN0b1VwZGF0ZSA9IG5ldyBNYXAoKTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHBhZ2VJbmRleFxuICB9KSB7XG4gICAgdGhpcy5wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gIH1cbiAgc2V0UGFyZW50KHBhcmVudCkge1xuICAgIGlmICghdGhpcy4jcGFyZW50KSB7XG4gICAgICB0aGlzLiNwYXJlbnQgPSBwYXJlbnQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNwYXJlbnQgIT09IHBhcmVudCkge1xuICAgICAgaWYgKHRoaXMuI21hcHBpbmcuc2l6ZSA+IDApIHtcbiAgICAgICAgZm9yIChjb25zdCByb290IG9mIHRoaXMuI21hcHBpbmcudmFsdWVzKCkpIHtcbiAgICAgICAgICByb290LnJlbW92ZSgpO1xuICAgICAgICAgIHBhcmVudC5hcHBlbmQocm9vdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuI3BhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldCBfc3ZnRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX3N2Z0ZhY3RvcnlcIiwgbmV3IERPTVNWR0ZhY3RvcnkoKSk7XG4gIH1cbiAgc3RhdGljICNzZXRCb3goZWxlbWVudCwgW3gsIHksIHdpZHRoLCBoZWlnaHRdKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gZWxlbWVudDtcbiAgICBzdHlsZS50b3AgPSBgJHsxMDAgKiB5fSVgO1xuICAgIHN0eWxlLmxlZnQgPSBgJHsxMDAgKiB4fSVgO1xuICAgIHN0eWxlLndpZHRoID0gYCR7MTAwICogd2lkdGh9JWA7XG4gICAgc3R5bGUuaGVpZ2h0ID0gYCR7MTAwICogaGVpZ2h0fSVgO1xuICB9XG4gICNjcmVhdGVTVkcoKSB7XG4gICAgY29uc3Qgc3ZnID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZSgxLCAxLCB0cnVlKTtcbiAgICB0aGlzLiNwYXJlbnQuYXBwZW5kKHN2Zyk7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIHRydWUpO1xuICAgIHJldHVybiBzdmc7XG4gIH1cbiAgI2NyZWF0ZUNsaXBQYXRoKGRlZnMsIHBhdGhJZCkge1xuICAgIGNvbnN0IGNsaXBQYXRoID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJjbGlwUGF0aFwiKTtcbiAgICBkZWZzLmFwcGVuZChjbGlwUGF0aCk7XG4gICAgY29uc3QgY2xpcFBhdGhJZCA9IGBjbGlwXyR7cGF0aElkfWA7XG4gICAgY2xpcFBhdGguc2V0QXR0cmlidXRlKFwiaWRcIiwgY2xpcFBhdGhJZCk7XG4gICAgY2xpcFBhdGguc2V0QXR0cmlidXRlKFwiY2xpcFBhdGhVbml0c1wiLCBcIm9iamVjdEJvdW5kaW5nQm94XCIpO1xuICAgIGNvbnN0IGNsaXBQYXRoVXNlID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJ1c2VcIik7XG4gICAgY2xpcFBhdGguYXBwZW5kKGNsaXBQYXRoVXNlKTtcbiAgICBjbGlwUGF0aFVzZS5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGAjJHtwYXRoSWR9YCk7XG4gICAgY2xpcFBhdGhVc2UuY2xhc3NMaXN0LmFkZChcImNsaXBcIik7XG4gICAgcmV0dXJuIGNsaXBQYXRoSWQ7XG4gIH1cbiAgI3VwZGF0ZVByb3BlcnRpZXMoZWxlbWVudCwgcHJvcGVydGllcykge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHByb3BlcnRpZXMpKSB7XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkcmF3KHByb3BlcnRpZXMsIGlzUGF0aFVwZGF0YWJsZSA9IGZhbHNlLCBoYXNDbGlwID0gZmFsc2UpIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuI2lkKys7XG4gICAgY29uc3Qgcm9vdCA9IHRoaXMuI2NyZWF0ZVNWRygpO1xuICAgIGNvbnN0IGRlZnMgPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcImRlZnNcIik7XG4gICAgcm9vdC5hcHBlbmQoZGVmcyk7XG4gICAgY29uc3QgcGF0aCA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwicGF0aFwiKTtcbiAgICBkZWZzLmFwcGVuZChwYXRoKTtcbiAgICBjb25zdCBwYXRoSWQgPSBgcGF0aF9wJHt0aGlzLnBhZ2VJbmRleH1fJHtpZH1gO1xuICAgIHBhdGguc2V0QXR0cmlidXRlKFwiaWRcIiwgcGF0aElkKTtcbiAgICBwYXRoLnNldEF0dHJpYnV0ZShcInZlY3Rvci1lZmZlY3RcIiwgXCJub24tc2NhbGluZy1zdHJva2VcIik7XG4gICAgaWYgKGlzUGF0aFVwZGF0YWJsZSkge1xuICAgICAgdGhpcy4jdG9VcGRhdGUuc2V0KGlkLCBwYXRoKTtcbiAgICB9XG4gICAgY29uc3QgY2xpcFBhdGhJZCA9IGhhc0NsaXAgPyB0aGlzLiNjcmVhdGVDbGlwUGF0aChkZWZzLCBwYXRoSWQpIDogbnVsbDtcbiAgICBjb25zdCB1c2UgPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInVzZVwiKTtcbiAgICByb290LmFwcGVuZCh1c2UpO1xuICAgIHVzZS5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGAjJHtwYXRoSWR9YCk7XG4gICAgdGhpcy51cGRhdGVQcm9wZXJ0aWVzKHJvb3QsIHByb3BlcnRpZXMpO1xuICAgIHRoaXMuI21hcHBpbmcuc2V0KGlkLCByb290KTtcbiAgICByZXR1cm4ge1xuICAgICAgaWQsXG4gICAgICBjbGlwUGF0aElkOiBgdXJsKCMke2NsaXBQYXRoSWR9KWBcbiAgICB9O1xuICB9XG4gIGRyYXdPdXRsaW5lKHByb3BlcnRpZXMsIG11c3RSZW1vdmVTZWxmSW50ZXJzZWN0aW9ucykge1xuICAgIGNvbnN0IGlkID0gdGhpcy4jaWQrKztcbiAgICBjb25zdCByb290ID0gdGhpcy4jY3JlYXRlU1ZHKCk7XG4gICAgY29uc3QgZGVmcyA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwiZGVmc1wiKTtcbiAgICByb290LmFwcGVuZChkZWZzKTtcbiAgICBjb25zdCBwYXRoID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIpO1xuICAgIGRlZnMuYXBwZW5kKHBhdGgpO1xuICAgIGNvbnN0IHBhdGhJZCA9IGBwYXRoX3Ake3RoaXMucGFnZUluZGV4fV8ke2lkfWA7XG4gICAgcGF0aC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBwYXRoSWQpO1xuICAgIHBhdGguc2V0QXR0cmlidXRlKFwidmVjdG9yLWVmZmVjdFwiLCBcIm5vbi1zY2FsaW5nLXN0cm9rZVwiKTtcbiAgICBsZXQgbWFza0lkO1xuICAgIGlmIChtdXN0UmVtb3ZlU2VsZkludGVyc2VjdGlvbnMpIHtcbiAgICAgIGNvbnN0IG1hc2sgPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcIm1hc2tcIik7XG4gICAgICBkZWZzLmFwcGVuZChtYXNrKTtcbiAgICAgIG1hc2tJZCA9IGBtYXNrX3Ake3RoaXMucGFnZUluZGV4fV8ke2lkfWA7XG4gICAgICBtYXNrLnNldEF0dHJpYnV0ZShcImlkXCIsIG1hc2tJZCk7XG4gICAgICBtYXNrLnNldEF0dHJpYnV0ZShcIm1hc2tVbml0c1wiLCBcIm9iamVjdEJvdW5kaW5nQm94XCIpO1xuICAgICAgY29uc3QgcmVjdCA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwicmVjdFwiKTtcbiAgICAgIG1hc2suYXBwZW5kKHJlY3QpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjFcIik7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBcIjFcIik7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ3aGl0ZVwiKTtcbiAgICAgIGNvbnN0IHVzZSA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwidXNlXCIpO1xuICAgICAgbWFzay5hcHBlbmQodXNlKTtcbiAgICAgIHVzZS5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGAjJHtwYXRoSWR9YCk7XG4gICAgICB1c2Uuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwibm9uZVwiKTtcbiAgICAgIHVzZS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwiYmxhY2tcIik7XG4gICAgICB1c2Uuc2V0QXR0cmlidXRlKFwiZmlsbC1ydWxlXCIsIFwibm9uemVyb1wiKTtcbiAgICAgIHVzZS5jbGFzc0xpc3QuYWRkKFwibWFza1wiKTtcbiAgICB9XG4gICAgY29uc3QgdXNlMSA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwidXNlXCIpO1xuICAgIHJvb3QuYXBwZW5kKHVzZTEpO1xuICAgIHVzZTEuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBgIyR7cGF0aElkfWApO1xuICAgIGlmIChtYXNrSWQpIHtcbiAgICAgIHVzZTEuc2V0QXR0cmlidXRlKFwibWFza1wiLCBgdXJsKCMke21hc2tJZH0pYCk7XG4gICAgfVxuICAgIGNvbnN0IHVzZTIgPSB1c2UxLmNsb25lTm9kZSgpO1xuICAgIHJvb3QuYXBwZW5kKHVzZTIpO1xuICAgIHVzZTEuY2xhc3NMaXN0LmFkZChcIm1haW5PdXRsaW5lXCIpO1xuICAgIHVzZTIuY2xhc3NMaXN0LmFkZChcInNlY29uZGFyeU91dGxpbmVcIik7XG4gICAgdGhpcy51cGRhdGVQcm9wZXJ0aWVzKHJvb3QsIHByb3BlcnRpZXMpO1xuICAgIHRoaXMuI21hcHBpbmcuc2V0KGlkLCByb290KTtcbiAgICByZXR1cm4gaWQ7XG4gIH1cbiAgZmluYWxpemVEcmF3KGlkLCBwcm9wZXJ0aWVzKSB7XG4gICAgdGhpcy4jdG9VcGRhdGUuZGVsZXRlKGlkKTtcbiAgICB0aGlzLnVwZGF0ZVByb3BlcnRpZXMoaWQsIHByb3BlcnRpZXMpO1xuICB9XG4gIHVwZGF0ZVByb3BlcnRpZXMoZWxlbWVudE9ySWQsIHByb3BlcnRpZXMpIHtcbiAgICBpZiAoIXByb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcm9vdCxcbiAgICAgIGJib3gsXG4gICAgICByb290Q2xhc3MsXG4gICAgICBwYXRoXG4gICAgfSA9IHByb3BlcnRpZXM7XG4gICAgY29uc3QgZWxlbWVudCA9IHR5cGVvZiBlbGVtZW50T3JJZCA9PT0gXCJudW1iZXJcIiA/IHRoaXMuI21hcHBpbmcuZ2V0KGVsZW1lbnRPcklkKSA6IGVsZW1lbnRPcklkO1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocm9vdCkge1xuICAgICAgdGhpcy4jdXBkYXRlUHJvcGVydGllcyhlbGVtZW50LCByb290KTtcbiAgICB9XG4gICAgaWYgKGJib3gpIHtcbiAgICAgIERyYXdMYXllci4jc2V0Qm94KGVsZW1lbnQsIGJib3gpO1xuICAgIH1cbiAgICBpZiAocm9vdENsYXNzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNsYXNzTGlzdFxuICAgICAgfSA9IGVsZW1lbnQ7XG4gICAgICBmb3IgKGNvbnN0IFtjbGFzc05hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhyb290Q2xhc3MpKSB7XG4gICAgICAgIGNsYXNzTGlzdC50b2dnbGUoY2xhc3NOYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXRoKSB7XG4gICAgICBjb25zdCBkZWZzID0gZWxlbWVudC5maXJzdENoaWxkO1xuICAgICAgY29uc3QgcGF0aEVsZW1lbnQgPSBkZWZzLmZpcnN0Q2hpbGQ7XG4gICAgICB0aGlzLiN1cGRhdGVQcm9wZXJ0aWVzKHBhdGhFbGVtZW50LCBwYXRoKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlUGFyZW50KGlkLCBsYXllcikge1xuICAgIGlmIChsYXllciA9PT0gdGhpcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByb290ID0gdGhpcy4jbWFwcGluZy5nZXQoaWQpO1xuICAgIGlmICghcm9vdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsYXllci4jcGFyZW50LmFwcGVuZChyb290KTtcbiAgICB0aGlzLiNtYXBwaW5nLmRlbGV0ZShpZCk7XG4gICAgbGF5ZXIuI21hcHBpbmcuc2V0KGlkLCByb290KTtcbiAgfVxuICByZW1vdmUoaWQpIHtcbiAgICB0aGlzLiN0b1VwZGF0ZS5kZWxldGUoaWQpO1xuICAgIGlmICh0aGlzLiNwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jbWFwcGluZy5nZXQoaWQpLnJlbW92ZSgpO1xuICAgIHRoaXMuI21hcHBpbmcuZGVsZXRlKGlkKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI3BhcmVudCA9IG51bGw7XG4gICAgZm9yIChjb25zdCByb290IG9mIHRoaXMuI21hcHBpbmcudmFsdWVzKCkpIHtcbiAgICAgIHJvb3QucmVtb3ZlKCk7XG4gICAgfVxuICAgIHRoaXMuI21hcHBpbmcuY2xlYXIoKTtcbiAgICB0aGlzLiN0b1VwZGF0ZS5jbGVhcigpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9wZGYuanNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuY29uc3QgcGRmanNWZXJzaW9uID0gXCI0LjkuMTU1XCI7XG5jb25zdCBwZGZqc0J1aWxkID0gXCJhNGViODQwN2NcIjtcbntcbiAgZ2xvYmFsVGhpcy5wZGZqc1Rlc3RpbmdVdGlscyA9IHtcbiAgICBIaWdobGlnaHRPdXRsaW5lcjogSGlnaGxpZ2h0T3V0bGluZXJcbiAgfTtcbn1cblxudmFyIF9fd2VicGFja19leHBvcnRzX19BYm9ydEV4Y2VwdGlvbiA9IF9fd2VicGFja19leHBvcnRzX18uQWJvcnRFeGNlcHRpb247XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0Fubm90YXRpb25FZGl0b3JMYXllciA9IF9fd2VicGFja19leHBvcnRzX18uQW5ub3RhdGlvbkVkaXRvckxheWVyO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZSA9IF9fd2VicGFja19leHBvcnRzX18uQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGU7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0Fubm90YXRpb25FZGl0b3JUeXBlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5Bbm5vdGF0aW9uRWRpdG9yVHlwZTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlciA9IF9fd2VicGFja19leHBvcnRzX18uQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlcjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQW5ub3RhdGlvbkxheWVyID0gX193ZWJwYWNrX2V4cG9ydHNfXy5Bbm5vdGF0aW9uTGF5ZXI7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0Fubm90YXRpb25Nb2RlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5Bbm5vdGF0aW9uTW9kZTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ29sb3JQaWNrZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkNvbG9yUGlja2VyO1xudmFyIF9fd2VicGFja19leHBvcnRzX19ET01TVkdGYWN0b3J5ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5ET01TVkdGYWN0b3J5O1xudmFyIF9fd2VicGFja19leHBvcnRzX19EcmF3TGF5ZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkRyYXdMYXllcjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRmVhdHVyZVRlc3QgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkZlYXR1cmVUZXN0O1xudmFyIF9fd2VicGFja19leHBvcnRzX19HbG9iYWxXb3JrZXJPcHRpb25zID0gX193ZWJwYWNrX2V4cG9ydHNfXy5HbG9iYWxXb3JrZXJPcHRpb25zO1xudmFyIF9fd2VicGFja19leHBvcnRzX19JbWFnZUtpbmQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkltYWdlS2luZDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fSW52YWxpZFBERkV4Y2VwdGlvbiA9IF9fd2VicGFja19leHBvcnRzX18uSW52YWxpZFBERkV4Y2VwdGlvbjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fTWlzc2luZ1BERkV4Y2VwdGlvbiA9IF9fd2VicGFja19leHBvcnRzX18uTWlzc2luZ1BERkV4Y2VwdGlvbjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fT1BTID0gX193ZWJwYWNrX2V4cG9ydHNfXy5PUFM7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX091dHB1dFNjYWxlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5PdXRwdXRTY2FsZTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUERGRGF0YVJhbmdlVHJhbnNwb3J0ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5QREZEYXRhUmFuZ2VUcmFuc3BvcnQ7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1BERkRhdGVTdHJpbmcgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlBERkRhdGVTdHJpbmc7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1BERldvcmtlciA9IF9fd2VicGFja19leHBvcnRzX18uUERGV29ya2VyO1xudmFyIF9fd2VicGFja19leHBvcnRzX19QYXNzd29yZFJlc3BvbnNlcyA9IF9fd2VicGFja19leHBvcnRzX18uUGFzc3dvcmRSZXNwb25zZXM7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1Blcm1pc3Npb25GbGFnID0gX193ZWJwYWNrX2V4cG9ydHNfXy5QZXJtaXNzaW9uRmxhZztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUGl4ZWxzUGVySW5jaCA9IF9fd2VicGFja19leHBvcnRzX18uUGl4ZWxzUGVySW5jaDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uID0gX193ZWJwYWNrX2V4cG9ydHNfXy5SZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb247XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1RleHRMYXllciA9IF9fd2VicGFja19leHBvcnRzX18uVGV4dExheWVyO1xudmFyIF9fd2VicGFja19leHBvcnRzX19VbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24gPSBfX3dlYnBhY2tfZXhwb3J0c19fLlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fVXRpbCA9IF9fd2VicGFja19leHBvcnRzX18uVXRpbDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fVmVyYm9zaXR5TGV2ZWwgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlZlcmJvc2l0eUxldmVsO1xudmFyIF9fd2VicGFja19leHBvcnRzX19YZmFMYXllciA9IF9fd2VicGFja19leHBvcnRzX18uWGZhTGF5ZXI7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX2J1aWxkID0gX193ZWJwYWNrX2V4cG9ydHNfXy5idWlsZDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCA9IF9fd2VicGFja19leHBvcnRzX18uY3JlYXRlVmFsaWRBYnNvbHV0ZVVybDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fZmV0Y2hEYXRhID0gX193ZWJwYWNrX2V4cG9ydHNfXy5mZXRjaERhdGE7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX2dldERvY3VtZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5nZXREb2N1bWVudDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fZ2V0RmlsZW5hbWVGcm9tVXJsID0gX193ZWJwYWNrX2V4cG9ydHNfXy5nZXRGaWxlbmFtZUZyb21Vcmw7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX2dldFBkZkZpbGVuYW1lRnJvbVVybCA9IF9fd2VicGFja19leHBvcnRzX18uZ2V0UGRmRmlsZW5hbWVGcm9tVXJsO1xudmFyIF9fd2VicGFja19leHBvcnRzX19nZXRYZmFQYWdlVmlld3BvcnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmdldFhmYVBhZ2VWaWV3cG9ydDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19faXNEYXRhU2NoZW1lID0gX193ZWJwYWNrX2V4cG9ydHNfXy5pc0RhdGFTY2hlbWU7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX2lzUGRmRmlsZSA9IF9fd2VicGFja19leHBvcnRzX18uaXNQZGZGaWxlO1xudmFyIF9fd2VicGFja19leHBvcnRzX19ub0NvbnRleHRNZW51ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5ub0NvbnRleHRNZW51O1xudmFyIF9fd2VicGFja19leHBvcnRzX19ub3JtYWxpemVVbmljb2RlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5ub3JtYWxpemVVbmljb2RlO1xudmFyIF9fd2VicGFja19leHBvcnRzX19zZXRMYXllckRpbWVuc2lvbnMgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnNldExheWVyRGltZW5zaW9ucztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fc2hhZG93ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5zaGFkb3c7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX3N0b3BFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18uc3RvcEV2ZW50O1xudmFyIF9fd2VicGFja19leHBvcnRzX192ZXJzaW9uID0gX193ZWJwYWNrX2V4cG9ydHNfXy52ZXJzaW9uO1xuZXhwb3J0IHsgX193ZWJwYWNrX2V4cG9ydHNfX0Fib3J0RXhjZXB0aW9uIGFzIEFib3J0RXhjZXB0aW9uLCBfX3dlYnBhY2tfZXhwb3J0c19fQW5ub3RhdGlvbkVkaXRvckxheWVyIGFzIEFubm90YXRpb25FZGl0b3JMYXllciwgX193ZWJwYWNrX2V4cG9ydHNfX0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlIGFzIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLCBfX3dlYnBhY2tfZXhwb3J0c19fQW5ub3RhdGlvbkVkaXRvclR5cGUgYXMgQW5ub3RhdGlvbkVkaXRvclR5cGUsIF9fd2VicGFja19leHBvcnRzX19Bbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyIGFzIEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIsIF9fd2VicGFja19leHBvcnRzX19Bbm5vdGF0aW9uTGF5ZXIgYXMgQW5ub3RhdGlvbkxheWVyLCBfX3dlYnBhY2tfZXhwb3J0c19fQW5ub3RhdGlvbk1vZGUgYXMgQW5ub3RhdGlvbk1vZGUsIF9fd2VicGFja19leHBvcnRzX19Db2xvclBpY2tlciBhcyBDb2xvclBpY2tlciwgX193ZWJwYWNrX2V4cG9ydHNfX0RPTVNWR0ZhY3RvcnkgYXMgRE9NU1ZHRmFjdG9yeSwgX193ZWJwYWNrX2V4cG9ydHNfX0RyYXdMYXllciBhcyBEcmF3TGF5ZXIsIF9fd2VicGFja19leHBvcnRzX19GZWF0dXJlVGVzdCBhcyBGZWF0dXJlVGVzdCwgX193ZWJwYWNrX2V4cG9ydHNfX0dsb2JhbFdvcmtlck9wdGlvbnMgYXMgR2xvYmFsV29ya2VyT3B0aW9ucywgX193ZWJwYWNrX2V4cG9ydHNfX0ltYWdlS2luZCBhcyBJbWFnZUtpbmQsIF9fd2VicGFja19leHBvcnRzX19JbnZhbGlkUERGRXhjZXB0aW9uIGFzIEludmFsaWRQREZFeGNlcHRpb24sIF9fd2VicGFja19leHBvcnRzX19NaXNzaW5nUERGRXhjZXB0aW9uIGFzIE1pc3NpbmdQREZFeGNlcHRpb24sIF9fd2VicGFja19leHBvcnRzX19PUFMgYXMgT1BTLCBfX3dlYnBhY2tfZXhwb3J0c19fT3V0cHV0U2NhbGUgYXMgT3V0cHV0U2NhbGUsIF9fd2VicGFja19leHBvcnRzX19QREZEYXRhUmFuZ2VUcmFuc3BvcnQgYXMgUERGRGF0YVJhbmdlVHJhbnNwb3J0LCBfX3dlYnBhY2tfZXhwb3J0c19fUERGRGF0ZVN0cmluZyBhcyBQREZEYXRlU3RyaW5nLCBfX3dlYnBhY2tfZXhwb3J0c19fUERGV29ya2VyIGFzIFBERldvcmtlciwgX193ZWJwYWNrX2V4cG9ydHNfX1Bhc3N3b3JkUmVzcG9uc2VzIGFzIFBhc3N3b3JkUmVzcG9uc2VzLCBfX3dlYnBhY2tfZXhwb3J0c19fUGVybWlzc2lvbkZsYWcgYXMgUGVybWlzc2lvbkZsYWcsIF9fd2VicGFja19leHBvcnRzX19QaXhlbHNQZXJJbmNoIGFzIFBpeGVsc1BlckluY2gsIF9fd2VicGFja19leHBvcnRzX19SZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24gYXMgUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uLCBfX3dlYnBhY2tfZXhwb3J0c19fVGV4dExheWVyIGFzIFRleHRMYXllciwgX193ZWJwYWNrX2V4cG9ydHNfX1VuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbiBhcyBVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24sIF9fd2VicGFja19leHBvcnRzX19VdGlsIGFzIFV0aWwsIF9fd2VicGFja19leHBvcnRzX19WZXJib3NpdHlMZXZlbCBhcyBWZXJib3NpdHlMZXZlbCwgX193ZWJwYWNrX2V4cG9ydHNfX1hmYUxheWVyIGFzIFhmYUxheWVyLCBfX3dlYnBhY2tfZXhwb3J0c19fYnVpbGQgYXMgYnVpbGQsIF9fd2VicGFja19leHBvcnRzX19jcmVhdGVWYWxpZEFic29sdXRlVXJsIGFzIGNyZWF0ZVZhbGlkQWJzb2x1dGVVcmwsIF9fd2VicGFja19leHBvcnRzX19mZXRjaERhdGEgYXMgZmV0Y2hEYXRhLCBfX3dlYnBhY2tfZXhwb3J0c19fZ2V0RG9jdW1lbnQgYXMgZ2V0RG9jdW1lbnQsIF9fd2VicGFja19leHBvcnRzX19nZXRGaWxlbmFtZUZyb21VcmwgYXMgZ2V0RmlsZW5hbWVGcm9tVXJsLCBfX3dlYnBhY2tfZXhwb3J0c19fZ2V0UGRmRmlsZW5hbWVGcm9tVXJsIGFzIGdldFBkZkZpbGVuYW1lRnJvbVVybCwgX193ZWJwYWNrX2V4cG9ydHNfX2dldFhmYVBhZ2VWaWV3cG9ydCBhcyBnZXRYZmFQYWdlVmlld3BvcnQsIF9fd2VicGFja19leHBvcnRzX19pc0RhdGFTY2hlbWUgYXMgaXNEYXRhU2NoZW1lLCBfX3dlYnBhY2tfZXhwb3J0c19faXNQZGZGaWxlIGFzIGlzUGRmRmlsZSwgX193ZWJwYWNrX2V4cG9ydHNfX25vQ29udGV4dE1lbnUgYXMgbm9Db250ZXh0TWVudSwgX193ZWJwYWNrX2V4cG9ydHNfX25vcm1hbGl6ZVVuaWNvZGUgYXMgbm9ybWFsaXplVW5pY29kZSwgX193ZWJwYWNrX2V4cG9ydHNfX3NldExheWVyRGltZW5zaW9ucyBhcyBzZXRMYXllckRpbWVuc2lvbnMsIF9fd2VicGFja19leHBvcnRzX19zaGFkb3cgYXMgc2hhZG93LCBfX3dlYnBhY2tfZXhwb3J0c19fc3RvcEV2ZW50IGFzIHN0b3BFdmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX3ZlcnNpb24gYXMgdmVyc2lvbiB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wZGYubWpzLm1hcCJdLCJuYW1lcyI6WyJfX3dlYnBhY2tfcmVxdWlyZV9fIiwiZCIsImV4cG9ydHMiLCJkZWZpbml0aW9uIiwia2V5IiwibyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImdldCIsIm9iaiIsInByb3AiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJfX3dlYnBhY2tfZXhwb3J0c19fIiwiZ2xvYmFsVGhpcyIsInBkZmpzTGliIiwiQWJvcnRFeGNlcHRpb24iLCJBbm5vdGF0aW9uRWRpdG9yTGF5ZXIiLCJBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZSIsIkFubm90YXRpb25FZGl0b3JUeXBlIiwiQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlciIsIkFubm90YXRpb25MYXllciIsIkFubm90YXRpb25Nb2RlIiwiQ29sb3JQaWNrZXIiLCJET01TVkdGYWN0b3J5IiwiRHJhd0xheWVyIiwiRmVhdHVyZVRlc3QiLCJ1dGlsX0ZlYXR1cmVUZXN0IiwiR2xvYmFsV29ya2VyT3B0aW9ucyIsIkltYWdlS2luZCIsInV0aWxfSW1hZ2VLaW5kIiwiSW52YWxpZFBERkV4Y2VwdGlvbiIsIk1pc3NpbmdQREZFeGNlcHRpb24iLCJPUFMiLCJPdXRwdXRTY2FsZSIsIlBERkRhdGFSYW5nZVRyYW5zcG9ydCIsIlBERkRhdGVTdHJpbmciLCJQREZXb3JrZXIiLCJQYXNzd29yZFJlc3BvbnNlcyIsIlBlcm1pc3Npb25GbGFnIiwiUGl4ZWxzUGVySW5jaCIsIlJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbiIsIlRleHRMYXllciIsIlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbiIsIlV0aWwiLCJWZXJib3NpdHlMZXZlbCIsIlhmYUxheWVyIiwiYnVpbGQiLCJjcmVhdGVWYWxpZEFic29sdXRlVXJsIiwiZmV0Y2hEYXRhIiwiZ2V0RG9jdW1lbnQiLCJnZXRGaWxlbmFtZUZyb21VcmwiLCJnZXRQZGZGaWxlbmFtZUZyb21VcmwiLCJnZXRYZmFQYWdlVmlld3BvcnQiLCJpc0RhdGFTY2hlbWUiLCJpc1BkZkZpbGUiLCJub0NvbnRleHRNZW51Iiwibm9ybWFsaXplVW5pY29kZSIsInNldExheWVyRGltZW5zaW9ucyIsInNoYWRvdyIsInN0b3BFdmVudCIsInZlcnNpb24iLCJpc05vZGVKUyIsInByb2Nlc3MiLCJ2ZXJzaW9ucyIsIm53IiwiZWxlY3Ryb24iLCJ0eXBlIiwiSURFTlRJVFlfTUFUUklYIiwiRk9OVF9JREVOVElUWV9NQVRSSVgiLCJNQVhfSU1BR0VfU0laRV9UT19DQUNIRSIsIkxJTkVfRkFDVE9SIiwiTElORV9ERVNDRU5UX0ZBQ1RPUiIsIkJBU0VMSU5FX0ZBQ1RPUiIsIlJlbmRlcmluZ0ludGVudEZsYWciLCJBTlkiLCJESVNQTEFZIiwiUFJJTlQiLCJTQVZFIiwiQU5OT1RBVElPTlNfRk9STVMiLCJBTk5PVEFUSU9OU19TVE9SQUdFIiwiQU5OT1RBVElPTlNfRElTQUJMRSIsIklTX0VESVRJTkciLCJPUExJU1QiLCJESVNBQkxFIiwiRU5BQkxFIiwiRU5BQkxFX0ZPUk1TIiwiRU5BQkxFX1NUT1JBR0UiLCJBbm5vdGF0aW9uRWRpdG9yUHJlZml4IiwiTk9ORSIsIkZSRUVURVhUIiwiSElHSExJR0hUIiwiU1RBTVAiLCJJTksiLCJSRVNJWkUiLCJDUkVBVEUiLCJGUkVFVEVYVF9TSVpFIiwiRlJFRVRFWFRfQ09MT1IiLCJGUkVFVEVYVF9PUEFDSVRZIiwiSU5LX0NPTE9SIiwiSU5LX1RISUNLTkVTUyIsIklOS19PUEFDSVRZIiwiSElHSExJR0hUX0NPTE9SIiwiSElHSExJR0hUX0RFRkFVTFRfQ09MT1IiLCJISUdITElHSFRfVEhJQ0tORVNTIiwiSElHSExJR0hUX0ZSRUUiLCJISUdITElHSFRfU0hPV19BTEwiLCJEUkFXX1NURVAiLCJNT0RJRllfQ09OVEVOVFMiLCJDT1BZIiwiTU9ESUZZX0FOTk9UQVRJT05TIiwiRklMTF9JTlRFUkFDVElWRV9GT1JNUyIsIkNPUFlfRk9SX0FDQ0VTU0lCSUxJVFkiLCJBU1NFTUJMRSIsIlBSSU5UX0hJR0hfUVVBTElUWSIsIlRleHRSZW5kZXJpbmdNb2RlIiwiRklMTCIsIlNUUk9LRSIsIkZJTExfU1RST0tFIiwiSU5WSVNJQkxFIiwiRklMTF9BRERfVE9fUEFUSCIsIlNUUk9LRV9BRERfVE9fUEFUSCIsIkZJTExfU1RST0tFX0FERF9UT19QQVRIIiwiQUREX1RPX1BBVEgiLCJGSUxMX1NUUk9LRV9NQVNLIiwiQUREX1RPX1BBVEhfRkxBRyIsIkdSQVlTQ0FMRV8xQlBQIiwiUkdCXzI0QlBQIiwiUkdCQV8zMkJQUCIsIkFubm90YXRpb25UeXBlIiwiVEVYVCIsIkxJTksiLCJMSU5FIiwiU1FVQVJFIiwiQ0lSQ0xFIiwiUE9MWUdPTiIsIlBPTFlMSU5FIiwiVU5ERVJMSU5FIiwiU1FVSUdHTFkiLCJTVFJJS0VPVVQiLCJDQVJFVCIsIlBPUFVQIiwiRklMRUFUVEFDSE1FTlQiLCJTT1VORCIsIk1PVklFIiwiV0lER0VUIiwiU0NSRUVOIiwiUFJJTlRFUk1BUksiLCJUUkFQTkVUIiwiV0FURVJNQVJLIiwiVEhSRUVEIiwiUkVEQUNUIiwiQW5ub3RhdGlvblJlcGx5VHlwZSIsIkdST1VQIiwiUkVQTFkiLCJBbm5vdGF0aW9uRmxhZyIsIkhJRERFTiIsIk5PWk9PTSIsIk5PUk9UQVRFIiwiTk9WSUVXIiwiUkVBRE9OTFkiLCJMT0NLRUQiLCJUT0dHTEVOT1ZJRVciLCJMT0NLRURDT05URU5UUyIsIkFubm90YXRpb25GaWVsZEZsYWciLCJSRVFVSVJFRCIsIk5PRVhQT1JUIiwiTVVMVElMSU5FIiwiUEFTU1dPUkQiLCJOT1RPR0dMRVRPT0ZGIiwiUkFESU8iLCJQVVNIQlVUVE9OIiwiQ09NQk8iLCJFRElUIiwiU09SVCIsIkZJTEVTRUxFQ1QiLCJNVUxUSVNFTEVDVCIsIkRPTk9UU1BFTExDSEVDSyIsIkRPTk9UU0NST0xMIiwiQ09NQiIsIlJJQ0hURVhUIiwiUkFESU9TSU5VTklTT04iLCJDT01NSVRPTlNFTENIQU5HRSIsIkFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUiLCJTT0xJRCIsIkRBU0hFRCIsIkJFVkVMRUQiLCJJTlNFVCIsIkFubm90YXRpb25BY3Rpb25FdmVudFR5cGUiLCJFIiwiWCIsIkQiLCJVIiwiRm8iLCJCbCIsIlBPIiwiUEMiLCJQViIsIlBJIiwiSyIsIkYiLCJWIiwiQyIsIkRvY3VtZW50QWN0aW9uRXZlbnRUeXBlIiwiV0MiLCJXUyIsIkRTIiwiV1AiLCJEUCIsIlBhZ2VBY3Rpb25FdmVudFR5cGUiLCJPIiwiRVJST1JTIiwiV0FSTklOR1MiLCJJTkZPUyIsImRlcGVuZGVuY3kiLCJzZXRMaW5lV2lkdGgiLCJzZXRMaW5lQ2FwIiwic2V0TGluZUpvaW4iLCJzZXRNaXRlckxpbWl0Iiwic2V0RGFzaCIsInNldFJlbmRlcmluZ0ludGVudCIsInNldEZsYXRuZXNzIiwic2V0R1N0YXRlIiwic2F2ZSIsInJlc3RvcmUiLCJ0cmFuc2Zvcm0iLCJtb3ZlVG8iLCJsaW5lVG8iLCJjdXJ2ZVRvIiwiY3VydmVUbzIiLCJjdXJ2ZVRvMyIsImNsb3NlUGF0aCIsInJlY3RhbmdsZSIsInN0cm9rZSIsImNsb3NlU3Ryb2tlIiwiZmlsbCIsImVvRmlsbCIsImZpbGxTdHJva2UiLCJlb0ZpbGxTdHJva2UiLCJjbG9zZUZpbGxTdHJva2UiLCJjbG9zZUVPRmlsbFN0cm9rZSIsImVuZFBhdGgiLCJjbGlwIiwiZW9DbGlwIiwiYmVnaW5UZXh0IiwiZW5kVGV4dCIsInNldENoYXJTcGFjaW5nIiwic2V0V29yZFNwYWNpbmciLCJzZXRIU2NhbGUiLCJzZXRMZWFkaW5nIiwic2V0Rm9udCIsInNldFRleHRSZW5kZXJpbmdNb2RlIiwic2V0VGV4dFJpc2UiLCJtb3ZlVGV4dCIsInNldExlYWRpbmdNb3ZlVGV4dCIsInNldFRleHRNYXRyaXgiLCJuZXh0TGluZSIsInNob3dUZXh0Iiwic2hvd1NwYWNlZFRleHQiLCJuZXh0TGluZVNob3dUZXh0IiwibmV4dExpbmVTZXRTcGFjaW5nU2hvd1RleHQiLCJzZXRDaGFyV2lkdGgiLCJzZXRDaGFyV2lkdGhBbmRCb3VuZHMiLCJzZXRTdHJva2VDb2xvclNwYWNlIiwic2V0RmlsbENvbG9yU3BhY2UiLCJzZXRTdHJva2VDb2xvciIsInNldFN0cm9rZUNvbG9yTiIsInNldEZpbGxDb2xvciIsInNldEZpbGxDb2xvck4iLCJzZXRTdHJva2VHcmF5Iiwic2V0RmlsbEdyYXkiLCJzZXRTdHJva2VSR0JDb2xvciIsInNldEZpbGxSR0JDb2xvciIsInNldFN0cm9rZUNNWUtDb2xvciIsInNldEZpbGxDTVlLQ29sb3IiLCJzaGFkaW5nRmlsbCIsImJlZ2luSW5saW5lSW1hZ2UiLCJiZWdpbkltYWdlRGF0YSIsImVuZElubGluZUltYWdlIiwicGFpbnRYT2JqZWN0IiwibWFya1BvaW50IiwibWFya1BvaW50UHJvcHMiLCJiZWdpbk1hcmtlZENvbnRlbnQiLCJiZWdpbk1hcmtlZENvbnRlbnRQcm9wcyIsImVuZE1hcmtlZENvbnRlbnQiLCJiZWdpbkNvbXBhdCIsImVuZENvbXBhdCIsInBhaW50Rm9ybVhPYmplY3RCZWdpbiIsInBhaW50Rm9ybVhPYmplY3RFbmQiLCJiZWdpbkdyb3VwIiwiZW5kR3JvdXAiLCJiZWdpbkFubm90YXRpb24iLCJlbmRBbm5vdGF0aW9uIiwicGFpbnRJbWFnZU1hc2tYT2JqZWN0IiwicGFpbnRJbWFnZU1hc2tYT2JqZWN0R3JvdXAiLCJwYWludEltYWdlWE9iamVjdCIsInBhaW50SW5saW5lSW1hZ2VYT2JqZWN0IiwicGFpbnRJbmxpbmVJbWFnZVhPYmplY3RHcm91cCIsInBhaW50SW1hZ2VYT2JqZWN0UmVwZWF0IiwicGFpbnRJbWFnZU1hc2tYT2JqZWN0UmVwZWF0IiwicGFpbnRTb2xpZENvbG9ySW1hZ2VNYXNrIiwiY29uc3RydWN0UGF0aCIsInNldFN0cm9rZVRyYW5zcGFyZW50Iiwic2V0RmlsbFRyYW5zcGFyZW50IiwiTkVFRF9QQVNTV09SRCIsIklOQ09SUkVDVF9QQVNTV09SRCIsInZlcmJvc2l0eSIsInNldFZlcmJvc2l0eUxldmVsIiwibGV2ZWwiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJnZXRWZXJib3NpdHlMZXZlbCIsImluZm8iLCJtc2ciLCJjb25zb2xlIiwibG9nIiwid2FybiIsInVucmVhY2hhYmxlIiwiRXJyb3IiLCJhc3NlcnQiLCJjb25kIiwiX2lzVmFsaWRQcm90b2NvbCIsInVybCIsInByb3RvY29sIiwiYmFzZVVybCIsIm9wdGlvbnMiLCJhZGREZWZhdWx0UHJvdG9jb2wiLCJzdGFydHNXaXRoIiwiZG90cyIsIm1hdGNoIiwibGVuZ3RoIiwidHJ5Q29udmVydEVuY29kaW5nIiwic3RyaW5nVG9VVEY4U3RyaW5nIiwiYWJzb2x1dGVVcmwiLCJVUkwiLCJ2YWx1ZSIsIm5vblNlcmlhbGl6YWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiQmFzZUV4Y2VwdGlvbiIsIkJhc2VFeGNlcHRpb25DbG9zdXJlIiwibWVzc2FnZSIsIm5hbWUiLCJjb25zdHJ1Y3RvciIsIlBhc3N3b3JkRXhjZXB0aW9uIiwiY29kZSIsIlVua25vd25FcnJvckV4Y2VwdGlvbiIsImRldGFpbHMiLCJzdGF0dXMiLCJGb3JtYXRFcnJvciIsImJ5dGVzVG9TdHJpbmciLCJieXRlcyIsInVuZGVmaW5lZCIsIk1BWF9BUkdVTUVOVF9DT1VOVCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImFwcGx5Iiwic3RyQnVmIiwiaSIsImNodW5rRW5kIiwiTWF0aCIsIm1pbiIsImNodW5rIiwic3ViYXJyYXkiLCJwdXNoIiwiam9pbiIsInN0cmluZ1RvQnl0ZXMiLCJzdHIiLCJVaW50OEFycmF5IiwiY2hhckNvZGVBdCIsInN0cmluZzMyIiwib2JqZWN0U2l6ZSIsImtleXMiLCJvYmplY3RGcm9tTWFwIiwibWFwIiwiY3JlYXRlIiwiaXNMaXR0bGVFbmRpYW4iLCJidWZmZXI4IiwidmlldzMyIiwiVWludDMyQXJyYXkiLCJidWZmZXIiLCJpc0V2YWxTdXBwb3J0ZWQiLCJGdW5jdGlvbiIsImlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkIiwiT2Zmc2NyZWVuQ2FudmFzIiwiaXNJbWFnZURlY29kZXJTdXBwb3J0ZWQiLCJJbWFnZURlY29kZXIiLCJwbGF0Zm9ybSIsIm5hdmlnYXRvciIsImlzTWFjIiwiaW5jbHVkZXMiLCJpc1dpbmRvd3MiLCJpc0ZpcmVmb3giLCJ1c2VyQWdlbnQiLCJpc0NTU1JvdW5kU3VwcG9ydGVkIiwiQ1NTIiwic3VwcG9ydHMiLCJoZXhOdW1iZXJzIiwiQXJyYXkiLCJmcm9tIiwibiIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJtYWtlSGV4Q29sb3IiLCJyIiwiZyIsImIiLCJzY2FsZU1pbk1heCIsIm1pbk1heCIsInRlbXAiLCJtMSIsIm0yIiwiYXBwbHlUcmFuc2Zvcm0iLCJwIiwibSIsInh0IiwieXQiLCJhcHBseUludmVyc2VUcmFuc2Zvcm0iLCJnZXRBeGlhbEFsaWduZWRCb3VuZGluZ0JveCIsInAxIiwicDIiLCJzbGljZSIsInAzIiwicDQiLCJtYXgiLCJpbnZlcnNlVHJhbnNmb3JtIiwic2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUiLCJ0cmFuc3Bvc2UiLCJhIiwiYyIsImZpcnN0Iiwic2Vjb25kIiwic3FydCIsInN4Iiwic3kiLCJub3JtYWxpemVSZWN0IiwicmVjdCIsImludGVyc2VjdCIsInJlY3QxIiwicmVjdDIiLCJ4TG93IiwieEhpZ2giLCJ5TG93IiwieUhpZ2giLCJnZXRFeHRyZW11bU9uQ3VydmUiLCJ4MCIsIngxIiwieDIiLCJ4MyIsInkwIiwieTEiLCJ5MiIsInkzIiwidCIsIm10IiwidHQiLCJ0dHQiLCJ4IiwieSIsImdldEV4dHJlbXVtIiwiYWJzIiwiZGVsdGEiLCJzcXJ0RGVsdGEiLCJhMiIsImJlemllckJvdW5kaW5nQm94IiwiUERGU3RyaW5nVHJhbnNsYXRlVGFibGUiLCJzdHJpbmdUb1BERlN0cmluZyIsImVuY29kaW5nIiwiZGVjb2RlciIsIlRleHREZWNvZGVyIiwiZmF0YWwiLCJkZWNvZGVkIiwiZGVjb2RlIiwicmVwbGFjZUFsbCIsImV4IiwiaWkiLCJjaGFyQ29kZSIsImNoYXJBdCIsImRlY29kZVVSSUNvbXBvbmVudCIsImVzY2FwZSIsInV0ZjhTdHJpbmdUb1N0cmluZyIsInVuZXNjYXBlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiaXNBcnJheUVxdWFsIiwiYXJyMSIsImFycjIiLCJnZXRNb2RpZmljYXRpb25EYXRlIiwiZGF0ZSIsIkRhdGUiLCJnZXRVVENGdWxsWWVhciIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRGF0ZSIsImdldFVUQ0hvdXJzIiwiZ2V0VVRDTWludXRlcyIsImdldFVUQ1NlY29uZHMiLCJOb3JtYWxpemVSZWdleCIsIk5vcm1hbGl6YXRpb25NYXAiLCJNYXAiLCJfIiwibm9ybWFsaXplIiwiZ2V0VXVpZCIsImNyeXB0byIsInJhbmRvbVVVSUQiLCJidWYiLCJnZXRSYW5kb21WYWx1ZXMiLCJBbm5vdGF0aW9uUHJlZml4IiwiRm9udFJlbmRlck9wcyIsIkJFWklFUl9DVVJWRV9UTyIsIk1PVkVfVE8iLCJMSU5FX1RPIiwiUVVBRFJBVElDX0NVUlZFX1RPIiwiUkVTVE9SRSIsIlNDQUxFIiwiVFJBTlNGT1JNIiwiVFJBTlNMQVRFIiwidG9IZXhVdGlsIiwiYXJyIiwidG9IZXgiLCJudW0iLCJ0b0Jhc2U2NFV0aWwiLCJ0b0Jhc2U2NCIsImJ0b2EiLCJmcm9tQmFzZTY0VXRpbCIsImZyb21CYXNlNjQiLCJhdG9iIiwiUHJvbWlzZSIsInRyeSIsImZuIiwiYXJncyIsInJlc29sdmUiLCJTVkdfTlMiLCJQREYiLCJQREZfVE9fQ1NTX1VOSVRTIiwiaXNWYWxpZEZldGNoVXJsIiwiZG9jdW1lbnQiLCJiYXNlVVJJIiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwic3RhdHVzVGV4dCIsImFycmF5QnVmZmVyIiwiYmxvYiIsImpzb24iLCJ0ZXh0IiwicmVqZWN0IiwicmVxdWVzdCIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsInJlc3BvbnNlVHlwZSIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlYWR5U3RhdGUiLCJET05FIiwicmVzcG9uc2VUZXh0Iiwic2VuZCIsIlBhZ2VWaWV3cG9ydCIsInZpZXdCb3giLCJzY2FsZSIsInJvdGF0aW9uIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJkb250RmxpcCIsImNlbnRlclgiLCJjZW50ZXJZIiwicm90YXRlQSIsInJvdGF0ZUIiLCJyb3RhdGVDIiwicm90YXRlRCIsIm9mZnNldENhbnZhc1giLCJvZmZzZXRDYW52YXNZIiwid2lkdGgiLCJoZWlnaHQiLCJyYXdEaW1zIiwicGFnZVdpZHRoIiwicGFnZUhlaWdodCIsInBhZ2VYIiwicGFnZVkiLCJjbG9uZSIsImNvbnZlcnRUb1ZpZXdwb3J0UG9pbnQiLCJjb252ZXJ0VG9WaWV3cG9ydFJlY3RhbmdsZSIsInRvcExlZnQiLCJib3R0b21SaWdodCIsImNvbnZlcnRUb1BkZlBvaW50IiwiZXh0cmFEZWxheSIsInRyaW0iLCJzdWJzdHJpbmciLCJ0b0xvd2VyQ2FzZSIsImZpbGVuYW1lIiwidGVzdCIsInNwbGl0IiwibGFzdEluZGV4T2YiLCJkZWZhdWx0RmlsZW5hbWUiLCJyZVVSSSIsInJlRmlsZW5hbWUiLCJzcGxpdFVSSSIsImV4ZWMiLCJzdWdnZXN0ZWRGaWxlbmFtZSIsIlN0YXRUaW1lciIsInRpbWUiLCJzdGFydGVkIiwibm93IiwidGltZUVuZCIsInRpbWVzIiwic3RhcnQiLCJlbmQiLCJvdXRCdWYiLCJsb25nZXN0IiwicGFkRW5kIiwiZSIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiZGVwcmVjYXRlZCIsInJlZ2V4IiwidG9EYXRlT2JqZWN0IiwiaW5wdXQiLCJSZWdFeHAiLCJtYXRjaGVzIiwieWVhciIsInBhcnNlSW50IiwibW9udGgiLCJkYXkiLCJob3VyIiwibWludXRlIiwidW5pdmVyc2FsVGltZVJlbGF0aW9uIiwib2Zmc2V0SG91ciIsIm9mZnNldE1pbnV0ZSIsIlVUQyIsInhmYVBhZ2UiLCJhdHRyaWJ1dGVzIiwic3R5bGUiLCJnZXRSR0IiLCJjb2xvciIsImNvbG9yUkdCIiwiZ2V0Q29sb3JWYWx1ZXMiLCJjb2xvcnMiLCJzcGFuIiwiY3JlYXRlRWxlbWVudCIsInZpc2liaWxpdHkiLCJib2R5IiwiYXBwZW5kIiwiY29tcHV0ZWRDb2xvciIsIndpbmRvdyIsImdldENvbXB1dGVkU3R5bGUiLCJzZXQiLCJyZW1vdmUiLCJnZXRDdXJyZW50VHJhbnNmb3JtIiwiY3R4IiwiZiIsImdldFRyYW5zZm9ybSIsImdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlIiwiaW52ZXJ0U2VsZiIsImRpdiIsInZpZXdwb3J0IiwibXVzdEZsaXAiLCJtdXN0Um90YXRlIiwidXNlUm91bmQiLCJ3IiwiaCIsIndpZHRoU3RyIiwiaGVpZ2h0U3RyIiwic2V0QXR0cmlidXRlIiwicGl4ZWxSYXRpbyIsImRldmljZVBpeGVsUmF0aW8iLCJzY2FsZWQiLCJzeW1tZXRyaWMiLCJFZGl0b3JUb29sYmFyIiwidG9vbGJhciIsImNvbG9yUGlja2VyIiwiZWRpdG9yIiwiYnV0dG9ucyIsImFsdFRleHQiLCJsMTBuUmVtb3ZlIiwiZnJlZXplIiwiZnJlZXRleHQiLCJoaWdobGlnaHQiLCJpbmsiLCJzdGFtcCIsInJlbmRlciIsImVkaXRUb29sYmFyIiwiY2xhc3NMaXN0IiwiYWRkIiwic2lnbmFsIiwiX3VpTWFuYWdlciIsIl9zaWduYWwiLCJhZGRFdmVudExpc3RlbmVyIiwicG9pbnRlckRvd24iLCJjbGFzc05hbWUiLCJwb3NpdGlvbiIsInRvb2xiYXJQb3NpdGlvbiIsImRpcmVjdGlvbiIsImluc2V0SW5saW5lRW5kIiwidG9wIiwiYWRkRGVsZXRlQnV0dG9uIiwiZm9jdXNJbiIsIl9mb2N1c0V2ZW50c0FsbG93ZWQiLCJmb2N1c091dCIsImFkZExpc3RlbmVyc1RvRWxlbWVudCIsImVsZW1lbnQiLCJiaW5kIiwiY2FwdHVyZSIsImhpZGUiLCJoaWRlRHJvcGRvd24iLCJzaG93Iiwic2hvd24iLCJlZGl0b3JUeXBlIiwiYnV0dG9uIiwidGFiSW5kZXgiLCJkZWxldGUiLCJkaXZpZGVyIiwiYWRkQWx0VGV4dCIsInByZXBlbmQiLCJhZGRDb2xvclBpY2tlciIsInJlbmRlckJ1dHRvbiIsImRlc3Ryb3kiLCJIaWdobGlnaHRUb29sYmFyIiwidWlNYW5hZ2VyIiwiYWRkSGlnaGxpZ2h0QnV0dG9uIiwiZ2V0TGFzdFBvaW50IiwiYm94ZXMiLCJpc0xUUiIsImxhc3RZIiwibGFzdFgiLCJib3giLCJwYXJlbnQiLCJoaWdobGlnaHRTZWxlY3Rpb24iLCJiaW5kRXZlbnRzIiwibmFtZXMiLCJvcGFjaXR5VG9IZXgiLCJvcGFjaXR5Iiwicm91bmQiLCJJZE1hbmFnZXIiLCJpZCIsIkltYWdlTWFuYWdlciIsImJhc2VJZCIsImNhY2hlIiwiX2lzU1ZHRml0dGluZ0NhbnZhcyIsInN2ZyIsImNhbnZhcyIsImdldENvbnRleHQiLCJ3aWxsUmVhZEZyZXF1ZW50bHkiLCJpbWFnZSIsIkltYWdlIiwic3JjIiwicHJvbWlzZSIsInRoZW4iLCJkcmF3SW1hZ2UiLCJnZXRJbWFnZURhdGEiLCJkYXRhIiwicmF3RGF0YSIsImJpdG1hcCIsInJlZkNvdW50ZXIiLCJpc1N2ZyIsIkZpbGUiLCJmaWxlIiwiQmxvYiIsIm11c3RSZW1vdmVBc3BlY3RSYXRpb1Byb21pc2UiLCJmaWxlUmVhZGVyIiwiRmlsZVJlYWRlciIsImltYWdlRWxlbWVudCIsImltYWdlUHJvbWlzZSIsIm9ubG9hZCIsInN2Z1VybCIsInJlc3VsdCIsIm9uZXJyb3IiLCJyZWFkQXNEYXRhVVJMIiwiY3JlYXRlSW1hZ2VCaXRtYXAiLCJnZXRGcm9tRmlsZSIsImxhc3RNb2RpZmllZCIsInNpemUiLCJnZXRGcm9tVXJsIiwiZ2V0RnJvbUJsb2IiLCJibG9iUHJvbWlzZSIsImdldEZyb21JZCIsImdldEZyb21DYW52YXMiLCJvZmZzY3JlZW4iLCJ0cmFuc2ZlclRvSW1hZ2VCaXRtYXAiLCJnZXRTdmdVcmwiLCJkZWxldGVJZCIsInRyYW5zZmVyRnJvbUltYWdlQml0bWFwIiwiY29udmVydFRvQmxvYiIsImNsb3NlIiwiaXNWYWxpZElkIiwiQ29tbWFuZE1hbmFnZXIiLCJjb21tYW5kcyIsImxvY2tlZCIsIm1heFNpemUiLCJjbWQiLCJ1bmRvIiwicG9zdCIsIm11c3RFeGVjIiwiTmFOIiwib3ZlcndyaXRlSWZTYW1lVHlwZSIsImtlZXBVbmRvIiwibmV4dCIsInNwbGljZSIsInJlZG8iLCJoYXNTb21ldGhpbmdUb1VuZG8iLCJoYXNTb21ldGhpbmdUb1JlZG8iLCJjbGVhblR5cGUiLCJLZXlib2FyZE1hbmFnZXIiLCJjYWxsYmFja3MiLCJhbGxLZXlzIiwiU2V0IiwiY2FsbGJhY2siLCJpc01hY0tleSIsImF0Iiwic2VyaWFsaXplIiwiZXZlbnQiLCJhbHRLZXkiLCJjdHJsS2V5IiwibWV0YUtleSIsInNoaWZ0S2V5Iiwic2VsZiIsImhhcyIsImJ1YmJsZXMiLCJjaGVja2VyIiwiQ29sb3JNYW5hZ2VyIiwiX2NvbG9yc01hcHBpbmciLCJfY29sb3JzIiwiY29udmVydCIsInJnYiIsIm1hdGNoTWVkaWEiLCJSR0IiLCJldmVyeSIsImdldEhleENvZGUiLCJhYm9ydENvbnRyb2xsZXIiLCJhY3RpdmVFZGl0b3IiLCJhbGxFZGl0b3JzIiwiYWxsTGF5ZXJzIiwiYWx0VGV4dE1hbmFnZXIiLCJhbm5vdGF0aW9uU3RvcmFnZSIsImNoYW5nZWRFeGlzdGluZ0Fubm90YXRpb25zIiwiY29tbWFuZE1hbmFnZXIiLCJjb3B5UGFzdGVBQyIsImN1cnJlbnREcmF3aW5nU2Vzc2lvbiIsImN1cnJlbnRQYWdlSW5kZXgiLCJkZWxldGVkQW5ub3RhdGlvbnNFbGVtZW50SWRzIiwiZHJhZ2dpbmdFZGl0b3JzIiwiZWRpdG9yVHlwZXMiLCJlZGl0b3JzVG9SZXNjYWxlIiwiZW5hYmxlSGlnaGxpZ2h0RmxvYXRpbmdCdXR0b24iLCJlbmFibGVVcGRhdGVkQWRkSW1hZ2UiLCJlbmFibGVOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlIiwiZmlsdGVyRmFjdG9yeSIsImZvY3VzTWFpbkNvbnRhaW5lclRpbWVvdXRJZCIsImZvY3VzTWFuYWdlckFDIiwiaGlnaGxpZ2h0Q29sb3JzIiwiaGlnaGxpZ2h0V2hlblNoaWZ0VXAiLCJoaWdobGlnaHRUb29sYmFyIiwiaWRNYW5hZ2VyIiwiaXNFbmFibGVkIiwiaXNXYWl0aW5nIiwia2V5Ym9hcmRNYW5hZ2VyQUMiLCJsYXN0QWN0aXZlRWxlbWVudCIsIm1haW5IaWdobGlnaHRDb2xvclBpY2tlciIsIm1sTWFuYWdlciIsIm1vZGUiLCJzZWxlY3RlZEVkaXRvcnMiLCJzZWxlY3RlZFRleHROb2RlIiwicGFnZUNvbG9ycyIsInNob3dBbGxTdGF0ZXMiLCJwcmV2aW91c1N0YXRlcyIsInRyYW5zbGF0aW9uIiwidHJhbnNsYXRpb25UaW1lb3V0SWQiLCJjb250YWluZXIiLCJ2aWV3ZXIiLCJ1cGRhdGVNb2RlQ2FwYWJpbGl0eSIsIlRSQU5TTEFURV9TTUFMTCIsIlRSQU5TTEFURV9CSUciLCJfa2V5Ym9hcmRNYW5hZ2VyIiwicHJvdG8iLCJhcnJvd0NoZWNrZXIiLCJjb250YWlucyIsImFjdGl2ZUVsZW1lbnQiLCJ0YWdOYW1lIiwiaGFzU29tZXRoaW5nVG9Db250cm9sIiwidGV4dElucHV0Q2hlY2tlciIsIl9zZWxmIiwidGFyZ2V0IiwiZWwiLCJIVE1MSW5wdXRFbGVtZW50Iiwic21hbGwiLCJiaWciLCJzZWxlY3RBbGwiLCJhZGROZXdFZGl0b3JGcm9tS2V5Ym9hcmQiLCJIVE1MQnV0dG9uRWxlbWVudCIsImlzRW50ZXJIYW5kbGVkIiwidW5zZWxlY3RBbGwiLCJ0cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMiLCJldmVudEJ1cyIsInBkZkRvY3VtZW50IiwiZWRpdG9yVW5kb0JhciIsIkFib3J0Q29udHJvbGxlciIsIl9lZGl0b3JVbmRvQmFyIiwiaXNFZGl0aW5nIiwiaXNFbXB0eSIsImhhc1NlbGVjdGVkRWRpdG9yIiwiaGFzU2VsZWN0ZWRUZXh0IiwiX2V2ZW50QnVzIiwiX29uIiwib25FZGl0aW5nQWN0aW9uIiwib25QYWdlQ2hhbmdpbmciLCJvblNjYWxlQ2hhbmdpbmciLCJvblJvdGF0aW9uQ2hhbmdpbmciLCJvblNldFByZWZlcmVuY2UiLCJldnQiLCJ1cGRhdGVQYXJhbXMiLCJhZGRTZWxlY3Rpb25MaXN0ZW5lciIsImFkZERyYWdBbmREcm9wTGlzdGVuZXJzIiwiYWRkS2V5Ym9hcmRNYW5hZ2VyIiwidmlld1BhcmFtZXRlcnMiLCJyZWFsU2NhbGUiLCJpc1NoaWZ0S2V5RG93biIsImFib3J0IiwibGF5ZXIiLCJ2YWx1ZXMiLCJjbGVhciIsImNsZWFyVGltZW91dCIsImNvbWJpbmVkU2lnbmFsIiwiYWMiLCJBYm9ydFNpZ25hbCIsImFueSIsInVzZU5ld0FsdFRleHRGbG93IiwidXNlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSIsImhjbUZpbHRlciIsImFkZEhDTUZpbHRlciIsImZvcmVncm91bmQiLCJiYWNrZ3JvdW5kIiwicGFpciIsImhpZ2hsaWdodENvbG9yTmFtZXMiLCJyZXZlcnNlIiwic2V0Q3VycmVudERyYXdpbmdTZXNzaW9uIiwiZGlzYWJsZVVzZXJTZWxlY3QiLCJzZXRNYWluSGlnaGxpZ2h0Q29sb3JQaWNrZXIiLCJlZGl0QWx0VGV4dCIsImZpcnN0VGltZSIsInN3aXRjaFRvTW9kZSIsIm9uIiwib25jZSIsImRpc3BhdGNoIiwic291cmNlIiwic2V0UHJlZmVyZW5jZSIsInBhZ2VOdW1iZXIiLCJmb2N1c01haW5Db250YWluZXIiLCJmb2N1cyIsImZpbmRQYXJlbnQiLCJsYXllclgiLCJsYXllclkiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ0b2dnbGUiLCJhZGRTaG91bGRSZXNjYWxlIiwicmVtb3ZlU2hvdWxkUmVzY2FsZSIsImNvbW1pdE9yUmVtb3ZlIiwicGFnZXNSb3RhdGlvbiIsImdldEFuY2hvckVsZW1lbnRGb3JTZWxlY3Rpb24iLCJhbmNob3JOb2RlIiwibm9kZVR5cGUiLCJOb2RlIiwiVEVYVF9OT0RFIiwicGFyZW50RWxlbWVudCIsImdldExheWVyRm9yVGV4dExheWVyIiwidGV4dExheWVyIiwiY3VycmVudExheWVyIiwiaGFzVGV4dExheWVyIiwibWV0aG9kT2ZDcmVhdGlvbiIsInNlbGVjdGlvbiIsImdldFNlbGVjdGlvbiIsImlzQ29sbGFwc2VkIiwiYW5jaG9yT2Zmc2V0IiwiZm9jdXNOb2RlIiwiZm9jdXNPZmZzZXQiLCJhbmNob3JFbGVtZW50IiwiY2xvc2VzdCIsImdldFNlbGVjdGlvbkJveGVzIiwiZW1wdHkiLCJpc05vbmVNb2RlIiwiY3JlYXRlQW5kQWRkTmV3RWRpdG9yIiwic2hvd0FsbEVkaXRvcnMiLCJkaXNwbGF5SGlnaGxpZ2h0VG9vbGJhciIsImFkZFRvQW5ub3RhdGlvblN0b3JhZ2UiLCJzZXRWYWx1ZSIsInNlbGVjdGlvbkNoYW5nZSIsImRpc3BhdGNoVXBkYXRlU3RhdGVzIiwiYWN0aXZlTGF5ZXIiLCJ0b2dnbGVEcmF3aW5nIiwicG9pbnRlcnVwIiwib25TZWxlY3RFbmQiLCJhZGRGb2N1c01hbmFnZXIiLCJibHVyIiwicmVtb3ZlRm9jdXNNYW5hZ2VyIiwiaGFzU2VsZWN0aW9uIiwibGFzdEVkaXRvciIsImtleWRvd24iLCJrZXl1cCIsInJlbW92ZUtleWJvYXJkTWFuYWdlciIsImFkZENvcHlQYXN0ZUxpc3RlbmVycyIsImNvcHkiLCJjdXQiLCJwYXN0ZSIsInJlbW92ZUNvcHlQYXN0ZUxpc3RlbmVycyIsImRyYWdPdmVyIiwiZHJvcCIsImFkZEVkaXRMaXN0ZW5lcnMiLCJyZW1vdmVFZGl0TGlzdGVuZXJzIiwiZGF0YVRyYW5zZmVyIiwiaXRlbXMiLCJpc0hhbmRsaW5nTWltZUZvclBhc3RpbmciLCJkcm9wRWZmZWN0IiwiaXRlbSIsImVkaXRvcnMiLCJzZXJpYWxpemVkIiwiY2xpcGJvYXJkRGF0YSIsInNldERhdGEiLCJKU09OIiwic3RyaW5naWZ5IiwiZ2V0RGF0YSIsInBhcnNlIiwiaXNBcnJheSIsIm5ld0VkaXRvcnMiLCJkZXNlcmlhbGl6ZWRFZGl0b3IiLCJkZXNlcmlhbGl6ZSIsImFkZEVkaXRvclRvTGF5ZXIiLCJzZWxlY3RFZGl0b3JzIiwiYWRkQ29tbWFuZHMiLCJpc0VkaXRvckhhbmRsaW5nS2V5Ym9hcmQiLCJoYXNDaGFuZ2VkIiwiZW50cmllcyIsInNvbWUiLCJhc3NpZ24iLCJkaXNwYXRjaFVwZGF0ZVVJIiwic2V0RWRpdGluZ1N0YXRlIiwicmVnaXN0ZXJFZGl0b3JUeXBlcyIsInR5cGVzIiwiZGVmYXVsdFByb3BlcnRpZXNUb1VwZGF0ZSIsImdldElkIiwiZ2V0TGF5ZXIiLCJwYWdlSW5kZXgiLCJhZGRMYXllciIsImVuYWJsZSIsImRpc2FibGUiLCJyZW1vdmVMYXllciIsInVwZGF0ZU1vZGUiLCJlZGl0SWQiLCJpc0Zyb21LZXlib2FyZCIsIndpdGhSZXNvbHZlcnMiLCJkaXNhYmxlQWxsIiwiZW5hYmxlQWxsIiwiYW5ub3RhdGlvbkVsZW1lbnRJZCIsInNldFNlbGVjdGVkIiwiZW50ZXJJbkVkaXRNb2RlIiwidW5zZWxlY3QiLCJjYW5DcmVhdGVOZXdFbXB0eUVkaXRvciIsImFkZE5ld0VkaXRvciIsInVwZGF0ZVRvb2xiYXIiLCJ1cGRhdGVDb2xvciIsImFjdGlvbiIsInVwZGF0ZURlZmF1bHRQYXJhbXMiLCJ2aXNpYmxlIiwidXBkYXRlQnV0dG9uIiwic3RhdGUiLCJlbmFibGVXYWl0aW5nIiwibXVzdFdhaXQiLCJkaXNhYmxlQ2xpY2siLCJlbmFibGVDbGljayIsInByb21pc2VzIiwiYWxsIiwiZ2V0RWRpdG9ycyIsImdldEVkaXRvciIsImFkZEVkaXRvciIsInJlbW92ZUVkaXRvciIsInNldFRpbWVvdXQiLCJhZGREZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQiLCJhZGRDaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9uIiwiZGVsZXRlZCIsImlzRGVsZXRlZEFubm90YXRpb25FbGVtZW50IiwicmVtb3ZlRGVsZXRlZEFubm90YXRpb25FbGVtZW50IiwicmVtb3ZlQ2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbiIsImFkZE9yUmVidWlsZCIsInNldEFjdGl2ZUVkaXRvciIsInByb3BlcnRpZXNUb1VwZGF0ZSIsImxhc3RTZWxlY3RlZEVkaXRvciIsImVkIiwidXBkYXRlVUkiLCJ1cGRhdGVVSUZvckRlZmF1bHRQcm9wZXJ0aWVzIiwidG9nZ2xlU2VsZWN0ZWQiLCJzZWxlY3QiLCJpc1NlbGVjdGVkIiwiZmlyc3RTZWxlY3RlZEVkaXRvciIsInBhcmFtcyIsImNsZWFuVW5kb1N0YWNrIiwiZHJhd2luZ0VkaXRvciIsImVuZERyYXdpbmdTZXNzaW9uIiwiY29tbWl0Iiwibm9Db21taXQiLCJ0b3RhbFgiLCJ0b3RhbFkiLCJUSU1FX1RPX1dBSVQiLCJ0cmFuc2xhdGVJblBhZ2UiLCJzZXRVcERyYWdTZXNzaW9uIiwic2F2ZWRYIiwic2F2ZWRZIiwic2F2ZWRQYWdlSW5kZXgiLCJuZXdYIiwibmV3WSIsIm5ld1BhZ2VJbmRleCIsImVuZERyYWdTZXNzaW9uIiwibXVzdEJlQWRkZWRJblVuZG9TdGFjayIsIm1vdmUiLCJfc2V0UGFyZW50QW5kUG9zaXRpb24iLCJkcmFnU2VsZWN0ZWRFZGl0b3JzIiwidHgiLCJ0eSIsImRyYWciLCJyZWJ1aWxkIiwiY2hhbmdlUGFyZW50IiwiZ2V0QWN0aXZlIiwic2hvdWxkR2V0S2V5Ym9hcmRFdmVudHMiLCJpc0FjdGl2ZSIsImdldE1vZGUiLCJpbWFnZU1hbmFnZXIiLCJyYW5nZUNvdW50IiwiZ2V0UmFuZ2VBdCIsImNvbW1vbkFuY2VzdG9yQ29udGFpbmVyIiwicGFyZW50V2lkdGgiLCJwYXJlbnRIZWlnaHQiLCJyb3RhdG9yIiwiZ2V0QXR0cmlidXRlIiwicmFuZ2UiLCJjb2xsYXBzZWQiLCJnZXRDbGllbnRSZWN0cyIsInJlbmRlckFubm90YXRpb25FbGVtZW50IiwiYW5ub3RhdGlvbiIsImVkaXRvcklkIiwiZ2V0UmF3VmFsdWUiLCJoYXNCZWVuTW9kaWZpZWQiLCJBbHRUZXh0IiwiYWx0VGV4dERlY29yYXRpdmUiLCJhbHRUZXh0QnV0dG9uIiwiYWx0VGV4dEJ1dHRvbkxhYmVsIiwiYWx0VGV4dFRvb2x0aXAiLCJhbHRUZXh0VG9vbHRpcFRpbWVvdXQiLCJhbHRUZXh0V2FzRnJvbUtleUJvYXJkIiwiYmFkZ2UiLCJndWVzc2VkVGV4dCIsInRleHRXaXRoRGlzY2xhaW1lciIsImwxMG5OZXdCdXR0b24iLCJfbDEwbiIsImFkZGVkIiwibWlzc2luZyIsInJldmlldyIsImluaXRpYWxpemUiLCJsMTBuIiwibGFiZWwiLCJvbkNsaWNrIiwiX3JlcG9ydFRlbGVtZXRyeSIsInNldFN0YXRlIiwiZmluaXNoIiwiZm9jdXNWaXNpYmxlIiwiaGFzRGF0YSIsInNldEd1ZXNzZWRUZXh0IiwiZ2VuZXJhdGVkQWx0VGV4dCIsInRvZ2dsZUFsdFRleHRCYWRnZSIsImlzRm9yQ29weWluZyIsImRlY29yYXRpdmUiLCJjYW5jZWwiLCJlbmFibGVkIiwiZGlzYWJsZWQiLCJ0b29sdGlwIiwiREVMQVlfVE9fU0hPV19UT09MVElQIiwicmVtb3ZlQXR0cmlidXRlIiwidGV4dENvbnRlbnQiLCJwYXJlbnROb2RlIiwiZ2V0SW1hZ2VGb3JBbHRUZXh0IiwiQW5ub3RhdGlvbkVkaXRvciIsImFjY2Vzc2liaWxpdHlEYXRhIiwiYWxsUmVzaXplckRpdnMiLCJkcmFnUG9pbnRlcklkIiwiZHJhZ1BvaW50ZXJUeXBlIiwia2VlcEFzcGVjdFJhdGlvIiwicmVzaXplcnNEaXYiLCJsYXN0UG9pbnRlckNvb3JkcyIsInNhdmVkRGltZW5zaW9ucyIsImZvY3VzQUMiLCJmb2N1c2VkUmVzaXplck5hbWUiLCJoYXNCZWVuQ2xpY2tlZCIsImluaXRpYWxSZWN0IiwiaXNJbkVkaXRNb2RlIiwiaXNSZXNpemVyRW5hYmxlZEZvcktleWJvYXJkIiwibW92ZUluRE9NVGltZW91dCIsInByZXZEcmFnWCIsInByZXZEcmFnWSIsInRlbGVtZXRyeVRpbWVvdXRzIiwiX2wxMG5SZXNpemVyIiwiaXNEcmFnZ2FibGUiLCJ6SW5kZXgiLCJfYm9yZGVyTGluZVdpZHRoIiwiX2NvbG9yTWFuYWdlciIsIl96SW5kZXgiLCJfdGVsZW1ldHJ5VGltZW91dCIsIl9yZXNpemVyS2V5Ym9hcmRNYW5hZ2VyIiwicmVzaXplIiwiX3Jlc2l6ZVdpdGhLZXlib2FyZCIsIl9zdG9wUmVzaXppbmdXaXRoS2V5Ym9hcmQiLCJwYXJhbWV0ZXJzIiwiX2VkaXRUb29sYmFyIiwiX2luaXRpYWxPcHRpb25zIiwiX2luaXRpYWxEYXRhIiwiX2lzVmlzaWJsZSIsIl93aWxsS2VlcEFzcGVjdFJhdGlvIiwiaXNDZW50ZXJlZCIsIl9zdHJ1Y3RUcmVlUGFyZW50SWQiLCJwYWdlUm90YXRpb24iLCJwYWdlRGltZW5zaW9ucyIsInBhZ2VUcmFuc2xhdGlvbiIsInBhcmVudERpbWVuc2lvbnMiLCJpc0F0dGFjaGVkVG9ET00iLCJnZXRQcm90b3R5cGVPZiIsIl90eXBlIiwiaXNEcmF3ZXIiLCJfZGVmYXVsdExpbmVDb2xvciIsImRlbGV0ZUFubm90YXRpb25FbGVtZW50IiwiZmFrZUVkaXRvciIsIkZha2VFZGl0b3IiLCJnZXROZXh0SWQiLCJ0b3BNaWRkbGUiLCJ0b3BSaWdodCIsIm1pZGRsZVJpZ2h0IiwiYm90dG9tTWlkZGxlIiwiYm90dG9tTGVmdCIsIm1pZGRsZUxlZnQiLCJkb2N1bWVudEVsZW1lbnQiLCJwYXJzZUZsb2F0IiwiZ2V0UHJvcGVydHlWYWx1ZSIsIl92YWx1ZSIsIm1pbWUiLCJfaXNEcmFnZ2FibGUiLCJjZW50ZXIiLCJwYXJlbnRSb3RhdGlvbiIsImZpeEFuZFNldFBvc2l0aW9uIiwic2V0SW5CYWNrZ3JvdW5kIiwic2V0SW5Gb3JlZ3JvdW5kIiwic2V0UGFyZW50Iiwic3RvcFJlc2l6aW5nIiwiZm9jdXNpbiIsImZvY3Vzb3V0IiwicmVsYXRlZFRhcmdldCIsImlzTXVsdGlwbGVTZWxlY3Rpb24iLCJzZXRBdCIsInNjcmVlblRvUGFnZVRyYW5zbGF0aW9uIiwidHJhbnNsYXRlIiwiX29uVHJhbnNsYXRpbmciLCJzY3JvbGxJbnRvVmlldyIsImJsb2NrIiwiZmluZE5ld1BhcmVudCIsImZsb29yIiwiYngiLCJieSIsImdldEJhc2VUcmFuc2xhdGlvbiIsImxlZnQiLCJ0b0ZpeGVkIiwiX29uVHJhbnNsYXRlZCIsIl9oYXNCZWVuTW92ZWQiLCJfaGFzQmVlblJlc2l6ZWQiLCJfbXVzdEZpeFBvc2l0aW9uIiwibW92ZUluRE9NIiwicm90YXRlUG9pbnQiLCJhbmdsZSIsInBhZ2VUcmFuc2xhdGlvblRvU2NyZWVuIiwiZ2V0Um90YXRpb25NYXRyaXgiLCJwYXJlbnRTY2FsZSIsInNldERpbXMiLCJmaXhEaW1zIiwid2lkdGhQZXJjZW50IiwiZW5kc1dpdGgiLCJoZWlnaHRQZXJjZW50IiwiZ2V0SW5pdGlhbFRyYW5zbGF0aW9uIiwiY3JlYXRlUmVzaXplcnMiLCJjbGFzc2VzIiwicmVzaXplclBvaW50ZXJkb3duIiwic2F2ZWREcmFnZ2FibGUiLCJzY3JlZW5YIiwic2NyZWVuWSIsInRvZ2dsZVBvaW50ZXJFdmVudHMiLCJyZXNpemVyUG9pbnRlcm1vdmUiLCJwYXNzaXZlIiwic2F2ZWRXaWR0aCIsInNhdmVkSGVpZ2h0Iiwic2F2ZWRQYXJlbnRDdXJzb3IiLCJjdXJzb3IiLCJzYXZlZEN1cnNvciIsInBvaW50ZXJVcENhbGxiYWNrIiwiYWRkUmVzaXplVG9VbmRvU3RhY2siLCJfb25SZXNpemVkIiwibmV3V2lkdGgiLCJuZXdIZWlnaHQiLCJtaW5XaWR0aCIsIk1JTl9TSVpFIiwibWluSGVpZ2h0Iiwicm90YXRpb25NYXRyaXgiLCJ0cmFuc2YiLCJpbnZSb3RhdGlvbk1hdHJpeCIsImludlRyYW5zZiIsImdldFBvaW50IiwiZ2V0T3Bwb3NpdGUiLCJpc0RpYWdvbmFsIiwiaXNIb3Jpem9udGFsIiwicG9pbnQiLCJvcHBvc2l0ZVBvaW50IiwidHJhbnNmT3Bwb3NpdGVQb2ludCIsIm9wcG9zaXRlWCIsIm9wcG9zaXRlWSIsInJhdGlvWCIsInJhdGlvWSIsImRlbHRhWCIsImRlbHRhWSIsImZyb21LZXlib2FyZCIsImxhc3RTY3JlZW5YIiwibGFzdFNjcmVlblkiLCJvbGREaWFnIiwiaHlwb3QiLCJfb25SZXNpemluZyIsImFsdFRleHRGaW5pc2giLCJhZGRFZGl0VG9vbGJhciIsInJlbW92ZUVkaXRUb29sYmFyIiwiYWRkQ29udGFpbmVyIiwiZWRpdFRvb2xiYXJEaXYiLCJiZWZvcmUiLCJnZXRDbGllbnREaW1lbnNpb25zIiwiYWRkQWx0VGV4dEJ1dHRvbiIsImFsdFRleHREYXRhIiwiZ3Vlc3NlZEFsdFRleHQiLCJzZXRHdWVzc2VkQWx0VGV4dCIsInNlcmlhbGl6ZUFsdFRleHQiLCJoYXNBbHRUZXh0IiwiaGFzQWx0VGV4dERhdGEiLCJhZGRGb2N1c0xpc3RlbmVycyIsIm1heFdpZHRoIiwibWF4SGVpZ2h0IiwicG9pbnRlcmRvd24iLCJzZWxlY3RPblBvaW50ZXJFdmVudCIsIm9wdHMiLCJjYW5jZWxEcmFnIiwiY2xpZW50WCIsImNsaWVudFkiLCJwb2ludGVySWQiLCJwb2ludGVyVHlwZSIsImlzUHJpbWFyeSIsIl9vblN0YXJ0RHJhZ2dpbmciLCJfb25TdG9wRHJhZ2dpbmciLCJtb3ZlRWRpdG9ySW5ET00iLCJnZXRSZWN0Iiwic2hpZnRYIiwic2hpZnRZIiwiZ2V0UmVjdEluQ3VycmVudENvb3JkcyIsIm9uY2VBZGRlZCIsImVuYWJsZUVkaXRNb2RlIiwiZGlzYWJsZUVkaXRNb2RlIiwibmVlZHNUb0JlUmVidWlsdCIsImlzT25TY3JlZW4iLCJib3R0b20iLCJyaWdodCIsImlubmVySGVpZ2h0IiwiaW5uZXJXaWR0aCIsInJvdGF0ZSIsIl9hbmdsZSIsInNlcmlhbGl6ZURlbGV0ZWQiLCJwb3B1cFJlZiIsImNvbnRleHQiLCJ0aW1lb3V0IiwiaXNSZXNpemFibGUiLCJtYWtlUmVzaXphYmxlIiwiY2hpbGRyZW4iLCJib3VuZFJlc2l6ZXJLZXlkb3duIiwicmVzaXplcktleWRvd24iLCJib3VuZFJlc2l6ZXJCbHVyIiwicmVzaXplckJsdXIiLCJyZXNpemVyRm9jdXMiLCJmaXJzdFBvc2l0aW9uIiwibmV4dEZpcnN0UG9zaXRpb24iLCJmaXJzdENoaWxkIiwibGFzdENoaWxkIiwiY2hpbGQiLCJzZXRSZXNpemVyVGFiSW5kZXgiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJwcmV2ZW50U2Nyb2xsIiwiZGlzYWJsZUVkaXRpbmciLCJlbmFibGVFZGl0aW5nIiwiY29udGVudERpdiIsInNldEFzcGVjdFJhdGlvIiwiYXNwZWN0UmF0aW8iLCJ0ZWxlbWV0cnlJbml0aWFsRGF0YSIsInRlbGVtZXRyeUZpbmFsRGF0YSIsImNvbnRlbnQiLCJxdWVyeVNlbGVjdG9yIiwibm9kZU5hbWUiLCJyZXNldEFubm90YXRpb25FbGVtZW50IiwiU0VFRCIsIk1BU0tfSElHSCIsIk1BU0tfTE9XIiwiTXVybXVySGFzaDNfNjQiLCJzZWVkIiwiaDEiLCJoMiIsInVwZGF0ZSIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiYnl0ZUxlbmd0aCIsImJsb2NrQ291bnRzIiwidGFpbExlbmd0aCIsImRhdGFVaW50MzIiLCJrMSIsImsyIiwiQzEiLCJDMiIsIkMxX0xPVyIsIkMyX0xPVyIsImhleGRpZ2VzdCIsIlNlcmlhbGl6YWJsZUVtcHR5IiwiaGFzaCIsInRyYW5zZmVyIiwiQW5ub3RhdGlvblN0b3JhZ2UiLCJtb2RpZmllZCIsIm1vZGlmaWVkSWRzIiwic3RvcmFnZSIsIm9uU2V0TW9kaWZpZWQiLCJvblJlc2V0TW9kaWZpZWQiLCJvbkFubm90YXRpb25FZGl0b3IiLCJnZXRWYWx1ZSIsImRlZmF1bHRWYWx1ZSIsInJlc2V0TW9kaWZpZWQiLCJlbnRyeSIsInZhbCIsInNldE1vZGlmaWVkIiwiZ2V0QWxsIiwic2V0QWxsIiwicHJpbnQiLCJQcmludEFubm90YXRpb25TdG9yYWdlIiwic2VyaWFsaXphYmxlIiwiaGFzQml0bWFwIiwiZWRpdG9yU3RhdHMiLCJzdGF0cyIsInR5cGVUb0VkaXRvciIsImNvdW50ZXJzIiwiY291bnQiLCJjb21wdXRlVGVsZW1ldHJ5RmluYWxEYXRhIiwicmVzZXRNb2RpZmllZElkcyIsImlkcyIsInN0cnVjdHVyZWRDbG9uZSIsIkZvbnRMb2FkZXIiLCJzeXN0ZW1Gb250cyIsIm93bmVyRG9jdW1lbnQiLCJzdHlsZUVsZW1lbnQiLCJfZG9jdW1lbnQiLCJuYXRpdmVGb250RmFjZXMiLCJsb2FkaW5nUmVxdWVzdHMiLCJsb2FkVGVzdEZvbnRJZCIsImFkZE5hdGl2ZUZvbnRGYWNlIiwibmF0aXZlRm9udEZhY2UiLCJmb250cyIsInJlbW92ZU5hdGl2ZUZvbnRGYWNlIiwiaW5zZXJ0UnVsZSIsInJ1bGUiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsInN0eWxlU2hlZXQiLCJzaGVldCIsImNzc1J1bGVzIiwibG9hZFN5c3RlbUZvbnQiLCJzeXN0ZW1Gb250SW5mbyIsIl9pbnNwZWN0Rm9udCIsImxvYWRlZE5hbWUiLCJkaXNhYmxlRm9udEZhY2UiLCJpc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkIiwiZm9udEZhY2UiLCJGb250RmFjZSIsImxvYWQiLCJiYXNlRm9udE5hbWUiLCJmb250IiwiYXR0YWNoZWQiLCJtaXNzaW5nRmlsZSIsImNyZWF0ZU5hdGl2ZUZvbnRGYWNlIiwibG9hZGVkIiwiZmFtaWx5IiwiY3JlYXRlRm9udEZhY2VSdWxlIiwiaXNTeW5jRm9udExvYWRpbmdTdXBwb3J0ZWQiLCJfcXVldWVMb2FkaW5nQ2FsbGJhY2siLCJfcHJlcGFyZUZvbnRMb2FkRXZlbnQiLCJoYXNGb250cyIsInN1cHBvcnRlZCIsImNvbXBsZXRlUmVxdWVzdCIsImRvbmUiLCJvdGhlclJlcXVlc3QiLCJzaGlmdCIsImNvbXBsZXRlIiwiX2xvYWRUZXN0Rm9udCIsInRlc3RGb250IiwiaW50MzIiLCJvZmZzZXQiLCJzcGxpY2VTdHJpbmciLCJzIiwiaW5zZXJ0IiwiY2h1bmsxIiwiY2h1bmsyIiwiY2FsbGVkIiwiaXNGb250UmVhZHkiLCJmaWxsVGV4dCIsImltYWdlRGF0YSIsIkNPTU1FTlRfT0ZGU0VUIiwiQ0ZGX0NIRUNLU1VNX09GRlNFVCIsIlhYWFhfVkFMVUUiLCJjaGVja3N1bSIsImZvbnRGYW1pbHkiLCJGb250RmFjZU9iamVjdCIsInRyYW5zbGF0ZWREYXRhIiwiaW5zcGVjdEZvbnQiLCJjb21waWxlZEdseXBocyIsImNzc0ZvbnRJbmZvIiwiY3NzIiwid2VpZ2h0IiwiZm9udFdlaWdodCIsIml0YWxpY0FuZ2xlIiwibWltZXR5cGUiLCJnZXRQYXRoR2VuZXJhdG9yIiwib2JqcyIsImNoYXJhY3RlciIsImNtZHMiLCJiZXppZXJDdXJ2ZVRvIiwicXVhZHJhdGljQ3VydmVUbyIsImdseXBoRHJhd2VyIiwiQmFzZUNhbnZhc0ZhY3RvcnkiLCJlbmFibGVIV0EiLCJfY3JlYXRlQ2FudmFzIiwicmVzZXQiLCJjYW52YXNBbmRDb250ZXh0IiwiRE9NQ2FudmFzRmFjdG9yeSIsIkJhc2VDTWFwUmVhZGVyRmFjdG9yeSIsImlzQ29tcHJlc3NlZCIsIl9mZXRjaCIsImNNYXBEYXRhIiwiY2F0Y2giLCJyZWFzb24iLCJET01DTWFwUmVhZGVyRmFjdG9yeSIsIkJhc2VGaWx0ZXJGYWN0b3J5IiwiYWRkRmlsdGVyIiwibWFwcyIsImZnQ29sb3IiLCJiZ0NvbG9yIiwiYWRkQWxwaGFGaWx0ZXIiLCJhZGRMdW1pbm9zaXR5RmlsdGVyIiwiYWRkSGlnaGxpZ2h0SENNRmlsdGVyIiwiZmlsdGVyTmFtZSIsIm5ld0ZnQ29sb3IiLCJuZXdCZ0NvbG9yIiwia2VlcEhDTSIsIkRPTUZpbHRlckZhY3RvcnkiLCJfY2FjaGUiLCJfZGVmcyIsImRvY0lkIiwiX2hjbUNhY2hlIiwiaGNtQ2FjaGUiLCJkZWZzIiwiY29udGFpbiIsImNyZWF0ZUVsZW1lbnROUyIsImNyZWF0ZVRhYmxlcyIsIm1hcFIiLCJ0YWJsZSIsIm1hcEciLCJtYXBCIiwiYnVmZmVyUiIsImJ1ZmZlckciLCJidWZmZXJCIiwiY3JlYXRlVXJsIiwidGFibGVSIiwidGFibGVHIiwidGFibGVCIiwiZmlsdGVyIiwiY3JlYXRlRmlsdGVyIiwiYWRkVHJhbnNmZXJNYXBDb252ZXJzaW9uIiwiZmdSR0IiLCJiZ1JHQiIsImFkZEdyYXlDb252ZXJzaW9uIiwiZ2V0U3RlcHMiLCJ0YWJsZUEiLCJhZGRUcmFuc2Zlck1hcEFscGhhQ29udmVyc2lvbiIsImFkZEx1bWlub3NpdHlDb252ZXJzaW9uIiwiZmdHcmF5IiwiYmdHcmF5IiwibmV3RmdSR0IiLCJuZXdCZ1JHQiIsImZnIiwiYmciLCJzdGVwIiwibmV3U3RhcnQiLCJuZXdTdGVwIiwicHJldiIsImsiLCJqIiwiZmVDb2xvck1hdHJpeCIsImFwcGVuZEZlRnVuYyIsImZlQ29tcG9uZW50VHJhbnNmZXIiLCJmdW5jIiwiZmVGdW5jIiwiclRhYmxlIiwiZ1RhYmxlIiwiYlRhYmxlIiwiYVRhYmxlIiwiQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IiwiRE9NU3RhbmRhcmRGb250RGF0YUZhY3RvcnkiLCJub2RlX3V0aWxzX2ZldGNoRGF0YSIsImZzIiwiZ2V0QnVpbHRpbk1vZHVsZSIsInJlYWRGaWxlIiwiTm9kZUZpbHRlckZhY3RvcnkiLCJOb2RlQ2FudmFzRmFjdG9yeSIsInJlcXVpcmUiLCJjcmVhdGVSZXF1aXJlIiwiY3JlYXRlQ2FudmFzIiwiTm9kZUNNYXBSZWFkZXJGYWN0b3J5IiwiTm9kZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IiwiUGF0aFR5cGUiLCJTSEFESU5HIiwiYXBwbHlCb3VuZGluZ0JveCIsImJib3giLCJyZWdpb24iLCJQYXRoMkQiLCJCYXNlU2hhZGluZ1BhdHRlcm4iLCJnZXRQYXR0ZXJuIiwiUmFkaWFsQXhpYWxTaGFkaW5nUGF0dGVybiIsIklSIiwiX2Jib3giLCJfY29sb3JTdG9wcyIsIl9wMCIsIl9wMSIsIl9yMCIsIl9yMSIsIm1hdHJpeCIsIl9jcmVhdGVHcmFkaWVudCIsImdyYWQiLCJjcmVhdGVMaW5lYXJHcmFkaWVudCIsImNyZWF0ZVJhZGlhbEdyYWRpZW50IiwiY29sb3JTdG9wIiwiYWRkQ29sb3JTdG9wIiwib3duZXIiLCJpbnZlcnNlIiwicGF0aFR5cGUiLCJwYXR0ZXJuIiwib3duZXJCQm94IiwiY3VycmVudCIsImdldENsaXBwZWRQYXRoQm91bmRpbmdCb3giLCJjZWlsIiwidG1wQ2FudmFzIiwiY2FjaGVkQ2FudmFzZXMiLCJnZXRDYW52YXMiLCJ0bXBDdHgiLCJjbGVhclJlY3QiLCJiZWdpblBhdGgiLCJiYXNlVHJhbnNmb3JtIiwiZmlsbFN0eWxlIiwiY3JlYXRlUGF0dGVybiIsImRvbU1hdHJpeCIsIkRPTU1hdHJpeCIsInNldFRyYW5zZm9ybSIsImRyYXdUcmlhbmdsZSIsImMxIiwiYzIiLCJjMyIsImNvb3JkcyIsInJvd1NpemUiLCJ0bXAiLCJzY2FsZVgiLCJzY2FsZVkiLCJjMXIiLCJjMWciLCJjMWIiLCJjMnIiLCJjMmciLCJjMmIiLCJjM3IiLCJjM2ciLCJjM2IiLCJtaW5ZIiwibWF4WSIsInhhIiwiY2FyIiwiY2FnIiwiY2FiIiwieGIiLCJjYnIiLCJjYmciLCJjYmIiLCJ4MV8iLCJ4Ml8iLCJkcmF3RmlndXJlIiwiZmlndXJlIiwicHMiLCJjcyIsInZlcnRpY2VzUGVyUm93Iiwicm93cyIsImNvbHMiLCJxIiwiTWVzaFNoYWRpbmdQYXR0ZXJuIiwiX2Nvb3JkcyIsIl9maWd1cmVzIiwiX2JvdW5kcyIsIl9iYWNrZ3JvdW5kIiwiX2NyZWF0ZU1lc2hDYW52YXMiLCJjb21iaW5lZFNjYWxlIiwiYmFja2dyb3VuZENvbG9yIiwiRVhQRUNURURfU0NBTEUiLCJNQVhfUEFUVEVSTl9TSVpFIiwiQk9SREVSX1NJWkUiLCJib3VuZHNXaWR0aCIsImJvdW5kc0hlaWdodCIsInBhZGRlZFdpZHRoIiwicGFkZGVkSGVpZ2h0IiwiY3JlYXRlSW1hZ2VEYXRhIiwicHV0SW1hZ2VEYXRhIiwibWF0cml4U2NhbGUiLCJ0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzIiwiRHVtbXlTaGFkaW5nUGF0dGVybiIsImdldFNoYWRpbmdQYXR0ZXJuIiwiUGFpbnRUeXBlIiwiQ09MT1JFRCIsIlVOQ09MT1JFRCIsIlRpbGluZ1BhdHRlcm4iLCJjYW52YXNHcmFwaGljc0ZhY3RvcnkiLCJvcGVyYXRvckxpc3QiLCJ4c3RlcCIsInlzdGVwIiwicGFpbnRUeXBlIiwidGlsaW5nVHlwZSIsImNyZWF0ZVBhdHRlcm5DYW52YXMiLCJjdXJNYXRyaXhTY2FsZSIsImNvbWJpbmVkU2NhbGVYIiwiY29tYmluZWRTY2FsZVkiLCJjYW52YXNXaWR0aCIsImNhbnZhc0hlaWdodCIsInJlZHJhd0hvcml6b250YWxseSIsInJlZHJhd1ZlcnRpY2FsbHkiLCJ4U2NhbGVkU3RlcCIsInlTY2FsZWRTdGVwIiwieFNjYWxlZFdpZHRoIiwieVNjYWxlZEhlaWdodCIsImRpbXgiLCJnZXRTaXplQW5kU2NhbGUiLCJkaW15IiwiZ3JhcGhpY3MiLCJjcmVhdGVDYW52YXNHcmFwaGljcyIsImdyb3VwTGV2ZWwiLCJzZXRGaWxsQW5kU3Ryb2tlU3R5bGVUb0NvbnRleHQiLCJjbGlwQmJveCIsImV4ZWN1dGVPcGVyYXRvckxpc3QiLCJlbmREcmF3aW5nIiwiZGlteDIiLCJkaW15MiIsInhTaXplIiwieVNpemUiLCJ0bXBDYW52YXMyIiwidG1wQ3R4MiIsImpqIiwicmVhbE91dHB1dFNpemUiLCJiYm94V2lkdGgiLCJiYm94SGVpZ2h0IiwidXBkYXRlUmVjdE1pbk1heCIsInN0cm9rZVN0eWxlIiwiZmlsbENvbG9yIiwic3Ryb2tlQ29sb3IiLCJjc3NDb2xvciIsImNvbnZlcnRUb1JHQkEiLCJraW5kIiwiY29udmVydEJsYWNrQW5kV2hpdGVUb1JHQkEiLCJjb252ZXJ0UkdCVG9SR0JBIiwic3JjUG9zIiwiZGVzdCIsIm5vbkJsYWNrQ29sb3IiLCJpbnZlcnNlRGVjb2RlIiwiYmxhY2siLCJ6ZXJvTWFwcGluZyIsIm9uZU1hcHBpbmciLCJ3aWR0aEluU291cmNlIiwid2lkdGhSZW1haW5kZXIiLCJzcmNMZW5ndGgiLCJkZXN0UG9zIiwiZWxlbSIsImxlbiIsImxlbjMyIiwic3JjMzIiLCJzMSIsInMyIiwiczMiLCJncmF5VG9SR0JBIiwiTUlOX0ZPTlRfU0laRSIsIk1BWF9GT05UX1NJWkUiLCJFWEVDVVRJT05fVElNRSIsIkVYRUNVVElPTl9TVEVQUyIsIk1BWF9TSVpFX1RPX0NPTVBJTEUiLCJGVUxMX0NIVU5LX0hFSUdIVCIsIm1pcnJvckNvbnRleHRPcGVyYXRpb25zIiwiZGVzdEN0eCIsIl9yZW1vdmVNaXJyb3JpbmciLCJfX29yaWdpbmFsU2F2ZSIsIl9fb3JpZ2luYWxSZXN0b3JlIiwiX19vcmlnaW5hbFJvdGF0ZSIsIl9fb3JpZ2luYWxTY2FsZSIsIl9fb3JpZ2luYWxUcmFuc2xhdGUiLCJfX29yaWdpbmFsVHJhbnNmb3JtIiwiX19vcmlnaW5hbFNldFRyYW5zZm9ybSIsIl9fb3JpZ2luYWxSZXNldFRyYW5zZm9ybSIsInJlc2V0VHJhbnNmb3JtIiwiX19vcmlnaW5hbENsaXAiLCJfX29yaWdpbmFsTW92ZVRvIiwiX19vcmlnaW5hbExpbmVUbyIsIl9fb3JpZ2luYWxCZXppZXJDdXJ2ZVRvIiwiX19vcmlnaW5hbFJlY3QiLCJfX29yaWdpbmFsQ2xvc2VQYXRoIiwiX19vcmlnaW5hbEJlZ2luUGF0aCIsImN0eFNhdmUiLCJjdHhSZXN0b3JlIiwiY3R4VHJhbnNsYXRlIiwiY3R4U2NhbGUiLCJjdHhUcmFuc2Zvcm0iLCJjdHhTZXRUcmFuc2Zvcm0iLCJjdHhSZXNldFRyYW5zZm9ybSIsImN0eFJvdGF0ZSIsImNwMXgiLCJjcDF5IiwiY3AyeCIsImNwMnkiLCJDYWNoZWRDYW52YXNlcyIsImNhbnZhc0ZhY3RvcnkiLCJjYW52YXNFbnRyeSIsImRyYXdJbWFnZUF0SW50ZWdlckNvb3JkcyIsInNyY0ltZyIsInNyY1giLCJzcmNZIiwic3JjVyIsInNyY0giLCJkZXN0WCIsImRlc3RZIiwiZGVzdFciLCJkZXN0SCIsInRsWCIsInJUbFgiLCJ0bFkiLCJyVGxZIiwiYnJYIiwicldpZHRoIiwiYnJZIiwickhlaWdodCIsInNpZ24iLCJjb21waWxlVHlwZTNHbHlwaCIsImltZ0RhdGEiLCJQT0lOVF9UT19QUk9DRVNTX0xJTUlUIiwiUE9JTlRfVFlQRVMiLCJ3aWR0aDEiLCJwb2ludHMiLCJqMCIsImxpbmVTaXplIiwicG9zIiwibWFzayIsInN1bSIsInN0ZXBzIiwiSW50MzJBcnJheSIsInBhdGgiLCJwMCIsInBwIiwiZHJhd091dGxpbmUiLCJDYW52YXNFeHRyYVN0YXRlIiwiYWxwaGFJc1NoYXBlIiwiZm9udFNpemUiLCJmb250U2l6ZVNjYWxlIiwidGV4dE1hdHJpeCIsInRleHRNYXRyaXhTY2FsZSIsImZvbnRNYXRyaXgiLCJsZWFkaW5nIiwibGluZVgiLCJsaW5lWSIsImNoYXJTcGFjaW5nIiwid29yZFNwYWNpbmciLCJ0ZXh0SFNjYWxlIiwidGV4dFJlbmRlcmluZ01vZGUiLCJ0ZXh0UmlzZSIsInBhdHRlcm5GaWxsIiwicGF0dGVyblN0cm9rZSIsImZpbGxBbHBoYSIsInN0cm9rZUFscGhhIiwibGluZVdpZHRoIiwiYWN0aXZlU01hc2siLCJ0cmFuc2Zlck1hcHMiLCJzdGFydE5ld1BhdGhBbmRDbGlwQm94IiwiY2xpcEJveCIsInNldEN1cnJlbnRQb2ludCIsInVwZGF0ZVBhdGhNaW5NYXgiLCJtaW5YIiwibWF4WCIsInVwZGF0ZVNjYWxpbmdQYXRoTWluTWF4IiwidXBkYXRlQ3VydmVQYXRoTWluTWF4IiwiZ2V0UGF0aEJvdW5kaW5nQm94IiwieFN0cm9rZVBhZCIsInlTdHJva2VQYWQiLCJ1cGRhdGVDbGlwRnJvbVBhdGgiLCJpc0VtcHR5Q2xpcCIsIkluZmluaXR5IiwicHV0QmluYXJ5SW1hZ2VEYXRhIiwiSW1hZ2VEYXRhIiwicGFydGlhbENodW5rSGVpZ2h0IiwiZnVsbENodW5rcyIsInRvdGFsQ2h1bmtzIiwiY2h1bmtJbWdEYXRhIiwidGhpc0NodW5rSGVpZ2h0IiwiZWxlbXNJblRoaXNDaHVuayIsImRlc3QzMiIsImRlc3QzMkRhdGFMZW5ndGgiLCJmdWxsU3JjRGlmZiIsIndoaXRlIiwic3JjRGlmZiIsImtFbmQiLCJrRW5kVW5yb2xsZWQiLCJzcmNCeXRlIiwicHV0QmluYXJ5SW1hZ2VNYXNrIiwiY29weUN0eFN0YXRlIiwic291cmNlQ3R4IiwicHJvcGVydGllcyIsInByb3BlcnR5Iiwic2V0TGluZURhc2giLCJnZXRMaW5lRGFzaCIsImxpbmVEYXNoT2Zmc2V0IiwicmVzZXRDdHhUb0RlZmF1bHQiLCJmaWxsUnVsZSIsImdsb2JhbEFscGhhIiwibGluZUNhcCIsImxpbmVKb2luIiwibWl0ZXJMaW1pdCIsImdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiIsImdldEltYWdlU21vb3RoaW5nRW5hYmxlZCIsImludGVycG9sYXRlIiwiZnJvdW5kIiwiYWN0dWFsU2NhbGUiLCJMSU5FX0NBUF9TVFlMRVMiLCJMSU5FX0pPSU5fU1RZTEVTIiwiTk9STUFMX0NMSVAiLCJFT19DTElQIiwiQ2FudmFzR3JhcGhpY3MiLCJjYW52YXNDdHgiLCJjb21tb25PYmpzIiwib3B0aW9uYWxDb250ZW50Q29uZmlnIiwibWFya2VkQ29udGVudFN0YWNrIiwiYW5ub3RhdGlvbkNhbnZhc01hcCIsInN0YXRlU3RhY2siLCJwZW5kaW5nQ2xpcCIsInBlbmRpbmdFT0ZpbGwiLCJyZXMiLCJ4b2JqcyIsImdyb3VwU3RhY2siLCJwcm9jZXNzaW5nVHlwZTMiLCJiYXNlVHJhbnNmb3JtU3RhY2siLCJzbWFza1N0YWNrIiwic21hc2tDb3VudGVyIiwidGVtcFNNYXNrIiwic3VzcGVuZGVkQ3R4IiwiY29udGVudFZpc2libGUiLCJjYWNoZWRQYXR0ZXJucyIsInZpZXdwb3J0U2NhbGUiLCJvdXRwdXRTY2FsZVgiLCJvdXRwdXRTY2FsZVkiLCJfY2FjaGVkU2NhbGVGb3JTdHJva2luZyIsIl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoIiwiX2NhY2hlZEJpdG1hcHNNYXAiLCJnZXRPYmplY3QiLCJmYWxsYmFjayIsImJlZ2luRHJhd2luZyIsInRyYW5zcGFyZW5jeSIsInNhdmVkRmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJ0cmFuc3BhcmVudENhbnZhcyIsImNvbXBvc2l0ZUN0eCIsImV4ZWN1dGlvblN0YXJ0SWR4IiwiY29udGludWVDYWxsYmFjayIsInN0ZXBwZXIiLCJhcmdzQXJyYXkiLCJmbkFycmF5IiwiYXJnc0FycmF5TGVuIiwiY2h1bmtPcGVyYXRpb25zIiwiZW5kVGltZSIsImZuSWQiLCJuZXh0QnJlYWtQb2ludCIsImJyZWFrSXQiLCJkZXBPYmpJZCIsIm9ianNQb29sIiwicmVzdG9yZUluaXRpYWxTdGF0ZSIsImluU01hc2tNb2RlIiwiSFRNTENhbnZhc0VsZW1lbnQiLCJkcmF3RmlsdGVyIiwiaGNtRmlsdGVySWQiLCJzYXZlZEZpbHRlciIsIl9zY2FsZUltYWdlIiwiaW1nIiwiZGlzcGxheVdpZHRoIiwiZGlzcGxheUhlaWdodCIsIndpZHRoU2NhbGUiLCJoZWlnaHRTY2FsZSIsInBhaW50V2lkdGgiLCJwYWludEhlaWdodCIsInRtcENhbnZhc0lkIiwiX2NyZWF0ZU1hc2tDYW52YXMiLCJpc1BhdHRlcm5GaWxsIiwiY3VycmVudFRyYW5zZm9ybSIsImNhY2hlS2V5IiwibWFza0NhbnZhcyIsIm1haW5LZXkiLCJjYWNoZWRJbWFnZSIsIm1hc2tUb0NhbnZhcyIsImRyYXduV2lkdGgiLCJkcmF3bkhlaWdodCIsImZpbGxDYW52YXMiLCJmaWxsQ3R4IiwiaW1hZ2VTbW9vdGhpbmdFbmFibGVkIiwibGltaXQiLCJkYXNoQXJyYXkiLCJkYXNoUGhhc2UiLCJpbnRlbnQiLCJmbGF0bmVzcyIsInN0YXRlcyIsImNoZWNrU01hc2tTdGF0ZSIsImJlZ2luU01hc2tNb2RlIiwiZW5kU01hc2tNb2RlIiwiY2FjaGVJZCIsInNjcmF0Y2hDYW52YXMiLCJjb21wb3NlIiwiZGlydHlCb3giLCJzbWFzayIsImNvbXBvc2VTTWFzayIsImxheWVyQ3R4IiwibGF5ZXJCb3giLCJsYXllck9mZnNldFgiLCJsYXllck9mZnNldFkiLCJsYXllcldpZHRoIiwibGF5ZXJIZWlnaHQiLCJnZW5lcmljQ29tcG9zZVNNYXNrIiwic3VidHlwZSIsImJhY2tkcm9wIiwidHJhbnNmZXJNYXAiLCJtYXNrQ3R4IiwibWFza09mZnNldFgiLCJtYXNrT2Zmc2V0WSIsIm1hc2tYIiwibWFza1kiLCJiYWNrZHJvcFJHQiIsIm9sZCIsInBvcCIsIm9wcyIsInN0YXJ0WCIsInN0YXJ0WSIsImlzU2NhbGluZ01hdHJpeCIsIm1pbk1heEZvckJlemllciIsInh3IiwieWgiLCJjb25zdW1lUGF0aCIsInJlc2NhbGVBbmRTdHJva2UiLCJuZWVkUmVzdG9yZSIsInBhdGhzIiwicGVuZGluZ1RleHRQYXRocyIsImFkZFRvUGF0aCIsInNwYWNpbmciLCJmb250UmVmTmFtZSIsImZvbnRPYmoiLCJmb250RGlyZWN0aW9uIiwiaXNUeXBlM0ZvbnQiLCJ0eXBlZmFjZSIsImZhbGxiYWNrTmFtZSIsImJvbGQiLCJpdGFsaWMiLCJicm93c2VyRm9udFNpemUiLCJyaXNlIiwicGFpbnRDaGFyIiwicGF0dGVybkZpbGxUcmFuc2Zvcm0iLCJwYXR0ZXJuU3Ryb2tlVHJhbnNmb3JtIiwiZmlsbFN0cm9rZU1vZGUiLCJpc0FkZFRvUGF0aFNldCIsInN0cm9rZVRleHQiLCJpc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZCIsImdseXBocyIsInNob3dUeXBlM1RleHQiLCJnbHlwaHNMZW5ndGgiLCJ2ZXJ0aWNhbCIsInNwYWNpbmdEaXIiLCJkZWZhdWx0Vk1ldHJpY3MiLCJ3aWR0aEFkdmFuY2VTY2FsZSIsInNpbXBsZUZpbGxUZXh0IiwiZ2V0U2luZ2xlUGl4ZWxXaWR0aCIsImlzSW52YWxpZFBERmpzRm9udCIsImNoYXJzIiwiZ2x5cGgiLCJ1bmljb2RlIiwicmVzdG9yZU5lZWRlZCIsImlzU3BhY2UiLCJmb250Q2hhciIsImFjY2VudCIsInNjYWxlZFgiLCJzY2FsZWRZIiwidm1ldHJpYyIsInZ4IiwidnkiLCJyZW1lYXN1cmUiLCJtZWFzdXJlZFdpZHRoIiwibWVhc3VyZVRleHQiLCJjaGFyYWN0ZXJTY2FsZVgiLCJpc0luRm9udCIsInNjYWxlZEFjY2VudFgiLCJzY2FsZWRBY2NlbnRZIiwiY2hhcldpZHRoIiwiaXNUZXh0SW52aXNpYmxlIiwic3BhY2luZ0xlbmd0aCIsImNoYXJQcm9jT3BlcmF0b3JMaXN0Iiwib3BlcmF0b3JMaXN0SWQiLCJ0cmFuc2Zvcm1lZCIsInhXaWR0aCIsInlXaWR0aCIsImxseCIsImxseSIsInVyeCIsInVyeSIsImdldENvbG9yTl9QYXR0ZXJuIiwiX2dldFBhdHRlcm4iLCJhcmd1bWVudHMiLCJvYmpJZCIsImludiIsImdyb3VwIiwiY3VycmVudEN0eCIsImlzb2xhdGVkIiwia25vY2tvdXQiLCJib3VuZHMiLCJjYW52YXNCb3VuZHMiLCJncm91cEN0eCIsInN0YXJ0VHJhbnNmb3JtSW52ZXJzZSIsImN1cnJlbnRNdHgiLCJoYXNPd25DYW52YXMiLCJhbm5vdGF0aW9uQ2FudmFzIiwic2F2ZWRDdHgiLCJjb21waWxlZCIsInNrZXdYIiwic2tld1kiLCJwb3NpdGlvbnMiLCJ0cmFucyIsImltYWdlcyIsImFwcGx5VHJhbnNmZXJNYXBzVG9DYW52YXMiLCJhcHBseVRyYW5zZmVyTWFwc1RvQml0bWFwIiwiaW1nVG9QYWludCIsIkhUTUxFbGVtZW50IiwidGFnIiwiaXNWaXNpYmxlIiwiaXNDb250ZW50VmlzaWJsZSIsImFic0RldCIsIm5vcm1YIiwibm9ybVkiLCJnZXRTY2FsZUZvclN0cm9raW5nIiwic2NhbGVkTGluZVdpZHRoIiwic2NhbGVkWExpbmVXaWR0aCIsInNjYWxlZFlMaW5lV2lkdGgiLCJiYXNlQXJlYSIsInNhdmVSZXN0b3JlIiwiZGFzaGVzIiwib3AiLCJwb3J0Iiwid29ya2VyUG9ydCIsIldvcmtlciIsIndvcmtlclNyYyIsIkNhbGxiYWNrS2luZCIsIlVOS05PV04iLCJEQVRBIiwiRVJST1IiLCJTdHJlYW1LaW5kIiwiQ0FOQ0VMIiwiQ0FOQ0VMX0NPTVBMRVRFIiwiQ0xPU0UiLCJFTlFVRVVFIiwiUFVMTCIsIlBVTExfQ09NUExFVEUiLCJTVEFSVF9DT01QTEVURSIsIm9uRm4iLCJ3cmFwUmVhc29uIiwiTWVzc2FnZUhhbmRsZXIiLCJtZXNzYWdlQUMiLCJzb3VyY2VOYW1lIiwidGFyZ2V0TmFtZSIsImNvbU9iaiIsImNhbGxiYWNrSWQiLCJzdHJlYW1JZCIsInN0cmVhbVNpbmtzIiwic3RyZWFtQ29udHJvbGxlcnMiLCJjYWxsYmFja0NhcGFiaWxpdGllcyIsImFjdGlvbkhhbmRsZXIiLCJvbk1lc3NhZ2UiLCJzdHJlYW0iLCJwcm9jZXNzU3RyZWFtTWVzc2FnZSIsImNhcGFiaWxpdHkiLCJwb3N0TWVzc2FnZSIsImNyZWF0ZVN0cmVhbVNpbmsiLCJhY3Rpb25OYW1lIiwiaGFuZGxlciIsImFoIiwidHJhbnNmZXJzIiwic2VuZFdpdGhQcm9taXNlIiwic2VuZFdpdGhTdHJlYW0iLCJxdWV1ZWluZ1N0cmF0ZWd5IiwiUmVhZGFibGVTdHJlYW0iLCJjb250cm9sbGVyIiwic3RhcnRDYXBhYmlsaXR5Iiwic3RhcnRDYWxsIiwicHVsbENhbGwiLCJjYW5jZWxDYWxsIiwiaXNDbG9zZWQiLCJkZXNpcmVkU2l6ZSIsInB1bGwiLCJwdWxsQ2FwYWJpbGl0eSIsImNhbmNlbENhcGFiaWxpdHkiLCJzdHJlYW1TaW5rIiwiZW5xdWV1ZSIsImlzQ2FuY2VsbGVkIiwibGFzdERlc2lyZWRTaXplIiwic2lua0NhcGFiaWxpdHkiLCJyZWFkeSIsImVycm9yIiwib25QdWxsIiwib25DYW5jZWwiLCJzdWNjZXNzIiwic3RyZWFtQ29udHJvbGxlciIsImRlbGV0ZVN0cmVhbUNvbnRyb2xsZXIiLCJkYXRhUmVhc29uIiwiYWxsU2V0dGxlZCIsIk1ldGFkYXRhIiwibWV0YWRhdGFNYXAiLCJwYXJzZWREYXRhIiwiZ2V0UmF3IiwiSU5URVJOQUwiLCJTeW1ib2wiLCJPcHRpb25hbENvbnRlbnRHcm91cCIsImlzRGlzcGxheSIsImlzUHJpbnQiLCJ1c2VyU2V0IiwicmVuZGVyaW5nSW50ZW50IiwidXNhZ2UiLCJyYkdyb3VwcyIsInZpZXciLCJ2aWV3U3RhdGUiLCJwcmludFN0YXRlIiwiX3NldFZpc2libGUiLCJpbnRlcm5hbCIsIk9wdGlvbmFsQ29udGVudENvbmZpZyIsImNhY2hlZEdldEhhc2giLCJncm91cHMiLCJpbml0aWFsSGFzaCIsIm9yZGVyIiwiY3JlYXRvciIsImJhc2VTdGF0ZSIsIm9mZiIsImdldEhhc2giLCJldmFsdWF0ZVZpc2liaWxpdHlFeHByZXNzaW9uIiwiYXJyYXkiLCJvcGVyYXRvciIsImV4cHJlc3Npb24iLCJwb2xpY3kiLCJzZXRWaXNpYmlsaXR5IiwicHJlc2VydmVSQiIsInJiR3JvdXAiLCJvdGhlcklkIiwic2V0T0NHU3RhdGUiLCJoYXNJbml0aWFsVmlzaWJpbGl0eSIsImdldE9yZGVyIiwiZ2V0R3JvdXBzIiwiZ2V0R3JvdXAiLCJQREZEYXRhVHJhbnNwb3J0U3RyZWFtIiwicGRmRGF0YVJhbmdlVHJhbnNwb3J0IiwiZGlzYWJsZVJhbmdlIiwiZGlzYWJsZVN0cmVhbSIsImluaXRpYWxEYXRhIiwicHJvZ3Jlc3NpdmVEb25lIiwiY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUiLCJfcXVldWVkQ2h1bmtzIiwiX3Byb2dyZXNzaXZlRG9uZSIsIl9jb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSIsIl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQiLCJfaXNTdHJlYW1pbmdTdXBwb3J0ZWQiLCJfaXNSYW5nZVN1cHBvcnRlZCIsIl9jb250ZW50TGVuZ3RoIiwiX2Z1bGxSZXF1ZXN0UmVhZGVyIiwiX3JhbmdlUmVhZGVycyIsImFkZFJhbmdlTGlzdGVuZXIiLCJiZWdpbiIsIl9vblJlY2VpdmVEYXRhIiwiYWRkUHJvZ3Jlc3NMaXN0ZW5lciIsInRvdGFsIiwiX29uUHJvZ3Jlc3MiLCJhZGRQcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lciIsImFkZFByb2dyZXNzaXZlRG9uZUxpc3RlbmVyIiwiX29uUHJvZ3Jlc3NpdmVEb25lIiwidHJhbnNwb3J0UmVhZHkiLCJfZW5xdWV1ZSIsImZvdW5kIiwicmFuZ2VSZWFkZXIiLCJfYmVnaW4iLCJfcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoIiwiX2xvYWRlZCIsIm9uUHJvZ3Jlc3MiLCJfcmVtb3ZlUmFuZ2VSZWFkZXIiLCJyZWFkZXIiLCJpbmRleE9mIiwiZ2V0RnVsbFJlYWRlciIsInF1ZXVlZENodW5rcyIsIlBERkRhdGFUcmFuc3BvcnRTdHJlYW1SZWFkZXIiLCJnZXRSYW5nZVJlYWRlciIsIlBERkRhdGFUcmFuc3BvcnRTdHJlYW1SYW5nZVJlYWRlciIsInJlcXVlc3REYXRhUmFuZ2UiLCJjYW5jZWxBbGxSZXF1ZXN0cyIsIl9zdHJlYW0iLCJfZG9uZSIsIl9maWxlbmFtZSIsIl9yZXF1ZXN0cyIsIl9oZWFkZXJzUmVhZHkiLCJyZXF1ZXN0Q2FwYWJpbGl0eSIsImhlYWRlcnNSZWFkeSIsImlzUmFuZ2VTdXBwb3J0ZWQiLCJpc1N0cmVhbWluZ1N1cHBvcnRlZCIsImNvbnRlbnRMZW5ndGgiLCJyZWFkIiwiX2VuZCIsIl9xdWV1ZWRDaHVuayIsInJlcXVlc3RzQ2FwYWJpbGl0eSIsImdldEZpbGVuYW1lRnJvbUNvbnRlbnREaXNwb3NpdGlvbkhlYWRlciIsImNvbnRlbnREaXNwb3NpdGlvbiIsIm5lZWRzRW5jb2RpbmdGaXh1cCIsInRvUGFyYW1SZWdFeHAiLCJyZmMyNjE2dW5xdW90ZSIsInJmYzU5ODdkZWNvZGUiLCJyZmMyMDQ3ZGVjb2RlIiwiZml4dXBFbmNvZGluZyIsInJmYzIyMzFnZXRwYXJhbSIsImF0dHJpYnV0ZVBhdHRlcm4iLCJmbGFncyIsInRleHRkZWNvZGUiLCJjb250ZW50RGlzcG9zaXRpb25TdHIiLCJpdGVyIiwicXVvdCIsInBhcnQiLCJwYXJ0cyIsInF1b3RpbmRleCIsImV4dHZhbHVlIiwiZW5jb2RpbmdlbmQiLCJsYW5ndmFsdWUiLCJyZXBsYWNlIiwiY2hhcnNldCIsImhleCIsImNyZWF0ZUhlYWRlcnMiLCJpc0h0dHAiLCJodHRwSGVhZGVycyIsImhlYWRlcnMiLCJIZWFkZXJzIiwiZ2V0UmVzcG9uc2VPcmlnaW4iLCJvcmlnaW4iLCJ2YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcyIsInJlc3BvbnNlSGVhZGVycyIsInJhbmdlQ2h1bmtTaXplIiwicmV0dXJuVmFsdWVzIiwiYWxsb3dSYW5nZVJlcXVlc3RzIiwic3VnZ2VzdGVkTGVuZ3RoIiwiY29udGVudEVuY29kaW5nIiwiZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlciIsImNyZWF0ZVJlc3BvbnNlU3RhdHVzRXJyb3IiLCJ2YWxpZGF0ZVJlc3BvbnNlU3RhdHVzIiwiY3JlYXRlRmV0Y2hPcHRpb25zIiwid2l0aENyZWRlbnRpYWxzIiwibWV0aG9kIiwiY3JlZGVudGlhbHMiLCJyZWRpcmVjdCIsImdldEFycmF5QnVmZmVyIiwiUERGRmV0Y2hTdHJlYW0iLCJfcmVzcG9uc2VPcmlnaW4iLCJfcmFuZ2VSZXF1ZXN0UmVhZGVycyIsIlBERkZldGNoU3RyZWFtUmVhZGVyIiwiUERGRmV0Y2hTdHJlYW1SYW5nZVJlYWRlciIsIl9yZWFkZXIiLCJfd2l0aENyZWRlbnRpYWxzIiwiX2hlYWRlcnNDYXBhYmlsaXR5IiwiX2Rpc2FibGVSYW5nZSIsIl9yYW5nZUNodW5rU2l6ZSIsIl9hYm9ydENvbnRyb2xsZXIiLCJnZXRSZWFkZXIiLCJfcmVhZENhcGFiaWxpdHkiLCJyZXNwb25zZU9yaWdpbiIsIk9LX1JFU1BPTlNFIiwiUEFSVElBTF9DT05URU5UX1JFU1BPTlNFIiwibmV0d29ya19nZXRBcnJheUJ1ZmZlciIsInhociIsIk5ldHdvcmtNYW5hZ2VyIiwiY3VyclhocklkIiwicGVuZGluZ1JlcXVlc3RzIiwicmVxdWVzdFJhbmdlIiwibGlzdGVuZXJzIiwicmVxdWVzdEZ1bGwiLCJ4aHJJZCIsInBlbmRpbmdSZXF1ZXN0Iiwic2V0UmVxdWVzdEhlYWRlciIsImV4cGVjdGVkU3RhdHVzIiwib25FcnJvciIsIm9uU3RhdGVDaGFuZ2UiLCJvbnByb2dyZXNzIiwib25IZWFkZXJzUmVjZWl2ZWQiLCJvbkRvbmUiLCJ4aHJTdGF0dXMiLCJva19yZXNwb25zZV9vbl9yYW5nZV9yZXF1ZXN0IiwicmFuZ2VIZWFkZXIiLCJnZXRSZXNwb25zZUhlYWRlciIsImdldFJlcXVlc3RYaHIiLCJpc1BlbmRpbmdSZXF1ZXN0IiwiYWJvcnRSZXF1ZXN0IiwiUERGTmV0d29ya1N0cmVhbSIsIl9zb3VyY2UiLCJfbWFuYWdlciIsIl9vblJhbmdlUmVxdWVzdFJlYWRlckNsb3NlZCIsIlBERk5ldHdvcmtTdHJlYW1GdWxsUmVxdWVzdFJlYWRlciIsIlBERk5ldHdvcmtTdHJlYW1SYW5nZVJlcXVlc3RSZWFkZXIiLCJvbkNsb3NlZCIsIm1hbmFnZXIiLCJfb25IZWFkZXJzUmVjZWl2ZWQiLCJfb25Eb25lIiwiX29uRXJyb3IiLCJfdXJsIiwiX2Z1bGxSZXF1ZXN0SWQiLCJfY2FjaGVkQ2h1bmtzIiwiX3N0b3JlZEVycm9yIiwiZnVsbFJlcXVlc3RYaHJJZCIsImZ1bGxSZXF1ZXN0WGhyIiwicmVzcG9uc2VVUkwiLCJyYXdSZXNwb25zZUhlYWRlcnMiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJsZW5ndGhDb21wdXRhYmxlIiwiX3JlcXVlc3RJZCIsIl9jbG9zZSIsInVybFJlZ2V4IiwicGFyc2VVcmxPclBhdGgiLCJzb3VyY2VVcmwiLCJwYXRoVG9GaWxlVVJMIiwiUERGTm9kZVN0cmVhbSIsIlBERk5vZGVTdHJlYW1Gc0Z1bGxSZWFkZXIiLCJQREZOb2RlU3RyZWFtRnNSYW5nZVJlYWRlciIsIl9yZWFkYWJsZVN0cmVhbSIsImxzdGF0Iiwic3RhdCIsIl9zZXRSZWFkYWJsZVN0cmVhbSIsImNyZWF0ZVJlYWRTdHJlYW0iLCJfZXJyb3IiLCJyZWFkYWJsZVN0cmVhbSIsIk1BWF9URVhUX0RJVlNfVE9fUkVOREVSIiwiREVGQVVMVF9GT05UX1NJWkUiLCJERUZBVUxUX0ZPTlRfQVNDRU5UIiwiZGlzYWJsZVByb2Nlc3NJdGVtcyIsImZvbnRJbnNwZWN0b3JFbmFibGVkIiwibGFuZyIsImxheW91dFRleHRQYXJhbXMiLCJyb290Q29udGFpbmVyIiwic3R5bGVDYWNoZSIsInRleHRDb250ZW50SXRlbXNTdHIiLCJ0ZXh0Q29udGVudFNvdXJjZSIsInRleHREaXZzIiwidGV4dERpdlByb3BlcnRpZXMiLCJhc2NlbnRDYWNoZSIsImNhbnZhc0NvbnRleHRzIiwiY2FudmFzQ3R4Rm9udHMiLCJXZWFrTWFwIiwibWluRm9udFNpemUiLCJwZW5kaW5nVGV4dExheWVycyIsIkZvbnRJbnNwZWN0b3IiLCJlbnN1cmVNaW5Gb250U2l6ZUNvbXB1dGVkIiwiZmluYWxseSIsImZvbnRGYW1pbHlNYXAiLCJwdW1wIiwic3R5bGVzIiwicHJvY2Vzc0l0ZW1zIiwib25CZWZvcmUiLCJnZXRDdHgiLCJsYXlvdXQiLCJhYm9ydEV4IiwiYXBwZW5kVGV4dCIsImdlb20iLCJ0ZXh0RGl2IiwiaGFzVGV4dCIsImhhc0VPTCIsImF0YW4yIiwiZm9udE5hbWUiLCJmb250U3Vic3RpdHV0aW9uIiwiZm9udEhlaWdodCIsImZvbnRBc2NlbnQiLCJnZXRBc2NlbnQiLCJzaW4iLCJjb3MiLCJzY2FsZUZhY3RvclN0ciIsImRpdlN0eWxlIiwiZGlyIiwiZGF0YXNldCIsImZvbnRTdWJzdGl0dXRpb25Mb2FkZWROYW1lIiwic2hvdWxkU2NhbGVUZXh0IiwiYWJzU2NhbGVYIiwiYWJzU2NhbGVZIiwiYnIiLCJlbnN1cmVDdHhGb250IiwiY2xlYW51cCIsImFscGhhIiwiY2FjaGVkIiwibGluZUhlaWdodCIsImNhY2hlZEFzY2VudCIsIm1ldHJpY3MiLCJhc2NlbnQiLCJmb250Qm91bmRpbmdCb3hBc2NlbnQiLCJkZXNjZW50IiwiZm9udEJvdW5kaW5nQm94RGVzY2VudCIsInJhdGlvIiwicGl4ZWxzIiwiWGZhVGV4dCIsInhmYSIsIm91dHB1dCIsIndhbGsiLCJub2RlIiwic2hvdWxkQnVpbGRUZXh0IiwiREVGQVVMVF9SQU5HRV9DSFVOS19TSVpFIiwiUkVOREVSSU5HX0NBTkNFTExFRF9USU1FT1VUIiwiREVMQVlFRF9DTEVBTlVQX1RJTUVPVVQiLCJEZWZhdWx0Q2FudmFzRmFjdG9yeSIsIkRlZmF1bHRDTWFwUmVhZGVyRmFjdG9yeSIsIkRlZmF1bHRGaWx0ZXJGYWN0b3J5IiwiRGVmYXVsdFN0YW5kYXJkRm9udERhdGFGYWN0b3J5IiwidGFzayIsIlBERkRvY3VtZW50TG9hZGluZ1Rhc2siLCJnZXRVcmxQcm9wIiwiZ2V0RGF0YVByb3AiLCJwYXNzd29yZCIsInJhbmdlVHJhbnNwb3J0Iiwid29ya2VyIiwiZG9jQmFzZVVybCIsImNNYXBVcmwiLCJjTWFwUGFja2VkIiwiQ01hcFJlYWRlckZhY3RvcnkiLCJzdGFuZGFyZEZvbnREYXRhVXJsIiwiU3RhbmRhcmRGb250RGF0YUZhY3RvcnkiLCJpZ25vcmVFcnJvcnMiLCJzdG9wQXRFcnJvcnMiLCJtYXhJbWFnZVNpemUiLCJjaHJvbWUiLCJjYW52YXNNYXhBcmVhSW5CeXRlcyIsImZvbnRFeHRyYVByb3BlcnRpZXMiLCJlbmFibGVYZmEiLCJkaXNhYmxlQXV0b0ZldGNoIiwicGRmQnVnIiwiQ2FudmFzRmFjdG9yeSIsIkZpbHRlckZhY3RvcnkiLCJ1c2VTeXN0ZW1Gb250cyIsInVzZVdvcmtlckZldGNoIiwidHJhbnNwb3J0RmFjdG9yeSIsImNNYXBSZWFkZXJGYWN0b3J5Iiwic3RhbmRhcmRGb250RGF0YUZhY3RvcnkiLCJ3b3JrZXJQYXJhbXMiLCJmcm9tUG9ydCIsIl93b3JrZXIiLCJkb2NQYXJhbXMiLCJhcGlWZXJzaW9uIiwiZXZhbHVhdG9yT3B0aW9ucyIsInRyYW5zcG9ydFBhcmFtcyIsImxvYWRpbmdQYXJhbXMiLCJkZXN0cm95ZWQiLCJ3b3JrZXJJZFByb21pc2UiLCJtZXNzYWdlSGFuZGxlciIsIm5ldHdvcmtTdHJlYW0iLCJOZXR3b3JrU3RyZWFtIiwiUmVzcG9uc2UiLCJ3b3JrZXJJZCIsInRyYW5zcG9ydCIsIldvcmtlclRyYW5zcG9ydCIsIl90cmFuc3BvcnQiLCJfY2FwYWJpbGl0eSIsImhyZWYiLCJsb2NhdGlvbiIsIkJ1ZmZlciIsImlzTmFOIiwiaXNSZWZQcm94eSIsInJlZiIsImdlbiIsIm9uUGFzc3dvcmQiLCJfcGVuZGluZ0Rlc3Ryb3kiLCJfcmFuZ2VMaXN0ZW5lcnMiLCJfcHJvZ3Jlc3NMaXN0ZW5lcnMiLCJfcHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXJzIiwiX3Byb2dyZXNzaXZlRG9uZUxpc3RlbmVycyIsIl9yZWFkeUNhcGFiaWxpdHkiLCJsaXN0ZW5lciIsIm9uRGF0YVJhbmdlIiwib25EYXRhUHJvZ3Jlc3MiLCJvbkRhdGFQcm9ncmVzc2l2ZVJlYWQiLCJvbkRhdGFQcm9ncmVzc2l2ZURvbmUiLCJQREZEb2N1bWVudFByb3h5IiwicGRmSW5mbyIsIl9wZGZJbmZvIiwibnVtUGFnZXMiLCJmaW5nZXJwcmludHMiLCJpc1B1cmVYZmEiLCJfaHRtbEZvclhmYSIsImFsbFhmYUh0bWwiLCJnZXRQYWdlIiwiZ2V0UGFnZUluZGV4IiwiZ2V0RGVzdGluYXRpb25zIiwiZ2V0RGVzdGluYXRpb24iLCJnZXRQYWdlTGFiZWxzIiwiZ2V0UGFnZUxheW91dCIsImdldFBhZ2VNb2RlIiwiZ2V0Vmlld2VyUHJlZmVyZW5jZXMiLCJnZXRPcGVuQWN0aW9uIiwiZ2V0QXR0YWNobWVudHMiLCJnZXRKU0FjdGlvbnMiLCJnZXREb2NKU0FjdGlvbnMiLCJnZXRPdXRsaW5lIiwiZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnIiwiZ2V0UmVuZGVyaW5nSW50ZW50IiwiZ2V0UGVybWlzc2lvbnMiLCJnZXRNZXRhZGF0YSIsImdldE1hcmtJbmZvIiwic2F2ZURvY3VtZW50IiwiZ2V0RG93bmxvYWRJbmZvIiwiZG93bmxvYWRJbmZvQ2FwYWJpbGl0eSIsImtlZXBMb2FkZWRGb250cyIsInN0YXJ0Q2xlYW51cCIsImxvYWRpbmdUYXNrIiwiY2FjaGVkUGFnZU51bWJlciIsImdldEZpZWxkT2JqZWN0cyIsImhhc0pTQWN0aW9ucyIsImdldENhbGN1bGF0aW9uT3JkZXJJZHMiLCJQREZQYWdlUHJveHkiLCJkZWxheWVkQ2xlYW51cFRpbWVvdXQiLCJwZW5kaW5nQ2xlYW51cCIsInBhZ2VJbmZvIiwiX3BhZ2VJbmRleCIsIl9wYWdlSW5mbyIsIl9zdGF0cyIsIl9wZGZCdWciLCJQREZPYmplY3RzIiwiX21heWJlQ2xlYW51cEFmdGVyUmVuZGVyIiwiX2ludGVudFN0YXRlcyIsInVzZXJVbml0IiwiZ2V0Vmlld3BvcnQiLCJnZXRBbm5vdGF0aW9ucyIsImdldFBhZ2VKU0FjdGlvbnMiLCJnZXRYZmEiLCJjYW52YXNDb250ZXh0IiwiYW5ub3RhdGlvbk1vZGUiLCJvcHRpb25hbENvbnRlbnRDb25maWdQcm9taXNlIiwicHJpbnRBbm5vdGF0aW9uU3RvcmFnZSIsImludGVudEFyZ3MiLCJhYm9ydERlbGF5ZWRDbGVhbnVwIiwiaW50ZW50U3RhdGUiLCJzdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0IiwiaW50ZW50UHJpbnQiLCJkaXNwbGF5UmVhZHlDYXBhYmlsaXR5IiwibGFzdENodW5rIiwic2VwYXJhdGVBbm5vdHMiLCJfcHVtcE9wZXJhdG9yTGlzdCIsInJlbmRlclRhc2tzIiwiaW50ZXJuYWxSZW5kZXJUYXNrIiwidHJ5Q2xlYW51cCIsIl9hYm9ydE9wZXJhdG9yTGlzdCIsIlN0YXRzIiwiSW50ZXJuYWxSZW5kZXJUYXNrIiwidXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwicmVuZGVyVGFzayIsImluaXRpYWxpemVHcmFwaGljcyIsIm9wZXJhdG9yTGlzdENoYW5nZWQiLCJnZXRPcGVyYXRvckxpc3QiLCJvcExpc3RSZWFkQ2FwYWJpbGl0eSIsIm9wTGlzdFRhc2siLCJzdHJlYW1UZXh0Q29udGVudCIsImluY2x1ZGVNYXJrZWRDb250ZW50IiwiZGlzYWJsZU5vcm1hbGl6YXRpb24iLCJURVhUX0NPTlRFTlRfQ0hVTktfU0laRSIsImhpZ2hXYXRlck1hcmsiLCJnZXRUZXh0Q29udGVudCIsImdldFN0cnVjdFRyZWUiLCJfZGVzdHJveSIsIndhaXRPbiIsImZvcmNlIiwiY29tcGxldGVkIiwicmVzZXRTdGF0cyIsImRlbGF5ZWQiLCJfc3RhcnRSZW5kZXJQYWdlIiwiX3JlbmRlclBhZ2VDaHVuayIsIm9wZXJhdG9yTGlzdENodW5rIiwiYW5ub3RhdGlvblN0b3JhZ2VTZXJpYWxpemFibGUiLCJzdHJlYW1SZWFkZXIiLCJkZWxheSIsImN1ckNhY2hlS2V5IiwiY3VySW50ZW50U3RhdGUiLCJMb29wYmFja1BvcnQiLCJkZWZlcnJlZCIsInJtQWJvcnQiLCJhYm9ydGVkIiwib25BYm9ydCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ0ZXJtaW5hdGUiLCJmYWtlV29ya2VySWQiLCJpc1dvcmtlckRpc2FibGVkIiwid29ya2VyUG9ydHMiLCJfaXNTYW1lT3JpZ2luIiwib3RoZXJVcmwiLCJiYXNlIiwib3RoZXIiLCJfY3JlYXRlQ0ROV3JhcHBlciIsIndyYXBwZXIiLCJjcmVhdGVPYmplY3RVUkwiLCJfcG9ydCIsIl93ZWJXb3JrZXIiLCJfbWVzc2FnZUhhbmRsZXIiLCJfaW5pdGlhbGl6ZUZyb21Qb3J0IiwiX2luaXRpYWxpemUiLCJtYWluVGhyZWFkV29ya2VyTWVzc2FnZUhhbmRsZXIiLCJfc2V0dXBGYWtlV29ya2VyIiwidGVybWluYXRlRWFybHkiLCJzZW5kVGVzdCIsInRlc3RPYmoiLCJfc2V0dXBGYWtlV29ya2VyR2xvYmFsIiwiV29ya2VyTWVzc2FnZUhhbmRsZXIiLCJ3b3JrZXJIYW5kbGVyIiwic2V0dXAiLCJjYWNoZWRQb3J0IiwicGRmanNXb3JrZXIiLCJsb2FkZXIiLCJtZXRob2RQcm9taXNlcyIsInBhZ2VDYWNoZSIsInBhZ2VQcm9taXNlcyIsInBhZ2VSZWZDYWNoZSIsInBhc3N3b3JkQ2FwYWJpbGl0eSIsImZhY3RvcnkiLCJmb250TG9hZGVyIiwiX3BhcmFtcyIsImRlc3Ryb3lDYXBhYmlsaXR5IiwiX25ldHdvcmtTdHJlYW0iLCJfZnVsbFJlYWRlciIsIl9sYXN0UHJvZ3Jlc3MiLCJzZXR1cE1lc3NhZ2VIYW5kbGVyIiwiY2FjaGVTaW1wbGVNZXRob2QiLCJjYWNoZWRQcm9taXNlIiwiaXNPcExpc3QiLCJtb2RpZmllZElkc0hhc2giLCJjYWNoZUtleUJ1ZiIsInBhZ2UiLCJ0ZXJtaW5hdGVkIiwic2luayIsInJlYWR5UmVhc29uIiwiX251bVBhZ2VzIiwiaHRtbEZvclhmYSIsImV4Y2VwdGlvbiIsInVwZGF0ZVBhc3N3b3JkIiwiZXhwb3J0ZWREYXRhIiwiZXhwb3J0ZWRFcnJvciIsImZvbnRBZGRlZCIsImltYWdlUmVmIiwicGFnZVByb3h5IiwiZGF0YUxlbiIsInJlZlN0ciIsInJlc3VsdHMiLCJtZXRhZGF0YSIsImNsZWFudXBTdWNjZXNzZnVsIiwiSU5JVElBTF9EQVRBIiwiZW5zdXJlT2JqIiwiaXRlcmF0b3IiLCJSZW5kZXJUYXNrIiwib25Db250aW51ZSIsImZvcm0iLCJyQUYiLCJjYW52YXNJblVzZSIsIldlYWtTZXQiLCJvcGVyYXRvckxpc3RJZHgiLCJydW5uaW5nIiwiZ3JhcGhpY3NSZWFkeUNhbGxiYWNrIiwiZ3JhcGhpY3NSZWFkeSIsIl91c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjYW5jZWxsZWQiLCJfY2FuY2VsQm91bmQiLCJfY29udGludWVCb3VuZCIsIl9jb250aW51ZSIsIl9zY2hlZHVsZU5leHRCb3VuZCIsIl9zY2hlZHVsZU5leHQiLCJfbmV4dEJvdW5kIiwiX25leHQiLCJfY2FudmFzIiwiU3RlcHBlck1hbmFnZXIiLCJpbml0IiwiZ2V0TmV4dEJyZWFrUG9pbnQiLCJnZngiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInVwZGF0ZU9wZXJhdG9yTGlzdCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1ha2VDb2xvckNvbXAiLCJzY2FsZUFuZENsYW1wIiwiQ29sb3JDb252ZXJ0ZXJzIiwiQ01ZS19HIiwiR19DTVlLIiwiR19SR0IiLCJHX3JnYiIsIkdfSFRNTCIsIkciLCJSR0JfRyIsIlJHQl9yZ2IiLCJSR0JfSFRNTCIsIlRfSFRNTCIsIlRfcmdiIiwiQ01ZS19SR0IiLCJDTVlLX3JnYiIsIkNNWUtfSFRNTCIsImNvbXBvbmVudHMiLCJSR0JfQ01ZSyIsIkJhc2VTVkdGYWN0b3J5Iiwic2tpcERpbWVuc2lvbnMiLCJfY3JlYXRlU1ZHIiwic2V0dXBTdG9yYWdlIiwiaHRtbCIsInN0b3JlZERhdGEiLCJ4ZmFPbiIsInhmYU9mZiIsImNoZWNrZWQiLCJvcHRpb24iLCJzZWxlY3RlZCIsInNlbGVjdGVkSW5kZXgiLCJzZXRBdHRyaWJ1dGVzIiwibGlua1NlcnZpY2UiLCJpc0hUTUxBbmNob3JFbGVtZW50IiwiSFRNTEFuY2hvckVsZW1lbnQiLCJhZGRMaW5rQXR0cmlidXRlcyIsIm5ld1dpbmRvdyIsImRhdGFJZCIsInJvb3QiLCJ4ZmFIdG1sIiwicm9vdEh0bWwiLCJpc05vdEZvclJpY2hUZXh0Iiwicm9vdERpdiIsImNyZWF0ZVRleHROb2RlIiwic3RhY2siLCJjaGlsZEh0bWwiLCJ4bWxucyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJoaWRkZW4iLCJERUZBVUxUX1RBQl9JTkRFWCIsImFubm90YXRpb25fbGF5ZXJfREVGQVVMVF9GT05UX1NJWkUiLCJHZXRFbGVtZW50c0J5TmFtZVNldCIsImdldFJlY3REaW1zIiwiQW5ub3RhdGlvbkVsZW1lbnRGYWN0b3J5IiwiYW5ub3RhdGlvblR5cGUiLCJMaW5rQW5ub3RhdGlvbkVsZW1lbnQiLCJUZXh0QW5ub3RhdGlvbkVsZW1lbnQiLCJmaWVsZFR5cGUiLCJUZXh0V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQiLCJyYWRpb0J1dHRvbiIsIlJhZGlvQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQiLCJjaGVja0JveCIsIkNoZWNrYm94V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQiLCJQdXNoQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQiLCJDaG9pY2VXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCIsIlNpZ25hdHVyZVdpZGdldEFubm90YXRpb25FbGVtZW50IiwiV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQiLCJQb3B1cEFubm90YXRpb25FbGVtZW50IiwiRnJlZVRleHRBbm5vdGF0aW9uRWxlbWVudCIsIkxpbmVBbm5vdGF0aW9uRWxlbWVudCIsIlNxdWFyZUFubm90YXRpb25FbGVtZW50IiwiQ2lyY2xlQW5ub3RhdGlvbkVsZW1lbnQiLCJQb2x5bGluZUFubm90YXRpb25FbGVtZW50IiwiQ2FyZXRBbm5vdGF0aW9uRWxlbWVudCIsIklua0Fubm90YXRpb25FbGVtZW50IiwiUG9seWdvbkFubm90YXRpb25FbGVtZW50IiwiSGlnaGxpZ2h0QW5ub3RhdGlvbkVsZW1lbnQiLCJVbmRlcmxpbmVBbm5vdGF0aW9uRWxlbWVudCIsIlNxdWlnZ2x5QW5ub3RhdGlvbkVsZW1lbnQiLCJTdHJpa2VPdXRBbm5vdGF0aW9uRWxlbWVudCIsIlN0YW1wQW5ub3RhdGlvbkVsZW1lbnQiLCJGaWxlQXR0YWNobWVudEFubm90YXRpb25FbGVtZW50IiwiQW5ub3RhdGlvbkVsZW1lbnQiLCJ1cGRhdGVzIiwiaGFzQm9yZGVyIiwicG9wdXBFbGVtZW50IiwiaXNSZW5kZXJhYmxlIiwiaWdub3JlQm9yZGVyIiwiY3JlYXRlUXVhZHJpbGF0ZXJhbHMiLCJkb3dubG9hZE1hbmFnZXIiLCJpbWFnZVJlc291cmNlc1BhdGgiLCJyZW5kZXJGb3JtcyIsInN2Z0ZhY3RvcnkiLCJlbmFibGVTY3JpcHRpbmciLCJfZmllbGRPYmplY3RzIiwiZmllbGRPYmplY3RzIiwiX2NyZWF0ZUNvbnRhaW5lciIsIl9jcmVhdGVRdWFkcmlsYXRlcmFscyIsIl9oYXNQb3B1cERhdGEiLCJ0aXRsZU9iaiIsImNvbnRlbnRzT2JqIiwicmljaFRleHQiLCJfaXNFZGl0YWJsZSIsImlzRWRpdGFibGUiLCJoYXNQb3B1cERhdGEiLCJ1cGRhdGVFZGl0ZWQiLCJzZXRSZWN0RWRpdGVkIiwicG9wdXAiLCJyZXNldEVkaXRlZCIsImN1cnJlbnRSZWN0Iiwic2V0Um90YXRpb24iLCJhbHRlcm5hdGl2ZVRleHQiLCJ0aXRsZSIsIm5vUm90YXRlIiwiYm9yZGVyU3R5bGUiLCJib3JkZXJXaWR0aCIsImhvcml6b250YWxSYWRpdXMiLCJob3Jpem9udGFsQ29ybmVyUmFkaXVzIiwidmVydGljYWxSYWRpdXMiLCJ2ZXJ0aWNhbENvcm5lclJhZGl1cyIsInJhZGl1cyIsImJvcmRlclJhZGl1cyIsImJvcmRlckJvdHRvbVN0eWxlIiwiYm9yZGVyQ29sb3IiLCJlbGVtZW50V2lkdGgiLCJlbGVtZW50SGVpZ2h0IiwiX2NvbW1vbkFjdGlvbnMiLCJzZXRDb2xvciIsImpzTmFtZSIsInN0eWxlTmFtZSIsImRldGFpbCIsImNvbG9yVHlwZSIsImNvbG9yQXJyYXkiLCJkaXNwbGF5Iiwibm9WaWV3Iiwibm9QcmludCIsInVzZXJOYW1lIiwicmVhZG9ubHkiLCJyZXF1aXJlZCIsIl9zZXRSZXF1aXJlZCIsInRleHRDb2xvciIsIl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3giLCJhY3Rpb25zIiwianNFdmVudCIsImNvbW1vbkFjdGlvbnMiLCJfc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMiLCJldmVudFByb3h5IiwicXVhZFBvaW50cyIsInJlY3RCbFgiLCJyZWN0QmxZIiwicmVjdFRyWCIsInJlY3RUclkiLCJ0clgiLCJ0clkiLCJibFgiLCJibFkiLCJzdmdCdWZmZXIiLCJjbGlwUGF0aCIsInJlY3RXaWR0aCIsInJlY3RIZWlnaHQiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJfY3JlYXRlUG9wdXAiLCJtb2RpZmljYXRpb25EYXRlIiwicGFyZW50UmVjdCIsImVsZW1lbnRzIiwiX2dldEVsZW1lbnRzQnlOYW1lIiwic2tpcElkIiwiZmllbGRzIiwiZmllbGRPYmoiLCJleHBvcnRWYWx1ZXMiLCJleHBvcnRWYWx1ZSIsImRvbUVsZW1lbnQiLCJnZXRFbGVtZW50c0J5TmFtZSIsIm1heWJlU2hvdyIsImZvcmNlSGlkZSIsImdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAiLCJhZGRIaWdobGlnaHRBcmVhIiwidHJpZ2dlcnMiLCJfZWRpdE9uRG91YmxlQ2xpY2siLCJhbm5vdGF0aW9uRWRpdG9yVHlwZSIsImlzVG9vbHRpcE9ubHkiLCJsaW5rIiwiaXNCb3VuZCIsIl9iaW5kTmFtZWRBY3Rpb24iLCJhdHRhY2htZW50IiwiYmluZEF0dGFjaG1lbnQiLCJhdHRhY2htZW50RGVzdCIsImJpbmRTZXRPQ0dTdGF0ZSIsIl9iaW5kTGluayIsIkFjdGlvbiIsIl9iaW5kSlNBY3Rpb24iLCJyZXNldEZvcm0iLCJfYmluZFJlc2V0Rm9ybUFjdGlvbiIsInNldEludGVybmFsTGluayIsImRlc3RpbmF0aW9uIiwiZ2V0RGVzdGluYXRpb25IYXNoIiwib25jbGljayIsImdvVG9EZXN0aW5hdGlvbiIsImdldEFuY2hvclVybCIsImV4ZWN1dGVOYW1lZEFjdGlvbiIsImRlc2NyaXB0aW9uIiwib3Blbk9yRG93bmxvYWREYXRhIiwiZXhlY3V0ZVNldE9DR1N0YXRlIiwib3RoZXJDbGlja0FjdGlvbiIsInJlc2V0Rm9ybUZpZWxkcyIsInJlZnMiLCJyZXNldEZvcm1SZWZzIiwiaW5jbHVkZSIsImFsbEZpZWxkcyIsImZpZWxkSWRzIiwiZmllbGROYW1lIiwiZmllbGQiLCJhbGxJZHMiLCJkaXNwYXRjaEV2ZW50IiwiRXZlbnQiLCJzaG93RWxlbWVudEFuZEhpZGVDYW52YXMiLCJwcmV2aW91c1NpYmxpbmciLCJfZ2V0S2V5TW9kaWZpZXIiLCJfc2V0RXZlbnRMaXN0ZW5lciIsImVsZW1lbnREYXRhIiwiYmFzZU5hbWUiLCJldmVudE5hbWUiLCJ2YWx1ZUdldHRlciIsIm1vZGlmaWVyIiwiZm9jdXNlZCIsIl9zZXRFdmVudExpc3RlbmVycyIsImdldHRlciIsIkJsdXIiLCJGb2N1cyIsIl9zZXRCYWNrZ3JvdW5kQ29sb3IiLCJfc2V0VGV4dFN0eWxlIiwiVEVYVF9BTElHTk1FTlQiLCJmb250Q29sb3IiLCJkZWZhdWx0QXBwZWFyYW5jZURhdGEiLCJjb21wdXRlZEZvbnRTaXplIiwicm91bmRUb09uZURlY2ltYWwiLCJtdWx0aUxpbmUiLCJudW1iZXJPZkxpbmVzIiwidGV4dEFsaWdubWVudCIsInRleHRBbGlnbiIsImlzUmVxdWlyZWQiLCJoYXNBcHBlYXJhbmNlIiwiZmllbGRWYWx1ZSIsInNldFByb3BlcnR5T25TaWJsaW5ncyIsImtleUluU3RvcmFnZSIsIm1heExlbiIsImNoYXJMaW1pdCIsImZpZWxkRm9ybWF0dGVkVmFsdWVzIiwiZm9ybWF0dGVkVmFsdWUiLCJjb21iIiwidXNlclZhbHVlIiwibGFzdENvbW1pdHRlZFZhbHVlIiwiY29tbWl0S2V5IiwiZG9Ob3RTY3JvbGwiLCJvdmVyZmxvd1kiLCJvdmVyZmxvd1giLCJyZWFkT25seSIsIm1heExlbmd0aCIsImRlZmF1bHRGaWVsZFZhbHVlIiwiYmx1ckxpc3RlbmVyIiwic2Nyb2xsTGVmdCIsInNlbFJhbmdlIiwic2V0U2VsZWN0aW9uUmFuZ2UiLCJ3aWxsQ29tbWl0Iiwic2VsU3RhcnQiLCJzZWxlY3Rpb25TdGFydCIsInNlbEVuZCIsInNlbGVjdGlvbkVuZCIsIl9ibHVyTGlzdGVuZXIiLCJLZXlzdHJva2UiLCJpbnB1dFR5cGUiLCJjaGFuZ2UiLCJmaWVsZFdpZHRoIiwiY29tYldpZHRoIiwibGV0dGVyU3BhY2luZyIsInZlcnRpY2FsQWxpZ24iLCJjaGVja2JveCIsImN1ckNoZWNrZWQiLCJidXR0b25WYWx1ZSIsInJhZGlvIiwicGRmQnV0dG9uVmFsdWUiLCJsaW5rRWxlbWVudCIsInNlbGVjdEVsZW1lbnQiLCJhZGRBbkVtcHR5RW50cnkiLCJjb21ibyIsIm11bHRpU2VsZWN0IiwibXVsdGlwbGUiLCJvcHRpb25FbGVtZW50IiwiZGlzcGxheVZhbHVlIiwicmVtb3ZlRW1wdHlFbnRyeSIsIm5vbmVPcHRpb25FbGVtZW50IiwiaXNFeHBvcnQiLCJzZWxlY3RlZFZhbHVlcyIsImdldEl0ZW1zIiwibXVsdGlwbGVTZWxlY3Rpb24iLCJpbmRleCIsImZpbmRJbmRleCIsInNlbGVjdENoaWxkIiwiaW5kaWNlcyIsImVkaXRhYmxlIiwiY2hhbmdlRXgiLCJrZXlEb3duIiwiUG9wdXBFbGVtZW50IiwiZWxlbWVudElkcyIsImFyaWFIYXNQb3B1cCIsImJvdW5kS2V5RG93biIsImJvdW5kSGlkZSIsImJvdW5kU2hvdyIsImJvdW5kVG9nZ2xlIiwiZGF0ZU9iaiIsInBpbm5lZCIsIndhc1Zpc2libGUiLCJ0cmlnZ2VyIiwiZmxhdE1hcCIsImJhc2VDb2xvciIsIm91dGxpbmVDb2xvciIsIkJBQ0tHUk9VTkRfRU5MSUdIVCIsImhlYWRlciIsInZhbHVlT2YiLCJjb250ZW50cyIsIl9mb3JtYXRDb250ZW50cyIsIm1ha2VQb3B1cENvbnRlbnQiLCJwb3B1cExpbmVzIiwicG9wdXBDb250ZW50IiwibGluZUF0dHJpYnV0ZXMiLCJsaW5lIiwibGluZXMiLCJzZXRQb3NpdGlvbiIsInVzZVBhcmVudFJlY3QiLCJub3JtYWxpemVkUmVjdCIsIkhPUklaT05UQUxfU1BBQ0VfQUZURVJfQU5OT1RBVElPTiIsInBvcHVwTGVmdCIsInBvcHVwVG9wIiwidGV4dFBvc2l0aW9uIiwibGluZVNwYW4iLCJsaW5lQ29vcmRpbmF0ZXMiLCJzcXVhcmUiLCJjaXJjbGUiLCJwb2x5bGluZSIsImNvbnRhaW5lckNsYXNzTmFtZSIsInN2Z0VsZW1lbnROYW1lIiwidmVydGljZXMiLCJwb2x5bGluZXNHcm91cEVsZW1lbnQiLCJwb2x5bGluZXMiLCJpdCIsImlua0xpc3RzIiwidGhpY2tuZXNzIiwiZG93bmxvYWQiLCJhY2Nlc3NpYmlsaXR5TWFuYWdlciIsImVkaXRhYmxlQW5ub3RhdGlvbnMiLCJzdHJ1Y3RUcmVlTGF5ZXIiLCJhbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyIiwiX2Fubm90YXRpb25FZGl0b3JVSU1hbmFnZXIiLCJoYXNFZGl0YWJsZUFubm90YXRpb25zIiwiYXBwZW5kRWxlbWVudCIsImNvbnRlbnRFbGVtZW50IiwiYW5ub3RhdGlvbklkIiwiYXJpYUF0dHJpYnV0ZXMiLCJnZXRBcmlhQXR0cmlidXRlcyIsIm1vdmVFbGVtZW50SW5ET00iLCJhbm5vdGF0aW9ucyIsInBvcHVwVG9FbGVtZW50cyIsImVsZW1lbnRQYXJhbXMiLCJub0hUTUwiLCJpc1BvcHVwQW5ub3RhdGlvbiIsInJlbmRlcmVkIiwic2V0QW5ub3RhdGlvbkNhbnZhc01hcCIsInJlcGxhY2VXaXRoIiwiYWZ0ZXIiLCJnZXRFZGl0YWJsZUFubm90YXRpb25zIiwiZ2V0RWRpdGFibGVBbm5vdGF0aW9uIiwiRU9MX1BBVFRFUk4iLCJGcmVlVGV4dEVkaXRvciIsImVkaXRvckRpdklkIiwiZWRpdE1vZGVBQyIsIl9mcmVlVGV4dERlZmF1bHRDb250ZW50IiwiX2ludGVybmFsUGFkZGluZyIsIl9kZWZhdWx0Q29sb3IiLCJfZGVmYXVsdEZvbnRTaXplIiwiX3RyYW5zbGF0ZUVtcHR5IiwiX2VkaXRvclR5cGUiLCJ1cGRhdGVGb250U2l6ZSIsInNldEZvbnRzaXplIiwiZWRpdG9yRGl2Iiwic2V0RWRpdG9yRGltZW5zaW9ucyIsInNhdmVkRm9udHNpemUiLCJjb2wiLCJzYXZlZENvbG9yIiwib3ZlcmxheURpdiIsImNvbnRlbnRFZGl0YWJsZSIsImVkaXRvckRpdktleWRvd24iLCJlZGl0b3JEaXZGb2N1cyIsImVkaXRvckRpdkJsdXIiLCJlZGl0b3JEaXZJbnB1dCIsImVkaXRvckRpdlBhc3RlIiwiaW5uZXJUZXh0IiwiZXh0cmFjdFRleHQiLCJwcmV2Q2hpbGQiLCJjaGlsZE5vZGVzIiwiZ2V0Tm9kZUNvbnRlbnQiLCJzYXZlZERpc3BsYXkiLCJzYXZlZFZpc2liaWxpdHkiLCJzYXZlZFRleHQiLCJuZXdUZXh0IiwidHJpbUVuZCIsInNldFRleHQiLCJzZXRDb250ZW50IiwiZGJsY2xpY2siLCJiYXNlWCIsImJhc2VZIiwicG9zWCIsInBvc1kiLCJub2RlVmFsdWUiLCJkZXNlcmlhbGl6ZUNvbnRlbnQiLCJkZWxldGVGcm9tRG9jdW1lbnQiLCJpbnNlcnROb2RlIiwiY29sbGFwc2VUb1N0YXJ0Iiwic3RhcnRDb250YWluZXIiLCJzdGFydE9mZnNldCIsImJ1ZmZlckJlZm9yZSIsImJ1ZmZlckFmdGVyIiwibmV3UmFuZ2UiLCJSYW5nZSIsImJlZm9yZUxlbmd0aCIsInJlZHVjZSIsImFjYyIsInNldFN0YXJ0Iiwic2V0RW5kIiwicmVtb3ZlQWxsUmFuZ2VzIiwiYWRkUmFuZ2UiLCJyZXBsYWNlQ2hpbGRyZW4iLCJzZXJpYWxpemVDb250ZW50IiwicGFkZGluZyIsInN0cnVjdFRyZWVQYXJlbnRJZCIsImhhc0VsZW1lbnRDaGFuZ2VkIiwiT3V0bGluZSIsIlBSRUNJU0lPTiIsInRvU1ZHUGF0aCIsIl9yb3RhdGlvbiIsIl9yZXNjYWxlIiwiRmxvYXQzMkFycmF5IiwiX3Jlc2NhbGVBbmRTd2FwIiwiX3RyYW5zbGF0ZSIsInN2Z1JvdW5kIiwiX25vcm1hbGl6ZVBvaW50IiwiX25vcm1hbGl6ZVBhZ2VQb2ludCIsImNyZWF0ZUJlemllclBvaW50cyIsIkZyZWVEcmF3T3V0bGluZXIiLCJpbm5lck1hcmdpbiIsImxhc3QiLCJtaW5fZGlzdCIsInNjYWxlRmFjdG9yIiwiTUlOX0RJU1QiLCJNSU5fRElGRiIsIk1JTiIsImdldExhc3RDb29yZHMiLCJsYXN0VG9wIiwibGFzdEJvdHRvbSIsImRpZmZYIiwiZGlmZlkiLCJkaWZmRCIsIm5YIiwiblkiLCJ0aFgiLCJ0aFkiLCJ0b1NWR1BhdGhUd29Qb2ludHMiLCJ0b1NWR1BhdGhFbmQiLCJ0b1NWR1BhdGhTdGFydCIsImxhc3RUb3BYIiwibGFzdFRvcFkiLCJsYXN0Qm90dG9tWCIsImxhc3RCb3R0b21ZIiwibmV3RnJlZURyYXdPdXRsaW5lIiwib3V0bGluZSIsIkZyZWVEcmF3T3V0bGluZSIsImdldE91dGxpbmVzIiwiZ2V0T3V0bGluZVR3b1BvaW50cyIsIk4iLCJnZXRPdXRsaW5lRW5kIiwiZ2V0T3V0bGluZVN0YXJ0IiwibGFzdFBvaW50IiwiY29tcHV0ZU1pbk1heCIsImxhc3RQb2ludFgiLCJsYXN0UG9pbnRZIiwibHRyQ2FsbGJhY2siLCJuZXdPdXRsaW5lciIsImdldE5ld091dGxpbmUiLCJvdXRsaW5lciIsIkhpZ2hsaWdodE91dGxpbmVyIiwidmVydGljYWxFZGdlcyIsImludGVydmFscyIsIk5VTUJFUl9PRl9ESUdJVFMiLCJFUFNJTE9OIiwic2hpZnRlZE1pblgiLCJzaGlmdGVkTWluWSIsImxhc3RFZGdlIiwiZWRnZSIsInNvcnQiLCJvdXRsaW5lVmVydGljYWxFZGdlcyIsImJyZWFrRWRnZSIsImVkZ2VzIiwiYWxsRWRnZXMiLCJlZGdlMSIsImVkZ2UyIiwib3V0bGluZXMiLCJIaWdobGlnaHRPdXRsaW5lIiwiYmluYXJ5U2VhcmNoIiwibWlkZGxlIiwieTQiLCJwb2x5Z29uIiwicHJldlgiLCJwcmV2WSIsImNsYXNzTmFtZXNGb3JPdXRsaW5pbmciLCJGcmVlSGlnaGxpZ2h0T3V0bGluZXIiLCJGcmVlSGlnaGxpZ2h0T3V0bGluZSIsImJ1dHRvblN3YXRjaCIsImRlZmF1bHRDb2xvciIsImRyb3Bkb3duIiwiZHJvcGRvd25XYXNGcm9tS2V5Ym9hcmQiLCJpc01haW5Db2xvclBpY2tlciIsIm9wZW5Ecm9wZG93bkFDIiwibDEwbkNvbG9yIiwiX2hpZGVEcm9wZG93bkZyb21LZXlib2FyZCIsIl9jb2xvclNlbGVjdEZyb21LZXlib2FyZCIsIl9tb3ZlVG9OZXh0IiwiX21vdmVUb1ByZXZpb3VzIiwiX21vdmVUb0JlZ2lubmluZyIsIl9tb3ZlVG9FbmQiLCJibHVlIiwiZ3JlZW4iLCJwaW5rIiwicmVkIiwieWVsbG93Iiwib3BlbkRyb3Bkb3duIiwic3dhdGNoIiwicmVuZGVyTWFpbkRyb3Bkb3duIiwiZ2V0RHJvcGRvd25Sb290Iiwicm9sZSIsImNvbG9yU2VsZWN0IiwiaXNEcm9wZG93blZpc2libGUiLCJuZXh0U2libGluZyIsIkhpZ2hsaWdodEVkaXRvciIsImNsaXBQYXRoSWQiLCJmb2N1c091dGxpbmVzIiwiaGlnaGxpZ2h0RGl2IiwiaGlnaGxpZ2h0T3V0bGluZXMiLCJpc0ZyZWVIaWdobGlnaHQiLCJvdXRsaW5lSWQiLCJfZGVmYXVsdE9wYWNpdHkiLCJfZGVmYXVsdFRoaWNrbmVzcyIsIl9mcmVlSGlnaGxpZ2h0SWQiLCJfZnJlZUhpZ2hsaWdodCIsIl9mcmVlSGlnaGxpZ2h0Q2xpcElkIiwiX21vdmVDYXJldCIsImhpZ2hsaWdodElkIiwiY3JlYXRlRnJlZU91dGxpbmVzIiwiYWRkVG9EcmF3TGF5ZXIiLCJjcmVhdGVPdXRsaW5lcyIsIm51bWJlck9mQ29sb3JzIiwib3V0bGluZXJGb3JPdXRsaW5lIiwiZXh0cmFUaGlja25lc3MiLCJkcmF3TGF5ZXIiLCJmaW5hbGl6ZURyYXciLCJyb290Q2xhc3MiLCJoaWdobGlnaHRPdXRsaW5lIiwiZnJlZSIsInVwZGF0ZVByb3BlcnRpZXMiLCJyb3RhdGVCYm94IiwidXBkYXRlVGhpY2tuZXNzIiwic2V0Q29sb3JBbmRPcGFjaXR5Iiwib3BhIiwic2F2ZWRPcGFjaXR5Iiwic2F2ZWRUaGlja25lc3MiLCJzZXRUaGlja25lc3MiLCJ0aCIsImNoYW5nZVRoaWNrbmVzcyIsImdldFJvdGF0aW9uIiwiYWRkVW5kb2FibGVFZGl0b3IiLCJjbGVhbkRyYXdMYXllciIsIm11c3RCZVNlbGVjdGVkIiwiZHJhdyIsInBvaW50ZXJvdmVyIiwiaG92ZXJlZCIsInBvaW50ZXJsZWF2ZSIsInNldENhcmV0Iiwic2VyaWFsaXplQm94ZXMiLCJzZXJpYWxpemVPdXRsaW5lcyIsInN0YXJ0SGlnaGxpZ2h0aW5nIiwiZW5kSGlnaGxpZ2h0IiwiaGlnaGxpZ2h0TW92ZSIsInJhd1dpZHRoIiwiRHJhd2luZ09wdGlvbnMiLCJzdmdQcm9wZXJ0aWVzIiwidXBkYXRlUHJvcGVydHkiLCJ1cGRhdGVTVkdQcm9wZXJ0eSIsInRvU1ZHUHJvcGVydGllcyIsInVwZGF0ZUFsbCIsIkRyYXdpbmdFZGl0b3IiLCJkcmF3T3V0bGluZXMiLCJtdXN0QmVDb21taXR0ZWQiLCJfY3VycmVudERyYXdJZCIsIl9jdXJyZW50RHJhdyIsIl9jdXJyZW50RHJhd2luZ09wdGlvbnMiLCJfY3VycmVudFBhcmVudCIsIl9JTk5FUl9NQVJHSU4iLCJfZHJhd0lkIiwiY3JlYXRlRHJhd091dGxpbmVzIiwiZHJhd0lkIiwiZHJhd2luZ09wdGlvbnMiLCJfZHJhd2luZ09wdGlvbnMiLCJkZWZhdWx0UHJvcGVydGllcyIsImNyZWF0ZURyYXdpbmciLCJ1cGRhdGVCYm94IiwiX21lcmdlU1ZHUHJvcGVydGllcyIsImRlZmF1bHRTVkdQcm9wZXJ0aWVzIiwicDFLZXlzIiwiZ2V0RGVmYXVsdERyYXdpbmdPcHRpb25zIiwiX29wdGlvbnMiLCJ0eXBlc01hcCIsInN1cHBvcnRNdWx0aXBsZURyYXdpbmdzIiwicHJvcGVydHlOYW1lIiwiX2RlZmF1bHREcmF3aW5nT3B0aW9ucyIsIl91cGRhdGVQcm9wZXJ0eSIsInNhdmVkVmFsdWUiLCJzZXR0ZXIiLCJnZXRQYXRoUmVzaXppbmdTVkdQcm9wZXJ0aWVzIiwiY29udmVydFRvRHJhd1NwYWNlIiwicm90YXRlQm94IiwiZ2V0UGF0aFJlc2l6ZWRTVkdQcm9wZXJ0aWVzIiwiZ2V0UGF0aFRyYW5zbGF0ZWRTVkdQcm9wZXJ0aWVzIiwibW92aW5nIiwidXBkYXRlUGFyZW50IiwiY29udmVydFRvUGFyZW50U3BhY2UiLCJwVyIsInBIIiwidXBkYXRlUm90YXRpb24iLCJ1cGRhdGVQYXJlbnREaW1lbnNpb25zIiwib25TY2FsZUNoYW5naW5nV2hlbkRyYXdpbmciLCJkcmF3RGl2IiwiY3JlYXRlRHJhd2VySW5zdGFuY2UiLCJfeCIsIl95IiwiX3BhcmVudFdpZHRoIiwiX3BhcmVudEhlaWdodCIsInN0YXJ0RHJhd2luZyIsIl9pc0xUUiIsIl9lbmREcmF3IiwiX2RyYXdNb3ZlIiwic3RhcnROZXciLCJsYXN0RWxlbWVudCIsImdldExhc3RFbGVtZW50Iiwic2V0TGFzdEVsZW1lbnQiLCJyZW1vdmVMYXN0RWxlbWVudCIsImlzQWJvcnRlZCIsIl9jbGVhbnVwIiwiY3JlYXRlRHJhd2luZ09wdGlvbnMiLCJfZGF0YSIsImRlc2VyaWFsaXplRHJhdyIsIl9wYWdlWCIsIl9wYWdlWSIsIl9wYWdlV2lkdGgiLCJfcGFnZUhlaWdodCIsIl9pbm5lcldpZHRoIiwic2VyaWFsaXplRHJhdyIsIklua0RyYXdPdXRsaW5lciIsImxhc3RTVkdQYXRoIiwibGFzdEluZGV4IiwiRmxvYXQ2NEFycmF5IiwiSW5rRHJhd091dGxpbmUiLCJub3JtYWxpemVQb2ludCIsImZpcnN0WCIsImZpcnN0WSIsInNlY29uZFgiLCJzZWNvbmRZIiwiYzF4IiwiYzF5IiwiYzJ4IiwiYzJ5IiwiY3VycmVudFJvdGF0aW9uIiwiY29tcHV0ZUJib3giLCJzZXJpYWxpemVkTGluZXMiLCJzZXJpYWxpemVkUG9pbnRzIiwiZ2V0QkJveFdpdGhOb01hcmdpbiIsInJlc2NhbGVGbiIsIm5ld0xpbmVzIiwiZ2V0TWFyZ2luQ29tcG9uZW50cyIsIm1hcmdpbiIsIm1hcmdpblgiLCJtYXJnaW5ZIiwib2xkTWFyZ2luWCIsIm9sZE1hcmdpblkiLCJuZXdNYXJnaW5YIiwibmV3TWFyZ2luWSIsImRpZmZNYXJnaW5YIiwiZGlmZk1hcmdpblkiLCJyb3RhdGlvblRyYW5zZm9ybSIsInMxeCIsInMxeSIsInMyeCIsInMyeSIsIm5ld1BhcmVudFdpZHRoIiwibmV3UGFyZW50SGVpZ2h0IiwiSW5rRHJhd2luZ09wdGlvbnMiLCJ2aWV3ZXJQYXJhbWV0ZXJzIiwiSW5rRWRpdG9yIiwiU3RhbXBFZGl0b3IiLCJiaXRtYXBJZCIsImJpdG1hcFByb21pc2UiLCJiaXRtYXBVcmwiLCJiaXRtYXBGaWxlIiwiYml0bWFwRmlsZU5hbWUiLCJvYnNlcnZlciIsInJlc2l6ZVRpbWVvdXRJZCIsImhhc0JlZW5BZGRlZEluVW5kb1N0YWNrIiwic3VwcG9ydGVkVHlwZXMiLCJzdXBwb3J0ZWRUeXBlc1N0ciIsInBhc3RlRWRpdG9yIiwiZ2V0QXNGaWxlIiwiaGFzQWx0VGV4dFN0YXRzIiwiaGFzTm9BbHRUZXh0IiwiZ2V0Qml0bWFwRmV0Y2hlZCIsImZyb21JZCIsImdldEJpdG1hcERvbmUiLCJhbHRfdGV4dF9tb2RhbCIsImFsdF90ZXh0X3R5cGUiLCJtbEd1ZXNzQWx0VGV4dCIsInVwZGF0ZUFsdFRleHREYXRhIiwiaXNFbmFibGVkRm9yIiwiY29weUNhbnZhcyIsImd1ZXNzIiwiY2hhbm5lbHMiLCJhbHQiLCJnZXRCaXRtYXAiLCJhY2NlcHQiLCJmaWxlcyIsImNsaWNrIiwiZGlzY29ubmVjdCIsIk1BWF9SQVRJTyIsImZhY3RvciIsImRyYXdCaXRtYXAiLCJjcmVhdGVPYnNlcnZlciIsIm1heERhdGFEaW1lbnNpb24iLCJtYXhQcmV2aWV3RGltZW5zaW9uIiwiYml0bWFwV2lkdGgiLCJiaXRtYXBIZWlnaHQiLCJvdXRwdXRTY2FsZSIsInNjYWxlZFdpZHRoIiwic2NhbGVkSGVpZ2h0Iiwic2NhbGVCaXRtYXAiLCJib3hEaW0iLCJib3hEaW1XaWR0aCIsImJveERpbUhlaWdodCIsInBhdHRlcm5DdHgiLCJkYXRhV2lkdGgiLCJkYXRhSGVpZ2h0Iiwib2Zmc2NyZWVuQ3R4Iiwic2V0RGltZW5zaW9ucyIsInByZXZXaWR0aCIsInByZXZIZWlnaHQiLCJzZXJpYWxpemVCaXRtYXAiLCJ0b1VybCIsInRvRGF0YVVSTCIsIlJlc2l6ZU9ic2VydmVyIiwiY29udGVudFJlY3QiLCJvYnNlcnZlIiwic3RydWN0UGFyZW50IiwiX3N0cnVjdFRyZWUiLCJjaGFuZ2VzIiwiaXNTYW1lIiwiaXNTYW1lQWx0VGV4dCIsInN0YW1wcyIsImFyZWEiLCJwcmV2RGF0YSIsImlzU2FtZVBhZ2VJbmRleCIsImFsbG93Q2xpY2siLCJhbm5vdGF0aW9uTGF5ZXIiLCJjbGlja0FDIiwiZWRpdG9yRm9jdXNUaW1lb3V0SWQiLCJoYWRQb2ludGVyRG93biIsImlzRGlzYWJsaW5nIiwiZHJhd2luZ0FDIiwidGV4dFNlbGVjdGlvbkFDIiwiX2luaXRpYWxpemVkIiwiaXNJbnZpc2libGUiLCJkaXNhYmxlVGV4dFNlbGVjdGlvbiIsInRvZ2dsZUFubm90YXRpb25MYXllclBvaW50ZXJFdmVudHMiLCJlbmFibGVUZXh0U2VsZWN0aW9uIiwiYW5ub3RhdGlvbkVsZW1lbnRJZHMiLCJlZGl0YWJsZXMiLCJjaGFuZ2VkQW5ub3RhdGlvbnMiLCJyZXNldEFubm90YXRpb25zIiwiY3VycmVudEFjdGl2ZSIsInRleHRMYXllclBvaW50ZXJEb3duIiwiYXR0YWNoIiwiZGV0YWNoIiwicmVtb3ZlUG9pbnRlckluVGV4dExheWVyIiwiY3VycmVudEVkaXRvclR5cGUiLCJjcmVhdGVOZXdFZGl0b3IiLCJnZXRDZW50ZXJQb2ludCIsInN0YXJ0RHJhd2luZ1Nlc3Npb24iLCJvbGRSb3RhdGlvbiIsIm1hcHBpbmciLCJ0b1VwZGF0ZSIsIl9zdmdGYWN0b3J5Iiwic2V0Qm94IiwiY3JlYXRlU1ZHIiwiY3JlYXRlQ2xpcFBhdGgiLCJwYXRoSWQiLCJjbGlwUGF0aFVzZSIsImlzUGF0aFVwZGF0YWJsZSIsImhhc0NsaXAiLCJ1c2UiLCJtdXN0UmVtb3ZlU2VsZkludGVyc2VjdGlvbnMiLCJtYXNrSWQiLCJ1c2UxIiwidXNlMiIsImNsb25lTm9kZSIsImVsZW1lbnRPcklkIiwicGF0aEVsZW1lbnQiLCJwZGZqc1ZlcnNpb24iLCJwZGZqc0J1aWxkIiwicGRmanNUZXN0aW5nVXRpbHMiLCJfX3dlYnBhY2tfZXhwb3J0c19fQWJvcnRFeGNlcHRpb24iLCJfX3dlYnBhY2tfZXhwb3J0c19fQW5ub3RhdGlvbkVkaXRvckxheWVyIiwiX193ZWJwYWNrX2V4cG9ydHNfX0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlIiwiX193ZWJwYWNrX2V4cG9ydHNfX0Fubm90YXRpb25FZGl0b3JUeXBlIiwiX193ZWJwYWNrX2V4cG9ydHNfX0Fubm90YXRpb25FZGl0b3JVSU1hbmFnZXIiLCJfX3dlYnBhY2tfZXhwb3J0c19fQW5ub3RhdGlvbkxheWVyIiwiX193ZWJwYWNrX2V4cG9ydHNfX0Fubm90YXRpb25Nb2RlIiwiX193ZWJwYWNrX2V4cG9ydHNfX0NvbG9yUGlja2VyIiwiX193ZWJwYWNrX2V4cG9ydHNfX0RPTVNWR0ZhY3RvcnkiLCJfX3dlYnBhY2tfZXhwb3J0c19fRHJhd0xheWVyIiwiX193ZWJwYWNrX2V4cG9ydHNfX0ZlYXR1cmVUZXN0IiwiX193ZWJwYWNrX2V4cG9ydHNfX0dsb2JhbFdvcmtlck9wdGlvbnMiLCJfX3dlYnBhY2tfZXhwb3J0c19fSW1hZ2VLaW5kIiwiX193ZWJwYWNrX2V4cG9ydHNfX0ludmFsaWRQREZFeGNlcHRpb24iLCJfX3dlYnBhY2tfZXhwb3J0c19fTWlzc2luZ1BERkV4Y2VwdGlvbiIsIl9fd2VicGFja19leHBvcnRzX19PUFMiLCJfX3dlYnBhY2tfZXhwb3J0c19fT3V0cHV0U2NhbGUiLCJfX3dlYnBhY2tfZXhwb3J0c19fUERGRGF0YVJhbmdlVHJhbnNwb3J0IiwiX193ZWJwYWNrX2V4cG9ydHNfX1BERkRhdGVTdHJpbmciLCJfX3dlYnBhY2tfZXhwb3J0c19fUERGV29ya2VyIiwiX193ZWJwYWNrX2V4cG9ydHNfX1Bhc3N3b3JkUmVzcG9uc2VzIiwiX193ZWJwYWNrX2V4cG9ydHNfX1Blcm1pc3Npb25GbGFnIiwiX193ZWJwYWNrX2V4cG9ydHNfX1BpeGVsc1BlckluY2giLCJfX3dlYnBhY2tfZXhwb3J0c19fUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uIiwiX193ZWJwYWNrX2V4cG9ydHNfX1RleHRMYXllciIsIl9fd2VicGFja19leHBvcnRzX19VbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24iLCJfX3dlYnBhY2tfZXhwb3J0c19fVXRpbCIsIl9fd2VicGFja19leHBvcnRzX19WZXJib3NpdHlMZXZlbCIsIl9fd2VicGFja19leHBvcnRzX19YZmFMYXllciIsIl9fd2VicGFja19leHBvcnRzX19idWlsZCIsIl9fd2VicGFja19leHBvcnRzX19jcmVhdGVWYWxpZEFic29sdXRlVXJsIiwiX193ZWJwYWNrX2V4cG9ydHNfX2ZldGNoRGF0YSIsIl9fd2VicGFja19leHBvcnRzX19nZXREb2N1bWVudCIsIl9fd2VicGFja19leHBvcnRzX19nZXRGaWxlbmFtZUZyb21VcmwiLCJfX3dlYnBhY2tfZXhwb3J0c19fZ2V0UGRmRmlsZW5hbWVGcm9tVXJsIiwiX193ZWJwYWNrX2V4cG9ydHNfX2dldFhmYVBhZ2VWaWV3cG9ydCIsIl9fd2VicGFja19leHBvcnRzX19pc0RhdGFTY2hlbWUiLCJfX3dlYnBhY2tfZXhwb3J0c19faXNQZGZGaWxlIiwiX193ZWJwYWNrX2V4cG9ydHNfX25vQ29udGV4dE1lbnUiLCJfX3dlYnBhY2tfZXhwb3J0c19fbm9ybWFsaXplVW5pY29kZSIsIl9fd2VicGFja19leHBvcnRzX19zZXRMYXllckRpbWVuc2lvbnMiLCJfX3dlYnBhY2tfZXhwb3J0c19fc2hhZG93IiwiX193ZWJwYWNrX2V4cG9ydHNfX3N0b3BFdmVudCIsIl9fd2VicGFja19leHBvcnRzX192ZXJzaW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pdfjs-dist/build/pdf.mjs\n");

/***/ })

};
;